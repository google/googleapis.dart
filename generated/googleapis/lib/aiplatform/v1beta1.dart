// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: doc_directive_unknown
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_string_interpolations

/// Vertex AI API - v1beta1
///
/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
///
/// For more information, see <https://cloud.google.com/vertex-ai/>
///
/// Create an instance of [AiplatformApi] to access these resources:
///
/// - [BatchPredictionJobsResource]
/// - [DatasetsResource]
///   - [DatasetsDatasetVersionsResource]
/// - [EndpointsResource]
///   - [EndpointsChatResource]
/// - [MediaResource]
/// - [ProjectsResource]
///   - [ProjectsLocationsResource]
///     - [ProjectsLocationsAgentsResource]
///       - [ProjectsLocationsAgentsOperationsResource]
///     - [ProjectsLocationsAppsResource]
///       - [ProjectsLocationsAppsOperationsResource]
///     - [ProjectsLocationsBatchPredictionJobsResource]
///     - [ProjectsLocationsCachedContentsResource]
///     - [ProjectsLocationsCustomJobsResource]
///       - [ProjectsLocationsCustomJobsOperationsResource]
///     - [ProjectsLocationsDataLabelingJobsResource]
///       - [ProjectsLocationsDataLabelingJobsOperationsResource]
///     - [ProjectsLocationsDatasetsResource]
///       - [ProjectsLocationsDatasetsAnnotationSpecsResource]
///         - [ProjectsLocationsDatasetsAnnotationSpecsOperationsResource]
///       - [ProjectsLocationsDatasetsDataItemsResource]
///         - [ProjectsLocationsDatasetsDataItemsAnnotationsResource]
/// - [ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource]
///         - [ProjectsLocationsDatasetsDataItemsOperationsResource]
///       - [ProjectsLocationsDatasetsDatasetVersionsResource]
///       - [ProjectsLocationsDatasetsOperationsResource]
///       - [ProjectsLocationsDatasetsSavedQueriesResource]
///         - [ProjectsLocationsDatasetsSavedQueriesOperationsResource]
///     - [ProjectsLocationsDeploymentResourcePoolsResource]
///       - [ProjectsLocationsDeploymentResourcePoolsOperationsResource]
///     - [ProjectsLocationsEdgeDevicesResource]
///       - [ProjectsLocationsEdgeDevicesOperationsResource]
///     - [ProjectsLocationsEndpointsResource]
///       - [ProjectsLocationsEndpointsChatResource]
///       - [ProjectsLocationsEndpointsOperationsResource]
///     - [ProjectsLocationsEvaluationItemsResource]
///       - [ProjectsLocationsEvaluationItemsOperationsResource]
///     - [ProjectsLocationsEvaluationRunsResource]
///       - [ProjectsLocationsEvaluationRunsOperationsResource]
///     - [ProjectsLocationsEvaluationSetsResource]
///       - [ProjectsLocationsEvaluationSetsOperationsResource]
///     - [ProjectsLocationsEvaluationTasksResource]
///       - [ProjectsLocationsEvaluationTasksOperationsResource]
///     - [ProjectsLocationsExampleStoresResource]
///       - [ProjectsLocationsExampleStoresOperationsResource]
///     - [ProjectsLocationsExtensionControllersResource]
///       - [ProjectsLocationsExtensionControllersOperationsResource]
///     - [ProjectsLocationsExtensionsResource]
///       - [ProjectsLocationsExtensionsOperationsResource]
///     - [ProjectsLocationsFeatureGroupsResource]
///       - [ProjectsLocationsFeatureGroupsFeatureMonitorsResource]
/// - [ProjectsLocationsFeatureGroupsFeatureMonitorsFeatureMonitorJobsResource]
///         - [ProjectsLocationsFeatureGroupsFeatureMonitorsOperationsResource]
///       - [ProjectsLocationsFeatureGroupsFeaturesResource]
///         - [ProjectsLocationsFeatureGroupsFeaturesOperationsResource]
///       - [ProjectsLocationsFeatureGroupsOperationsResource]
///     - [ProjectsLocationsFeatureOnlineStoresResource]
///       - [ProjectsLocationsFeatureOnlineStoresFeatureViewsResource]
/// - [ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource]
/// - [ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource]
///       - [ProjectsLocationsFeatureOnlineStoresOperationsResource]
///     - [ProjectsLocationsFeaturestoresResource]
///       - [ProjectsLocationsFeaturestoresEntityTypesResource]
///         - [ProjectsLocationsFeaturestoresEntityTypesFeaturesResource]
/// - [ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource]
///         - [ProjectsLocationsFeaturestoresEntityTypesOperationsResource]
///       - [ProjectsLocationsFeaturestoresOperationsResource]
///     - [ProjectsLocationsHyperparameterTuningJobsResource]
///       - [ProjectsLocationsHyperparameterTuningJobsOperationsResource]
///     - [ProjectsLocationsIndexEndpointsResource]
///       - [ProjectsLocationsIndexEndpointsOperationsResource]
///     - [ProjectsLocationsIndexesResource]
///       - [ProjectsLocationsIndexesOperationsResource]
///     - [ProjectsLocationsMetadataStoresResource]
///       - [ProjectsLocationsMetadataStoresArtifactsResource]
///         - [ProjectsLocationsMetadataStoresArtifactsOperationsResource]
///       - [ProjectsLocationsMetadataStoresContextsResource]
///         - [ProjectsLocationsMetadataStoresContextsOperationsResource]
///       - [ProjectsLocationsMetadataStoresExecutionsResource]
///         - [ProjectsLocationsMetadataStoresExecutionsOperationsResource]
///       - [ProjectsLocationsMetadataStoresMetadataSchemasResource]
///       - [ProjectsLocationsMetadataStoresOperationsResource]
///     - [ProjectsLocationsMigratableResourcesResource]
///       - [ProjectsLocationsMigratableResourcesOperationsResource]
///     - [ProjectsLocationsModelDeploymentMonitoringJobsResource]
///       - [ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource]
///     - [ProjectsLocationsModelMonitorsResource]
///       - [ProjectsLocationsModelMonitorsModelMonitoringJobsResource]
///       - [ProjectsLocationsModelMonitorsOperationsResource]
///     - [ProjectsLocationsModelsResource]
///       - [ProjectsLocationsModelsEvaluationsResource]
///         - [ProjectsLocationsModelsEvaluationsOperationsResource]
///         - [ProjectsLocationsModelsEvaluationsSlicesResource]
///       - [ProjectsLocationsModelsOperationsResource]
///     - [ProjectsLocationsNasJobsResource]
///       - [ProjectsLocationsNasJobsNasTrialDetailsResource]
///     - [ProjectsLocationsNotebookExecutionJobsResource]
///       - [ProjectsLocationsNotebookExecutionJobsOperationsResource]
///     - [ProjectsLocationsNotebookRuntimeTemplatesResource]
///       - [ProjectsLocationsNotebookRuntimeTemplatesOperationsResource]
///     - [ProjectsLocationsNotebookRuntimesResource]
///       - [ProjectsLocationsNotebookRuntimesOperationsResource]
///     - [ProjectsLocationsOperationsResource]
///     - [ProjectsLocationsPersistentResourcesResource]
///       - [ProjectsLocationsPersistentResourcesOperationsResource]
///     - [ProjectsLocationsPipelineJobsResource]
///       - [ProjectsLocationsPipelineJobsOperationsResource]
///     - [ProjectsLocationsPublishersResource]
///       - [ProjectsLocationsPublishersModelsResource]
///     - [ProjectsLocationsRagCorporaResource]
///       - [ProjectsLocationsRagCorporaOperationsResource]
///       - [ProjectsLocationsRagCorporaRagFilesResource]
///         - [ProjectsLocationsRagCorporaRagFilesOperationsResource]
///     - [ProjectsLocationsRagEngineConfigResource]
///       - [ProjectsLocationsRagEngineConfigOperationsResource]
///     - [ProjectsLocationsReasoningEnginesResource]
///       - [ProjectsLocationsReasoningEnginesExamplesResource]
///         - [ProjectsLocationsReasoningEnginesExamplesOperationsResource]
///       - [ProjectsLocationsReasoningEnginesMemoriesResource]
///         - [ProjectsLocationsReasoningEnginesMemoriesOperationsResource]
///       - [ProjectsLocationsReasoningEnginesOperationsResource]
///       - [ProjectsLocationsReasoningEnginesSandboxEnvironmentsResource]
/// - [ProjectsLocationsReasoningEnginesSandboxEnvironmentsOperationsResource]
///       - [ProjectsLocationsReasoningEnginesSessionsResource]
///         - [ProjectsLocationsReasoningEnginesSessionsEventsResource]
///         - [ProjectsLocationsReasoningEnginesSessionsOperationsResource]
///     - [ProjectsLocationsSchedulesResource]
///       - [ProjectsLocationsSchedulesOperationsResource]
///     - [ProjectsLocationsSolversResource]
///       - [ProjectsLocationsSolversOperationsResource]
///     - [ProjectsLocationsSpecialistPoolsResource]
///       - [ProjectsLocationsSpecialistPoolsOperationsResource]
///     - [ProjectsLocationsStudiesResource]
///       - [ProjectsLocationsStudiesOperationsResource]
///       - [ProjectsLocationsStudiesTrialsResource]
///         - [ProjectsLocationsStudiesTrialsOperationsResource]
///     - [ProjectsLocationsTensorboardsResource]
///       - [ProjectsLocationsTensorboardsExperimentsResource]
///         - [ProjectsLocationsTensorboardsExperimentsOperationsResource]
///         - [ProjectsLocationsTensorboardsExperimentsRunsResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsOperationsResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource]
///       - [ProjectsLocationsTensorboardsOperationsResource]
///     - [ProjectsLocationsTrainingPipelinesResource]
///       - [ProjectsLocationsTrainingPipelinesOperationsResource]
///     - [ProjectsLocationsTuningJobsResource]
///       - [ProjectsLocationsTuningJobsOperationsResource]
///   - [ProjectsModelGardenEulaResource]
/// - [PublishersResource]
///   - [PublishersModelsResource]
/// - [ReasoningEnginesResource]
///   - [ReasoningEnginesMemoriesResource]
///   - [ReasoningEnginesSessionsResource]
///     - [ReasoningEnginesSessionsEventsResource]
library;

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

import '../shared.dart';
import '../src/user_agent.dart';

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show
        ApiRequestError,
        ByteRange,
        DetailedApiRequestError,
        DownloadOptions,
        Media,
        PartialDownloadOptions,
        ResumableUploadOptions,
        UploadOptions;

/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
class AiplatformApi {
  /// See, edit, configure, and delete your Google Cloud data and see the email
  /// address for your Google Account.
  static const cloudPlatformScope =
      'https://www.googleapis.com/auth/cloud-platform';

  /// View your data across Google Cloud services and see the email address of
  /// your Google Account
  static const cloudPlatformReadOnlyScope =
      'https://www.googleapis.com/auth/cloud-platform.read-only';

  final commons.ApiRequester _requester;

  BatchPredictionJobsResource get batchPredictionJobs =>
      BatchPredictionJobsResource(_requester);
  DatasetsResource get datasets => DatasetsResource(_requester);
  EndpointsResource get endpoints => EndpointsResource(_requester);
  MediaResource get media => MediaResource(_requester);
  ProjectsResource get projects => ProjectsResource(_requester);
  PublishersResource get publishers => PublishersResource(_requester);
  ReasoningEnginesResource get reasoningEngines =>
      ReasoningEnginesResource(_requester);

  AiplatformApi(
    http.Client client, {
    core.String rootUrl = 'https://aiplatform.googleapis.com/',
    core.String servicePath = '',
  }) : _requester = commons.ApiRequester(
         client,
         rootUrl,
         servicePath,
         requestHeaders,
       );
}

class BatchPredictionJobsResource {
  final commons.ApiRequester _requester;

  BatchPredictionJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a BatchPredictionJob.
  ///
  /// A BatchPredictionJob once created will right away be attempted to start.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1BatchPredictionJob> create(
    GoogleCloudAiplatformV1beta1BatchPredictionJob request, {
    core.String? parent,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (parent != null) 'parent': [parent],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1beta1/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchPredictionJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a BatchPredictionJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob resource. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern `^batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1BatchPredictionJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchPredictionJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists BatchPredictionJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. *
  /// \`model_display_name\` supports \`=\`, \`!=\` comparisons. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListBatchPredictionJobsResponse.next_page_token of the previous
  /// JobService.ListBatchPredictionJobs call.
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// BatchPredictionJobs from. Format:
  /// `projects/{project}/locations/{location}`
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse>
  list({
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? parent,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parent != null) 'parent': [parent],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1beta1/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class DatasetsResource {
  final commons.ApiRequester _requester;

  DatasetsDatasetVersionsResource get datasetVersions =>
      DatasetsDatasetVersionsResource(_requester);

  DatasetsResource(commons.ApiRequester client) : _requester = client;

  /// Creates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Dataset in. Format: `projects/{project}/locations/{location}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Dataset request, {
    core.String? parent,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (parent != null) 'parent': [parent],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1beta1/datasets';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource.
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Dataset> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Dataset.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Datasets in a Location.
  ///
  /// Request parameters:
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. *
  /// \`display_name\`: supports = and != * \`metadata_schema_uri\`: supports =
  /// and != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. Some examples: * \`displayName="myDisplayName"\` *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [parent] - Required. The name of the Dataset's parent resource. Format:
  /// `projects/{project}/locations/{location}`
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListDatasetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListDatasetsResponse> list({
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? parent,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parent != null) 'parent': [parent],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1beta1/datasets';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListDatasetsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the Dataset.
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name` * `description` * `labels`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Dataset> patch(
    GoogleCloudAiplatformV1beta1Dataset request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Dataset.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class DatasetsDatasetVersionsResource {
  final commons.ApiRequester _requester;

  DatasetsDatasetVersionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Create a version from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1DatasetVersion request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DatasetVersion> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DatasetVersion.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists DatasetVersions in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list
  /// DatasetVersions from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a DatasetVersion.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the DatasetVersion.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DatasetVersion> patch(
    GoogleCloudAiplatformV1beta1DatasetVersion request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DatasetVersion.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Restores a dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DatasetVersion resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> restore(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':restore';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class EndpointsResource {
  final commons.ApiRequester _requester;

  EndpointsChatResource get chat => EndpointsChatResource(_requester);

  EndpointsResource(commons.ApiRequester client) : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1beta1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ComputeTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1beta1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CountTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetch an asynchronous online prediction operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> fetchPredictOperation(
    GoogleCloudAiplatformV1beta1FetchPredictOperationRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$endpoint') +
        ':fetchPredictOperation';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  generateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PredictResponse> predict(
    GoogleCloudAiplatformV1beta1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> predictLongRunning(
    GoogleCloudAiplatformV1beta1PredictLongRunningRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predictLongRunning';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  streamGenerateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class EndpointsChatResource {
  final commons.ApiRequester _requester;

  EndpointsChatResource(commons.ApiRequester client) : _requester = client;

  /// Exposes an OpenAI-compatible endpoint for chat completions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> completions(
    GoogleApiHttpBody request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + '/chat/completions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class MediaResource {
  final commons.ApiRequester _requester;

  MediaResource(commons.ApiRequester client) : _requester = client;

  /// Upload a file into a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the RagCorpus resource into which to
  /// upload the file. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// [uploadMedia] - The media to upload.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1UploadRagFileResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1UploadRagFileResponse> upload(
    GoogleCloudAiplatformV1beta1UploadRagFileRequest request,
    core.String parent, {
    core.String? $fields,
    commons.Media? uploadMedia,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    core.String url_;
    if (uploadMedia == null) {
      url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/ragFiles:upload';
    } else {
      url_ =
          '/upload/v1beta1/' +
          core.Uri.encodeFull('$parent') +
          '/ragFiles:upload';
    }

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
      uploadMedia: uploadMedia,
      uploadOptions: commons.UploadOptions.defaultOptions,
    );
    return GoogleCloudAiplatformV1beta1UploadRagFileResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsResource get locations =>
      ProjectsLocationsResource(_requester);
  ProjectsModelGardenEulaResource get modelGardenEula =>
      ProjectsModelGardenEulaResource(_requester);

  ProjectsResource(commons.ApiRequester client) : _requester = client;

  /// Fetches the configs of publisher models.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PublisherModelConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PublisherModelConfig>
  fetchPublisherModelConfig(core.String name, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$name') +
        ':fetchPublisherModelConfig';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PublisherModelConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a GenAI cache config.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Name of the cache config. Format: -
  /// `projects/{project}/cacheConfig`.
  /// Value must have pattern `^projects/\[^/\]+/cacheConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CacheConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CacheConfig> getCacheConfig(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CacheConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets (creates or updates) configs of publisher models.
  ///
  /// For example, sets the request/response logging config.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> setPublisherModelConfig(
    GoogleCloudAiplatformV1beta1SetPublisherModelConfigRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$name') + ':setPublisherModelConfig';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a cache config.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the cache config. Format: -
  /// `projects/{project}/cacheConfig`.
  /// Value must have pattern `^projects/\[^/\]+/cacheConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> updateCacheConfig(
    GoogleCloudAiplatformV1beta1CacheConfig request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsAgentsResource get agents =>
      ProjectsLocationsAgentsResource(_requester);
  ProjectsLocationsAppsResource get apps =>
      ProjectsLocationsAppsResource(_requester);
  ProjectsLocationsBatchPredictionJobsResource get batchPredictionJobs =>
      ProjectsLocationsBatchPredictionJobsResource(_requester);
  ProjectsLocationsCachedContentsResource get cachedContents =>
      ProjectsLocationsCachedContentsResource(_requester);
  ProjectsLocationsCustomJobsResource get customJobs =>
      ProjectsLocationsCustomJobsResource(_requester);
  ProjectsLocationsDataLabelingJobsResource get dataLabelingJobs =>
      ProjectsLocationsDataLabelingJobsResource(_requester);
  ProjectsLocationsDatasetsResource get datasets =>
      ProjectsLocationsDatasetsResource(_requester);
  ProjectsLocationsDeploymentResourcePoolsResource
  get deploymentResourcePools =>
      ProjectsLocationsDeploymentResourcePoolsResource(_requester);
  ProjectsLocationsEdgeDevicesResource get edgeDevices =>
      ProjectsLocationsEdgeDevicesResource(_requester);
  ProjectsLocationsEndpointsResource get endpoints =>
      ProjectsLocationsEndpointsResource(_requester);
  ProjectsLocationsEvaluationItemsResource get evaluationItems =>
      ProjectsLocationsEvaluationItemsResource(_requester);
  ProjectsLocationsEvaluationRunsResource get evaluationRuns =>
      ProjectsLocationsEvaluationRunsResource(_requester);
  ProjectsLocationsEvaluationSetsResource get evaluationSets =>
      ProjectsLocationsEvaluationSetsResource(_requester);
  ProjectsLocationsEvaluationTasksResource get evaluationTasks =>
      ProjectsLocationsEvaluationTasksResource(_requester);
  ProjectsLocationsExampleStoresResource get exampleStores =>
      ProjectsLocationsExampleStoresResource(_requester);
  ProjectsLocationsExtensionControllersResource get extensionControllers =>
      ProjectsLocationsExtensionControllersResource(_requester);
  ProjectsLocationsExtensionsResource get extensions =>
      ProjectsLocationsExtensionsResource(_requester);
  ProjectsLocationsFeatureGroupsResource get featureGroups =>
      ProjectsLocationsFeatureGroupsResource(_requester);
  ProjectsLocationsFeatureOnlineStoresResource get featureOnlineStores =>
      ProjectsLocationsFeatureOnlineStoresResource(_requester);
  ProjectsLocationsFeaturestoresResource get featurestores =>
      ProjectsLocationsFeaturestoresResource(_requester);
  ProjectsLocationsHyperparameterTuningJobsResource
  get hyperparameterTuningJobs =>
      ProjectsLocationsHyperparameterTuningJobsResource(_requester);
  ProjectsLocationsIndexEndpointsResource get indexEndpoints =>
      ProjectsLocationsIndexEndpointsResource(_requester);
  ProjectsLocationsIndexesResource get indexes =>
      ProjectsLocationsIndexesResource(_requester);
  ProjectsLocationsMetadataStoresResource get metadataStores =>
      ProjectsLocationsMetadataStoresResource(_requester);
  ProjectsLocationsMigratableResourcesResource get migratableResources =>
      ProjectsLocationsMigratableResourcesResource(_requester);
  ProjectsLocationsModelDeploymentMonitoringJobsResource
  get modelDeploymentMonitoringJobs =>
      ProjectsLocationsModelDeploymentMonitoringJobsResource(_requester);
  ProjectsLocationsModelMonitorsResource get modelMonitors =>
      ProjectsLocationsModelMonitorsResource(_requester);
  ProjectsLocationsModelsResource get models =>
      ProjectsLocationsModelsResource(_requester);
  ProjectsLocationsNasJobsResource get nasJobs =>
      ProjectsLocationsNasJobsResource(_requester);
  ProjectsLocationsNotebookExecutionJobsResource get notebookExecutionJobs =>
      ProjectsLocationsNotebookExecutionJobsResource(_requester);
  ProjectsLocationsNotebookRuntimeTemplatesResource
  get notebookRuntimeTemplates =>
      ProjectsLocationsNotebookRuntimeTemplatesResource(_requester);
  ProjectsLocationsNotebookRuntimesResource get notebookRuntimes =>
      ProjectsLocationsNotebookRuntimesResource(_requester);
  ProjectsLocationsOperationsResource get operations =>
      ProjectsLocationsOperationsResource(_requester);
  ProjectsLocationsPersistentResourcesResource get persistentResources =>
      ProjectsLocationsPersistentResourcesResource(_requester);
  ProjectsLocationsPipelineJobsResource get pipelineJobs =>
      ProjectsLocationsPipelineJobsResource(_requester);
  ProjectsLocationsPublishersResource get publishers =>
      ProjectsLocationsPublishersResource(_requester);
  ProjectsLocationsRagCorporaResource get ragCorpora =>
      ProjectsLocationsRagCorporaResource(_requester);
  ProjectsLocationsRagEngineConfigResource get ragEngineConfig =>
      ProjectsLocationsRagEngineConfigResource(_requester);
  ProjectsLocationsReasoningEnginesResource get reasoningEngines =>
      ProjectsLocationsReasoningEnginesResource(_requester);
  ProjectsLocationsSchedulesResource get schedules =>
      ProjectsLocationsSchedulesResource(_requester);
  ProjectsLocationsSolversResource get solvers =>
      ProjectsLocationsSolversResource(_requester);
  ProjectsLocationsSpecialistPoolsResource get specialistPools =>
      ProjectsLocationsSpecialistPoolsResource(_requester);
  ProjectsLocationsStudiesResource get studies =>
      ProjectsLocationsStudiesResource(_requester);
  ProjectsLocationsTensorboardsResource get tensorboards =>
      ProjectsLocationsTensorboardsResource(_requester);
  ProjectsLocationsTrainingPipelinesResource get trainingPipelines =>
      ProjectsLocationsTrainingPipelinesResource(_requester);
  ProjectsLocationsTuningJobsResource get tuningJobs =>
      ProjectsLocationsTuningJobsResource(_requester);

  ProjectsLocationsResource(commons.ApiRequester client) : _requester = client;

  /// Given an input prompt, it returns augmented prompt from vertex rag store
  /// to guide LLM towards generating grounded responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to
  /// augment prompt. The users must have permission to make a call in the
  /// project. Format: `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1AugmentPromptResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1AugmentPromptResponse> augmentPrompt(
    GoogleCloudAiplatformV1beta1AugmentPromptRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + ':augmentPrompt';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1AugmentPromptResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Given an input text, it returns a score that evaluates the factuality of
  /// the text.
  ///
  /// It also extracts and returns claims from the text and provides supporting
  /// facts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to
  /// corroborate text. The users must have permission to make a call in the
  /// project. Format: `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CorroborateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CorroborateContentResponse>
  corroborateContent(
    GoogleCloudAiplatformV1beta1CorroborateContentRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + ':corroborateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CorroborateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deploys a model to a new endpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [destination] - Required. The resource name of the Location to deploy the
  /// model in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deploy(
    GoogleCloudAiplatformV1beta1DeployRequest request,
    core.String destination, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$destination') + ':deploy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deploys publisher models.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [destination] - Required. The resource name of the Location to deploy the
  /// model in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  async.Future<GoogleLongrunningOperation> deployPublisherModel(
    GoogleCloudAiplatformV1beta1DeployPublisherModelRequest request,
    core.String destination, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$destination') +
        ':deployPublisherModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Evaluates a dataset based on a set of given metrics.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The resource name of the Location to evaluate the
  /// dataset. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> evaluateDataset(
    GoogleCloudAiplatformV1beta1EvaluateDatasetRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$location') + ':evaluateDataset';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Evaluates instances based on a given metric.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The resource name of the Location to evaluate the
  /// instances. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1EvaluateInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1EvaluateInstancesResponse>
  evaluateInstances(
    GoogleCloudAiplatformV1beta1EvaluateInstancesRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$location') + ':evaluateInstances';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1EvaluateInstancesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets information about a location.
  ///
  /// Request parameters:
  ///
  /// [name] - Resource name for the location.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudLocationLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudLocationLocation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudLocationLocation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a RagEngineConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagEngineConfig resource. Format:
  /// `projects/{project}/locations/{location}/ragEngineConfig`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragEngineConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RagEngineConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RagEngineConfig> getRagEngineConfig(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RagEngineConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource that owns the locations collection, if applicable.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [extraLocationTypes] - Optional. A list of extra location types that
  /// should be used as conditions for controlling the visibility of the
  /// locations.
  ///
  /// [filter] - A filter to narrow down results to a preferred subset. The
  /// filtering language accepts strings like `"displayName=tokyo"`, and is
  /// documented in more detail in \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - The maximum number of results to return. If not set, the
  /// service selects a default.
  ///
  /// [pageToken] - A page token received from the `next_page_token` field in
  /// the response. Send that page token to receive the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudLocationListLocationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudLocationListLocationsResponse> list(
    core.String name, {
    core.List<core.String>? extraLocationTypes,
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (extraLocationTypes != null) 'extraLocationTypes': extraLocationTypes,
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/locations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudLocationListLocationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves relevant contexts for a query.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to
  /// retrieve RagContexts. The users must have permission to make a call in the
  /// project. Format: `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RetrieveContextsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RetrieveContextsResponse>
  retrieveContexts(
    GoogleCloudAiplatformV1beta1RetrieveContextsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + ':retrieveContexts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RetrieveContextsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a RagEngineConfig.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The name of the RagEngineConfig. Format:
  /// `projects/{project}/locations/{location}/ragEngineConfig`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragEngineConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> updateRagEngineConfig(
    GoogleCloudAiplatformV1beta1RagEngineConfig request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsAgentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsAgentsOperationsResource get operations =>
      ProjectsLocationsAgentsOperationsResource(_requester);

  ProjectsLocationsAgentsResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsAgentsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsAgentsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/agents/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/agents/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/agents/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/agents/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/agents/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsAppsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsAppsOperationsResource get operations =>
      ProjectsLocationsAppsOperationsResource(_requester);

  ProjectsLocationsAppsResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsAppsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsAppsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/apps/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/apps/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/apps/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/apps/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/apps/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsBatchPredictionJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsBatchPredictionJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Cancels a BatchPredictionJob.
  ///
  /// Starts asynchronous cancellation on the BatchPredictionJob. The server
  /// makes the best effort to cancel the job, but success is not guaranteed.
  /// Clients can use JobService.GetBatchPredictionJob or other methods to check
  /// whether the cancellation succeeded or whether the job completed despite
  /// cancellation. On a successful cancellation, the BatchPredictionJob is not
  /// deleted;instead its BatchPredictionJob.state is set to `CANCELLED`. Any
  /// files already outputted by the job are not deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob to cancel. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelBatchPredictionJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a BatchPredictionJob.
  ///
  /// A BatchPredictionJob once created will right away be attempted to start.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1BatchPredictionJob> create(
    GoogleCloudAiplatformV1beta1BatchPredictionJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchPredictionJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a BatchPredictionJob.
  ///
  /// Can only be called on jobs that already finished.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a BatchPredictionJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob resource. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1BatchPredictionJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchPredictionJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists BatchPredictionJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// BatchPredictionJobs from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. *
  /// \`model_display_name\` supports \`=\`, \`!=\` comparisons. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListBatchPredictionJobsResponse.next_page_token of the previous
  /// JobService.ListBatchPredictionJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCachedContentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCachedContentsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates cached content, this call will initialize the cached content in
  /// the data storage, and users need to pay for the cache data storage.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource where the cached content will be
  /// created
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CachedContent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CachedContent> create(
    GoogleCloudAiplatformV1beta1CachedContent request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/cachedContents';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CachedContent.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes cached content
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name referring to the cached content
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cachedContents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets cached content configurations
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name referring to the cached content
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cachedContents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CachedContent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CachedContent> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CachedContent.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists cached contents in a project
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent, which owns this collection of cached
  /// contents.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The maximum number of cached contents to return.
  /// The service may return fewer than this value. If unspecified, some default
  /// (under maximum) number of items will be returned. The maximum value is
  /// 1000; values above 1000 will be coerced to 1000.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListCachedContents` call. Provide this to retrieve the subsequent page.
  /// When paginating, all other parameters provided to `ListCachedContents`
  /// must match the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListCachedContentsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListCachedContentsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/cachedContents';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListCachedContentsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates cached content configurations
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Identifier. The server-generated resource name of the
  /// cached content Format:
  /// projects/{project}/locations/{location}/cachedContents/{cached_content}
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cachedContents/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The list of fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CachedContent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CachedContent> patch(
    GoogleCloudAiplatformV1beta1CachedContent request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CachedContent.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCustomJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCustomJobsOperationsResource get operations =>
      ProjectsLocationsCustomJobsOperationsResource(_requester);

  ProjectsLocationsCustomJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Cancels a CustomJob.
  ///
  /// Starts asynchronous cancellation on the CustomJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// JobService.GetCustomJob or other methods to check whether the cancellation
  /// succeeded or whether the job completed despite cancellation. On successful
  /// cancellation, the CustomJob is not deleted; instead it becomes a job with
  /// a CustomJob.error value with a google.rpc.Status.code of 1, corresponding
  /// to `Code.CANCELLED`, and CustomJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob to cancel. Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelCustomJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a CustomJob.
  ///
  /// A created CustomJob right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// CustomJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CustomJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CustomJob> create(
    GoogleCloudAiplatformV1beta1CustomJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/customJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CustomJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a CustomJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a CustomJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob resource. Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CustomJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CustomJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CustomJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists CustomJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// CustomJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListCustomJobsResponse.next_page_token of the previous
  /// JobService.ListCustomJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListCustomJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListCustomJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/customJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListCustomJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCustomJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCustomJobsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataLabelingJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataLabelingJobsOperationsResource get operations =>
      ProjectsLocationsDataLabelingJobsOperationsResource(_requester);

  ProjectsLocationsDataLabelingJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Cancels a DataLabelingJob.
  ///
  /// Success of cancellation is not guaranteed.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelDataLabelingJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a DataLabelingJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DataLabelingJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DataLabelingJob> create(
    GoogleCloudAiplatformV1beta1DataLabelingJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/dataLabelingJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DataLabelingJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a DataLabelingJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob to be deleted. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a DataLabelingJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DataLabelingJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DataLabelingJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DataLabelingJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists DataLabelingJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order by default. Use `desc` after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read. FieldMask represents a
  /// set of symbolic field paths. For example, the mask can be `paths: "name"`.
  /// The "name" here is a field in DataLabelingJob. If this field is not set,
  /// all fields of the DataLabelingJob are returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListDataLabelingJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListDataLabelingJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/dataLabelingJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListDataLabelingJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataLabelingJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataLabelingJobsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsResource get annotationSpecs =>
      ProjectsLocationsDatasetsAnnotationSpecsResource(_requester);
  ProjectsLocationsDatasetsDataItemsResource get dataItems =>
      ProjectsLocationsDatasetsDataItemsResource(_requester);
  ProjectsLocationsDatasetsDatasetVersionsResource get datasetVersions =>
      ProjectsLocationsDatasetsDatasetVersionsResource(_requester);
  ProjectsLocationsDatasetsOperationsResource get operations =>
      ProjectsLocationsDatasetsOperationsResource(_requester);
  ProjectsLocationsDatasetsSavedQueriesResource get savedQueries =>
      ProjectsLocationsDatasetsSavedQueriesResource(_requester);

  ProjectsLocationsDatasetsResource(commons.ApiRequester client)
    : _requester = client;

  /// Assembles each row of a multimodal dataset and writes the result into a
  /// BigQuery table.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource (used only for
  /// MULTIMODAL datasets). Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> assemble(
    GoogleCloudAiplatformV1beta1AssembleDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':assemble';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Assesses the state or validity of the dataset with respect to a given use
  /// case.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource. Used only for
  /// MULTIMODAL datasets. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> assess(
    GoogleCloudAiplatformV1beta1AssessDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':assess';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Dataset in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Dataset request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/datasets';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Exports data from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> export(
    GoogleCloudAiplatformV1beta1ExportDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':export';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Dataset> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Dataset.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Imports data into a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudAiplatformV1beta1ImportDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Datasets in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset's parent resource. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. *
  /// \`display_name\`: supports = and != * \`metadata_schema_uri\`: supports =
  /// and != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. Some examples: * \`displayName="myDisplayName"\` *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListDatasetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListDatasetsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/datasets';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListDatasetsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the Dataset.
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name` * `description` * `labels`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Dataset> patch(
    GoogleCloudAiplatformV1beta1Dataset request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Dataset.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Searches DataItems in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [dataset] - Required. The resource name of the Dataset from which to
  /// search DataItems. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [annotationFilters] - An expression that specifies what Annotations will
  /// be returned per DataItem. Annotations satisfied either of the conditions
  /// will be returned. * `annotation_spec_id` - for = or !=. Must specify
  /// `saved_query_id=` - saved query id that annotations should belong to.
  ///
  /// [annotationsFilter] - An expression for filtering the Annotations that
  /// will be returned per DataItem. * `annotation_spec_id` - for = or !=.
  ///
  /// [annotationsLimit] - If set, only up to this many of Annotations will be
  /// returned per DataItemView. The maximum value is 1000. If not set, the
  /// maximum value will be used.
  ///
  /// [dataItemFilter] - An expression for filtering the DataItem that will be
  /// returned. * `data_item_id` - for = or !=. * `labeled` - for = or !=. *
  /// `has_annotation(ANNOTATION_SPEC_ID)` - true only for DataItem that have at
  /// least one annotation with annotation_spec_id = `ANNOTATION_SPEC_ID` in the
  /// context of SavedQuery or DataLabelingJob. For example: * `data_item=1` *
  /// `has_annotation(5)`
  ///
  /// [dataLabelingJob] - The resource name of a DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// If this field is set, all of the search will be done in the context of
  /// this DataLabelingJob.
  ///
  /// [fieldMask] - Mask specifying which fields of DataItemView to read.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [orderByAnnotation_orderBy] - A comma-separated list of annotation fields
  /// to order by, sorted in ascending order. Use "desc" after a field name for
  /// descending. Must also specify saved_query.
  ///
  /// [orderByAnnotation_savedQuery] - Required. Saved query of the Annotation.
  /// Only Annotations belong to this saved query will be considered for
  /// ordering.
  ///
  /// [orderByDataItem] - A comma-separated list of data item fields to order
  /// by, sorted in ascending order. Use "desc" after a field name for
  /// descending.
  ///
  /// [pageSize] - Requested page size. Server may return fewer results than
  /// requested. Default and maximum page size is 100.
  ///
  /// [pageToken] - A token identifying a page of results for the server to
  /// return Typically obtained via SearchDataItemsResponse.next_page_token of
  /// the previous DatasetService.SearchDataItems call.
  ///
  /// [savedQuery] - The resource name of a SavedQuery(annotation set in UI).
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// All of the search will be done in the context of this SavedQuery.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1SearchDataItemsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SearchDataItemsResponse>
  searchDataItems(
    core.String dataset, {
    core.List<core.String>? annotationFilters,
    core.String? annotationsFilter,
    core.int? annotationsLimit,
    core.String? dataItemFilter,
    core.String? dataLabelingJob,
    core.String? fieldMask,
    core.String? orderBy,
    core.String? orderByAnnotation_orderBy,
    core.String? orderByAnnotation_savedQuery,
    core.String? orderByDataItem,
    core.int? pageSize,
    core.String? pageToken,
    core.String? savedQuery,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (annotationFilters != null) 'annotationFilters': annotationFilters,
      if (annotationsFilter != null) 'annotationsFilter': [annotationsFilter],
      if (annotationsLimit != null) 'annotationsLimit': ['${annotationsLimit}'],
      if (dataItemFilter != null) 'dataItemFilter': [dataItemFilter],
      if (dataLabelingJob != null) 'dataLabelingJob': [dataLabelingJob],
      if (fieldMask != null) 'fieldMask': [fieldMask],
      if (orderBy != null) 'orderBy': [orderBy],
      if (orderByAnnotation_orderBy != null)
        'orderByAnnotation.orderBy': [orderByAnnotation_orderBy],
      if (orderByAnnotation_savedQuery != null)
        'orderByAnnotation.savedQuery': [orderByAnnotation_savedQuery],
      if (orderByDataItem != null) 'orderByDataItem': [orderByDataItem],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (savedQuery != null) 'savedQuery': [savedQuery],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$dataset') + ':searchDataItems';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchDataItemsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsAnnotationSpecsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsOperationsResource get operations =>
      ProjectsLocationsDatasetsAnnotationSpecsOperationsResource(_requester);

  ProjectsLocationsDatasetsAnnotationSpecsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets an AnnotationSpec.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the AnnotationSpec resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1AnnotationSpec].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1AnnotationSpec> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1AnnotationSpec.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsAnnotationSpecsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsDataItemsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsResource get annotations =>
      ProjectsLocationsDatasetsDataItemsAnnotationsResource(_requester);
  ProjectsLocationsDatasetsDataItemsOperationsResource get operations =>
      ProjectsLocationsDatasetsDataItemsOperationsResource(_requester);

  ProjectsLocationsDatasetsDataItemsResource(commons.ApiRequester client)
    : _requester = client;

  /// Lists DataItems in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list DataItems
  /// from. Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListDataItemsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListDataItemsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/dataItems';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListDataItemsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsDataItemsAnnotationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource
  get operations =>
      ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource(
        _requester,
      );

  ProjectsLocationsDatasetsDataItemsAnnotationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Lists Annotations belongs to a dataitem.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the DataItem to list Annotations
  /// from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListAnnotationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListAnnotationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/annotations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListAnnotationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsDataItemsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsDatasetVersionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDatasetVersionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Create a version from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1DatasetVersion request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DatasetVersion> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DatasetVersion.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists DatasetVersions in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list
  /// DatasetVersions from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a DatasetVersion.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the DatasetVersion.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DatasetVersion> patch(
    GoogleCloudAiplatformV1beta1DatasetVersion request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DatasetVersion.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Restores a dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DatasetVersion resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> restore(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':restore';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsSavedQueriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsSavedQueriesOperationsResource get operations =>
      ProjectsLocationsDatasetsSavedQueriesOperationsResource(_requester);

  ProjectsLocationsDatasetsSavedQueriesResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a SavedQuery.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SavedQuery to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists SavedQueries in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list SavedQueries
  /// from. Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListSavedQueriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListSavedQueriesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/savedQueries';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListSavedQueriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDatasetsSavedQueriesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsSavedQueriesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDeploymentResourcePoolsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDeploymentResourcePoolsOperationsResource get operations =>
      ProjectsLocationsDeploymentResourcePoolsOperationsResource(_requester);

  ProjectsLocationsDeploymentResourcePoolsResource(commons.ApiRequester client)
    : _requester = client;

  /// Create a DeploymentResourcePool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent location resource where this
  /// DeploymentResourcePool will be created. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1CreateDeploymentResourcePoolRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/deploymentResourcePools';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Delete a DeploymentResourcePool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DeploymentResourcePool to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Get a DeploymentResourcePool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DeploymentResourcePool to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DeploymentResourcePool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DeploymentResourcePool> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DeploymentResourcePool.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// List DeploymentResourcePools in a location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent Location which owns this collection of
  /// DeploymentResourcePools. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of DeploymentResourcePools to return. The
  /// service may return fewer than this value.
  ///
  /// [pageToken] - A page token, received from a previous
  /// `ListDeploymentResourcePools` call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// `ListDeploymentResourcePools` must match the call that provided the page
  /// token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListDeploymentResourcePoolsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListDeploymentResourcePoolsResponse>
  list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/deploymentResourcePools';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListDeploymentResourcePoolsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Update a DeploymentResourcePool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the DeploymentResourcePool.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The list of fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1DeploymentResourcePool request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// List DeployedModels that have been deployed on this
  /// DeploymentResourcePool.
  ///
  /// Request parameters:
  ///
  /// [deploymentResourcePool] - Required. The name of the target
  /// DeploymentResourcePool to query. Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of DeployedModels to return. The service
  /// may return fewer than this value.
  ///
  /// [pageToken] - A page token, received from a previous `QueryDeployedModels`
  /// call. Provide this to retrieve the subsequent page. When paginating, all
  /// other parameters provided to `QueryDeployedModels` must match the call
  /// that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1QueryDeployedModelsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1QueryDeployedModelsResponse>
  queryDeployedModels(
    core.String deploymentResourcePool, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$deploymentResourcePool') +
        ':queryDeployedModels';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1QueryDeployedModelsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDeploymentResourcePoolsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDeploymentResourcePoolsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEdgeDevicesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEdgeDevicesOperationsResource get operations =>
      ProjectsLocationsEdgeDevicesOperationsResource(_requester);

  ProjectsLocationsEdgeDevicesResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsEdgeDevicesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEdgeDevicesOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/edgeDevices/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/edgeDevices/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/edgeDevices/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/edgeDevices/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/edgeDevices/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEndpointsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsChatResource get chat =>
      ProjectsLocationsEndpointsChatResource(_requester);
  ProjectsLocationsEndpointsOperationsResource get operations =>
      ProjectsLocationsEndpointsOperationsResource(_requester);

  ProjectsLocationsEndpointsResource(commons.ApiRequester client)
    : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1beta1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ComputeTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1beta1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CountTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates an Endpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Endpoint in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [endpointId] - Immutable. The ID to use for endpoint, which will become
  /// the final component of the endpoint resource name. If not provided, Vertex
  /// AI will generate a value for this ID. If the first character is a letter,
  /// this value may be up to 63 characters, and valid characters are
  /// `[a-z0-9-]`. The last character must be a letter or number. If the first
  /// character is a number, this value may be up to 9 characters, and valid
  /// characters are `[0-9]` with no leading zeros. When using HTTP/JSON, this
  /// field is populated based on a query string argument, such as
  /// `?endpoint_id=12345`. This is the fallback for fields that are not
  /// included in either the URI or the body.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Endpoint request,
    core.String parent, {
    core.String? endpointId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (endpointId != null) 'endpointId': [endpointId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/endpoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes an Endpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Endpoint resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deploys a Model into this Endpoint, creating a DeployedModel within it.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource into which to
  /// deploy a Model. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deployModel(
    GoogleCloudAiplatformV1beta1DeployModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':deployModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// Vertex first-party products and frameworks.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DirectPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DirectPredictResponse> directPredict(
    GoogleCloudAiplatformV1beta1DirectPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':directPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DirectPredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// custom containers.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1DirectRawPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1DirectRawPredictResponse>
  directRawPredict(
    GoogleCloudAiplatformV1beta1DirectRawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':directRawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1DirectRawPredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an online explanation.
  ///
  /// If deployed_model_id is specified, the corresponding DeployModel must have
  /// explanation_spec populated. If deployed_model_id is not specified, all
  /// DeployedModels must have explanation_spec populated.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// explanation. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ExplainResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ExplainResponse> explain(
    GoogleCloudAiplatformV1beta1ExplainRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':explain';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ExplainResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetch an asynchronous online prediction operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> fetchPredictOperation(
    GoogleCloudAiplatformV1beta1FetchPredictOperationRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$endpoint') +
        ':fetchPredictOperation';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  generateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets an Endpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Endpoint resource. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Endpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Endpoint> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Endpoint.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Endpoints in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the Endpoints. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `endpoint` supports `=` and `!=`. `endpoint` represents the Endpoint ID,
  /// i.e. the last segment of the Endpoint's resource name. * `display_name`
  /// supports `=` and `!=`. * `labels` supports general map functions that is:
  /// * `labels.key=value` - key:value equality * `labels.key:*` or `labels:key`
  /// - key existence * A key including a space must be quoted. `labels."a
  /// key"`. * `base_model_name` only supports `=`. Some examples: *
  /// `endpoint=1` * `displayName="myDisplayName"` * `labels.myKey="myValue"` *
  /// `baseModelName="text-bison"`
  ///
  /// [gdcZone] - Optional. Configures the Google Distributed Cloud (GDC)
  /// environment for online prediction. Only set this field when the Endpoint
  /// is to be deployed in a GDC environment.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListEndpointsResponse.next_page_token of the previous
  /// EndpointService.ListEndpoints call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListEndpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListEndpointsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? gdcZone,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (gdcZone != null) 'gdcZone': [gdcZone],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/endpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListEndpointsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an existing deployed model.
  ///
  /// Updatable fields include `min_replica_count`, `max_replica_count`,
  /// `required_replica_count`, `autoscaling_metric_specs`,
  /// `disable_container_logging` (v1 only), and `enable_container_logging`
  /// (v1beta1 only).
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource into which to
  /// mutate a DeployedModel. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> mutateDeployedModel(
    GoogleCloudAiplatformV1beta1MutateDeployedModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':mutateDeployedModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an Endpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Endpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Endpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Endpoint> patch(
    GoogleCloudAiplatformV1beta1Endpoint request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Endpoint.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PredictResponse> predict(
    GoogleCloudAiplatformV1beta1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> predictLongRunning(
    GoogleCloudAiplatformV1beta1PredictLongRunningRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predictLongRunning';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers: *
  /// `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction.
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's DeployedModel that
  /// served this prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> rawPredict(
    GoogleCloudAiplatformV1beta1RawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':rawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a server-side streaming online prediction request for Vertex LLM
  /// streaming.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1StreamingPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1StreamingPredictResponse>
  serverStreamingPredict(
    GoogleCloudAiplatformV1beta1StreamingPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$endpoint') +
        ':serverStreamingPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1StreamingPredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  streamGenerateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a streaming online prediction with an arbitrary HTTP payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> streamRawPredict(
    GoogleCloudAiplatformV1beta1StreamRawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':streamRawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Undeploys a Model from an Endpoint, removing a DeployedModel from it, and
  /// freeing all resources it's using.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource from which to
  /// undeploy a Model. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> undeployModel(
    GoogleCloudAiplatformV1beta1UndeployModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':undeployModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an Endpoint with a long running operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Endpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> update(
    GoogleCloudAiplatformV1beta1UpdateEndpointLongRunningRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':update';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEndpointsChatResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsChatResource(commons.ApiRequester client)
    : _requester = client;

  /// Exposes an OpenAI-compatible endpoint for chat completions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> completions(
    GoogleApiHttpBody request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + '/chat/completions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEndpointsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEvaluationItemsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationItemsOperationsResource get operations =>
      ProjectsLocationsEvaluationItemsOperationsResource(_requester);

  ProjectsLocationsEvaluationItemsResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsEvaluationItemsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationItemsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationItems/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEvaluationRunsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationRunsOperationsResource get operations =>
      ProjectsLocationsEvaluationRunsOperationsResource(_requester);

  ProjectsLocationsEvaluationRunsResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsEvaluationRunsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationRunsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationRuns/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationRuns/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationRuns/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationRuns/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEvaluationSetsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationSetsOperationsResource get operations =>
      ProjectsLocationsEvaluationSetsOperationsResource(_requester);

  ProjectsLocationsEvaluationSetsResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsEvaluationSetsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationSetsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationSets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationSets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationSets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationSets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEvaluationTasksResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationTasksOperationsResource get operations =>
      ProjectsLocationsEvaluationTasksOperationsResource(_requester);

  ProjectsLocationsEvaluationTasksResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsEvaluationTasksOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationTasksOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationTasks/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationTasks/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationTasks/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluationTasks/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsExampleStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsExampleStoresOperationsResource get operations =>
      ProjectsLocationsExampleStoresOperationsResource(_requester);

  ProjectsLocationsExampleStoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Create an ExampleStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// ExampleStore in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [exampleStore_createTime] - Output only. Timestamp when this ExampleStore
  /// was created.
  ///
  /// [exampleStore_description] - Optional. Description of the ExampleStore.
  ///
  /// [exampleStore_displayName] - Required. Display name of the ExampleStore.
  ///
  /// [exampleStore_exampleStoreConfig_vertexEmbeddingModel] - Required. The
  /// embedding model to be used for vector embedding. Immutable. Supported
  /// models: * "text-embedding-005" * "text-multilingual-embedding-002"
  ///
  /// [exampleStore_name] - Identifier. The resource name of the ExampleStore.
  /// This is a unique identifier. Format:
  /// projects/{project}/locations/{location}/exampleStores/{example_store}
  ///
  /// [exampleStore_updateTime] - Output only. Timestamp when this ExampleStore
  /// was most recently updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    core.String parent, {
    core.String? exampleStore_createTime,
    core.String? exampleStore_description,
    core.String? exampleStore_displayName,
    core.String? exampleStore_exampleStoreConfig_vertexEmbeddingModel,
    core.String? exampleStore_name,
    core.String? exampleStore_updateTime,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (exampleStore_createTime != null)
        'exampleStore.createTime': [exampleStore_createTime],
      if (exampleStore_description != null)
        'exampleStore.description': [exampleStore_description],
      if (exampleStore_displayName != null)
        'exampleStore.displayName': [exampleStore_displayName],
      if (exampleStore_exampleStoreConfig_vertexEmbeddingModel != null)
        'exampleStore.exampleStoreConfig.vertexEmbeddingModel': [
          exampleStore_exampleStoreConfig_vertexEmbeddingModel,
        ],
      if (exampleStore_name != null) 'exampleStore.name': [exampleStore_name],
      if (exampleStore_updateTime != null)
        'exampleStore.updateTime': [exampleStore_updateTime],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/exampleStores:create';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Delete an ExampleStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ExampleStore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Get Examples from the Example Store.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [exampleStore] - Required. The name of the ExampleStore resource that the
  /// examples should be fetched from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FetchExamplesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FetchExamplesResponse> fetchExamples(
    GoogleCloudAiplatformV1beta1FetchExamplesRequest request,
    core.String exampleStore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$exampleStore') + ':fetchExamples';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FetchExamplesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Get an ExampleStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ExampleStore. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ExampleStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ExampleStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ExampleStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// List ExampleStores in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// ExampleStores from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListExampleStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListExampleStoresResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/exampleStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListExampleStoresResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Update an ExampleStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the ExampleStore. This is a
  /// unique identifier. Format:
  /// projects/{project}/locations/{location}/exampleStores/{example_store}
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Mask specifying which fields to update. Supported
  /// fields: * `display_name` * `description`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1ExampleStore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Remove Examples from the Example Store.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [exampleStore] - Required. The name of the ExampleStore resource that the
  /// examples should be removed from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RemoveExamplesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RemoveExamplesResponse>
  removeExamples(
    GoogleCloudAiplatformV1beta1RemoveExamplesRequest request,
    core.String exampleStore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$exampleStore') + ':removeExamples';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RemoveExamplesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Search for similar Examples for given selection criteria.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [exampleStore] - Required. The name of the ExampleStore resource that
  /// examples are retrieved from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1SearchExamplesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SearchExamplesResponse>
  searchExamples(
    GoogleCloudAiplatformV1beta1SearchExamplesRequest request,
    core.String exampleStore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$exampleStore') + ':searchExamples';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchExamplesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Create or update Examples in the Example Store.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [exampleStore] - Required. The name of the ExampleStore resource that
  /// examples are added to or updated in. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1UpsertExamplesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1UpsertExamplesResponse>
  upsertExamples(
    GoogleCloudAiplatformV1beta1UpsertExamplesRequest request,
    core.String exampleStore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$exampleStore') + ':upsertExamples';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1UpsertExamplesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsExampleStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsExampleStoresOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/exampleStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsExtensionControllersResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsExtensionControllersOperationsResource get operations =>
      ProjectsLocationsExtensionControllersOperationsResource(_requester);

  ProjectsLocationsExtensionControllersResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsExtensionControllersOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsExtensionControllersOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensionControllers/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensionControllers/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensionControllers/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensionControllers/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensionControllers/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsExtensionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsExtensionsOperationsResource get operations =>
      ProjectsLocationsExtensionsOperationsResource(_requester);

  ProjectsLocationsExtensionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes an Extension.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Extension resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/extensions/{extension}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Executes the request against a given extension.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Name (identifier) of the extension; Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ExecuteExtensionResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ExecuteExtensionResponse> execute(
    GoogleCloudAiplatformV1beta1ExecuteExtensionRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':execute';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ExecuteExtensionResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets an Extension.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Extension resource. Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Extension].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Extension> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Extension.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Imports an Extension.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to import the
  /// Extension in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudAiplatformV1beta1Extension request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/extensions:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Extensions in a location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// Extensions from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. Supported fields: *
  /// `display_name` * `create_time` * `update_time` More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListExtensionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListExtensionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/extensions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListExtensionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an Extension.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the Extension.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Mask specifying which fields to update. Supported
  /// fields: * `display_name` * `description` * `runtime_config` *
  /// `tool_use_examples` * `manifest.description`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Extension].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Extension> patch(
    GoogleCloudAiplatformV1beta1Extension request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Extension.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Queries an extension with a default controller.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Name (identifier) of the extension; Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1QueryExtensionResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1QueryExtensionResponse> query(
    GoogleCloudAiplatformV1beta1QueryExtensionRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':query';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1QueryExtensionResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsExtensionsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsExtensionsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/extensions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureGroupsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeatureMonitorsResource get featureMonitors =>
      ProjectsLocationsFeatureGroupsFeatureMonitorsResource(_requester);
  ProjectsLocationsFeatureGroupsFeaturesResource get features =>
      ProjectsLocationsFeatureGroupsFeaturesResource(_requester);
  ProjectsLocationsFeatureGroupsOperationsResource get operations =>
      ProjectsLocationsFeatureGroupsOperationsResource(_requester);

  ProjectsLocationsFeatureGroupsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a new FeatureGroup in a given project and location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create
  /// FeatureGroups. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [featureGroupId] - Required. The ID to use for this FeatureGroup, which
  /// will become the final component of the FeatureGroup's resource name. This
  /// value may be up to 128 characters, and valid characters are `[a-z0-9_]`.
  /// The first character cannot be a number. The value must be unique within
  /// the project and location.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1FeatureGroup request,
    core.String parent, {
    core.String? featureGroupId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureGroupId != null) 'featureGroupId': [featureGroupId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureGroups';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single FeatureGroup.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureGroup to be deleted. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [force] - If set to true, any Features under this FeatureGroup will also
  /// be deleted. (Otherwise, the request will only work if the FeatureGroup has
  /// no Features.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single FeatureGroup.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureGroup resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FeatureGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureGroup> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureGroup.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists FeatureGroups in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// FeatureGroups. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureGroups that match the filter expression. The
  /// following fields are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// and key presence. Examples: * `create_time > "2020-01-01" OR update_time >
  /// "2020-01-01"` FeatureGroups created or updated after 2020-01-01. *
  /// `labels.env = "prod"` FeatureGroups with label "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// Fields: * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of FeatureGroups to return. The service
  /// may return fewer than this value. If unspecified, at most 100
  /// FeatureGroups will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureRegistryService.ListFeatureGroups call. Provide this to retrieve
  /// the subsequent page. When paginating, all other parameters provided to
  /// FeatureRegistryService.ListFeatureGroups must match the call that provided
  /// the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListFeatureGroupsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeatureGroupsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureGroups';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeatureGroupsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single FeatureGroup.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the FeatureGroup. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the FeatureGroup resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `labels` * `description` * `big_query` *
  /// `big_query.entity_id_columns` * `service_agent_type`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1FeatureGroup request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureGroupsFeatureMonitorsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeatureMonitorsFeatureMonitorJobsResource
  get featureMonitorJobs =>
      ProjectsLocationsFeatureGroupsFeatureMonitorsFeatureMonitorJobsResource(
        _requester,
      );
  ProjectsLocationsFeatureGroupsFeatureMonitorsOperationsResource
  get operations =>
      ProjectsLocationsFeatureGroupsFeatureMonitorsOperationsResource(
        _requester,
      );

  ProjectsLocationsFeatureGroupsFeatureMonitorsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a new FeatureMonitor in a given project, location and
  /// FeatureGroup.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of FeatureGroup to create
  /// FeatureMonitor. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featuregroup}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [featureMonitorId] - Required. The ID to use for this FeatureMonitor,
  /// which will become the final component of the FeatureGroup's resource name.
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number. The value must be
  /// unique within the FeatureGroup.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1FeatureMonitor request,
    core.String parent, {
    core.String? featureMonitorId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureMonitorId != null) 'featureMonitorId': [featureMonitorId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureMonitors';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single FeatureMonitor.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureMonitor to be deleted. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single FeatureMonitor.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureMonitor resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FeatureMonitor].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureMonitor> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureMonitor.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists FeatureGroups in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureGroup to list
  /// FeatureMonitors. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [filter] - Optional. Lists the FeatureMonitors that match the filter
  /// expression. The following fields are supported: * `create_time`: Supports
  /// `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons. Values must be in RFC
  /// 3339 format. * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  /// comparisons. Values must be in RFC 3339 format. * `labels`: Supports
  /// key-value equality and key presence. Examples: * `create_time >
  /// "2020-01-01" OR update_time > "2020-01-01"` FeatureMonitors created or
  /// updated after 2020-01-01. * `labels.env = "prod"` FeatureGroups with label
  /// "env" set to "prod".
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported Fields: * `create_time` * `update_time`
  ///
  /// [pageSize] - Optional. The maximum number of FeatureGroups to return. The
  /// service may return fewer than this value. If unspecified, at most 100
  /// FeatureMonitors will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// FeatureRegistryService.ListFeatureMonitors call. Provide this to retrieve
  /// the subsequent page. When paginating, all other parameters provided to
  /// FeatureRegistryService.ListFeatureMonitors must match the call that
  /// provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListFeatureMonitorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeatureMonitorsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureMonitors';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeatureMonitorsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single FeatureMonitor.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the FeatureMonitor. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}/featureMonitors/{featureMonitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Field mask is used to specify the fields to be
  /// overwritten in the FeatureMonitor resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field will be overwritten if it is in the mask. If the user
  /// does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields. Updatable fields: * `labels` * `description` * `schedule_config` *
  /// `feature_selection_config`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1FeatureMonitor request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureGroupsFeatureMonitorsFeatureMonitorJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeatureMonitorsFeatureMonitorJobsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a new feature monitor job.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of FeatureMonitor to create
  /// FeatureMonitorJob. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+$`.
  ///
  /// [featureMonitorJobId] - Optional. Output only. System-generated ID for
  /// feature monitor job.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FeatureMonitorJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureMonitorJob> create(
    GoogleCloudAiplatformV1beta1FeatureMonitorJob request,
    core.String parent, {
    core.String? featureMonitorJobId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureMonitorJobId != null)
        'featureMonitorJobId': [featureMonitorJobId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureMonitorJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureMonitorJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Get a feature monitor job.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureMonitorJob resource. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}/featureMonitorJobs/{feature_monitor_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+/featureMonitorJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FeatureMonitorJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureMonitorJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureMonitorJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// List feature monitor jobs.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureMonitor to list
  /// FeatureMonitorJobs. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+$`.
  ///
  /// [filter] - Optional. Lists the FeatureMonitorJobs that match the filter
  /// expression. The following fields are supported: * `create_time`: Supports
  /// `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons. Values must be Examples:
  /// * `create_time > "2020-01-01"` FeatureMonitorJobs created after
  /// 2020-01-01.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported Fields: * `create_time`
  ///
  /// [pageSize] - Optional. The maximum number of FeatureMonitorJobs to return.
  /// The service may return fewer than this value. If unspecified, at most 100
  /// FeatureMonitorJobs will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// FeatureRegistryService.ListFeatureMonitorJobs call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to FeatureRegistryService.ListFeatureMonitorJobs must match the
  /// call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListFeatureMonitorJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeatureMonitorJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureMonitorJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeatureMonitorJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureGroupsFeatureMonitorsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeatureMonitorsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/featureMonitors/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureGroupsFeaturesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeaturesOperationsResource get operations =>
      ProjectsLocationsFeatureGroupsFeaturesOperationsResource(_requester);

  ProjectsLocationsFeatureGroupsFeaturesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a batch of Features in a given FeatureGroup.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType/FeatureGroup to
  /// create the batch of Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCreate(
    GoogleCloudAiplatformV1beta1BatchCreateFeaturesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/features:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a new Feature in a given FeatureGroup.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType or FeatureGroup
  /// to create a Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [featureId] - Required. The ID to use for the Feature, which will become
  /// the final component of the Feature's resource name. This value may be up
  /// to 128 characters, and valid characters are `[a-z0-9_]`. The first
  /// character cannot be a number. The value must be unique within an
  /// EntityType/FeatureGroup.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Feature request,
    core.String parent, {
    core.String? featureId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureId != null) 'featureId': [featureId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Features to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Feature resource. Format for
  /// entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [featureStatsAndAnomalySpec_latestStatsCount] - Optional. If set, returns
  /// the most recent count of stats. Valid value is \[0, 100\]. If
  /// stats_time_range is set, return most recent count of stats within the
  /// stats_time_range.
  ///
  /// [featureStatsAndAnomalySpec_statsTimeRange_endTime] - Optional. Exclusive
  /// end of the interval. If specified, a Timestamp matching this interval will
  /// have to be before the end.
  ///
  /// [featureStatsAndAnomalySpec_statsTimeRange_startTime] - Optional.
  /// Inclusive start of the interval. If specified, a Timestamp matching this
  /// interval will have to be the same or after the start.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Feature> get(
    core.String name, {
    core.int? featureStatsAndAnomalySpec_latestStatsCount,
    core.String? featureStatsAndAnomalySpec_statsTimeRange_endTime,
    core.String? featureStatsAndAnomalySpec_statsTimeRange_startTime,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureStatsAndAnomalySpec_latestStatsCount != null)
        'featureStatsAndAnomalySpec.latestStatsCount': [
          '${featureStatsAndAnomalySpec_latestStatsCount}',
        ],
      if (featureStatsAndAnomalySpec_statsTimeRange_endTime != null)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime': [
          featureStatsAndAnomalySpec_statsTimeRange_endTime,
        ],
      if (featureStatsAndAnomalySpec_statsTimeRange_startTime != null)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime': [
          featureStatsAndAnomalySpec_statsTimeRange_startTime,
        ],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Feature.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Features in a given FeatureGroup.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [filter] - Lists the Features that match the filter expression. The
  /// following filters are supported: * `value_type`: Supports = and !=
  /// comparisons. * `create_time`: Supports =, !=, \<, \>, \>=, and \<=
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// =, !=, \<, \>, \>=, and \<= comparisons. Values must be in RFC 3339
  /// format. * `labels`: Supports key-value equality as well as key presence.
  /// Examples: * `value_type = DOUBLE` --\> Features whose type is DOUBLE. *
  /// `create_time > \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with 'env' as the key.
  ///
  /// [latestStatsCount] - Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent ListFeaturesRequest.latest_stats_count of
  /// stats for each Feature in response. Valid value is \[0, 10\]. If number of
  /// stats exists \< ListFeaturesRequest.latest_stats_count, return all
  /// existing stats.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `feature_id` * `value_type` (Not supported for FeatureRegistry
  /// Feature) * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 Features will
  /// be returned. The maximum value is 1000; any value greater than 1000 will
  /// be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeatures call or
  /// FeatureRegistryService.ListFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeatures or FeatureRegistryService.ListFeatures
  /// must match the call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeaturesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? latestStatsCount,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (latestStatsCount != null) 'latestStatsCount': ['${latestStatsCount}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeaturesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single Feature.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the Feature. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Features resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` * `disable_monitoring` (Not supported
  /// for FeatureRegistryService Feature) * `point_of_contact` (Not supported
  /// for FeaturestoreService FeatureStore)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1Feature request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureGroupsFeaturesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeaturesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureGroupsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureOnlineStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsResource get featureViews =>
      ProjectsLocationsFeatureOnlineStoresFeatureViewsResource(_requester);
  ProjectsLocationsFeatureOnlineStoresOperationsResource get operations =>
      ProjectsLocationsFeatureOnlineStoresOperationsResource(_requester);

  ProjectsLocationsFeatureOnlineStoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a new FeatureOnlineStore in a given project and location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create
  /// FeatureOnlineStores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [featureOnlineStoreId] - Required. The ID to use for this
  /// FeatureOnlineStore, which will become the final component of the
  /// FeatureOnlineStore's resource name. This value may be up to 60 characters,
  /// and valid characters are `[a-z0-9_]`. The first character cannot be a
  /// number. The value must be unique within the project and location.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1FeatureOnlineStore request,
    core.String parent, {
    core.String? featureOnlineStoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureOnlineStoreId != null)
        'featureOnlineStoreId': [featureOnlineStoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureOnlineStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single FeatureOnlineStore.
  ///
  /// The FeatureOnlineStore must not contain any FeatureViews.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureOnlineStore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [force] - If set to true, any FeatureViews and Features for this
  /// FeatureOnlineStore will also be deleted. (Otherwise, the request will only
  /// work if the FeatureOnlineStore has no FeatureViews.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single FeatureOnlineStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureOnlineStore resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FeatureOnlineStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureOnlineStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureOnlineStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists FeatureOnlineStores in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// FeatureOnlineStores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureOnlineStores that match the filter expression.
  /// The following fields are supported: * `create_time`: Supports `=`, `!=`,
  /// `<`, `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// and key presence. Examples: * `create_time > "2020-01-01" OR update_time >
  /// "2020-01-01"` FeatureOnlineStores created or updated after 2020-01-01. *
  /// `labels.env = "prod"` FeatureOnlineStores with label "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// Fields: * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of FeatureOnlineStores to return. The
  /// service may return fewer than this value. If unspecified, at most 100
  /// FeatureOnlineStores will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureOnlineStoreAdminService.ListFeatureOnlineStores call. Provide this
  /// to retrieve the subsequent page. When paginating, all other parameters
  /// provided to FeatureOnlineStoreAdminService.ListFeatureOnlineStores must
  /// match the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListFeatureOnlineStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeatureOnlineStoresResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureOnlineStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeatureOnlineStoresResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single FeatureOnlineStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the FeatureOnlineStore. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the FeatureOnlineStore resource by the update. The fields specified in
  /// the update_mask are relative to the resource, not the full request. A
  /// field will be overwritten if it is in the mask. If the user does not
  /// provide a mask then only the non-empty fields present in the request will
  /// be overwritten. Set the update_mask to `*` to override all fields.
  /// Updatable fields: * `labels` * `description` * `bigtable` *
  /// `bigtable.auto_scaling` * `bigtable.enable_multi_region_replica`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1FeatureOnlineStore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureOnlineStoresFeatureViewsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource
  get featureViewSyncs =>
      ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource(
        _requester,
      );
  ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource
  get operations =>
      ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource(
        _requester,
      );

  ProjectsLocationsFeatureOnlineStoresFeatureViewsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a new FeatureView in a given FeatureOnlineStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureOnlineStore to create
  /// FeatureViews. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [featureViewId] - Required. The ID to use for the FeatureView, which will
  /// become the final component of the FeatureView's resource name. This value
  /// may be up to 60 characters, and valid characters are `[a-z0-9_]`. The
  /// first character cannot be a number. The value must be unique within a
  /// FeatureOnlineStore.
  ///
  /// [runSyncImmediately] - Immutable. If set to true, one on demand sync will
  /// be run immediately, regardless whether the FeatureView.sync_config is
  /// configured or not.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1FeatureView request,
    core.String parent, {
    core.String? featureViewId,
    core.bool? runSyncImmediately,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureViewId != null) 'featureViewId': [featureViewId],
      if (runSyncImmediately != null)
        'runSyncImmediately': ['${runSyncImmediately}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureViews';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single FeatureView.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureView to be deleted. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bidirectional streaming RPC to directly write to feature values in a
  /// feature view.
  ///
  /// Requests may not have a one-to-one mapping to responses and responses may
  /// be returned out-of-order to reduce latency.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponse>
  directWrite(
    GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$featureView') + ':directWrite';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetch feature values under a FeatureView.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse>
  fetchFeatureValues(
    GoogleCloudAiplatformV1beta1FetchFeatureValuesRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$featureView') +
        ':fetchFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single FeatureView.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureView resource. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FeatureView].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureView> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureView.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists FeatureViews in a given FeatureOnlineStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureOnlineStore to list
  /// FeatureViews. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureViews that match the filter expression. The
  /// following filters are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `>=`, and `<=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// as well as key presence. Examples: * `create_time >
  /// \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> FeatureViews created or updated
  /// after 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env =
  /// prod` --\> FeatureViews having both (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --\> Any FeatureView which has a label with 'env' as the
  /// key.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `feature_view_id` * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of FeatureViews to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 FeatureViews
  /// will be returned. The maximum value is 1000; any value greater than 1000
  /// will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureOnlineStoreAdminService.ListFeatureViews call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to FeatureOnlineStoreAdminService.ListFeatureViews must match the
  /// call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListFeatureViewsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeatureViewsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureViews';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeatureViewsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single FeatureView.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the FeatureView. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the FeatureView resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `labels` * `service_agent_type` * `big_query_source` *
  /// `big_query_source.uri` * `big_query_source.entity_id_columns` *
  /// `feature_registry_source` * `feature_registry_source.feature_groups` *
  /// `sync_config` * `sync_config.cron` *
  /// `optimized_config.automatic_resources`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1FeatureView request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Search the nearest entities under a FeatureView.
  ///
  /// Search only works for indexable feature view; if a feature view isn't
  /// indexable, returns Invalid argument response.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1SearchNearestEntitiesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SearchNearestEntitiesResponse>
  searchNearestEntities(
    GoogleCloudAiplatformV1beta1SearchNearestEntitiesRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$featureView') +
        ':searchNearestEntities';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchNearestEntitiesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bidirectional streaming RPC to fetch feature values under a FeatureView.
  ///
  /// Requests may not have a one-to-one mapping to responses and responses may
  /// be returned out-of-order to reduce latency.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesResponse>
  streamingFetchFeatureValues(
    GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$featureView') +
        ':streamingFetchFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Triggers on-demand sync for the FeatureView.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - Required. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1SyncFeatureViewResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SyncFeatureViewResponse> sync(
    GoogleCloudAiplatformV1beta1SyncFeatureViewRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$featureView') + ':sync';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SyncFeatureViewResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets details of a single FeatureViewSync.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureViewSync resource. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/featureViewSyncs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FeatureViewSync].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FeatureViewSync> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FeatureViewSync.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists FeatureViewSyncs in a given FeatureView.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureView to list
  /// FeatureViewSyncs. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureViewSyncs that match the filter expression.
  /// The following filters are supported: * `create_time`: Supports `=`, `!=`,
  /// `<`, `>`, `>=`, and `<=` comparisons. Values must be in RFC 3339 format.
  /// Examples: * `create_time > \"2020-01-31T15:30:00.000000Z\"` --\>
  /// FeatureViewSyncs created after 2020-01-31T15:30:00.000000Z.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `create_time`
  ///
  /// [pageSize] - The maximum number of FeatureViewSyncs to return. The service
  /// may return fewer than this value. If unspecified, at most 1000
  /// FeatureViewSyncs will be returned. The maximum value is 1000; any value
  /// greater than 1000 will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureOnlineStoreAdminService.ListFeatureViewSyncs call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to FeatureOnlineStoreAdminService.ListFeatureViewSyncs must match
  /// the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListFeatureViewSyncsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeatureViewSyncsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/featureViewSyncs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeatureViewSyncsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeatureOnlineStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeaturestoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesResource get entityTypes =>
      ProjectsLocationsFeaturestoresEntityTypesResource(_requester);
  ProjectsLocationsFeaturestoresOperationsResource get operations =>
      ProjectsLocationsFeaturestoresOperationsResource(_requester);

  ProjectsLocationsFeaturestoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Batch reads Feature values from a Featurestore.
  ///
  /// This API enables batch reading Feature values, where each read instance in
  /// the batch may read Feature values of entities from one or more
  /// EntityTypes. Point-in-time correctness is guaranteed for Feature values of
  /// each read instance as of each instance's read timestamp.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featurestore] - Required. The resource name of the Featurestore from
  /// which to query Feature values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchReadFeatureValues(
    GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequest request,
    core.String featurestore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$featurestore') +
        ':batchReadFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a new Featurestore in a given project and location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create
  /// Featurestores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [featurestoreId] - Required. The ID to use for this Featurestore, which
  /// will become the final component of the Featurestore's resource name. This
  /// value may be up to 60 characters, and valid characters are `[a-z0-9_]`.
  /// The first character cannot be a number. The value must be unique within
  /// the project and location.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Featurestore request,
    core.String parent, {
    core.String? featurestoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featurestoreId != null) 'featurestoreId': [featurestoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/featurestores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single Featurestore.
  ///
  /// The Featurestore must not contain any EntityTypes or `force` must be set
  /// to true for the request to succeed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Featurestore to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [force] - If set to true, any EntityTypes and Features for this
  /// Featurestore will also be deleted. (Otherwise, the request will only work
  /// if the Featurestore has no EntityTypes.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single Featurestore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Featurestore resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Featurestore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Featurestore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Featurestore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    GoogleIamV1GetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Featurestores in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// Featurestores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the featurestores that match the filter expression. The
  /// following fields are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. *
  /// `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
  /// `<=`, and `>=` comparisons. * `labels`: Supports key-value equality and
  /// key presence. Examples: * `create_time > "2020-01-01" OR update_time >
  /// "2020-01-01"` Featurestores created or updated after 2020-01-01. *
  /// `labels.env = "prod"` Featurestores with label "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// Fields: * `create_time` * `update_time` *
  /// `online_serving_config.fixed_node_count`
  ///
  /// [pageSize] - The maximum number of Featurestores to return. The service
  /// may return fewer than this value. If unspecified, at most 100
  /// Featurestores will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeaturestores call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeaturestores must match the call that provided
  /// the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListFeaturestoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeaturestoresResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/featurestores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeaturestoresResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single Featurestore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the Featurestore. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Featurestore resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `labels` * `online_serving_config.fixed_node_count` *
  /// `online_serving_config.scaling` * `online_storage_ttl_days`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1Featurestore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Searches Features matching a query in a given project.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The resource name of the Location to search
  /// Features. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Features will be
  /// returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.SearchFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.SearchFeatures, except `page_size`, must match the
  /// call that provided the page token.
  ///
  /// [query] - Query string that is a conjunction of field-restricted queries
  /// and/or field-restricted filters. Field-restricted queries and filters can
  /// be combined using `AND` to form a conjunction. A field query is in the
  /// form FIELD:QUERY. This implicitly checks if QUERY exists as a substring
  /// within Feature's FIELD. The QUERY and the FIELD are converted to a
  /// sequence of words (i.e. tokens) for comparison. This is done by: *
  /// Removing leading/trailing whitespace and tokenizing the search value.
  /// Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore `_`,
  /// or asterisk `*` are treated as delimiters for tokens. `*` is treated as a
  /// wildcard that matches characters within a token. * Ignoring case. *
  /// Prepending an asterisk to the first and appending an asterisk to the last
  /// token in QUERY. A QUERY must be either a singular token or a phrase. A
  /// phrase is one or multiple words enclosed in double quotation marks (").
  /// With phrases, the order of the words is important. Words in the phrase
  /// must be matching in order and consecutively. Supported FIELDs for
  /// field-restricted queries: * `feature_id` * `description` *
  /// `entity_type_id` Examples: * `feature_id: foo` --\> Matches a Feature with
  /// ID containing the substring `foo` (eg. `foo`, `foofeature`, `barfoo`). *
  /// `feature_id: foo*feature` --\> Matches a Feature with ID containing the
  /// substring `foo*feature` (eg. `foobarfeature`). * `feature_id: foo AND
  /// description: bar` --\> Matches a Feature with ID containing the substring
  /// `foo` and description containing the substring `bar`. Besides field
  /// queries, the following exact-match filters are supported. The exact-match
  /// filters do not support wildcards. Unlike field-restricted queries,
  /// exact-match filters are case-sensitive. * `feature_id`: Supports =
  /// comparisons. * `description`: Supports = comparisons. Multi-token filters
  /// should be enclosed in quotes. * `entity_type_id`: Supports = comparisons.
  /// * `value_type`: Supports = and != comparisons. * `labels`: Supports
  /// key-value equality as well as key presence. * `featurestore_id`: Supports
  /// = comparisons. Examples: * `description = "foo bar"` --\> Any Feature with
  /// description exactly equal to `foo bar` * `value_type = DOUBLE` --\>
  /// Features whose type is DOUBLE. * `labels.active = yes AND labels.env =
  /// prod` --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with `env` as the key.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1SearchFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SearchFeaturesResponse>
  searchFeatures(
    core.String location, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? query,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (query != null) 'query': [query],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$location') +
        '/featurestores:searchFeatures';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchFeaturesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    GoogleIamV1TestIamPermissionsRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeaturestoresEntityTypesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesResource get features =>
      ProjectsLocationsFeaturestoresEntityTypesFeaturesResource(_requester);
  ProjectsLocationsFeaturestoresEntityTypesOperationsResource get operations =>
      ProjectsLocationsFeaturestoresEntityTypesOperationsResource(_requester);

  ProjectsLocationsFeaturestoresEntityTypesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a new EntityType in a given Featurestore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Featurestore to create
  /// EntityTypes. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [entityTypeId] - Required. The ID to use for the EntityType, which will
  /// become the final component of the EntityType's resource name. This value
  /// may be up to 60 characters, and valid characters are `[a-z0-9_]`. The
  /// first character cannot be a number. The value must be unique within a
  /// featurestore.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1EntityType request,
    core.String parent, {
    core.String? entityTypeId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (entityTypeId != null) 'entityTypeId': [entityTypeId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/entityTypes';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single EntityType.
  ///
  /// The EntityType must not have any Features or `force` must be set to true
  /// for the request to succeed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the EntityType to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [force] - If set to true, any Features for this EntityType will also be
  /// deleted. (Otherwise, the request will only work if the EntityType has no
  /// Features.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Delete Feature values from Featurestore.
  ///
  /// The progress of the deletion is tracked by the returned operation. The
  /// deleted feature values are guaranteed to be invisible to subsequent read
  /// operations after the operation is marked as successfully done. If a delete
  /// feature values operation fails, the feature values returned from reads and
  /// exports may be inconsistent. If consistency is required, the caller must
  /// retry the same delete request again and wait till the new operation
  /// returned is marked as successfully done.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType grouping the
  /// Features for which values are being deleted from. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deleteFeatureValues(
    GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$entityType') +
        ':deleteFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Exports Feature values from all the entities of a target EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType from which to
  /// export Feature values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> exportFeatureValues(
    GoogleCloudAiplatformV1beta1ExportFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$entityType') +
        ':exportFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single EntityType.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the EntityType resource. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1EntityType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1EntityType> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1EntityType.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Imports Feature values into the Featurestore from a source storage.
  ///
  /// The progress of the import is tracked by the returned operation. The
  /// imported features are guaranteed to be visible to subsequent read
  /// operations after the operation is marked as successfully done. If an
  /// import operation fails, the Feature values returned from reads and exports
  /// may be inconsistent. If consistency is required, the caller must retry the
  /// same import request again and wait till the new operation returned is
  /// marked as successfully done. There are also scenarios where the caller can
  /// cause inconsistency. - Source data for import contains multiple distinct
  /// Feature values for the same entity ID and timestamp. - Source is modified
  /// during an import. This includes adding, updating, or removing source data
  /// and/or metadata. Examples of updating metadata include but are not limited
  /// to changing storage location, storage class, or retention policy. - Online
  /// serving cluster is under-provisioned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType grouping the
  /// Features for which values are being imported. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> importFeatureValues(
    GoogleCloudAiplatformV1beta1ImportFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$entityType') +
        ':importFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists EntityTypes in a given Featurestore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Featurestore to list
  /// EntityTypes. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [filter] - Lists the EntityTypes that match the filter expression. The
  /// following filters are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `>=`, and `<=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// as well as key presence. Examples: * `create_time >
  /// \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> EntityTypes having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any EntityType which has a label with 'env' as the
  /// key.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `entity_type_id` * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of EntityTypes to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 EntityTypes
  /// will be returned. The maximum value is 1000; any value greater than 1000
  /// will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListEntityTypes call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListEntityTypes must match the call that provided the
  /// page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListEntityTypesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListEntityTypesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/entityTypes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListEntityTypesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the EntityType. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// The last part entity_type is assigned by the client. The entity_type can
  /// be up to 64 characters long and can consist only of ASCII Latin letters
  /// A-Z and a-z and underscore(_), and ASCII digits 0-9 starting with a
  /// letter. The value will be unique given a featurestore.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the EntityType resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` *
  /// `monitoring_config.snapshot_analysis.disabled` *
  /// `monitoring_config.snapshot_analysis.monitoring_interval_days` *
  /// `monitoring_config.snapshot_analysis.staleness_days` *
  /// `monitoring_config.import_features_analysis.state` *
  /// `monitoring_config.import_features_analysis.anomaly_detection_baseline` *
  /// `monitoring_config.numerical_threshold_config.value` *
  /// `monitoring_config.categorical_threshold_config.value` *
  /// `offline_storage_ttl_days`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1EntityType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1EntityType> patch(
    GoogleCloudAiplatformV1beta1EntityType request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1EntityType.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Reads Feature values of a specific entity of an EntityType.
  ///
  /// For reading feature values of multiple entities of an EntityType, please
  /// use StreamingReadFeatureValues.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType for the
  /// entity being read. Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse>
  readFeatureValues(
    GoogleCloudAiplatformV1beta1ReadFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$entityType') + ':readFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Reads Feature values for multiple entities.
  ///
  /// Depending on their size, data for different entities may be broken up
  /// across multiple responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the entities' type. Value
  /// format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse>
  streamingReadFeatureValues(
    GoogleCloudAiplatformV1beta1StreamingReadFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$entityType') +
        ':streamingReadFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Writes Feature values of one or more entities of an EntityType.
  ///
  /// The Feature values are merged into existing entities if any. The Feature
  /// values to be written must have timestamp within the online storage
  /// retention.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType for the
  /// entities being written. Value format:
  /// `projects/{project}/locations/{location}/featurestores/
  /// {featurestore}/entityTypes/{entityType}`. For example, for a machine
  /// learning model predicting user clicks on a website, an EntityType ID could
  /// be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1WriteFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1WriteFeatureValuesResponse>
  writeFeatureValues(
    GoogleCloudAiplatformV1beta1WriteFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$entityType') + ':writeFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1WriteFeatureValuesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeaturestoresEntityTypesFeaturesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource
  get operations =>
      ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource(
        _requester,
      );

  ProjectsLocationsFeaturestoresEntityTypesFeaturesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a batch of Features in a given EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType/FeatureGroup to
  /// create the batch of Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCreate(
    GoogleCloudAiplatformV1beta1BatchCreateFeaturesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/features:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a new Feature in a given EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType or FeatureGroup
  /// to create a Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [featureId] - Required. The ID to use for the Feature, which will become
  /// the final component of the Feature's resource name. This value may be up
  /// to 128 characters, and valid characters are `[a-z0-9_]`. The first
  /// character cannot be a number. The value must be unique within an
  /// EntityType/FeatureGroup.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Feature request,
    core.String parent, {
    core.String? featureId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureId != null) 'featureId': [featureId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Features to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Feature resource. Format for
  /// entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [featureStatsAndAnomalySpec_latestStatsCount] - Optional. If set, returns
  /// the most recent count of stats. Valid value is \[0, 100\]. If
  /// stats_time_range is set, return most recent count of stats within the
  /// stats_time_range.
  ///
  /// [featureStatsAndAnomalySpec_statsTimeRange_endTime] - Optional. Exclusive
  /// end of the interval. If specified, a Timestamp matching this interval will
  /// have to be before the end.
  ///
  /// [featureStatsAndAnomalySpec_statsTimeRange_startTime] - Optional.
  /// Inclusive start of the interval. If specified, a Timestamp matching this
  /// interval will have to be the same or after the start.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Feature> get(
    core.String name, {
    core.int? featureStatsAndAnomalySpec_latestStatsCount,
    core.String? featureStatsAndAnomalySpec_statsTimeRange_endTime,
    core.String? featureStatsAndAnomalySpec_statsTimeRange_startTime,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureStatsAndAnomalySpec_latestStatsCount != null)
        'featureStatsAndAnomalySpec.latestStatsCount': [
          '${featureStatsAndAnomalySpec_latestStatsCount}',
        ],
      if (featureStatsAndAnomalySpec_statsTimeRange_endTime != null)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime': [
          featureStatsAndAnomalySpec_statsTimeRange_endTime,
        ],
      if (featureStatsAndAnomalySpec_statsTimeRange_startTime != null)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime': [
          featureStatsAndAnomalySpec_statsTimeRange_startTime,
        ],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Feature.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Features in a given EntityType.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [filter] - Lists the Features that match the filter expression. The
  /// following filters are supported: * `value_type`: Supports = and !=
  /// comparisons. * `create_time`: Supports =, !=, \<, \>, \>=, and \<=
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// =, !=, \<, \>, \>=, and \<= comparisons. Values must be in RFC 3339
  /// format. * `labels`: Supports key-value equality as well as key presence.
  /// Examples: * `value_type = DOUBLE` --\> Features whose type is DOUBLE. *
  /// `create_time > \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with 'env' as the key.
  ///
  /// [latestStatsCount] - Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent ListFeaturesRequest.latest_stats_count of
  /// stats for each Feature in response. Valid value is \[0, 10\]. If number of
  /// stats exists \< ListFeaturesRequest.latest_stats_count, return all
  /// existing stats.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `feature_id` * `value_type` (Not supported for FeatureRegistry
  /// Feature) * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 Features will
  /// be returned. The maximum value is 1000; any value greater than 1000 will
  /// be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeatures call or
  /// FeatureRegistryService.ListFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeatures or FeatureRegistryService.ListFeatures
  /// must match the call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListFeaturesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? latestStatsCount,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (latestStatsCount != null) 'latestStatsCount': ['${latestStatsCount}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListFeaturesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the parameters of a single Feature.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the Feature. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Features resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` * `disable_monitoring` (Not supported
  /// for FeatureRegistryService Feature) * `point_of_contact` (Not supported
  /// for FeaturestoreService FeatureStore)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Feature> patch(
    GoogleCloudAiplatformV1beta1Feature request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Feature.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeaturestoresEntityTypesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsFeaturestoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsHyperparameterTuningJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsHyperparameterTuningJobsOperationsResource get operations =>
      ProjectsLocationsHyperparameterTuningJobsOperationsResource(_requester);

  ProjectsLocationsHyperparameterTuningJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Cancels a HyperparameterTuningJob.
  ///
  /// Starts asynchronous cancellation on the HyperparameterTuningJob. The
  /// server makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use JobService.GetHyperparameterTuningJob or other
  /// methods to check whether the cancellation succeeded or whether the job
  /// completed despite cancellation. On successful cancellation, the
  /// HyperparameterTuningJob is not deleted; instead it becomes a job with a
  /// HyperparameterTuningJob.error value with a google.rpc.Status.code of 1,
  /// corresponding to `Code.CANCELLED`, and HyperparameterTuningJob.state is
  /// set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelHyperparameterTuningJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a HyperparameterTuningJob
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// HyperparameterTuningJob in. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1HyperparameterTuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1HyperparameterTuningJob> create(
    GoogleCloudAiplatformV1beta1HyperparameterTuningJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/hyperparameterTuningJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1HyperparameterTuningJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a HyperparameterTuningJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a HyperparameterTuningJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1HyperparameterTuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1HyperparameterTuningJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1HyperparameterTuningJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists HyperparameterTuningJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// HyperparameterTuningJobs from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListHyperparameterTuningJobsResponse.next_page_token of the previous
  /// JobService.ListHyperparameterTuningJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListHyperparameterTuningJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListHyperparameterTuningJobsResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/hyperparameterTuningJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListHyperparameterTuningJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsHyperparameterTuningJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsHyperparameterTuningJobsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsIndexEndpointsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexEndpointsOperationsResource get operations =>
      ProjectsLocationsIndexEndpointsOperationsResource(_requester);

  ProjectsLocationsIndexEndpointsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// IndexEndpoint in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1IndexEndpoint request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/indexEndpoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes an IndexEndpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the IndexEndpoint resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deploys an Index into this IndexEndpoint, creating a DeployedIndex within
  /// it.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource into
  /// which to deploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deployIndex(
    GoogleCloudAiplatformV1beta1DeployIndexRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$indexEndpoint') + ':deployIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Finds the nearest neighbors of each vector within the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the index endpoint. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1FindNeighborsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1FindNeighborsResponse> findNeighbors(
    GoogleCloudAiplatformV1beta1FindNeighborsRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$indexEndpoint') + ':findNeighbors';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1FindNeighborsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets an IndexEndpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the IndexEndpoint resource. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1IndexEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1IndexEndpoint> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1IndexEndpoint.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists IndexEndpoints in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the IndexEndpoints. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `index_endpoint` supports = and !=. `index_endpoint` represents the
  /// IndexEndpoint ID, ie. the last segment of the IndexEndpoint's
  /// resourcename. * `display_name` supports =, != and regex() (uses
  /// [re2](https://github.com/google/re2/wiki/Syntax) syntax) * `labels`
  /// supports general map functions that is: `labels.key=value` - key:value
  /// equality `labels.key:* or labels:key - key existence A key including a
  /// space must be quoted. `labels."a key"`. Some examples: *
  /// `index_endpoint="1"` * `display_name="myDisplayName"` *
  /// `regex(display_name, "^A") -\> The display name starts with an A. *
  /// `labels.myKey="myValue"`
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListIndexEndpointsResponse.next_page_token of the previous
  /// IndexEndpointService.ListIndexEndpoints call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListIndexEndpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListIndexEndpointsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/indexEndpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListIndexEndpointsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Update an existing DeployedIndex under an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource into
  /// which to deploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> mutateDeployedIndex(
    GoogleCloudAiplatformV1beta1DeployedIndex request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$indexEndpoint') +
        ':mutateDeployedIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the IndexEndpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1IndexEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1IndexEndpoint> patch(
    GoogleCloudAiplatformV1beta1IndexEndpoint request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1IndexEndpoint.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Reads the datapoints/vectors of the given IDs.
  ///
  /// A maximum of 1000 datapoints can be retrieved in a batch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the index endpoint. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ReadIndexDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReadIndexDatapointsResponse>
  readIndexDatapoints(
    GoogleCloudAiplatformV1beta1ReadIndexDatapointsRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$indexEndpoint') +
        ':readIndexDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReadIndexDatapointsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Undeploys an Index from an IndexEndpoint, removing a DeployedIndex from
  /// it, and freeing all resources it's using.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource from
  /// which to undeploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> undeployIndex(
    GoogleCloudAiplatformV1beta1UndeployIndexRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$indexEndpoint') + ':undeployIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsIndexEndpointsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexEndpointsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsIndexesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexesOperationsResource get operations =>
      ProjectsLocationsIndexesOperationsResource(_requester);

  ProjectsLocationsIndexesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the Index
  /// in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Index request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/indexes';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes an Index.
  ///
  /// An Index can only be deleted when all its DeployedIndexes had been
  /// undeployed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Index resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets an Index.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Index resource. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Index].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Index> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Index.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Imports an Index from an external source (e.g., BigQuery).
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Index resource to import data to.
  /// Format: `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudAiplatformV1beta1ImportIndexRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Indexes in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the Indexes. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListIndexesResponse.next_page_token of the previous
  /// IndexService.ListIndexes call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListIndexesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListIndexesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/indexes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListIndexesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Index.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [updateMask] - The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1Index request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Remove Datapoints from an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [index] - Required. The name of the Index resource to be updated. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RemoveDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RemoveDatapointsResponse>
  removeDatapoints(
    GoogleCloudAiplatformV1beta1RemoveDatapointsRequest request,
    core.String index, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$index') + ':removeDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RemoveDatapointsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Add/update Datapoints into an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [index] - Required. The name of the Index resource to be updated. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1UpsertDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1UpsertDatapointsResponse>
  upsertDatapoints(
    GoogleCloudAiplatformV1beta1UpsertDatapointsRequest request,
    core.String index, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$index') + ':upsertDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1UpsertDatapointsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsIndexesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexesOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsResource get artifacts =>
      ProjectsLocationsMetadataStoresArtifactsResource(_requester);
  ProjectsLocationsMetadataStoresContextsResource get contexts =>
      ProjectsLocationsMetadataStoresContextsResource(_requester);
  ProjectsLocationsMetadataStoresExecutionsResource get executions =>
      ProjectsLocationsMetadataStoresExecutionsResource(_requester);
  ProjectsLocationsMetadataStoresMetadataSchemasResource get metadataSchemas =>
      ProjectsLocationsMetadataStoresMetadataSchemasResource(_requester);
  ProjectsLocationsMetadataStoresOperationsResource get operations =>
      ProjectsLocationsMetadataStoresOperationsResource(_requester);

  ProjectsLocationsMetadataStoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Initializes a MetadataStore, including allocation of resources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location where the
  /// MetadataStore should be created. Format:
  /// `projects/{project}/locations/{location}/`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [metadataStoreId] - The {metadatastore} portion of the resource name with
  /// the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all MetadataStores in the parent Location.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting MetadataStore.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1MetadataStore request,
    core.String parent, {
    core.String? metadataStoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (metadataStoreId != null) 'metadataStoreId': [metadataStoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/metadataStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a single MetadataStore and all its child resources (Artifacts,
  /// Executions, and Contexts).
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataStore to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [force] - Deprecated: Field is no longer supported.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves a specific MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataStore to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1MetadataStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1MetadataStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1MetadataStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists MetadataStores for a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The Location whose MetadataStores should be listed.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Metadata Stores to return. The service
  /// may return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListMetadataStores call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListMetadataStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListMetadataStoresResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/metadataStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListMetadataStoresResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresArtifactsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsOperationsResource get operations =>
      ProjectsLocationsMetadataStoresArtifactsOperationsResource(_requester);

  ProjectsLocationsMetadataStoresArtifactsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates an Artifact associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Artifact should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [artifactId] - The {artifact} portion of the resource name with the
  /// format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// If not provided, the Artifact's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all Artifacts in the parent MetadataStore.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting Artifact.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Artifact> create(
    GoogleCloudAiplatformV1beta1Artifact request,
    core.String parent, {
    core.String? artifactId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (artifactId != null) 'artifactId': [artifactId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/artifacts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Artifact.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes an Artifact.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Artifact to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Artifact to delete. If this is
  /// provided, it must match the server's etag. Otherwise, the request will
  /// fail with a FAILED_PRECONDITION.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves a specific Artifact.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Artifact to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Artifact> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Artifact.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Artifacts in the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Artifacts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Artifacts to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. The supported set of filters
  /// include the following: * **Attribute filtering**: For example:
  /// `display_name = "test"`. Supported fields include: `name`, `display_name`,
  /// `uri`, `state`, `schema_title`, `create_time`, and `update_time`. Time
  /// fields, such as `create_time` and `update_time`, require values specified
  /// in RFC-3339 format. For example: `create_time =
  /// "2020-11-19T11:30:00-04:00"` * **Metadata field**: To filter on metadata
  /// fields use traversal operation as follows: `metadata..`. For example:
  /// `metadata.field_1.number_value = 10.0` In case the field name contains
  /// special characters (such as colon), one can embed it inside double quote.
  /// For example: `metadata."field:1".number_value = 10.0` * **Context based
  /// filtering**: To filter Artifacts based on the contexts to which they
  /// belong, use the function operator with the full resource name
  /// `in_context()`. For example:
  /// `in_context("projects//locations//metadataStores//contexts/")` Each of the
  /// above supported filter types can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Artifacts to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListArtifacts call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListArtifactsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListArtifactsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/artifacts';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListArtifactsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a stored Artifact.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Artifact.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Artifact is not found, a new
  /// Artifact is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Artifact> patch(
    GoogleCloudAiplatformV1beta1Artifact request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Artifact.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Purges Artifacts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Artifacts from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1beta1PurgeArtifactsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/artifacts:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves lineage of an Artifact represented through Artifacts and
  /// Executions connected by Event edges and returned as a LineageSubgraph.
  ///
  /// Request parameters:
  ///
  /// [artifact] - Required. The resource name of the Artifact whose Lineage
  /// needs to be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Artifacts to
  /// satisfy in order to be part of the Lineage Subgraph. The syntax to define
  /// filter query is based on https://google.aip.dev/160. The supported set of
  /// filters include the following: * **Attribute filtering**: For example:
  /// `display_name = "test"` Supported fields include: `name`, `display_name`,
  /// `uri`, `state`, `schema_title`, `create_time`, and `update_time`. Time
  /// fields, such as `create_time` and `update_time`, require values specified
  /// in RFC-3339 format. For example: `create_time =
  /// "2020-11-19T11:30:00-04:00"` * **Metadata field**: To filter on metadata
  /// fields use traversal operation as follows: `metadata..`. For example:
  /// `metadata.field_1.number_value = 10.0` In case the field name contains
  /// special characters (such as colon), one can embed it inside double quote.
  /// For example: `metadata."field:1".number_value = 10.0` Each of the above
  /// supported filter types can be combined together using logical operators
  /// (`AND` & `OR`). Maximum nested expression depth allowed is 5. For example:
  /// `display_name = "test" AND metadata.field1.bool_value = true`.
  ///
  /// [maxHops] - Specifies the size of the lineage graph in terms of number of
  /// hops from the specified artifact. Negative Value: INVALID_ARGUMENT error
  /// is returned 0: Only input artifact is returned. No value: Transitive
  /// closure is performed to return the complete graph.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1LineageSubgraph>
  queryArtifactLineageSubgraph(
    core.String artifact, {
    core.String? filter,
    core.int? maxHops,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxHops != null) 'maxHops': ['${maxHops}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$artifact') +
        ':queryArtifactLineageSubgraph';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1LineageSubgraph.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresArtifactsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresContextsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresContextsOperationsResource get operations =>
      ProjectsLocationsMetadataStoresContextsOperationsResource(_requester);

  ProjectsLocationsMetadataStoresContextsResource(commons.ApiRequester client)
    : _requester = client;

  /// Adds a set of Artifacts and Executions to a Context.
  ///
  /// If any of the Artifacts or Executions have already been added to a
  /// Context, they are simply skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the Context that the Artifacts
  /// and Executions belong to. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsResponse
  >
  addContextArtifactsAndExecutions(
    GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$context') +
        ':addContextArtifactsAndExecutions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Adds a set of Contexts as children to a parent Context.
  ///
  /// If any of the child Contexts have already been added to the parent
  /// Context, they are simply skipped. If this call would create a cycle or
  /// cause any Context to have more than 10 parents, the request will fail with
  /// an INVALID_ARGUMENT error.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the parent Context. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1AddContextChildrenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1AddContextChildrenResponse>
  addContextChildren(
    GoogleCloudAiplatformV1beta1AddContextChildrenRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$context') + ':addContextChildren';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1AddContextChildrenResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a Context associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Context should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [contextId] - The {context} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`.
  /// If not provided, the Context's ID will be a UUID generated by the service.
  /// Must be 4-128 characters in length. Valid characters are `/a-z-/`. Must be
  /// unique across all Contexts in the parent MetadataStore. (Otherwise the
  /// request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the caller
  /// can't view the preexisting Context.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Context> create(
    GoogleCloudAiplatformV1beta1Context request,
    core.String parent, {
    core.String? contextId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (contextId != null) 'contextId': [contextId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/contexts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Context.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a stored Context.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Context to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Context to delete. If this is provided,
  /// it must match the server's etag. Otherwise, the request will fail with a
  /// FAILED_PRECONDITION.
  ///
  /// [force] - The force deletion semantics is still undefined. Users should
  /// not use this field.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves a specific Context.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Context to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Context> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Context.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Contexts on the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Contexts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Contexts to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. Following are the supported
  /// set of filters: * **Attribute filtering**: For example: `display_name =
  /// "test"`. Supported fields include: `name`, `display_name`, `schema_title`,
  /// `create_time`, and `update_time`. Time fields, such as `create_time` and
  /// `update_time`, require values specified in RFC-3339 format. For example:
  /// `create_time = "2020-11-19T11:30:00-04:00"`. * **Metadata field**: To
  /// filter on metadata fields use traversal operation as follows:
  /// `metadata..`. For example: `metadata.field_1.number_value = 10.0`. In case
  /// the field name contains special characters (such as colon), one can embed
  /// it inside double quote. For example: `metadata."field:1".number_value =
  /// 10.0` * **Parent Child filtering**: To filter Contexts based on
  /// parent-child relationship use the HAS operator as follows: ```
  /// parent_contexts: "projects//locations//metadataStores//contexts/"
  /// child_contexts: "projects//locations//metadataStores//contexts/" ``` Each
  /// of the above supported filters can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Contexts to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListContexts call. Provide this to retrieve the subsequent
  /// page. When paginating, all other provided parameters must match the call
  /// that provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListContextsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListContextsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/contexts';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListContextsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a stored Context.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the Context.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Context is not found, a new
  /// Context is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Context> patch(
    GoogleCloudAiplatformV1beta1Context request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Context.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Purges Contexts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Contexts from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1beta1PurgeContextsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/contexts:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves Artifacts and Executions within the specified Context, connected
  /// by Event edges and returned as a LineageSubgraph.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the Context whose Artifacts and
  /// Executions should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1LineageSubgraph>
  queryContextLineageSubgraph(
    core.String context, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$context') +
        ':queryContextLineageSubgraph';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1LineageSubgraph.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Remove a set of children contexts from a parent Context.
  ///
  /// If any of the child Contexts were NOT added to the parent Context, they
  /// are simply skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the parent Context. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1RemoveContextChildrenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RemoveContextChildrenResponse>
  removeContextChildren(
    GoogleCloudAiplatformV1beta1RemoveContextChildrenRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$context') + ':removeContextChildren';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RemoveContextChildrenResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresContextsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresContextsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresExecutionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresExecutionsOperationsResource get operations =>
      ProjectsLocationsMetadataStoresExecutionsOperationsResource(_requester);

  ProjectsLocationsMetadataStoresExecutionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Adds Events to the specified Execution.
  ///
  /// An Event indicates whether an Artifact was used as an input or output for
  /// an Execution. If an Event already exists between the Execution and the
  /// Artifact, the Event is skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [execution] - Required. The resource name of the Execution that the Events
  /// connect Artifacts with. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1AddExecutionEventsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1AddExecutionEventsResponse>
  addExecutionEvents(
    GoogleCloudAiplatformV1beta1AddExecutionEventsRequest request,
    core.String execution, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$execution') + ':addExecutionEvents';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1AddExecutionEventsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates an Execution associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Execution should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [executionId] - The {execution} portion of the resource name with the
  /// format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// If not provided, the Execution's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all Executions in the parent
  /// MetadataStore. (Otherwise the request will fail with ALREADY_EXISTS, or
  /// PERMISSION_DENIED if the caller can't view the preexisting Execution.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Execution> create(
    GoogleCloudAiplatformV1beta1Execution request,
    core.String parent, {
    core.String? executionId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (executionId != null) 'executionId': [executionId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/executions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Execution.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes an Execution.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Execution to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Execution to delete. If this is
  /// provided, it must match the server's etag. Otherwise, the request will
  /// fail with a FAILED_PRECONDITION.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves a specific Execution.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Execution to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Execution> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Execution.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Executions in the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Executions should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Executions to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. Following are the supported
  /// set of filters: * **Attribute filtering**: For example: `display_name =
  /// "test"`. Supported fields include: `name`, `display_name`, `state`,
  /// `schema_title`, `create_time`, and `update_time`. Time fields, such as
  /// `create_time` and `update_time`, require values specified in RFC-3339
  /// format. For example: `create_time = "2020-11-19T11:30:00-04:00"`. *
  /// **Metadata field**: To filter on metadata fields use traversal operation
  /// as follows: `metadata..` For example: `metadata.field_1.number_value =
  /// 10.0` In case the field name contains special characters (such as colon),
  /// one can embed it inside double quote. For example:
  /// `metadata."field:1".number_value = 10.0` * **Context based filtering**: To
  /// filter Executions based on the contexts to which they belong use the
  /// function operator with the full resource name: `in_context()`. For
  /// example: `in_context("projects//locations//metadataStores//contexts/")`
  /// Each of the above supported filters can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Executions to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListExecutions call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with an INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListExecutionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListExecutionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/executions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListExecutionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a stored Execution.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Execution.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Execution is not found, a new
  /// Execution is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Execution> patch(
    GoogleCloudAiplatformV1beta1Execution request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Execution.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Purges Executions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Executions from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1beta1PurgeExecutionsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/executions:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Obtains the set of input and output Artifacts for this Execution, in the
  /// form of LineageSubgraph that also contains the Execution and connecting
  /// Events.
  ///
  /// Request parameters:
  ///
  /// [execution] - Required. The resource name of the Execution whose input and
  /// output Artifacts should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1LineageSubgraph>
  queryExecutionInputsAndOutputs(
    core.String execution, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$execution') +
        ':queryExecutionInputsAndOutputs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1LineageSubgraph.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresExecutionsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresExecutionsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresMetadataSchemasResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresMetadataSchemasResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a MetadataSchema.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// MetadataSchema should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [metadataSchemaId] - The {metadata_schema} portion of the resource name
  /// with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all MetadataSchemas in the parent
  /// Location. (Otherwise the request will fail with ALREADY_EXISTS, or
  /// PERMISSION_DENIED if the caller can't view the preexisting
  /// MetadataSchema.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1MetadataSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1MetadataSchema> create(
    GoogleCloudAiplatformV1beta1MetadataSchema request,
    core.String parent, {
    core.String? metadataSchemaId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (metadataSchemaId != null) 'metadataSchemaId': [metadataSchemaId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/metadataSchemas';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1MetadataSchema.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieves a specific MetadataSchema.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataSchema to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/metadataSchemas/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1MetadataSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1MetadataSchema> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1MetadataSchema.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists MetadataSchemas.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose MetadataSchemas should be
  /// listed. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - A query to filter available MetadataSchemas for matching
  /// results.
  ///
  /// [pageSize] - The maximum number of MetadataSchemas to return. The service
  /// may return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListMetadataSchemas call. Provide this to retrieve the
  /// next page. When paginating, all other provided parameters must match the
  /// call that provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListMetadataSchemasResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListMetadataSchemasResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/metadataSchemas';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListMetadataSchemasResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMetadataStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMigratableResourcesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMigratableResourcesOperationsResource get operations =>
      ProjectsLocationsMigratableResourcesOperationsResource(_requester);

  ProjectsLocationsMigratableResourcesResource(commons.ApiRequester client)
    : _requester = client;

  /// Batch migrates resources from ml.googleapis.com, automl.googleapis.com,
  /// and datalabeling.googleapis.com to Vertex AI.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The location of the migrated resource will live in.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchMigrate(
    GoogleCloudAiplatformV1beta1BatchMigrateResourcesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/migratableResources:batchMigrate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Searches all of the resources in automl.googleapis.com,
  /// datalabeling.googleapis.com and ml.googleapis.com that can be migrated to
  /// Vertex AI's given location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The location that the migratable resources should be
  /// searched from. It's the Vertex AI location that the resources can be
  /// migrated to, not the resources' original location. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1SearchMigratableResourcesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SearchMigratableResourcesResponse>
  search(
    GoogleCloudAiplatformV1beta1SearchMigratableResourcesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/migratableResources:search';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchMigratableResourcesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsMigratableResourcesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMigratableResourcesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelDeploymentMonitoringJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource
  get operations =>
      ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource(
        _requester,
      );

  ProjectsLocationsModelDeploymentMonitoringJobsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a ModelDeploymentMonitoringJob.
  ///
  /// It will run periodically on a configured interval.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob> create(
    GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/modelDeploymentMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a ModelDeploymentMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the model monitoring job to
  /// delete. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a ModelDeploymentMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists ModelDeploymentMonitoringJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListModelDeploymentMonitoringJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1ListModelDeploymentMonitoringJobsResponse
  >
  list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/modelDeploymentMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelDeploymentMonitoringJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a ModelDeploymentMonitoringJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Resource name of a ModelDeploymentMonitoringJob.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask is used to specify the fields to
  /// be overwritten in the ModelDeploymentMonitoringJob resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields. For the objective config, the user can either provide the update
  /// mask for model_deployment_monitoring_objective_configs or any combination
  /// of its nested fields, such as:
  /// model_deployment_monitoring_objective_configs.objective_config.training_dataset.
  /// Updatable fields: * `display_name` *
  /// `model_deployment_monitoring_schedule_config` *
  /// `model_monitoring_alert_config` * `logging_sampling_strategy` * `labels` *
  /// `log_ttl` * `enable_monitoring_pipeline_logs` . and *
  /// `model_deployment_monitoring_objective_configs` . or *
  /// `model_deployment_monitoring_objective_configs.objective_config.training_dataset`
  /// *
  /// `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config`
  /// *
  /// `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Pauses a ModelDeploymentMonitoringJob.
  ///
  /// If the job is running, the server makes a best effort to cancel the job.
  /// Will mark ModelDeploymentMonitoringJob.state to 'PAUSED'.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob
  /// to pause. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> pause(
    GoogleCloudAiplatformV1beta1PauseModelDeploymentMonitoringJobRequest
    request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':pause';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Resumes a paused ModelDeploymentMonitoringJob.
  ///
  /// It will start to run from next scheduled time. A deleted
  /// ModelDeploymentMonitoringJob can't be resumed.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob
  /// to resume. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> resume(
    GoogleCloudAiplatformV1beta1ResumeModelDeploymentMonitoringJobRequest
    request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':resume';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Searches Model Monitoring Statistics generated within a given time window.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [modelDeploymentMonitoringJob] - Required. ModelDeploymentMonitoring Job
  /// resource name. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesResponse
  >
  searchModelDeploymentMonitoringStatsAnomalies(
    GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequest
    request,
    core.String modelDeploymentMonitoringJob, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$modelDeploymentMonitoringJob') +
        ':searchModelDeploymentMonitoringStatsAnomalies';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelMonitorsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelMonitorsModelMonitoringJobsResource
  get modelMonitoringJobs =>
      ProjectsLocationsModelMonitorsModelMonitoringJobsResource(_requester);
  ProjectsLocationsModelMonitorsOperationsResource get operations =>
      ProjectsLocationsModelMonitorsOperationsResource(_requester);

  ProjectsLocationsModelMonitorsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a ModelMonitor.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// ModelMonitor in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [modelMonitorId] - Optional. The ID to use for the Model Monitor, which
  /// will become the final component of the model monitor resource name. The
  /// maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1ModelMonitor request,
    core.String parent, {
    core.String? modelMonitorId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (modelMonitorId != null) 'modelMonitorId': [modelMonitorId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/modelMonitors';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a ModelMonitor.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelMonitor resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitords/{model_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [force] - Optional. Force delete the model monitor with schedules.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a ModelMonitor.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelMonitor resource. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ModelMonitor].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelMonitor> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelMonitor.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists ModelMonitors in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// ModelMonitors from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListModelMonitorsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListModelMonitorsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/modelMonitors';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelMonitorsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a ModelMonitor.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Resource name of the ModelMonitor. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Mask specifying which fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1ModelMonitor request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns the Model Monitoring alerts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [modelMonitor] - Required. ModelMonitor resource name. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsResponse>
  searchModelMonitoringAlerts(
    GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsRequest request,
    core.String modelMonitor, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$modelMonitor') +
        ':searchModelMonitoringAlerts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Searches Model Monitoring Stats generated within a given time window.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [modelMonitor] - Required. ModelMonitor resource name. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsResponse>
  searchModelMonitoringStats(
    GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsRequest request,
    core.String modelMonitor, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$modelMonitor') +
        ':searchModelMonitoringStats';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelMonitorsModelMonitoringJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelMonitorsModelMonitoringJobsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a ModelMonitoringJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelMonitoringJob. Format:
  /// `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [modelMonitoringJobId] - Optional. The ID to use for the Model Monitoring
  /// Job, which will become the final component of the model monitoring job
  /// resource name. The maximum length is 63 characters, and valid characters
  /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ModelMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelMonitoringJob> create(
    GoogleCloudAiplatformV1beta1ModelMonitoringJob request,
    core.String parent, {
    core.String? modelMonitoringJobId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (modelMonitoringJobId != null)
        'modelMonitoringJobId': [modelMonitoringJobId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/modelMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelMonitoringJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a ModelMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the model monitoring job to
  /// delete. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}/modelMonitoringJobs/{model_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+/modelMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a ModelMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelMonitoringJob. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}/modelMonitoringJobs/{model_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+/modelMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ModelMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelMonitoringJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelMonitoringJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists ModelMonitoringJobs.
  ///
  /// Callers may choose to read across multiple Monitors as per
  /// \[AIP-159\](https://google.aip.dev/159) by using '-' (the hyphen or dash
  /// character) as a wildcard character instead of modelMonitor id in the
  /// parent. Format
  /// `projects/{project_id}/locations/{location}/moodelMonitors/-/modelMonitoringJobs`
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelMonitoringJob. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListModelMonitoringJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListModelMonitoringJobsResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/modelMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelMonitoringJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelMonitorsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelMonitorsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelMonitors/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsResource get evaluations =>
      ProjectsLocationsModelsEvaluationsResource(_requester);
  ProjectsLocationsModelsOperationsResource get operations =>
      ProjectsLocationsModelsOperationsResource(_requester);

  ProjectsLocationsModelsResource(commons.ApiRequester client)
    : _requester = client;

  /// Copies an already existing Vertex AI Model into the specified Location.
  ///
  /// The source Model must exist in the same Project. When copying custom
  /// Models, the users themselves are responsible for Model.metadata content to
  /// be region-agnostic, as well as making sure that any resources (e.g. files)
  /// it depends on remain accessible.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to copy
  /// the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> copy(
    GoogleCloudAiplatformV1beta1CopyModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/models:copy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Model.
  ///
  /// A model cannot be deleted if any Endpoint resource has a DeployedModel
  /// based on the model in its deployed_models field.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Model resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Model version.
  ///
  /// Model version can only be deleted if there are no DeployedModels created
  /// from it. Deleting the only version in the Model is not allowed. Use
  /// DeleteModel for deleting the Model instead.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to be deleted, with a
  /// version ID explicitly included. Example:
  /// `projects/{project}/locations/{location}/models/{model}@1234`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deleteVersion(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':deleteVersion';

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Exports a trained, exportable Model to a location specified by the user.
  ///
  /// A Model is considered to be exportable if it has at least one supported
  /// export format.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Model to export. The resource
  /// name may contain version id or version alias to specify the version, if no
  /// version is specified, the default version will be exported.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> export(
    GoogleCloudAiplatformV1beta1ExportModelRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':export';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Model resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}` In order to
  /// retrieve a specific version of the model, also provide the version ID or
  /// version alias. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` If no
  /// version ID or alias is specified, the "default" version will be returned.
  /// The "default" version alias is created for the first version of the model,
  /// and can be moved to other versions later on. There will be exactly one
  /// default version.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Model> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Model.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Models in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the Models
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. * \`model\`
  /// supports = and !=. \`model\` represents the Model ID, i.e. the last
  /// segment of the Model's resource name. * \`display_name\` supports = and !=
  /// * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. * \`base_model_name\` only supports = Some examples: *
  /// \`model=1234\` * \`displayName="myDisplayName"\` *
  /// \`labels.myKey="myValue"\` * \`baseModelName="text-bison"\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelsResponse.next_page_token of the previous ModelService.ListModels
  /// call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListModelsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListModelsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/models';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists checkpoints of the specified model version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to list checkpoints for.
  /// `projects/{project}/locations/{location}/models/{model}@{version}`
  /// Example: `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` If no
  /// version ID or alias is specified, the latest version will be used.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via next_page_token of the previous ListModelVersionCheckpoints call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListModelVersionCheckpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListModelVersionCheckpointsResponse>
  listCheckpoints(
    core.String name, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':listCheckpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelVersionCheckpointsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists versions of the specified model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model to list versions for.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. * \`labels\`
  /// supports general map functions that is: * \`labels.key=value\` - key:value
  /// equality * \`labels.key:* or labels:key - key existence * A key including
  /// a space must be quoted. \`labels."a key"\`. Some examples: *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `create_time` * `update_time` Example: `update_time asc,
  /// create_time desc`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// next_page_token of the previous ListModelVersions call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListModelVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListModelVersionsResponse>
  listVersions(
    core.String name, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':listVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelVersionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Merges a set of aliases for a Model version.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to merge aliases, with a
  /// version ID explicitly included. Example:
  /// `projects/{project}/locations/{location}/models/{model}@1234`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Model> mergeVersionAliases(
    GoogleCloudAiplatformV1beta1MergeVersionAliasesRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$name') + ':mergeVersionAliases';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Model.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource name of the Model.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Model> patch(
    GoogleCloudAiplatformV1beta1Model request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Model.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Incrementally update the dataset used for an examples model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The resource name of the Model to update. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> updateExplanationDataset(
    GoogleCloudAiplatformV1beta1UpdateExplanationDatasetRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$model') +
        ':updateExplanationDataset';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Uploads a Model artifact into Vertex AI.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to
  /// upload the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> upload(
    GoogleCloudAiplatformV1beta1UploadModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/models:upload';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelsEvaluationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsOperationsResource get operations =>
      ProjectsLocationsModelsEvaluationsOperationsResource(_requester);
  ProjectsLocationsModelsEvaluationsSlicesResource get slices =>
      ProjectsLocationsModelsEvaluationsSlicesResource(_requester);

  ProjectsLocationsModelsEvaluationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets a ModelEvaluation.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelEvaluation resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ModelEvaluation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelEvaluation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelEvaluation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Imports an externally generated ModelEvaluation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the parent model resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ModelEvaluation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelEvaluation> import(
    GoogleCloudAiplatformV1beta1ImportModelEvaluationRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/evaluations:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelEvaluation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists ModelEvaluations in a Model.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Model to list the
  /// ModelEvaluations from. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelEvaluationsResponse.next_page_token of the previous
  /// ModelService.ListModelEvaluations call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListModelEvaluationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListModelEvaluationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/evaluations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelEvaluationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelsEvaluationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelsEvaluationsSlicesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsSlicesResource(commons.ApiRequester client)
    : _requester = client;

  /// Imports a list of externally generated EvaluatedAnnotations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the parent ModelEvaluationSlice resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/slices/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsResponse
  >
  batchImport(
    GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + ':batchImport';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a ModelEvaluationSlice.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelEvaluationSlice resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/slices/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ModelEvaluationSlice].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ModelEvaluationSlice> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ModelEvaluationSlice.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists ModelEvaluationSlices in a ModelEvaluation.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ModelEvaluation to list the
  /// ModelEvaluationSlices from. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. * `slice.dimension` - for =.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelEvaluationSlicesResponse.next_page_token of the previous
  /// ModelService.ListModelEvaluationSlices call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListModelEvaluationSlicesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListModelEvaluationSlicesResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/slices';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListModelEvaluationSlicesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsModelsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNasJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNasJobsNasTrialDetailsResource get nasTrialDetails =>
      ProjectsLocationsNasJobsNasTrialDetailsResource(_requester);

  ProjectsLocationsNasJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Cancels a NasJob.
  ///
  /// Starts asynchronous cancellation on the NasJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// JobService.GetNasJob or other methods to check whether the cancellation
  /// succeeded or whether the job completed despite cancellation. On successful
  /// cancellation, the NasJob is not deleted; instead it becomes a job with a
  /// NasJob.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`, and NasJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob to cancel. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelNasJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a NasJob
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NasJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1NasJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1NasJob> create(
    GoogleCloudAiplatformV1beta1NasJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/nasJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1NasJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a NasJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a NasJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1NasJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1NasJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1NasJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists NasJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the NasJobs
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListNasJobsResponse.next_page_token of the previous JobService.ListNasJobs
  /// call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListNasJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListNasJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/nasJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListNasJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNasJobsNasTrialDetailsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNasJobsNasTrialDetailsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets a NasTrialDetail.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasTrialDetail resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}/nasTrialDetails/{nas_trial_detail}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+/nasTrialDetails/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1NasTrialDetail].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1NasTrialDetail> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1NasTrialDetail.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// List top NasTrialDetails of a NasJob.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the NasJob resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListNasTrialDetailsResponse.next_page_token of the previous
  /// JobService.ListNasTrialDetails call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListNasTrialDetailsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListNasTrialDetailsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/nasTrialDetails';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListNasTrialDetailsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebookExecutionJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookExecutionJobsOperationsResource get operations =>
      ProjectsLocationsNotebookExecutionJobsOperationsResource(_requester);

  ProjectsLocationsNotebookExecutionJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a NotebookExecutionJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [notebookExecutionJobId] - Optional. User specified ID for the
  /// NotebookExecutionJob.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1NotebookExecutionJob request,
    core.String parent, {
    core.String? notebookExecutionJobId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (notebookExecutionJobId != null)
        'notebookExecutionJobId': [notebookExecutionJobId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/notebookExecutionJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a NotebookExecutionJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookExecutionJob resource to be
  /// deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Internal only: Called from Compute Engine instance to obtain EUC for owner
  /// Anonymous access: authenticates caller using VM identity JWT.
  ///
  /// Design doc: go/colab-on-vertex-euc-dd
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the resource requesting the OAuth2 token.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimes/{notebook_runtime}`
  /// `projects/{project}/locations/{location}/notebookExecutionJobs/{notebook_execution_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse>
  generateAccessToken(
    GoogleCloudAiplatformV1beta1GenerateAccessTokenRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$name') + ':generateAccessToken';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a NotebookExecutionJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookExecutionJob resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [view] - Optional. The NotebookExecutionJob view. Defaults to BASIC.
  /// Possible string values are:
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED" : When unspecified, the API
  /// defaults to the BASIC view.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC" : Includes all fields except for
  /// direct notebook inputs.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_FULL" : Includes all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1NotebookExecutionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1NotebookExecutionJob> get(
    core.String name, {
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1NotebookExecutionJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists NotebookExecutionJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookExecutionJobs. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `notebookExecutionJob` supports = and !=. `notebookExecutionJob`
  /// represents the NotebookExecutionJob ID. * `displayName` supports = and !=
  /// and regex. * `schedule` supports = and != and regex. Some examples: *
  /// `notebookExecutionJob="123"` * `notebookExecutionJob="my-execution-job"` *
  /// `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookExecutionJobsResponse.next_page_token of the previous
  /// NotebookService.ListNotebookExecutionJobs call.
  ///
  /// [view] - Optional. The NotebookExecutionJob view. Defaults to BASIC.
  /// Possible string values are:
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED" : When unspecified, the API
  /// defaults to the BASIC view.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC" : Includes all fields except for
  /// direct notebook inputs.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_FULL" : Includes all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListNotebookExecutionJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListNotebookExecutionJobsResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/notebookExecutionJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListNotebookExecutionJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookExecutionJob resource. Format:
  /// `projects/{project}/locations/{location}/notebookExecutionJobs/{notebook_execution_jobs}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ReportExecutionEventResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReportExecutionEventResponse>
  reportEvent(
    GoogleCloudAiplatformV1beta1ReportExecutionEventRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':reportEvent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReportExecutionEventResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebookExecutionJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookExecutionJobsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebookRuntimeTemplatesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimeTemplatesOperationsResource get operations =>
      ProjectsLocationsNotebookRuntimeTemplatesOperationsResource(_requester);

  ProjectsLocationsNotebookRuntimeTemplatesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a NotebookRuntimeTemplate.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NotebookRuntimeTemplate. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [notebookRuntimeTemplateId] - Optional. User specified ID for the notebook
  /// runtime template.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate request,
    core.String parent, {
    core.String? notebookRuntimeTemplateId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (notebookRuntimeTemplateId != null)
        'notebookRuntimeTemplateId': [notebookRuntimeTemplateId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/notebookRuntimeTemplates';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a NotebookRuntimeTemplate.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntimeTemplate resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a NotebookRuntimeTemplate.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntimeTemplate resource.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists NotebookRuntimeTemplates in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookRuntimeTemplates. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// \`notebookRuntimeTemplate\` supports = and !=. \`notebookRuntimeTemplate\`
  /// represents the NotebookRuntimeTemplate ID, i.e. the last segment of the
  /// NotebookRuntimeTemplate's resource name. * \`display_name\` supports = and
  /// != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. * \`notebookRuntimeType\` supports = and !=. notebookRuntimeType
  /// enum: \[USER_DEFINED, ONE_CLICK\]. * \`machineType\` supports = and !=. *
  /// \`acceleratorType\` supports = and !=. Some examples: *
  /// \`notebookRuntimeTemplate=notebookRuntimeTemplate123\` *
  /// \`displayName="myDisplayName"\` * \`labels.myKey="myValue"\` *
  /// \`notebookRuntimeType=USER_DEFINED\` * \`machineType=e2-standard-4\` *
  /// \`acceleratorType=NVIDIA_TESLA_T4\`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookRuntimeTemplatesResponse.next_page_token of the previous
  /// NotebookService.ListNotebookRuntimeTemplates call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListNotebookRuntimeTemplatesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListNotebookRuntimeTemplatesResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/notebookRuntimeTemplates';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListNotebookRuntimeTemplatesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a NotebookRuntimeTemplate.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource name of the NotebookRuntimeTemplate.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Input format:
  /// `{paths: "${updated_filed}"}` Updatable fields: *
  /// `encryption_spec.kms_key_name`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate> patch(
    GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebookRuntimeTemplatesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimeTemplatesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebookRuntimesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimesOperationsResource get operations =>
      ProjectsLocationsNotebookRuntimesOperationsResource(_requester);

  ProjectsLocationsNotebookRuntimesResource(commons.ApiRequester client)
    : _requester = client;

  /// Assigns a NotebookRuntime to a user for a particular Notebook file.
  ///
  /// This method will either returns an existing assignment or generates a new
  /// one.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to get the
  /// NotebookRuntime assignment. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> assign(
    GoogleCloudAiplatformV1beta1AssignNotebookRuntimeRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/notebookRuntimes:assign';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a NotebookRuntime.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be deleted.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Internal only: Called from Compute Engine instance to obtain EUC for owner
  /// Anonymous access: authenticates caller using VM identity JWT.
  ///
  /// Design doc: go/colab-on-vertex-euc-dd
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the resource requesting the OAuth2 token.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimes/{notebook_runtime}`
  /// `projects/{project}/locations/{location}/notebookExecutionJobs/{notebook_execution_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse>
  generateAccessToken(
    GoogleCloudAiplatformV1beta1GenerateAccessTokenRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$name') + ':generateAccessToken';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a NotebookRuntime.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource. Instead of
  /// checking whether the name is in valid NotebookRuntime resource name
  /// format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1NotebookRuntime].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1NotebookRuntime> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1NotebookRuntime.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists NotebookRuntimes in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookRuntimes. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `notebookRuntime` supports = and !=. `notebookRuntime` represents the
  /// NotebookRuntime ID, i.e. the last segment of the NotebookRuntime's
  /// resource name. * `displayName` supports = and != and regex. *
  /// `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
  /// represents the NotebookRuntimeTemplate ID, i.e. the last segment of the
  /// NotebookRuntimeTemplate's resource name. * `healthState` supports = and
  /// !=. healthState enum: \[HEALTHY, UNHEALTHY, HEALTH_STATE_UNSPECIFIED\]. *
  /// `runtimeState` supports = and !=. runtimeState enum:
  /// \[RUNTIME_STATE_UNSPECIFIED, RUNNING, BEING_STARTED, BEING_STOPPED,
  /// STOPPED, BEING_UPGRADED, ERROR, INVALID\]. * `runtimeUser` supports = and
  /// !=. * API version is UI only: `uiState` supports = and !=. uiState enum:
  /// \[UI_RESOURCE_STATE_UNSPECIFIED, UI_RESOURCE_STATE_BEING_CREATED,
  /// UI_RESOURCE_STATE_ACTIVE, UI_RESOURCE_STATE_BEING_DELETED,
  /// UI_RESOURCE_STATE_CREATION_FAILED\]. * `notebookRuntimeType` supports =
  /// and !=. notebookRuntimeType enum: \[USER_DEFINED, ONE_CLICK\]. *
  /// `machineType` supports = and !=. * `acceleratorType` supports = and !=.
  /// Some examples: * `notebookRuntime="notebookRuntime123"` *
  /// `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"` *
  /// `notebookRuntimeTemplate="notebookRuntimeTemplate321"` *
  /// `healthState=HEALTHY` * `runtimeState=RUNNING` *
  /// `runtimeUser="test@google.com"` *
  /// `uiState=UI_RESOURCE_STATE_BEING_DELETED` *
  /// `notebookRuntimeType=USER_DEFINED` * `machineType=e2-standard-4` *
  /// `acceleratorType=NVIDIA_TESLA_T4`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookRuntimesResponse.next_page_token of the previous
  /// NotebookService.ListNotebookRuntimes call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListNotebookRuntimesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListNotebookRuntimesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListNotebookRuntimesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource. Format:
  /// `projects/{project}/locations/{location}/notebookRuntimes/{notebook_runtime}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ReportRuntimeEventResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReportRuntimeEventResponse>
  reportEvent(
    GoogleCloudAiplatformV1beta1ReportRuntimeEventRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':reportEvent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReportRuntimeEventResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Starts a NotebookRuntime.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be started.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> start(
    GoogleCloudAiplatformV1beta1StartNotebookRuntimeRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':start';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Stops a NotebookRuntime.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be stopped.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> stop(
    GoogleCloudAiplatformV1beta1StopNotebookRuntimeRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':stop';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Upgrades a NotebookRuntime.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be upgrade.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> upgrade(
    GoogleCloudAiplatformV1beta1UpgradeNotebookRuntimeRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':upgrade';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebookRuntimesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsPersistentResourcesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPersistentResourcesOperationsResource get operations =>
      ProjectsLocationsPersistentResourcesOperationsResource(_requester);

  ProjectsLocationsPersistentResourcesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a PersistentResource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// PersistentResource in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [persistentResourceId] - Required. The ID to use for the
  /// PersistentResource, which become the final component of the
  /// PersistentResource's resource name. The maximum length is 63 characters,
  /// and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1PersistentResource request,
    core.String parent, {
    core.String? persistentResourceId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (persistentResourceId != null)
        'persistentResourceId': [persistentResourceId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/persistentResources';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a PersistentResource.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PersistentResource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a PersistentResource.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PersistentResource resource. Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PersistentResource].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PersistentResource> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PersistentResource.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists PersistentResources in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// PersistentResources from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListPersistentResourcesResponse.next_page_token of the previous
  /// PersistentResourceService.ListPersistentResource call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListPersistentResourcesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListPersistentResourcesResponse>
  list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/persistentResources';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListPersistentResourcesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a PersistentResource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Resource name of a PersistentResource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Specify the fields to be overwritten in the
  /// PersistentResource by the update method.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1PersistentResource request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Reboots a PersistentResource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PersistentResource resource. Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> reboot(
    GoogleCloudAiplatformV1beta1RebootPersistentResourceRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':reboot';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsPersistentResourcesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPersistentResourcesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsPipelineJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPipelineJobsOperationsResource get operations =>
      ProjectsLocationsPipelineJobsOperationsResource(_requester);

  ProjectsLocationsPipelineJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Batch cancel PipelineJobs.
  ///
  /// Firstly the server will check if all the jobs are in non-terminal states,
  /// and skip the jobs that are already terminated. If the operation failed,
  /// none of the pipeline jobs are cancelled. The server will poll the states
  /// of all the pipeline jobs periodically to check the cancellation status.
  /// This operation will return an LRO.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCancel(
    GoogleCloudAiplatformV1beta1BatchCancelPipelineJobsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/pipelineJobs:batchCancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Batch deletes PipelineJobs The Operation is atomic.
  ///
  /// If it fails, none of the PipelineJobs are deleted. If it succeeds, all of
  /// the PipelineJobs are deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchDelete(
    GoogleCloudAiplatformV1beta1BatchDeletePipelineJobsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/pipelineJobs:batchDelete';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Cancels a PipelineJob.
  ///
  /// Starts asynchronous cancellation on the PipelineJob. The server makes a
  /// best effort to cancel the pipeline, but success is not guaranteed. Clients
  /// can use PipelineService.GetPipelineJob or other methods to check whether
  /// the cancellation succeeded or whether the pipeline completed despite
  /// cancellation. On successful cancellation, the PipelineJob is not deleted;
  /// instead it becomes a pipeline with a PipelineJob.error value with a
  /// google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`, and
  /// PipelineJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob to cancel. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelPipelineJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a PipelineJob.
  ///
  /// A PipelineJob will run immediately when created.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// PipelineJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pipelineJobId] - The ID to use for the PipelineJob, which will become the
  /// final component of the PipelineJob name. If not provided, an ID will be
  /// automatically generated. This value should be less than 128 characters,
  /// and valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PipelineJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PipelineJob> create(
    GoogleCloudAiplatformV1beta1PipelineJob request,
    core.String parent, {
    core.String? pipelineJobId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pipelineJobId != null) 'pipelineJobId': [pipelineJobId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PipelineJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a PipelineJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a PipelineJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob resource. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PipelineJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PipelineJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PipelineJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists PipelineJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// PipelineJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the PipelineJobs that match the filter expression. The
  /// following fields are supported: * `pipeline_name`: Supports `=` and `!=`
  /// comparisons. * `display_name`: Supports `=`, `!=` comparisons, and `:`
  /// wildcard. * `pipeline_job_user_id`: Supports `=`, `!=` comparisons, and
  /// `:` wildcard. for example, can check if pipeline's display_name contains
  /// *step* by doing display_name:\"*step*\" * `state`: Supports `=` and `!=`
  /// comparisons. * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons. Values must be in RFC
  /// 3339 format. * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  /// comparisons. Values must be in RFC 3339 format. * `labels`: Supports
  /// key-value equality and key presence. * `template_uri`: Supports `=`, `!=`
  /// comparisons, and `:` wildcard. * `template_metadata.version`: Supports
  /// `=`, `!=` comparisons, and `:` wildcard. Filter expressions can be
  /// combined together using logical operators (`AND` & `OR`). For example:
  /// `pipeline_name="test" AND create_time>"2020-05-18T13:30:00Z"`. The syntax
  /// to define filter expression is based on https://google.aip.dev/160.
  /// Examples: * `create_time>"2021-05-18T00:00:00Z" OR
  /// update_time>"2020-05-18T00:00:00Z"` PipelineJobs created or updated after
  /// 2020-05-18 00:00:00 UTC. * `labels.env = "prod"` PipelineJobs with label
  /// "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by. The default sort
  /// order is in ascending order. Use "desc" after a field name for descending.
  /// You can have multiple order_by fields provided e.g. "create_time desc,
  /// end_time", "end_time, start_time, update_time" For example, using
  /// "create_time desc, end_time" will order results by create time in
  /// descending order, and if there are multiple jobs having the same create
  /// time, order them by the end time in ascending order. if order_by is not
  /// specified, it will order by default order is create time in descending
  /// order. Supported fields: * `create_time` * `update_time` * `end_time` *
  /// `start_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListPipelineJobsResponse.next_page_token of the previous
  /// PipelineService.ListPipelineJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListPipelineJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListPipelineJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListPipelineJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsPipelineJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPipelineJobsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsPublishersResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPublishersModelsResource get models =>
      ProjectsLocationsPublishersModelsResource(_requester);

  ProjectsLocationsPublishersResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsPublishersModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPublishersModelsResource(commons.ApiRequester client)
    : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1beta1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ComputeTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1beta1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CountTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Exports a publisher model to a user provided Google Cloud Storage bucket.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The Location to export the model weights from Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [name] - Required. The name of the PublisherModel resource. Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> export(
    GoogleCloudAiplatformV1beta1ExportPublisherModelRequest request,
    core.String parent,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/' +
        core.Uri.encodeFull('$name') +
        ':export';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetch an asynchronous online prediction operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> fetchPredictOperation(
    GoogleCloudAiplatformV1beta1FetchPredictOperationRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$endpoint') +
        ':fetchPredictOperation';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetches the configs of publisher models.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PublisherModelConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PublisherModelConfig>
  fetchPublisherModelConfig(core.String name, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$name') +
        ':fetchPublisherModelConfig';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PublisherModelConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  generateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PredictResponse> predict(
    GoogleCloudAiplatformV1beta1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> predictLongRunning(
    GoogleCloudAiplatformV1beta1PredictLongRunningRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predictLongRunning';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers: *
  /// `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction.
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's DeployedModel that
  /// served this prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> rawPredict(
    GoogleCloudAiplatformV1beta1RawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':rawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a server-side streaming online prediction request for Vertex LLM
  /// streaming.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1StreamingPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1StreamingPredictResponse>
  serverStreamingPredict(
    GoogleCloudAiplatformV1beta1StreamingPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$endpoint') +
        ':serverStreamingPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1StreamingPredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets (creates or updates) configs of publisher models.
  ///
  /// For example, sets the request/response logging config.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> setPublisherModelConfig(
    GoogleCloudAiplatformV1beta1SetPublisherModelConfigRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$name') + ':setPublisherModelConfig';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  streamGenerateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a streaming online prediction with an arbitrary HTTP payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> streamRawPredict(
    GoogleCloudAiplatformV1beta1StreamRawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':streamRawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsRagCorporaResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaOperationsResource get operations =>
      ProjectsLocationsRagCorporaOperationsResource(_requester);
  ProjectsLocationsRagCorporaRagFilesResource get ragFiles =>
      ProjectsLocationsRagCorporaRagFilesResource(_requester);

  ProjectsLocationsRagCorporaResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// RagCorpus in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1RagCorpus request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/ragCorpora';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a RagCorpus.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagCorpus resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [force] - Optional. If set to true, any RagFiles in this RagCorpus will
  /// also be deleted. Otherwise, the request will only work if the RagCorpus
  /// has no RagFiles.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a RagCorpus.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagCorpus resource. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RagCorpus].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RagCorpus> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RagCorpus.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists RagCorpora in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the RagCorpora. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListRagCorporaResponse.next_page_token of the previous
  /// VertexRagDataService.ListRagCorpora call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListRagCorporaResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListRagCorporaResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/ragCorpora';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListRagCorporaResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the RagCorpus.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1RagCorpus request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsRagCorporaOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsRagCorporaRagFilesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaRagFilesOperationsResource get operations =>
      ProjectsLocationsRagCorporaRagFilesOperationsResource(_requester);

  ProjectsLocationsRagCorporaRagFilesResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a RagFile.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagFile resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a RagFile.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagFile resource. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RagFile].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RagFile> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RagFile.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Import files from Google Cloud Storage or Google Drive into a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the RagCorpus resource into which to
  /// import files. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudAiplatformV1beta1ImportRagFilesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/ragFiles:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists RagFiles in a RagCorpus.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the RagCorpus from which to list
  /// the RagFiles. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListRagFilesResponse.next_page_token of the previous
  /// VertexRagDataService.ListRagFiles call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListRagFilesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListRagFilesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/ragFiles';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListRagFilesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsRagCorporaRagFilesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaRagFilesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsRagEngineConfigResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagEngineConfigOperationsResource get operations =>
      ProjectsLocationsRagEngineConfigOperationsResource(_requester);

  ProjectsLocationsRagEngineConfigResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsRagEngineConfigOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagEngineConfigOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragEngineConfig/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragEngineConfig/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragEngineConfig/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragEngineConfig$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragEngineConfig/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesExamplesResource get examples =>
      ProjectsLocationsReasoningEnginesExamplesResource(_requester);
  ProjectsLocationsReasoningEnginesMemoriesResource get memories =>
      ProjectsLocationsReasoningEnginesMemoriesResource(_requester);
  ProjectsLocationsReasoningEnginesOperationsResource get operations =>
      ProjectsLocationsReasoningEnginesOperationsResource(_requester);
  ProjectsLocationsReasoningEnginesSandboxEnvironmentsResource
  get sandboxEnvironments =>
      ProjectsLocationsReasoningEnginesSandboxEnvironmentsResource(_requester);
  ProjectsLocationsReasoningEnginesSessionsResource get sessions =>
      ProjectsLocationsReasoningEnginesSessionsResource(_requester);

  ProjectsLocationsReasoningEnginesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// ReasoningEngine in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1ReasoningEngine request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/reasoningEngines';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [force] - Optional. If set to true, child resources of this reasoning
  /// engine will also be deleted. Otherwise, the request will fail with
  /// FAILED_PRECONDITION error when the reasoning engine has undeleted child
  /// resources.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ReasoningEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReasoningEngine> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReasoningEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists reasoning engines in a location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// ReasoningEngines from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/reasoningEngines';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the ReasoningEngine. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Mask specifying which fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1ReasoningEngine request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Queries using a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse> query(
    GoogleCloudAiplatformV1beta1QueryReasoningEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':query';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Streams queries using a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> streamQuery(
    GoogleCloudAiplatformV1beta1StreamQueryReasoningEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':streamQuery';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesExamplesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesExamplesOperationsResource get operations =>
      ProjectsLocationsReasoningEnginesExamplesOperationsResource(_requester);

  ProjectsLocationsReasoningEnginesExamplesResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsReasoningEnginesExamplesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesExamplesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/examples/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/examples/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/examples/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/examples/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesMemoriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesMemoriesOperationsResource get operations =>
      ProjectsLocationsReasoningEnginesMemoriesOperationsResource(_requester);

  ProjectsLocationsReasoningEnginesMemoriesResource(commons.ApiRequester client)
    : _requester = client;

  /// Create a Memory.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to create
  /// the Memory under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Memory request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Delete a Memory.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Memory to delete. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate memories.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to generate
  /// memories for. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> generate(
    GoogleCloudAiplatformV1beta1GenerateMemoriesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories:generate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Get a Memory.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Memory. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Memory].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Memory> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Memory.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// List Memories.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to list the
  /// Memories under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160). Supported fields (equality match
  /// only): * `scope` (as a JSON string)
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListMemoriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListMemoriesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListMemoriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Update a Memory.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the Memory. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Mask specifying which fields to update. Supported
  /// fields: * `display_name` * `description` * `fact`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1Memory request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieve memories.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to retrieve
  /// memories from. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse> retrieve(
    GoogleCloudAiplatformV1beta1RetrieveMemoriesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories:retrieve';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesMemoriesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesMemoriesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/memories/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesSandboxEnvironmentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesSandboxEnvironmentsOperationsResource
  get operations =>
      ProjectsLocationsReasoningEnginesSandboxEnvironmentsOperationsResource(
        _requester,
      );

  ProjectsLocationsReasoningEnginesSandboxEnvironmentsResource(
    commons.ApiRequester client,
  ) : _requester = client;
}

class ProjectsLocationsReasoningEnginesSandboxEnvironmentsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesSandboxEnvironmentsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sandboxEnvironments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sandboxEnvironments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sandboxEnvironments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sandboxEnvironments/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sandboxEnvironments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesSessionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesSessionsEventsResource get events =>
      ProjectsLocationsReasoningEnginesSessionsEventsResource(_requester);
  ProjectsLocationsReasoningEnginesSessionsOperationsResource get operations =>
      ProjectsLocationsReasoningEnginesSessionsOperationsResource(_requester);

  ProjectsLocationsReasoningEnginesSessionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Appends an event to a given session.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the session to append event to.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1AppendEventResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1AppendEventResponse> appendEvent(
    GoogleCloudAiplatformV1beta1SessionEvent request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':appendEvent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1AppendEventResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a new Session.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the location to create the
  /// session in. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Session request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes details of the specific Session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the session. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of the specific Session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the session. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Session].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Session> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Session.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Sessions in a given reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the location to list sessions
  /// from. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. Supported fields: *
  /// `display_name` Example: `display_name=abc`.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `create_time` * `update_time` Example: `create_time
  /// desc`.
  ///
  /// [pageSize] - Optional. The maximum number of sessions to return. The
  /// service may return fewer than this value. If unspecified, at most 100
  /// sessions will be returned.
  ///
  /// [pageToken] - Optional. The next_page_token value returned from a previous
  /// list SessionService.ListSessions call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListSessionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListSessionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListSessionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the specific Session.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the session. Format:
  /// 'projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}'.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Field mask is used to control which fields get
  /// updated. If the mask is not present, all fields will be updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Session].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Session> patch(
    GoogleCloudAiplatformV1beta1Session request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Session.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesSessionsEventsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesSessionsEventsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Lists Events in a given session.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the session to list events from.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. Supported fields: *
  /// `timestamp` range (i.e. `timestamp>="2025-01-31T11:30:00-04:00"` where the
  /// timestamp is in RFC 3339 format) More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - Optional. The maximum number of events to return. The service
  /// may return fewer than this value. If unspecified, at most 100 events will
  /// be returned. These events are ordered by timestamp in ascending order.
  ///
  /// [pageToken] - Optional. The next_page_token value returned from a previous
  /// list SessionService.ListEvents call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListEventsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListEventsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/events';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListEventsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsReasoningEnginesSessionsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesSessionsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/sessions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSchedulesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSchedulesOperationsResource get operations =>
      ProjectsLocationsSchedulesOperationsResource(_requester);

  ProjectsLocationsSchedulesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a Schedule.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Schedule in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Schedule> create(
    GoogleCloudAiplatformV1beta1Schedule request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/schedules';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Schedule.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Schedule.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Schedule.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource. Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Schedule> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Schedule.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Schedules in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// Schedules from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the Schedules that match the filter expression. The
  /// following fields are supported: * `display_name`: Supports `=`, `!=`
  /// comparisons, and `:` wildcard. * `state`: Supports `=` and `!=`
  /// comparisons. * `request`: Supports existence of the check. (e.g.
  /// `create_pipeline_job_request:*` --\> Schedule has
  /// create_pipeline_job_request). * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `start_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. * `end_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, `>=` comparisons and `:*` existence check. Values must be in
  /// RFC 3339 format. * `next_run_time`: Supports `=`, `!=`, `<`, `>`, `<=`,
  /// and `>=` comparisons. Values must be in RFC 3339 format. Filter
  /// expressions can be combined together using logical operators (`NOT`, `AND`
  /// & `OR`). The syntax to define filter expression is based on
  /// https://google.aip.dev/160. Examples: * `state="ACTIVE" AND
  /// display_name:"my_schedule_*"` * `NOT display_name="my_schedule"` *
  /// `create_time>"2021-05-18T00:00:00Z"` * `end_time>"2021-05-18T00:00:00Z" OR
  /// NOT end_time:*` * `create_pipeline_job_request:*`
  ///
  /// [orderBy] - A comma-separated list of fields to order by. The default sort
  /// order is in ascending order. Use "desc" after a field name for descending.
  /// You can have multiple order_by fields provided. For example, using
  /// "create_time desc, end_time" will order results by create time in
  /// descending order, and if there are multiple schedules having the same
  /// create time, order them by the end time in ascending order. If order_by is
  /// not specified, it will order by default with create_time in descending
  /// order. Supported fields: * `create_time` * `start_time` * `end_time` *
  /// `next_run_time`
  ///
  /// [pageSize] - The standard list page size. Default to 100 if not specified.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListSchedulesResponse.next_page_token of the previous
  /// ScheduleService.ListSchedules call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListSchedulesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListSchedulesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/schedules';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListSchedulesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an active or paused Schedule.
  ///
  /// When the Schedule is updated, new runs will be scheduled starting from the
  /// updated next execution time after the update time based on the
  /// time_specification in the updated Schedule. All unstarted runs before the
  /// update time will be skipped while already created runs will NOT be paused
  /// or canceled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the Schedule.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Schedule> patch(
    GoogleCloudAiplatformV1beta1Schedule request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Schedule.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Pauses a Schedule.
  ///
  /// Will mark Schedule.state to 'PAUSED'. If the schedule is paused, no new
  /// runs will be created. Already created runs will NOT be paused or canceled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be paused. Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> pause(
    GoogleCloudAiplatformV1beta1PauseScheduleRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':pause';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Resumes a paused Schedule to start scheduling new runs.
  ///
  /// Will mark Schedule.state to 'ACTIVE'. Only paused Schedule can be resumed.
  /// When the Schedule is resumed, new runs will be scheduled starting from the
  /// next execution time after the current time based on the time_specification
  /// in the Schedule. If Schedule.catch_up is set up true, all missed runs will
  /// be scheduled for backfill first.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be resumed.
  /// Format: `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> resume(
    GoogleCloudAiplatformV1beta1ResumeScheduleRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':resume';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSchedulesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSchedulesOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSolversResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSolversOperationsResource get operations =>
      ProjectsLocationsSolversOperationsResource(_requester);

  ProjectsLocationsSolversResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsSolversOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSolversOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/solvers/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/solvers/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/solvers/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSpecialistPoolsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSpecialistPoolsOperationsResource get operations =>
      ProjectsLocationsSpecialistPoolsOperationsResource(_requester);

  ProjectsLocationsSpecialistPoolsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a SpecialistPool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent Project name for the new SpecialistPool.
  /// The form is `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1SpecialistPool request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/specialistPools';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a SpecialistPool as well as all Specialists in the pool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SpecialistPool to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [force] - If set to true, any specialist managers in this SpecialistPool
  /// will also be deleted. (Otherwise, the request will only work if the
  /// SpecialistPool has no specialist managers.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a SpecialistPool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the SpecialistPool resource. The form is
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1SpecialistPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1SpecialistPool> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1SpecialistPool.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists SpecialistPools in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the SpecialistPool's parent resource.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained by
  /// ListSpecialistPoolsResponse.next_page_token of the previous
  /// SpecialistPoolService.ListSpecialistPools call. Return first page if
  /// empty.
  ///
  /// [readMask] - Mask specifying which fields to read. FieldMask represents a
  /// set of
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListSpecialistPoolsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListSpecialistPoolsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/specialistPools';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListSpecialistPoolsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a SpecialistPool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SpecialistPool.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1SpecialistPool request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSpecialistPoolsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSpecialistPoolsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsStudiesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesOperationsResource get operations =>
      ProjectsLocationsStudiesOperationsResource(_requester);
  ProjectsLocationsStudiesTrialsResource get trials =>
      ProjectsLocationsStudiesTrialsResource(_requester);

  ProjectsLocationsStudiesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a Study.
  ///
  /// A resource name will be generated after creation of the Study.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// CustomJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Study> create(
    GoogleCloudAiplatformV1beta1Study request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/studies';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Study.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Study.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Study resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Study by name.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Study resource. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Study> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Study.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all the studies in a region for an associated project.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the Study
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The maximum number of studies to return per "page"
  /// of results. If unspecified, service will pick an appropriate default.
  ///
  /// [pageToken] - Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListStudiesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListStudiesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/studies';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListStudiesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Looks a study up using the user-defined display_name field instead of the
  /// fully qualified resource name.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to get the Study
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Study> lookup(
    GoogleCloudAiplatformV1beta1LookupStudyRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/studies:lookup';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Study.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsStudiesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsStudiesTrialsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesTrialsOperationsResource get operations =>
      ProjectsLocationsStudiesTrialsOperationsResource(_requester);

  ProjectsLocationsStudiesTrialsResource(commons.ApiRequester client)
    : _requester = client;

  /// Adds a measurement of the objective metrics to a Trial.
  ///
  /// This measurement is assumed to have been taken before the Trial is
  /// complete.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [trialName] - Required. The name of the trial to add measurement. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Trial> addTrialMeasurement(
    GoogleCloudAiplatformV1beta1AddTrialMeasurementRequest request,
    core.String trialName, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$trialName') + ':addTrialMeasurement';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Trial.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Checks whether a Trial should stop or not.
  ///
  /// Returns a long-running operation. When the operation is successful, it
  /// will contain a CheckTrialEarlyStoppingStateResponse.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [trialName] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> checkTrialEarlyStoppingState(
    GoogleCloudAiplatformV1beta1CheckTrialEarlyStoppingStateRequest request,
    core.String trialName, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$trialName') +
        ':checkTrialEarlyStoppingState';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Marks a Trial as complete.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Trial> complete(
    GoogleCloudAiplatformV1beta1CompleteTrialRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':complete';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Trial.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Adds a user provided Trial to a Study.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Study to create the Trial
  /// in. Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Trial> create(
    GoogleCloudAiplatformV1beta1Trial request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/trials';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Trial.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Trial.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Trial.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Trial resource. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Trial> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Trial.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists the Trials associated with a Study.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Study to list the Trial
  /// from. Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The number of Trials to retrieve per "page" of
  /// results. If unspecified, the service will pick an appropriate default.
  ///
  /// [pageToken] - Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListTrialsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListTrialsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/trials';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListTrialsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists the pareto-optimal Trials for multi-objective Study or the optimal
  /// Trials for single-objective Study.
  ///
  /// The definition of pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Study that the optimal Trial belongs
  /// to.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListOptimalTrialsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListOptimalTrialsResponse>
  listOptimalTrials(
    GoogleCloudAiplatformV1beta1ListOptimalTrialsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/trials:listOptimalTrials';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListOptimalTrialsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Stops a Trial.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Trial> stop(
    GoogleCloudAiplatformV1beta1StopTrialRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':stop';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Trial.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Adds one or more Trials to a Study, with parameter values suggested by
  /// Vertex AI Vizier.
  ///
  /// Returns a long-running operation associated with the generation of Trial
  /// suggestions. When this long-running operation succeeds, it will contain a
  /// SuggestTrialsResponse.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The project and location that the Study belongs to.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> suggest(
    GoogleCloudAiplatformV1beta1SuggestTrialsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/trials:suggest';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsStudiesTrialsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesTrialsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsResource get experiments =>
      ProjectsLocationsTensorboardsExperimentsResource(_requester);
  ProjectsLocationsTensorboardsOperationsResource get operations =>
      ProjectsLocationsTensorboardsOperationsResource(_requester);

  ProjectsLocationsTensorboardsResource(commons.ApiRequester client)
    : _requester = client;

  /// Reads multiple TensorboardTimeSeries' data.
  ///
  /// The data point number limit is 1000 for scalars, 100 for tensors and blob
  /// references. If the number of data points stored is less than the limit,
  /// all data is returned. Otherwise, the number limit of data points is
  /// randomly selected from this time series and returned.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The resource name of the Tensorboard containing
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`. The
  /// TensorboardTimeSeries referenced by time_series must be sub resources of
  /// this Tensorboard.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [timeSeries] - Required. The resource names of the TensorboardTimeSeries
  /// to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1BatchReadTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1BatchReadTensorboardTimeSeriesDataResponse
  >
  batchRead(
    core.String tensorboard, {
    core.List<core.String>? timeSeries,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeSeries != null) 'timeSeries': timeSeries,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$tensorboard') + ':batchRead';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchReadTensorboardTimeSeriesDataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a Tensorboard.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Tensorboard in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Tensorboard request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/tensorboards';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Tensorboard.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Tensorboard to be deleted. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Tensorboard.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Tensorboard].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Tensorboard> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Tensorboard.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Tensorboards in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// Tensorboards. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the Tensorboards that match the filter expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of Tensorboards to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Tensorboards are
  /// returned. The maximum value is 100; values above 100 are coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboards call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// TensorboardService.ListTensorboards must match the call that provided the
  /// page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListTensorboardsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListTensorboardsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/tensorboards';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListTensorboardsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Tensorboard.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the Tensorboard. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the Tensorboard resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field is overwritten if it's in the mask. If the user does not
  /// provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1Tensorboard request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns the storage size for a given TensorBoard instance.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ReadTensorboardSizeResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReadTensorboardSizeResponse>
  readSize(core.String tensorboard, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$tensorboard') + ':readSize';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReadTensorboardSizeResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns a list of monthly active users for a given TensorBoard instance.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponse>
  readUsage(core.String tensorboard, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$tensorboard') + ':readUsage';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsExperimentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsOperationsResource get operations =>
      ProjectsLocationsTensorboardsExperimentsOperationsResource(_requester);
  ProjectsLocationsTensorboardsExperimentsRunsResource get runs =>
      ProjectsLocationsTensorboardsExperimentsRunsResource(_requester);

  ProjectsLocationsTensorboardsExperimentsResource(commons.ApiRequester client)
    : _requester = client;

  /// Batch create TensorboardTimeSeries that belong to a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardTimeSeries in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The TensorboardRuns referenced by the parent fields in the
  /// CreateTensorboardTimeSeriesRequest messages must be sub resources of this
  /// TensorboardExperiment.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesResponse
  >
  batchCreate(
    GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + ':batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Tensorboard to create the
  /// TensorboardExperiment in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [tensorboardExperimentId] - Required. The ID to use for the Tensorboard
  /// experiment, which becomes the final component of the Tensorboard
  /// experiment's resource name. This value should be 1-128 characters, and
  /// valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardExperiment> create(
    GoogleCloudAiplatformV1beta1TensorboardExperiment request,
    core.String parent, {
    core.String? tensorboardExperimentId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardExperimentId != null)
        'tensorboardExperimentId': [tensorboardExperimentId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/experiments';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardExperiment.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a TensorboardExperiment.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardExperiment to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a TensorboardExperiment.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardExperiment resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardExperiment> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardExperiment.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists TensorboardExperiments in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Tensorboard to list
  /// TensorboardExperiments. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardExperiments that match the filter
  /// expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardExperiments to return. The
  /// service may return fewer than this value. If unspecified, at most 50
  /// TensorboardExperiments are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardExperiments call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to TensorboardService.ListTensorboardExperiments must match the
  /// call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListTensorboardExperimentsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListTensorboardExperimentsResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/experiments';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListTensorboardExperimentsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardExperiment. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardExperiment resource by the update. The
  /// fields specified in the update_mask are relative to the resource, not the
  /// full request. A field is overwritten if it's in the mask. If the user does
  /// not provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardExperiment> patch(
    GoogleCloudAiplatformV1beta1TensorboardExperiment request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardExperiment.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Write time series data points of multiple TensorboardTimeSeries in
  /// multiple TensorboardRun's.
  ///
  /// If any data fail to be ingested, an error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardExperiment] - Required. The resource name of the
  /// TensorboardExperiment to write data to. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataResponse
  >
  write(
    GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataRequest request,
    core.String tensorboardExperiment, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$tensorboardExperiment') + ':write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsExperimentsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsOperationsResource
  get operations =>
      ProjectsLocationsTensorboardsExperimentsRunsOperationsResource(
        _requester,
      );
  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource
  get timeSeries =>
      ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource(
        _requester,
      );

  ProjectsLocationsTensorboardsExperimentsRunsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Batch create TensorboardRuns.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardRuns in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The parent field in the CreateTensorboardRunRequest messages must match
  /// this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsResponse>
  batchCreate(
    GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/runs:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a TensorboardRun.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardRun in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [tensorboardRunId] - Required. The ID to use for the Tensorboard run,
  /// which becomes the final component of the Tensorboard run's resource name.
  /// This value should be 1-128 characters, and valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardRun> create(
    GoogleCloudAiplatformV1beta1TensorboardRun request,
    core.String parent, {
    core.String? tensorboardRunId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardRunId != null) 'tensorboardRunId': [tensorboardRunId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/runs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardRun.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a TensorboardRun.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardRun to be deleted. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a TensorboardRun.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardRun resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardRun> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardRun.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists TensorboardRuns in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// list TensorboardRuns. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardRuns that match the filter expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardRuns to return. The service
  /// may return fewer than this value. If unspecified, at most 50
  /// TensorboardRuns are returned. The maximum value is 1000; values above 1000
  /// are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardRuns call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// TensorboardService.ListTensorboardRuns must match the call that provided
  /// the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListTensorboardRunsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListTensorboardRunsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/runs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListTensorboardRunsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a TensorboardRun.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardRun. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardRun resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field is overwritten if it's in the mask. If the user does not
  /// provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardRun> patch(
    GoogleCloudAiplatformV1beta1TensorboardRun request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardRun.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Write time series data points into multiple TensorboardTimeSeries under a
  /// TensorboardRun.
  ///
  /// If any data fail to be ingested, an error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardRun] - Required. The resource name of the TensorboardRun to
  /// write data to. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1WriteTensorboardRunDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1WriteTensorboardRunDataResponse>
  write(
    GoogleCloudAiplatformV1beta1WriteTensorboardRunDataRequest request,
    core.String tensorboardRun, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$tensorboardRun') + ':write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1WriteTensorboardRunDataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource
  get operations =>
      ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource(
        _requester,
      );

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a TensorboardTimeSeries.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [tensorboardTimeSeriesId] - Optional. The user specified unique ID to use
  /// for the TensorboardTimeSeries, which becomes the final component of the
  /// TensorboardTimeSeries's resource name. This value should match "a-z0-9{0,
  /// 127}"
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardTimeSeries> create(
    GoogleCloudAiplatformV1beta1TensorboardTimeSeries request,
    core.String parent, {
    core.String? tensorboardTimeSeriesId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId': [tensorboardTimeSeriesId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/timeSeries';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardTimeSeries.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a TensorboardTimeSeries.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardTimeSeries to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Exports a TensorboardTimeSeries' data.
  ///
  /// Data is returned in paginated responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardTimeSeries] - Required. The resource name of the
  /// TensorboardTimeSeries to export data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataResponse
  >
  exportTensorboardTimeSeries(
    GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataRequest request,
    core.String tensorboardTimeSeries, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$tensorboardTimeSeries') +
        ':exportTensorboardTimeSeries';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a TensorboardTimeSeries.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardTimeSeries resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardTimeSeries> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardTimeSeries.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists TensorboardTimeSeries in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardRun to list
  /// TensorboardTimeSeries. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardTimeSeries that match the filter
  /// expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardTimeSeries to return. The
  /// service may return fewer than this value. If unspecified, at most 50
  /// TensorboardTimeSeries are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardTimeSeries call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to TensorboardService.ListTensorboardTimeSeries must match the
  /// call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListTensorboardTimeSeriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListTensorboardTimeSeriesResponse>
  list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/timeSeries';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListTensorboardTimeSeriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a TensorboardTimeSeries.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardTimeSeries.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardTimeSeries resource by the update. The
  /// fields specified in the update_mask are relative to the resource, not the
  /// full request. A field is overwritten if it's in the mask. If the user does
  /// not provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TensorboardTimeSeries> patch(
    GoogleCloudAiplatformV1beta1TensorboardTimeSeries request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TensorboardTimeSeries.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Reads a TensorboardTimeSeries' data.
  ///
  /// By default, if the number of data points stored is less than 1000, all
  /// data is returned. Otherwise, 1000 data points is randomly selected from
  /// this time series and returned. This value can be changed by changing
  /// max_data_points, which can't be greater than 10k.
  ///
  /// Request parameters:
  ///
  /// [tensorboardTimeSeries] - Required. The resource name of the
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [filter] - Reads the TensorboardTimeSeries' data that match the filter
  /// expression.
  ///
  /// [maxDataPoints] - The maximum number of TensorboardTimeSeries' data to
  /// return. This value should be a positive integer. This value can be set to
  /// -1 to return all data.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ReadTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudAiplatformV1beta1ReadTensorboardTimeSeriesDataResponse
  >
  read(
    core.String tensorboardTimeSeries, {
    core.String? filter,
    core.int? maxDataPoints,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxDataPoints != null) 'maxDataPoints': ['${maxDataPoints}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$tensorboardTimeSeries') + ':read';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReadTensorboardTimeSeriesDataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets bytes of TensorboardBlobs.
  ///
  /// This is to allow reading blob data stored in consumer project's Cloud
  /// Storage bucket without users having to obtain Cloud Storage access
  /// permission.
  ///
  /// Request parameters:
  ///
  /// [timeSeries] - Required. The resource name of the TensorboardTimeSeries to
  /// list Blobs. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [blobIds] - IDs of the blobs to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ReadTensorboardBlobDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReadTensorboardBlobDataResponse>
  readBlobData(
    core.String timeSeries, {
    core.List<core.String>? blobIds,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (blobIds != null) 'blobIds': blobIds,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$timeSeries') + ':readBlobData';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReadTensorboardBlobDataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTensorboardsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTrainingPipelinesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTrainingPipelinesOperationsResource get operations =>
      ProjectsLocationsTrainingPipelinesOperationsResource(_requester);

  ProjectsLocationsTrainingPipelinesResource(commons.ApiRequester client)
    : _requester = client;

  /// Cancels a TrainingPipeline.
  ///
  /// Starts asynchronous cancellation on the TrainingPipeline. The server makes
  /// a best effort to cancel the pipeline, but success is not guaranteed.
  /// Clients can use PipelineService.GetTrainingPipeline or other methods to
  /// check whether the cancellation succeeded or whether the pipeline completed
  /// despite cancellation. On successful cancellation, the TrainingPipeline is
  /// not deleted; instead it becomes a pipeline with a TrainingPipeline.error
  /// value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`, and TrainingPipeline.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline to cancel. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelTrainingPipelineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a TrainingPipeline.
  ///
  /// A created TrainingPipeline right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// TrainingPipeline in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TrainingPipeline].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TrainingPipeline> create(
    GoogleCloudAiplatformV1beta1TrainingPipeline request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/trainingPipelines';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TrainingPipeline.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a TrainingPipeline.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a TrainingPipeline.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline resource. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TrainingPipeline].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TrainingPipeline> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TrainingPipeline.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists TrainingPipelines in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// TrainingPipelines from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`training_task_definition\` \`=\`,
  /// \`!=\` comparisons, and \`:\` wildcard. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="PIPELINE_STATE_SUCCEEDED" AND display_name:"my_pipeline_*"\` *
  /// \`state!="PIPELINE_STATE_FAILED" OR display_name="my_pipeline"\` * \`NOT
  /// display_name="my_pipeline"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`training_task_definition:"*automl_text_classification*"\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListTrainingPipelinesResponse.next_page_token of the previous
  /// PipelineService.ListTrainingPipelines call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListTrainingPipelinesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListTrainingPipelinesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/trainingPipelines';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListTrainingPipelinesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTrainingPipelinesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTrainingPipelinesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTuningJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTuningJobsOperationsResource get operations =>
      ProjectsLocationsTuningJobsOperationsResource(_requester);

  ProjectsLocationsTuningJobsResource(commons.ApiRequester client)
    : _requester = client;

  /// Cancels a TuningJob.
  ///
  /// Starts asynchronous cancellation on the TuningJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// GenAiTuningService.GetTuningJob or other methods to check whether the
  /// cancellation succeeded or whether the job completed despite cancellation.
  /// On successful cancellation, the TuningJob is not deleted; instead it
  /// becomes a job with a TuningJob.error value with a google.rpc.Status.code
  /// of 1, corresponding to `Code.CANCELLED`, and TuningJob.state is set to
  /// `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TuningJob to cancel. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1beta1CancelTuningJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a TuningJob.
  ///
  /// A created TuningJob right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// TuningJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TuningJob> create(
    GoogleCloudAiplatformV1beta1TuningJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/tuningJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TuningJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a TuningJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TuningJob resource. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1TuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1TuningJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1TuningJob.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists TuningJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// TuningJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListTuningJobsResponse.next_page_token of the previous
  /// GenAiTuningService.ListTuningJob\]\[\] call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListTuningJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListTuningJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/tuningJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListTuningJobsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Optimizes a prompt.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to optimize the
  /// prompt in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1OptimizePromptResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1OptimizePromptResponse>
  optimizePrompt(
    GoogleCloudAiplatformV1beta1OptimizePromptRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/tuningJobs:optimizePrompt';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1OptimizePromptResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Rebase a TunedModel.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to
  /// rebase the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> rebaseTunedModel(
    GoogleCloudAiplatformV1beta1RebaseTunedModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$parent') +
        '/tuningJobs:rebaseTunedModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsTuningJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTuningJobsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsModelGardenEulaResource {
  final commons.ApiRequester _requester;

  ProjectsModelGardenEulaResource(commons.ApiRequester client)
    : _requester = client;

  /// Accepts the EULA acceptance status of a publisher model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The project requesting access for named model. The
  /// format is `projects/{project}`.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance> accept(
    GoogleCloudAiplatformV1beta1AcceptPublisherModelEulaRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/modelGardenEula:accept';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Checks the EULA acceptance status of a publisher model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The project requesting access for named model. The
  /// format is `projects/{project}`.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance> check(
    GoogleCloudAiplatformV1beta1CheckPublisherModelEulaAcceptanceRequest
    request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/modelGardenEula:check';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class PublishersResource {
  final commons.ApiRequester _requester;

  PublishersModelsResource get models => PublishersModelsResource(_requester);

  PublishersResource(commons.ApiRequester client) : _requester = client;
}

class PublishersModelsResource {
  final commons.ApiRequester _requester;

  PublishersModelsResource(commons.ApiRequester client) : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1beta1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ComputeTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1beta1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1CountTokensResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetch an asynchronous online prediction operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> fetchPredictOperation(
    GoogleCloudAiplatformV1beta1FetchPredictOperationRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' +
        core.Uri.encodeFull('$endpoint') +
        ':fetchPredictOperation';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  generateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Model Garden publisher model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PublisherModel resource. Format:
  /// `publishers/{publisher}/models/{publisher_model}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [huggingFaceToken] - Optional. Token used to access Hugging Face gated
  /// models.
  ///
  /// [includeEquivalentModelGardenModelDeploymentConfigs] - Optional. Whether
  /// to cnclude the deployment configs from the equivalent Model Garden model
  /// if the requested model is a Hugging Face model.
  ///
  /// [isHuggingFaceModel] - Optional. Boolean indicates whether the requested
  /// model is a Hugging Face model.
  ///
  /// [languageCode] - Optional. The IETF BCP-47 language code representing the
  /// language in which the publisher model's text information should be written
  /// in.
  ///
  /// [view] - Optional. PublisherModel view specifying which fields to read.
  /// Possible string values are:
  /// - "PUBLISHER_MODEL_VIEW_UNSPECIFIED" : The default / unset value. The API
  /// will default to the BASIC view.
  /// - "PUBLISHER_MODEL_VIEW_BASIC" : Include basic metadata about the
  /// publisher model, but not the full contents.
  /// - "PUBLISHER_MODEL_VIEW_FULL" : Include everything.
  /// - "PUBLISHER_MODEL_VERSION_VIEW_BASIC" : Include: VersionId,
  /// ModelVersionExternalName, and SupportedActions.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PublisherModel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PublisherModel> get(
    core.String name, {
    core.String? huggingFaceToken,
    core.bool? includeEquivalentModelGardenModelDeploymentConfigs,
    core.bool? isHuggingFaceModel,
    core.String? languageCode,
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (huggingFaceToken != null) 'huggingFaceToken': [huggingFaceToken],
      if (includeEquivalentModelGardenModelDeploymentConfigs != null)
        'includeEquivalentModelGardenModelDeploymentConfigs': [
          '${includeEquivalentModelGardenModelDeploymentConfigs}',
        ],
      if (isHuggingFaceModel != null)
        'isHuggingFaceModel': ['${isHuggingFaceModel}'],
      if (languageCode != null) 'languageCode': [languageCode],
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PublisherModel.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists publisher models in Model Garden.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Publisher from which to list the
  /// PublisherModels. Format: `publishers/{publisher}`
  /// Value must have pattern `^publishers/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [languageCode] - Optional. The IETF BCP-47 language code representing the
  /// language in which the publisher models' text information should be written
  /// in. If not set, by default English (en).
  ///
  /// [listAllVersions] - Optional. List all publisher model versions if the
  /// flag is set to true.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListPublisherModelsResponse.next_page_token of the previous
  /// ModelGardenService.ListPublisherModels call.
  ///
  /// [view] - Optional. PublisherModel view specifying which fields to read.
  /// Possible string values are:
  /// - "PUBLISHER_MODEL_VIEW_UNSPECIFIED" : The default / unset value. The API
  /// will default to the BASIC view.
  /// - "PUBLISHER_MODEL_VIEW_BASIC" : Include basic metadata about the
  /// publisher model, but not the full contents.
  /// - "PUBLISHER_MODEL_VIEW_FULL" : Include everything.
  /// - "PUBLISHER_MODEL_VERSION_VIEW_BASIC" : Include: VersionId,
  /// ModelVersionExternalName, and SupportedActions.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListPublisherModelsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListPublisherModelsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? languageCode,
    core.bool? listAllVersions,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (languageCode != null) 'languageCode': [languageCode],
      if (listAllVersions != null) 'listAllVersions': ['${listAllVersions}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/models';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListPublisherModelsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1PredictResponse> predict(
    GoogleCloudAiplatformV1beta1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1PredictResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> predictLongRunning(
    GoogleCloudAiplatformV1beta1PredictLongRunningRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$endpoint') + ':predictLongRunning';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1GenerateContentResponse>
  streamGenerateContent(
    GoogleCloudAiplatformV1beta1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ReasoningEnginesResource {
  final commons.ApiRequester _requester;

  ReasoningEnginesMemoriesResource get memories =>
      ReasoningEnginesMemoriesResource(_requester);
  ReasoningEnginesSessionsResource get sessions =>
      ReasoningEnginesSessionsResource(_requester);

  ReasoningEnginesResource(commons.ApiRequester client) : _requester = client;

  /// Creates a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// ReasoningEngine in. Format: `projects/{project}/locations/{location}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1ReasoningEngine request, {
    core.String? parent,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (parent != null) 'parent': [parent],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1beta1/reasoningEngines';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [force] - Optional. If set to true, child resources of this reasoning
  /// engine will also be deleted. Otherwise, the request will fail with
  /// FAILED_PRECONDITION error when the reasoning engine has undeleted child
  /// resources.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ReasoningEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ReasoningEngine> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ReasoningEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists reasoning engines in a location.
  ///
  /// Request parameters:
  ///
  /// [filter] - Optional. The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// ReasoningEngines from. Format: `projects/{project}/locations/{location}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse> list({
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? parent,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parent != null) 'parent': [parent],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1beta1/reasoningEngines';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the ReasoningEngine. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Mask specifying which fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1ReasoningEngine request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Queries using a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse> query(
    GoogleCloudAiplatformV1beta1QueryReasoningEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':query';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Streams queries using a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> streamQuery(
    GoogleCloudAiplatformV1beta1StreamQueryReasoningEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':streamQuery';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ReasoningEnginesMemoriesResource {
  final commons.ApiRequester _requester;

  ReasoningEnginesMemoriesResource(commons.ApiRequester client)
    : _requester = client;

  /// Create a Memory.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to create
  /// the Memory under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Memory request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Delete a Memory.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Memory to delete. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+/memories/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Generate memories.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to generate
  /// memories for. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> generate(
    GoogleCloudAiplatformV1beta1GenerateMemoriesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories:generate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Get a Memory.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Memory. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+/memories/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Memory].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Memory> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Memory.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// List Memories.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to list the
  /// Memories under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160). Supported fields (equality match
  /// only): * `scope` (as a JSON string)
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListMemoriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListMemoriesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListMemoriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Update a Memory.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the Memory. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+/memories/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Mask specifying which fields to update. Supported
  /// fields: * `display_name` * `description` * `fact`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1beta1Memory request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Retrieve memories.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ReasoningEngine to retrieve
  /// memories from. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse> retrieve(
    GoogleCloudAiplatformV1beta1RetrieveMemoriesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1beta1/' + core.Uri.encodeFull('$parent') + '/memories:retrieve';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ReasoningEnginesSessionsResource {
  final commons.ApiRequester _requester;

  ReasoningEnginesSessionsEventsResource get events =>
      ReasoningEnginesSessionsEventsResource(_requester);

  ReasoningEnginesSessionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Appends an event to a given session.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the session to append event to.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1AppendEventResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1AppendEventResponse> appendEvent(
    GoogleCloudAiplatformV1beta1SessionEvent request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name') + ':appendEvent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1AppendEventResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a new Session.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the location to create the
  /// session in. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1beta1Session request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes details of the specific Session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the session. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets details of the specific Session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the session. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Session].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Session> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Session.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Sessions in a given reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the location to list sessions
  /// from. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. Supported fields: *
  /// `display_name` Example: `display_name=abc`.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `create_time` * `update_time` Example: `create_time
  /// desc`.
  ///
  /// [pageSize] - Optional. The maximum number of sessions to return. The
  /// service may return fewer than this value. If unspecified, at most 100
  /// sessions will be returned.
  ///
  /// [pageToken] - Optional. The next_page_token value returned from a previous
  /// list SessionService.ListSessions call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListSessionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListSessionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListSessionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the specific Session.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the session. Format:
  /// 'projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}'.
  /// Value must have pattern `^reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Field mask is used to control which fields get
  /// updated. If the mask is not present, all fields will be updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1Session].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1Session> patch(
    GoogleCloudAiplatformV1beta1Session request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1Session.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ReasoningEnginesSessionsEventsResource {
  final commons.ApiRequester _requester;

  ReasoningEnginesSessionsEventsResource(commons.ApiRequester client)
    : _requester = client;

  /// Lists Events in a given session.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the session to list events from.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  /// Value must have pattern `^reasoningEngines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. Supported fields: *
  /// `timestamp` range (i.e. `timestamp>="2025-01-31T11:30:00-04:00"` where the
  /// timestamp is in RFC 3339 format) More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - Optional. The maximum number of events to return. The service
  /// may return fewer than this value. If unspecified, at most 100 events will
  /// be returned. These events are ordered by timestamp in ascending order.
  ///
  /// [pageToken] - Optional. The next_page_token value returned from a previous
  /// list SessionService.ListEvents call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1beta1ListEventsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1beta1ListEventsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1beta1/' + core.Uri.encodeFull('$parent') + '/events';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1beta1ListEventsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

/// Message that represents an arbitrary HTTP body.
///
/// It should only be used for payload formats that can't be represented as
/// JSON, such as raw binary or an HTML page. This message can be used both in
/// streaming and non-streaming API methods in the request as well as the
/// response. It can be used as a top-level request field, which is convenient
/// if one wants to extract parameters from either the URL or HTTP template into
/// the request fields and also want access to the raw HTTP body. Example:
/// message GetResourceRequest { // A unique request id. string request_id = 1;
/// // The raw HTTP body is bound to this field. google.api.HttpBody http_body =
/// 2; } service ResourceService { rpc GetResource(GetResourceRequest) returns
/// (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns
/// (google.protobuf.Empty); } Example with streaming methods: service
/// CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream
/// google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
/// (stream google.api.HttpBody); } Use of this type only changes how the
/// request and response bodies are handled, all other features will continue to
/// work unchanged.
typedef GoogleApiHttpBody = $HttpBody;

/// Request message for ModelGardenService.AcceptPublisherModelEula.
typedef GoogleCloudAiplatformV1beta1AcceptPublisherModelEulaRequest =
    $Request10;

/// Parameters that configure the active learning pipeline.
///
/// Active learning will label the data incrementally by several iterations. For
/// every iteration, it will select a batch of data based on the sampling
/// strategy.
class GoogleCloudAiplatformV1beta1ActiveLearningConfig {
  /// Max number of human labeled DataItems.
  core.String? maxDataItemCount;

  /// Max percent of total DataItems for human labeling.
  core.int? maxDataItemPercentage;

  /// Active learning data sampling config.
  ///
  /// For every active learning labeling iteration, it will select a batch of
  /// data based on the sampling strategy.
  GoogleCloudAiplatformV1beta1SampleConfig? sampleConfig;

  /// CMLE training config.
  ///
  /// For every active learning labeling iteration, system will train a machine
  /// learning model on CMLE. The trained model will be used by data sampling
  /// algorithm to select DataItems.
  GoogleCloudAiplatformV1beta1TrainingConfig? trainingConfig;

  GoogleCloudAiplatformV1beta1ActiveLearningConfig({
    this.maxDataItemCount,
    this.maxDataItemPercentage,
    this.sampleConfig,
    this.trainingConfig,
  });

  GoogleCloudAiplatformV1beta1ActiveLearningConfig.fromJson(core.Map json_)
    : this(
        maxDataItemCount: json_['maxDataItemCount'] as core.String?,
        maxDataItemPercentage: json_['maxDataItemPercentage'] as core.int?,
        sampleConfig:
            json_.containsKey('sampleConfig')
                ? GoogleCloudAiplatformV1beta1SampleConfig.fromJson(
                  json_['sampleConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingConfig:
            json_.containsKey('trainingConfig')
                ? GoogleCloudAiplatformV1beta1TrainingConfig.fromJson(
                  json_['trainingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxDataItemCount != null) 'maxDataItemCount': maxDataItemCount!,
    if (maxDataItemPercentage != null)
      'maxDataItemPercentage': maxDataItemPercentage!,
    if (sampleConfig != null) 'sampleConfig': sampleConfig!,
    if (trainingConfig != null) 'trainingConfig': trainingConfig!,
  };
}

/// Request message for MetadataService.AddContextArtifactsAndExecutions.
typedef GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsRequest =
    $AddContextArtifactsAndExecutionsRequest;

/// Response message for MetadataService.AddContextArtifactsAndExecutions.
typedef GoogleCloudAiplatformV1beta1AddContextArtifactsAndExecutionsResponse =
    $Empty;

/// Request message for MetadataService.AddContextChildren.
typedef GoogleCloudAiplatformV1beta1AddContextChildrenRequest =
    $ContextChildrenRequest;

/// Response message for MetadataService.AddContextChildren.
typedef GoogleCloudAiplatformV1beta1AddContextChildrenResponse = $Empty;

/// Request message for MetadataService.AddExecutionEvents.
class GoogleCloudAiplatformV1beta1AddExecutionEventsRequest {
  /// The Events to create and add.
  core.List<GoogleCloudAiplatformV1beta1Event>? events;

  GoogleCloudAiplatformV1beta1AddExecutionEventsRequest({this.events});

  GoogleCloudAiplatformV1beta1AddExecutionEventsRequest.fromJson(core.Map json_)
    : this(
        events:
            (json_['events'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Event.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (events != null) 'events': events!,
  };
}

/// Response message for MetadataService.AddExecutionEvents.
typedef GoogleCloudAiplatformV1beta1AddExecutionEventsResponse = $Empty;

/// Request message for VizierService.AddTrialMeasurement.
class GoogleCloudAiplatformV1beta1AddTrialMeasurementRequest {
  /// The measurement to be added to a Trial.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Measurement? measurement;

  GoogleCloudAiplatformV1beta1AddTrialMeasurementRequest({this.measurement});

  GoogleCloudAiplatformV1beta1AddTrialMeasurementRequest.fromJson(
    core.Map json_,
  ) : this(
        measurement:
            json_.containsKey('measurement')
                ? GoogleCloudAiplatformV1beta1Measurement.fromJson(
                  json_['measurement'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (measurement != null) 'measurement': measurement!,
  };
}

/// Used to assign specific AnnotationSpec to a particular area of a DataItem or
/// the whole part of the DataItem.
class GoogleCloudAiplatformV1beta1Annotation {
  /// The source of the Annotation.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1UserActionReference? annotationSource;

  /// Timestamp when this Annotation was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Annotations.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Annotation(System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for each Annotation: *
  /// "aiplatform.googleapis.com/annotation_set_name": optional, name of the
  /// UI's annotation set this Annotation belongs to. If not set, the Annotation
  /// is not visible in the UI. * "aiplatform.googleapis.com/payload_schema":
  /// output only, its value is the payload_schema's title.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the Annotation.
  ///
  /// Output only.
  core.String? name;

  /// The schema of the payload can be found in payload_schema.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? payload;

  /// Google Cloud Storage URI points to a YAML file describing payload.
  ///
  /// The schema is defined as an
  /// [OpenAPI 3.0.2 Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
  /// chosen schema must be consistent with the parent Dataset's metadata.
  ///
  /// Required.
  core.String? payloadSchemaUri;

  /// Timestamp when this Annotation was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Annotation({
    this.annotationSource,
    this.createTime,
    this.etag,
    this.labels,
    this.name,
    this.payload,
    this.payloadSchemaUri,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Annotation.fromJson(core.Map json_)
    : this(
        annotationSource:
            json_.containsKey('annotationSource')
                ? GoogleCloudAiplatformV1beta1UserActionReference.fromJson(
                  json_['annotationSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        payload: json_['payload'],
        payloadSchemaUri: json_['payloadSchemaUri'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationSource != null) 'annotationSource': annotationSource!,
    if (createTime != null) 'createTime': createTime!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (payload != null) 'payload': payload!,
    if (payloadSchemaUri != null) 'payloadSchemaUri': payloadSchemaUri!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Identifies a concept with which DataItems may be annotated with.
typedef GoogleCloudAiplatformV1beta1AnnotationSpec = $AnnotationSpec;

/// The generic reusable api auth config.
///
/// Deprecated. Please use AuthConfig
/// (google/cloud/aiplatform/master/auth.proto) instead.
class GoogleCloudAiplatformV1beta1ApiAuth {
  /// The API secret.
  GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig? apiKeyConfig;

  GoogleCloudAiplatformV1beta1ApiAuth({this.apiKeyConfig});

  GoogleCloudAiplatformV1beta1ApiAuth.fromJson(core.Map json_)
    : this(
        apiKeyConfig:
            json_.containsKey('apiKeyConfig')
                ? GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig.fromJson(
                  json_['apiKeyConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!,
  };
}

/// The API secret.
typedef GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig = $ApiAuthApiKeyConfig;

/// Response message for SessionService.AppendEvent.
typedef GoogleCloudAiplatformV1beta1AppendEventResponse = $Empty;

/// Instance of a general artifact.
typedef GoogleCloudAiplatformV1beta1Artifact = $Artifact01;

/// The definition of a artifact type in MLMD.
class GoogleCloudAiplatformV1beta1ArtifactTypeSchema {
  /// Contains a raw YAML string, describing the format of the properties of the
  /// type.
  core.String? instanceSchema;

  /// The name of the type.
  ///
  /// The format of the title must be: `.`. Examples: - `aiplatform.Model` -
  /// `acme.CustomModel` When this field is set, the type must be pre-registered
  /// in the MLMD store.
  core.String? schemaTitle;

  /// Points to a YAML file stored on Cloud Storage describing the format.
  ///
  /// Deprecated. Use PipelineArtifactTypeSchema.schema_title or
  /// PipelineArtifactTypeSchema.instance_schema instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? schemaUri;

  /// The schema version of the artifact.
  ///
  /// If the value is not set, it defaults to the latest version in the system.
  core.String? schemaVersion;

  GoogleCloudAiplatformV1beta1ArtifactTypeSchema({
    this.instanceSchema,
    this.schemaTitle,
    this.schemaUri,
    this.schemaVersion,
  });

  GoogleCloudAiplatformV1beta1ArtifactTypeSchema.fromJson(core.Map json_)
    : this(
        instanceSchema: json_['instanceSchema'] as core.String?,
        schemaTitle: json_['schemaTitle'] as core.String?,
        schemaUri: json_['schemaUri'] as core.String?,
        schemaVersion: json_['schemaVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instanceSchema != null) 'instanceSchema': instanceSchema!,
    if (schemaTitle != null) 'schemaTitle': schemaTitle!,
    if (schemaUri != null) 'schemaUri': schemaUri!,
    if (schemaVersion != null) 'schemaVersion': schemaVersion!,
  };
}

/// Request message for DatasetService.AssembleData.
///
/// Used only for MULTIMODAL datasets.
class GoogleCloudAiplatformV1beta1AssembleDataRequest {
  /// The read config for the dataset.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GeminiRequestReadConfig? geminiRequestReadConfig;

  GoogleCloudAiplatformV1beta1AssembleDataRequest({
    this.geminiRequestReadConfig,
  });

  GoogleCloudAiplatformV1beta1AssembleDataRequest.fromJson(core.Map json_)
    : this(
        geminiRequestReadConfig:
            json_.containsKey('geminiRequestReadConfig')
                ? GoogleCloudAiplatformV1beta1GeminiRequestReadConfig.fromJson(
                  json_['geminiRequestReadConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (geminiRequestReadConfig != null)
      'geminiRequestReadConfig': geminiRequestReadConfig!,
  };
}

/// Request message for DatasetService.AssessData.
///
/// Used only for MULTIMODAL datasets.
class GoogleCloudAiplatformV1beta1AssessDataRequest {
  /// Configuration for the batch prediction resource usage assessment.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionResourceUsageAssessmentConfig?
  batchPredictionResourceUsageAssessmentConfig;

  /// Configuration for the batch prediction validation assessment.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionValidationAssessmentConfig?
  batchPredictionValidationAssessmentConfig;

  /// The Gemini request read config for the dataset.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GeminiRequestReadConfig? geminiRequestReadConfig;

  /// Configuration for the tuning resource usage assessment.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AssessDataRequestTuningResourceUsageAssessmentConfig?
  tuningResourceUsageAssessmentConfig;

  /// Configuration for the tuning validation assessment.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AssessDataRequestTuningValidationAssessmentConfig?
  tuningValidationAssessmentConfig;

  GoogleCloudAiplatformV1beta1AssessDataRequest({
    this.batchPredictionResourceUsageAssessmentConfig,
    this.batchPredictionValidationAssessmentConfig,
    this.geminiRequestReadConfig,
    this.tuningResourceUsageAssessmentConfig,
    this.tuningValidationAssessmentConfig,
  });

  GoogleCloudAiplatformV1beta1AssessDataRequest.fromJson(core.Map json_)
    : this(
        batchPredictionResourceUsageAssessmentConfig:
            json_.containsKey('batchPredictionResourceUsageAssessmentConfig')
                ? GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionResourceUsageAssessmentConfig.fromJson(
                  json_['batchPredictionResourceUsageAssessmentConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        batchPredictionValidationAssessmentConfig:
            json_.containsKey('batchPredictionValidationAssessmentConfig')
                ? GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionValidationAssessmentConfig.fromJson(
                  json_['batchPredictionValidationAssessmentConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        geminiRequestReadConfig:
            json_.containsKey('geminiRequestReadConfig')
                ? GoogleCloudAiplatformV1beta1GeminiRequestReadConfig.fromJson(
                  json_['geminiRequestReadConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tuningResourceUsageAssessmentConfig:
            json_.containsKey('tuningResourceUsageAssessmentConfig')
                ? GoogleCloudAiplatformV1beta1AssessDataRequestTuningResourceUsageAssessmentConfig.fromJson(
                  json_['tuningResourceUsageAssessmentConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tuningValidationAssessmentConfig:
            json_.containsKey('tuningValidationAssessmentConfig')
                ? GoogleCloudAiplatformV1beta1AssessDataRequestTuningValidationAssessmentConfig.fromJson(
                  json_['tuningValidationAssessmentConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (batchPredictionResourceUsageAssessmentConfig != null)
      'batchPredictionResourceUsageAssessmentConfig':
          batchPredictionResourceUsageAssessmentConfig!,
    if (batchPredictionValidationAssessmentConfig != null)
      'batchPredictionValidationAssessmentConfig':
          batchPredictionValidationAssessmentConfig!,
    if (geminiRequestReadConfig != null)
      'geminiRequestReadConfig': geminiRequestReadConfig!,
    if (tuningResourceUsageAssessmentConfig != null)
      'tuningResourceUsageAssessmentConfig':
          tuningResourceUsageAssessmentConfig!,
    if (tuningValidationAssessmentConfig != null)
      'tuningValidationAssessmentConfig': tuningValidationAssessmentConfig!,
  };
}

/// Configuration for the batch prediction resource usage assessment.
typedef GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionResourceUsageAssessmentConfig =
    $AssessmentConfig;

/// Configuration for the batch prediction validation assessment.
typedef GoogleCloudAiplatformV1beta1AssessDataRequestBatchPredictionValidationAssessmentConfig =
    $AssessmentConfig;

/// Configuration for the tuning resource usage assessment.
class GoogleCloudAiplatformV1beta1AssessDataRequestTuningResourceUsageAssessmentConfig {
  /// The name of the model used for tuning.
  ///
  /// Required.
  core.String? modelName;

  GoogleCloudAiplatformV1beta1AssessDataRequestTuningResourceUsageAssessmentConfig({
    this.modelName,
  });

  GoogleCloudAiplatformV1beta1AssessDataRequestTuningResourceUsageAssessmentConfig.fromJson(
    core.Map json_,
  ) : this(modelName: json_['modelName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelName != null) 'modelName': modelName!,
  };
}

/// Configuration for the tuning validation assessment.
class GoogleCloudAiplatformV1beta1AssessDataRequestTuningValidationAssessmentConfig {
  /// The dataset usage (e.g. training/validation).
  ///
  /// Required.
  /// Possible string values are:
  /// - "DATASET_USAGE_UNSPECIFIED" : Default value. Should not be used.
  /// - "SFT_TRAINING" : Supervised fine-tuning training dataset.
  /// - "SFT_VALIDATION" : Supervised fine-tuning validation dataset.
  core.String? datasetUsage;

  /// The name of the model used for tuning.
  ///
  /// Required.
  core.String? modelName;

  GoogleCloudAiplatformV1beta1AssessDataRequestTuningValidationAssessmentConfig({
    this.datasetUsage,
    this.modelName,
  });

  GoogleCloudAiplatformV1beta1AssessDataRequestTuningValidationAssessmentConfig.fromJson(
    core.Map json_,
  ) : this(
        datasetUsage: json_['datasetUsage'] as core.String?,
        modelName: json_['modelName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datasetUsage != null) 'datasetUsage': datasetUsage!,
    if (modelName != null) 'modelName': modelName!,
  };
}

/// Request message for NotebookService.AssignNotebookRuntime.
class GoogleCloudAiplatformV1beta1AssignNotebookRuntimeRequest {
  /// Provide runtime specific information (e.g. runtime owner, notebook id)
  /// used for NotebookRuntime assignment.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1NotebookRuntime? notebookRuntime;

  /// User specified ID for the notebook runtime.
  ///
  /// Optional.
  core.String? notebookRuntimeId;

  /// The resource name of the NotebookRuntimeTemplate based on which a
  /// NotebookRuntime will be assigned (reuse or create a new one).
  ///
  /// Required.
  core.String? notebookRuntimeTemplate;

  GoogleCloudAiplatformV1beta1AssignNotebookRuntimeRequest({
    this.notebookRuntime,
    this.notebookRuntimeId,
    this.notebookRuntimeTemplate,
  });

  GoogleCloudAiplatformV1beta1AssignNotebookRuntimeRequest.fromJson(
    core.Map json_,
  ) : this(
        notebookRuntime:
            json_.containsKey('notebookRuntime')
                ? GoogleCloudAiplatformV1beta1NotebookRuntime.fromJson(
                  json_['notebookRuntime']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        notebookRuntimeId: json_['notebookRuntimeId'] as core.String?,
        notebookRuntimeTemplate:
            json_['notebookRuntimeTemplate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (notebookRuntime != null) 'notebookRuntime': notebookRuntime!,
    if (notebookRuntimeId != null) 'notebookRuntimeId': notebookRuntimeId!,
    if (notebookRuntimeTemplate != null)
      'notebookRuntimeTemplate': notebookRuntimeTemplate!,
  };
}

/// Attribution that explains a particular prediction output.
typedef GoogleCloudAiplatformV1beta1Attribution = $Attribution00;

/// Request message for AugmentPrompt.
class GoogleCloudAiplatformV1beta1AugmentPromptRequest {
  /// Input content to augment, only text format is supported for now.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// Metadata of the backend deployed model.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AugmentPromptRequestModel? model;

  /// Retrieves contexts from the Vertex RagStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1VertexRagStore? vertexRagStore;

  GoogleCloudAiplatformV1beta1AugmentPromptRequest({
    this.contents,
    this.model,
    this.vertexRagStore,
  });

  GoogleCloudAiplatformV1beta1AugmentPromptRequest.fromJson(core.Map json_)
    : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        model:
            json_.containsKey('model')
                ? GoogleCloudAiplatformV1beta1AugmentPromptRequestModel.fromJson(
                  json_['model'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexRagStore:
            json_.containsKey('vertexRagStore')
                ? GoogleCloudAiplatformV1beta1VertexRagStore.fromJson(
                  json_['vertexRagStore']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (model != null) 'model': model!,
    if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!,
  };
}

/// Metadata of the backend deployed model.
typedef GoogleCloudAiplatformV1beta1AugmentPromptRequestModel =
    $AugmentPromptRequestModel;

/// Response message for AugmentPrompt.
class GoogleCloudAiplatformV1beta1AugmentPromptResponse {
  /// Augmented prompt, only text format is supported for now.
  core.List<GoogleCloudAiplatformV1beta1Content>? augmentedPrompt;

  /// Retrieved facts from RAG data sources.
  core.List<GoogleCloudAiplatformV1beta1Fact>? facts;

  GoogleCloudAiplatformV1beta1AugmentPromptResponse({
    this.augmentedPrompt,
    this.facts,
  });

  GoogleCloudAiplatformV1beta1AugmentPromptResponse.fromJson(core.Map json_)
    : this(
        augmentedPrompt:
            (json_['augmentedPrompt'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        facts:
            (json_['facts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Fact.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (augmentedPrompt != null) 'augmentedPrompt': augmentedPrompt!,
    if (facts != null) 'facts': facts!,
  };
}

/// Auth configuration to run the extension.
class GoogleCloudAiplatformV1beta1AuthConfig {
  /// Config for API key auth.
  GoogleCloudAiplatformV1beta1AuthConfigApiKeyConfig? apiKeyConfig;

  /// Type of auth scheme.
  /// Possible string values are:
  /// - "AUTH_TYPE_UNSPECIFIED"
  /// - "NO_AUTH" : No Auth.
  /// - "API_KEY_AUTH" : API Key Auth.
  /// - "HTTP_BASIC_AUTH" : HTTP Basic Auth.
  /// - "GOOGLE_SERVICE_ACCOUNT_AUTH" : Google Service Account Auth.
  /// - "OAUTH" : OAuth auth.
  /// - "OIDC_AUTH" : OpenID Connect (OIDC) Auth.
  core.String? authType;

  /// Config for Google Service Account auth.
  GoogleCloudAiplatformV1beta1AuthConfigGoogleServiceAccountConfig?
  googleServiceAccountConfig;

  /// Config for HTTP Basic auth.
  GoogleCloudAiplatformV1beta1AuthConfigHttpBasicAuthConfig?
  httpBasicAuthConfig;

  /// Config for user oauth.
  GoogleCloudAiplatformV1beta1AuthConfigOauthConfig? oauthConfig;

  /// Config for user OIDC auth.
  GoogleCloudAiplatformV1beta1AuthConfigOidcConfig? oidcConfig;

  GoogleCloudAiplatformV1beta1AuthConfig({
    this.apiKeyConfig,
    this.authType,
    this.googleServiceAccountConfig,
    this.httpBasicAuthConfig,
    this.oauthConfig,
    this.oidcConfig,
  });

  GoogleCloudAiplatformV1beta1AuthConfig.fromJson(core.Map json_)
    : this(
        apiKeyConfig:
            json_.containsKey('apiKeyConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfigApiKeyConfig.fromJson(
                  json_['apiKeyConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        authType: json_['authType'] as core.String?,
        googleServiceAccountConfig:
            json_.containsKey('googleServiceAccountConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfigGoogleServiceAccountConfig.fromJson(
                  json_['googleServiceAccountConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        httpBasicAuthConfig:
            json_.containsKey('httpBasicAuthConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfigHttpBasicAuthConfig.fromJson(
                  json_['httpBasicAuthConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        oauthConfig:
            json_.containsKey('oauthConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfigOauthConfig.fromJson(
                  json_['oauthConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        oidcConfig:
            json_.containsKey('oidcConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfigOidcConfig.fromJson(
                  json_['oidcConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!,
    if (authType != null) 'authType': authType!,
    if (googleServiceAccountConfig != null)
      'googleServiceAccountConfig': googleServiceAccountConfig!,
    if (httpBasicAuthConfig != null)
      'httpBasicAuthConfig': httpBasicAuthConfig!,
    if (oauthConfig != null) 'oauthConfig': oauthConfig!,
    if (oidcConfig != null) 'oidcConfig': oidcConfig!,
  };
}

/// Config for authentication with API key.
typedef GoogleCloudAiplatformV1beta1AuthConfigApiKeyConfig =
    $AuthConfigApiKeyConfig;

/// Config for Google Service Account Authentication.
typedef GoogleCloudAiplatformV1beta1AuthConfigGoogleServiceAccountConfig =
    $AuthConfigGoogleServiceAccountConfig;

/// Config for HTTP Basic Authentication.
typedef GoogleCloudAiplatformV1beta1AuthConfigHttpBasicAuthConfig =
    $AuthConfigHttpBasicAuthConfig;

/// Config for user oauth.
typedef GoogleCloudAiplatformV1beta1AuthConfigOauthConfig =
    $AuthConfigOauthConfig;

/// Config for user OIDC auth.
typedef GoogleCloudAiplatformV1beta1AuthConfigOidcConfig =
    $AuthConfigOidcConfig;

/// A description of resources that to large degree are decided by Vertex AI,
/// and require only a modest additional configuration.
///
/// Each Model supporting these resources documents its specific guidelines.
typedef GoogleCloudAiplatformV1beta1AutomaticResources = $AutomaticResources;

/// The configs for autorater.
///
/// This is applicable to both EvaluateInstances and EvaluateDataset.
typedef GoogleCloudAiplatformV1beta1AutoraterConfig = $AutoraterConfig;

/// The metric specification that defines the target resource utilization (CPU
/// utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
typedef GoogleCloudAiplatformV1beta1AutoscalingMetricSpec =
    $AutoscalingMetricSpec;

/// The storage details for Avro input content.
class GoogleCloudAiplatformV1beta1AvroSource {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  GoogleCloudAiplatformV1beta1AvroSource({this.gcsSource});

  GoogleCloudAiplatformV1beta1AvroSource.fromJson(core.Map json_)
    : this(
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!,
  };
}

/// Request message for PipelineService.BatchCancelPipelineJobs.
typedef GoogleCloudAiplatformV1beta1BatchCancelPipelineJobsRequest =
    $BatchCancelPipelineJobsRequest;

/// Request message for FeaturestoreService.BatchCreateFeatures.
///
/// Request message for FeatureRegistryService.BatchCreateFeatures.
class GoogleCloudAiplatformV1beta1BatchCreateFeaturesRequest {
  /// The request message specifying the Features to create.
  ///
  /// All Features must be created under the same parent EntityType /
  /// FeatureGroup. The `parent` field in each child request message can be
  /// omitted. If `parent` is set in a child request, then the value must match
  /// the `parent` value in this request message.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1CreateFeatureRequest>? requests;

  GoogleCloudAiplatformV1beta1BatchCreateFeaturesRequest({this.requests});

  GoogleCloudAiplatformV1beta1BatchCreateFeaturesRequest.fromJson(
    core.Map json_,
  ) : this(
        requests:
            (json_['requests'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1CreateFeatureRequest.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requests != null) 'requests': requests!,
  };
}

/// Request message for TensorboardService.BatchCreateTensorboardRuns.
class GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsRequest {
  /// The request message specifying the TensorboardRuns to create.
  ///
  /// A maximum of 1000 TensorboardRuns can be created in a batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1CreateTensorboardRunRequest>? requests;

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsRequest.fromJson(
    core.Map json_,
  ) : this(
        requests:
            (json_['requests'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1CreateTensorboardRunRequest.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requests != null) 'requests': requests!,
  };
}

/// Response message for TensorboardService.BatchCreateTensorboardRuns.
class GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsResponse {
  /// The created TensorboardRuns.
  core.List<GoogleCloudAiplatformV1beta1TensorboardRun>? tensorboardRuns;

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsResponse({
    this.tensorboardRuns,
  });

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardRunsResponse.fromJson(
    core.Map json_,
  ) : this(
        tensorboardRuns:
            (json_['tensorboardRuns'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TensorboardRun.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tensorboardRuns != null) 'tensorboardRuns': tensorboardRuns!,
  };
}

/// Request message for TensorboardService.BatchCreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesRequest {
  /// The request message specifying the TensorboardTimeSeries to create.
  ///
  /// A maximum of 1000 TensorboardTimeSeries can be created in a batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1CreateTensorboardTimeSeriesRequest>?
  requests;

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesRequest.fromJson(
    core.Map json_,
  ) : this(
        requests:
            (json_['requests'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1CreateTensorboardTimeSeriesRequest.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requests != null) 'requests': requests!,
  };
}

/// Response message for TensorboardService.BatchCreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesResponse {
  /// The created TensorboardTimeSeries.
  core.List<GoogleCloudAiplatformV1beta1TensorboardTimeSeries>?
  tensorboardTimeSeries;

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesResponse({
    this.tensorboardTimeSeries,
  });

  GoogleCloudAiplatformV1beta1BatchCreateTensorboardTimeSeriesResponse.fromJson(
    core.Map json_,
  ) : this(
        tensorboardTimeSeries:
            (json_['tensorboardTimeSeries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TensorboardTimeSeries.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tensorboardTimeSeries != null)
      'tensorboardTimeSeries': tensorboardTimeSeries!,
  };
}

/// A description of resources that are used for performing batch operations,
/// are dedicated to a Model, and need manual configuration.
class GoogleCloudAiplatformV1beta1BatchDedicatedResources {
  /// If set, use DWS resource to schedule the deployment workload.
  ///
  /// reference:
  /// (https://cloud.google.com/blog/products/compute/introducing-dynamic-workload-scheduler)
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1FlexStart? flexStart;

  /// The specification of a single machine.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1beta1MachineSpec? machineSpec;

  /// The maximum number of machine replicas the batch operation may be scaled
  /// to.
  ///
  /// The default value is 10.
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// If true, schedule the deployment workload on
  /// [spot VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
  ///
  /// Optional.
  core.bool? spot;

  /// The number of machine replicas used at the start of the batch operation.
  ///
  /// If not set, Vertex AI decides starting number, not greater than
  /// max_replica_count
  ///
  /// Immutable.
  core.int? startingReplicaCount;

  GoogleCloudAiplatformV1beta1BatchDedicatedResources({
    this.flexStart,
    this.machineSpec,
    this.maxReplicaCount,
    this.spot,
    this.startingReplicaCount,
  });

  GoogleCloudAiplatformV1beta1BatchDedicatedResources.fromJson(core.Map json_)
    : this(
        flexStart:
            json_.containsKey('flexStart')
                ? GoogleCloudAiplatformV1beta1FlexStart.fromJson(
                  json_['flexStart'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        machineSpec:
            json_.containsKey('machineSpec')
                ? GoogleCloudAiplatformV1beta1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        maxReplicaCount: json_['maxReplicaCount'] as core.int?,
        spot: json_['spot'] as core.bool?,
        startingReplicaCount: json_['startingReplicaCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (flexStart != null) 'flexStart': flexStart!,
    if (machineSpec != null) 'machineSpec': machineSpec!,
    if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
    if (spot != null) 'spot': spot!,
    if (startingReplicaCount != null)
      'startingReplicaCount': startingReplicaCount!,
  };
}

/// Request message for PipelineService.BatchDeletePipelineJobs.
typedef GoogleCloudAiplatformV1beta1BatchDeletePipelineJobsRequest =
    $BatchDeletePipelineJobsRequest;

/// Request message for ModelService.BatchImportEvaluatedAnnotations
class GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsRequest {
  /// Evaluated annotations resource to be imported.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1EvaluatedAnnotation>?
  evaluatedAnnotations;

  GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsRequest({
    this.evaluatedAnnotations,
  });

  GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsRequest.fromJson(
    core.Map json_,
  ) : this(
        evaluatedAnnotations:
            (json_['evaluatedAnnotations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1EvaluatedAnnotation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (evaluatedAnnotations != null)
      'evaluatedAnnotations': evaluatedAnnotations!,
  };
}

/// Response message for ModelService.BatchImportEvaluatedAnnotations
typedef GoogleCloudAiplatformV1beta1BatchImportEvaluatedAnnotationsResponse =
    $BatchImportEvaluatedAnnotationsResponse;

/// Request message for MigrationService.BatchMigrateResources.
class GoogleCloudAiplatformV1beta1BatchMigrateResourcesRequest {
  /// The request messages specifying the resources to migrate.
  ///
  /// They must be in the same location as the destination. Up to 50 resources
  /// can be migrated in one batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1MigrateResourceRequest>?
  migrateResourceRequests;

  GoogleCloudAiplatformV1beta1BatchMigrateResourcesRequest({
    this.migrateResourceRequests,
  });

  GoogleCloudAiplatformV1beta1BatchMigrateResourcesRequest.fromJson(
    core.Map json_,
  ) : this(
        migrateResourceRequests:
            (json_['migrateResourceRequests'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1MigrateResourceRequest.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (migrateResourceRequests != null)
      'migrateResourceRequests': migrateResourceRequests!,
  };
}

/// A job that uses a Model to produce predictions on multiple input instances.
///
/// If predictions for significant portion of the instances fail, the job may
/// finish without attempting predictions for all remaining instances.
class GoogleCloudAiplatformV1beta1BatchPredictionJob {
  /// Statistics on completed and failed prediction instances.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1CompletionStats? completionStats;

  /// Time when the BatchPredictionJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The config of resources used by the Model during the batch prediction.
  ///
  /// If the Model supports DEDICATED_RESOURCES this config may be provided (and
  /// the job will use these resources), if the Model doesn't support
  /// AUTOMATIC_RESOURCES, this config must be provided.
  GoogleCloudAiplatformV1beta1BatchDedicatedResources? dedicatedResources;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to Cloud
  /// Logging by default.
  ///
  /// Please note that the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging/pricing). User
  /// can disable container logging by setting this flag to true.
  core.bool? disableContainerLogging;

  /// The user-defined name of this BatchPredictionJob.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a BatchPredictionJob.
  ///
  /// If this is set, then all resources created by the BatchPredictionJob will
  /// be encrypted with the provided encryption key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Time when the BatchPredictionJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when the job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Explanation configuration for this BatchPredictionJob.
  ///
  /// Can be specified only if generate_explanation is set to `true`. This value
  /// overrides the value of Model.explanation_spec. All fields of
  /// explanation_spec are optional in the request. If a field of the
  /// explanation_spec object is not populated, the corresponding field of the
  /// Model.explanation_spec object is inherited.
  GoogleCloudAiplatformV1beta1ExplanationSpec? explanationSpec;

  /// Generate explanation with the batch prediction results.
  ///
  /// When set to `true`, the batch prediction output changes based on the
  /// `predictions_format` field of the BatchPredictionJob.output_config object:
  /// * `bigquery`: output includes a column named `explanation`. The value is a
  /// struct that conforms to the Explanation object. * `jsonl`: The JSON
  /// objects on each line include an additional entry keyed `explanation`. The
  /// value of the entry is a JSON object that conforms to the Explanation
  /// object. * `csv`: Generating explanations for CSV format is not supported.
  /// If this field is set to true, either the Model.explanation_spec or
  /// explanation_spec must be populated.
  core.bool? generateExplanation;

  /// Input configuration of the instances on which predictions are performed.
  ///
  /// The schema of any single instance may be specified via the Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1BatchPredictionJobInputConfig? inputConfig;

  /// Configuration for how to convert batch prediction input instances to the
  /// prediction instances that are sent to the Model.
  GoogleCloudAiplatformV1beta1BatchPredictionJobInstanceConfig? instanceConfig;

  /// The labels with user-defined metadata to organize BatchPredictionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Parameters configuring the batch behavior.
  ///
  /// Currently only applicable when dedicated_resources are used (in other
  /// cases Vertex AI does the tuning itself).
  ///
  /// Immutable.
  GoogleCloudAiplatformV1beta1ManualBatchTuningParameters?
  manualBatchTuningParameters;

  /// The name of the Model resource that produces the predictions via this job,
  /// must share the same ancestor Location.
  ///
  /// Starting this job has no impact on any existing deployments of the Model
  /// and their resources. Exactly one of model and unmanaged_container_model
  /// must be set. The model resource name may contain version id or version
  /// alias to specify the version. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` if no
  /// version is specified, the default version will be deployed. The model
  /// resource could also be a publisher model. Example:
  /// `publishers/{publisher}/models/{model}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  core.String? model;

  /// Model monitoring config will be used for analysis model behaviors, based
  /// on the input and output to the batch prediction job, as well as the
  /// provided training dataset.
  GoogleCloudAiplatformV1beta1ModelMonitoringConfig? modelMonitoringConfig;

  /// Get batch prediction job monitoring statistics.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomalies>?
  modelMonitoringStatsAnomalies;

  /// The running status of the model monitoring pipeline.
  ///
  /// Output only.
  GoogleRpcStatus? modelMonitoringStatus;

  /// The parameters that govern the predictions.
  ///
  /// The schema of the parameters may be specified via the Model's
  /// PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? modelParameters;

  /// The version ID of the Model that produces the predictions via this job.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// Resource name of the BatchPredictionJob.
  ///
  /// Output only.
  core.String? name;

  /// The Configuration specifying where output predictions should be written.
  ///
  /// The schema of any single prediction may be specified as a concatenation of
  /// Model's PredictSchemata's instance_schema_uri and prediction_schema_uri.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1BatchPredictionJobOutputConfig? outputConfig;

  /// Information further describing the output of this job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1BatchPredictionJobOutputInfo? outputInfo;

  /// Partial failures encountered.
  ///
  /// For example, single files that can't be read. This field never exceeds 20
  /// entries. Status details fields contain standard Google Cloud error
  /// details.
  ///
  /// Output only.
  core.List<GoogleRpcStatus>? partialFailures;

  /// Information about resources that had been consumed by this job.
  ///
  /// Provided in real time at best effort basis, as well as a final value once
  /// the job completes. Note: This field currently may be not populated for
  /// batch predictions that use AutoML Models.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ResourcesConsumed? resourcesConsumed;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// The service account that the DeployedModel's container runs as.
  ///
  /// If not specified, a system generated one will be used, which has minimal
  /// permissions and the custom container, if used, may not have enough
  /// permission to access other Google Cloud resources. Users deploying the
  /// Model must have the `iam.serviceAccounts.actAs` permission on this service
  /// account.
  core.String? serviceAccount;

  /// Time when the BatchPredictionJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Contains model information necessary to perform batch prediction without
  /// requiring uploading to model registry.
  ///
  /// Exactly one of model and unmanaged_container_model must be set.
  GoogleCloudAiplatformV1beta1UnmanagedContainerModel? unmanagedContainerModel;

  /// Time when the BatchPredictionJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1BatchPredictionJob({
    this.completionStats,
    this.createTime,
    this.dedicatedResources,
    this.disableContainerLogging,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.explanationSpec,
    this.generateExplanation,
    this.inputConfig,
    this.instanceConfig,
    this.labels,
    this.manualBatchTuningParameters,
    this.model,
    this.modelMonitoringConfig,
    this.modelMonitoringStatsAnomalies,
    this.modelMonitoringStatus,
    this.modelParameters,
    this.modelVersionId,
    this.name,
    this.outputConfig,
    this.outputInfo,
    this.partialFailures,
    this.resourcesConsumed,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.unmanagedContainerModel,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1BatchPredictionJob.fromJson(core.Map json_)
    : this(
        completionStats:
            json_.containsKey('completionStats')
                ? GoogleCloudAiplatformV1beta1CompletionStats.fromJson(
                  json_['completionStats']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        dedicatedResources:
            json_.containsKey('dedicatedResources')
                ? GoogleCloudAiplatformV1beta1BatchDedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        disableContainerLogging: json_['disableContainerLogging'] as core.bool?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        explanationSpec:
            json_.containsKey('explanationSpec')
                ? GoogleCloudAiplatformV1beta1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        generateExplanation: json_['generateExplanation'] as core.bool?,
        inputConfig:
            json_.containsKey('inputConfig')
                ? GoogleCloudAiplatformV1beta1BatchPredictionJobInputConfig.fromJson(
                  json_['inputConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        instanceConfig:
            json_.containsKey('instanceConfig')
                ? GoogleCloudAiplatformV1beta1BatchPredictionJobInstanceConfig.fromJson(
                  json_['instanceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        manualBatchTuningParameters:
            json_.containsKey('manualBatchTuningParameters')
                ? GoogleCloudAiplatformV1beta1ManualBatchTuningParameters.fromJson(
                  json_['manualBatchTuningParameters']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        model: json_['model'] as core.String?,
        modelMonitoringConfig:
            json_.containsKey('modelMonitoringConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringConfig.fromJson(
                  json_['modelMonitoringConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelMonitoringStatsAnomalies:
            (json_['modelMonitoringStatsAnomalies'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomalies.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        modelMonitoringStatus:
            json_.containsKey('modelMonitoringStatus')
                ? GoogleRpcStatus.fromJson(
                  json_['modelMonitoringStatus']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelParameters: json_['modelParameters'],
        modelVersionId: json_['modelVersionId'] as core.String?,
        name: json_['name'] as core.String?,
        outputConfig:
            json_.containsKey('outputConfig')
                ? GoogleCloudAiplatformV1beta1BatchPredictionJobOutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        outputInfo:
            json_.containsKey('outputInfo')
                ? GoogleCloudAiplatformV1beta1BatchPredictionJobOutputInfo.fromJson(
                  json_['outputInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        partialFailures:
            (json_['partialFailures'] as core.List?)
                ?.map(
                  (value) => GoogleRpcStatus.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        resourcesConsumed:
            json_.containsKey('resourcesConsumed')
                ? GoogleCloudAiplatformV1beta1ResourcesConsumed.fromJson(
                  json_['resourcesConsumed']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        unmanagedContainerModel:
            json_.containsKey('unmanagedContainerModel')
                ? GoogleCloudAiplatformV1beta1UnmanagedContainerModel.fromJson(
                  json_['unmanagedContainerModel']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completionStats != null) 'completionStats': completionStats!,
    if (createTime != null) 'createTime': createTime!,
    if (dedicatedResources != null) 'dedicatedResources': dedicatedResources!,
    if (disableContainerLogging != null)
      'disableContainerLogging': disableContainerLogging!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (explanationSpec != null) 'explanationSpec': explanationSpec!,
    if (generateExplanation != null)
      'generateExplanation': generateExplanation!,
    if (inputConfig != null) 'inputConfig': inputConfig!,
    if (instanceConfig != null) 'instanceConfig': instanceConfig!,
    if (labels != null) 'labels': labels!,
    if (manualBatchTuningParameters != null)
      'manualBatchTuningParameters': manualBatchTuningParameters!,
    if (model != null) 'model': model!,
    if (modelMonitoringConfig != null)
      'modelMonitoringConfig': modelMonitoringConfig!,
    if (modelMonitoringStatsAnomalies != null)
      'modelMonitoringStatsAnomalies': modelMonitoringStatsAnomalies!,
    if (modelMonitoringStatus != null)
      'modelMonitoringStatus': modelMonitoringStatus!,
    if (modelParameters != null) 'modelParameters': modelParameters!,
    if (modelVersionId != null) 'modelVersionId': modelVersionId!,
    if (name != null) 'name': name!,
    if (outputConfig != null) 'outputConfig': outputConfig!,
    if (outputInfo != null) 'outputInfo': outputInfo!,
    if (partialFailures != null) 'partialFailures': partialFailures!,
    if (resourcesConsumed != null) 'resourcesConsumed': resourcesConsumed!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (unmanagedContainerModel != null)
      'unmanagedContainerModel': unmanagedContainerModel!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Configures the input to BatchPredictionJob.
///
/// See Model.supported_input_storage_formats for Model's supported input
/// formats, and how instances should be expressed via any of them.
class GoogleCloudAiplatformV1beta1BatchPredictionJobInputConfig {
  /// The BigQuery location of the input table.
  ///
  /// The schema of the table should be in the format described by the given
  /// context OpenAPI Schema, if one is provided. The table may contain
  /// additional columns that are not described by the schema, and they will be
  /// ignored.
  GoogleCloudAiplatformV1beta1BigQuerySource? bigquerySource;

  /// The Cloud Storage location for the input instances.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  /// The format in which instances are given, must be one of the Model's
  /// supported_input_storage_formats.
  ///
  /// Required.
  core.String? instancesFormat;

  GoogleCloudAiplatformV1beta1BatchPredictionJobInputConfig({
    this.bigquerySource,
    this.gcsSource,
    this.instancesFormat,
  });

  GoogleCloudAiplatformV1beta1BatchPredictionJobInputConfig.fromJson(
    core.Map json_,
  ) : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudAiplatformV1beta1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        instancesFormat: json_['instancesFormat'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (instancesFormat != null) 'instancesFormat': instancesFormat!,
  };
}

/// Configuration defining how to transform batch prediction input instances to
/// the instances that the Model accepts.
typedef GoogleCloudAiplatformV1beta1BatchPredictionJobInstanceConfig =
    $BatchPredictionJobInstanceConfig;

/// Configures the output of BatchPredictionJob.
///
/// See Model.supported_output_storage_formats for supported output formats, and
/// how predictions are expressed via any of them.
class GoogleCloudAiplatformV1beta1BatchPredictionJobOutputConfig {
  /// The BigQuery project or dataset location where the output is to be written
  /// to.
  ///
  /// If project is provided, a new dataset is created with name `prediction__`
  /// where is made BigQuery-dataset-name compatible (for example, most special
  /// characters become underscores), and timestamp is in
  /// YYYY_MM_DDThh_mm_ss_sssZ "based on ISO-8601" format. In the dataset two
  /// tables will be created, `predictions`, and `errors`. If the Model has both
  /// instance and prediction schemata defined then the tables have columns as
  /// follows: The `predictions` table contains instances for which the
  /// prediction succeeded, it has columns as per a concatenation of the Model's
  /// instance and prediction schemata. The `errors` table contains rows for
  /// which the prediction has failed, it has instance columns, as per the
  /// instance schema, followed by a single "errors" column, which as values has
  /// google.rpc.Status represented as a STRUCT, and containing only `code` and
  /// `message`.
  GoogleCloudAiplatformV1beta1BigQueryDestination? bigqueryDestination;

  /// The Cloud Storage location of the directory where the output is to be
  /// written to.
  ///
  /// In the given directory a new directory is created. Its name is
  /// `prediction--`, where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601
  /// format. Inside of it files `predictions_0001.`, `predictions_0002.`, ...,
  /// `predictions_N.` are created where `` depends on chosen
  /// predictions_format, and N may equal 0001 and depends on the total number
  /// of successfully predicted instances. If the Model has both instance and
  /// prediction schemata defined then each such file contains predictions as
  /// per the predictions_format. If prediction for any instance failed
  /// (partially or completely), then an additional `errors_0001.`,
  /// `errors_0002.`,..., `errors_N.` files are created (N depends on total
  /// number of failed predictions). These files contain the failed instances,
  /// as per their schema, followed by an additional `error` field which as
  /// value has google.rpc.Status containing only `code` and `message` fields.
  GoogleCloudAiplatformV1beta1GcsDestination? gcsDestination;

  /// The format in which Vertex AI gives the predictions, must be one of the
  /// Model's supported_output_storage_formats.
  ///
  /// Required.
  core.String? predictionsFormat;

  GoogleCloudAiplatformV1beta1BatchPredictionJobOutputConfig({
    this.bigqueryDestination,
    this.gcsDestination,
    this.predictionsFormat,
  });

  GoogleCloudAiplatformV1beta1BatchPredictionJobOutputConfig.fromJson(
    core.Map json_,
  ) : this(
        bigqueryDestination:
            json_.containsKey('bigqueryDestination')
                ? GoogleCloudAiplatformV1beta1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsDestination:
            json_.containsKey('gcsDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        predictionsFormat: json_['predictionsFormat'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!,
    if (gcsDestination != null) 'gcsDestination': gcsDestination!,
    if (predictionsFormat != null) 'predictionsFormat': predictionsFormat!,
  };
}

/// Further describes this job's output.
///
/// Supplements output_config.
typedef GoogleCloudAiplatformV1beta1BatchPredictionJobOutputInfo =
    $BatchPredictionJobOutputInfo;

/// Request message for FeaturestoreService.BatchReadFeatureValues.
class GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequest {
  /// Similar to csv_read_instances, but from BigQuery source.
  GoogleCloudAiplatformV1beta1BigQuerySource? bigqueryReadInstances;

  /// Each read instance consists of exactly one read timestamp and one or more
  /// entity IDs identifying entities of the corresponding EntityTypes whose
  /// Features are requested.
  ///
  /// Each output instance contains Feature values of requested entities
  /// concatenated together as of the read time. An example read instance may be
  /// `foo_entity_id, bar_entity_id, 2020-01-01T10:00:00.123Z`. An example
  /// output instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
  /// bar_entity_feature2_value`. Timestamp in each read instance must be
  /// millisecond-aligned. `csv_read_instances` are read instances stored in a
  /// plain-text CSV file. The header should be: \[ENTITY_TYPE_ID1\],
  /// \[ENTITY_TYPE_ID2\], ..., timestamp The columns can be in any order.
  /// Values in the timestamp column must use the RFC 3339 format, e.g.
  /// `2012-07-30T10:43:17.123Z`.
  GoogleCloudAiplatformV1beta1CsvSource? csvReadInstances;

  /// Specifies output location and format.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureValueDestination? destination;

  /// Specifies EntityType grouping Features to read values of and settings.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestEntityTypeSpec
  >?
  entityTypeSpecs;

  /// When not empty, the specified fields in the *_read_instances source will
  /// be joined as-is in the output, in addition to those fields from the
  /// Featurestore Entity.
  ///
  /// For BigQuery source, the type of the pass-through values will be
  /// automatically inferred. For CSV source, the pass-through values will be
  /// passed as opaque bytes.
  core.List<
    GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestPassThroughField
  >?
  passThroughFields;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  ///
  /// Optional.
  core.String? startTime;

  GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequest({
    this.bigqueryReadInstances,
    this.csvReadInstances,
    this.destination,
    this.entityTypeSpecs,
    this.passThroughFields,
    this.startTime,
  });

  GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequest.fromJson(
    core.Map json_,
  ) : this(
        bigqueryReadInstances:
            json_.containsKey('bigqueryReadInstances')
                ? GoogleCloudAiplatformV1beta1BigQuerySource.fromJson(
                  json_['bigqueryReadInstances']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        csvReadInstances:
            json_.containsKey('csvReadInstances')
                ? GoogleCloudAiplatformV1beta1CsvSource.fromJson(
                  json_['csvReadInstances']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        destination:
            json_.containsKey('destination')
                ? GoogleCloudAiplatformV1beta1FeatureValueDestination.fromJson(
                  json_['destination'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        entityTypeSpecs:
            (json_['entityTypeSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestEntityTypeSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        passThroughFields:
            (json_['passThroughFields'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestPassThroughField.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigqueryReadInstances != null)
      'bigqueryReadInstances': bigqueryReadInstances!,
    if (csvReadInstances != null) 'csvReadInstances': csvReadInstances!,
    if (destination != null) 'destination': destination!,
    if (entityTypeSpecs != null) 'entityTypeSpecs': entityTypeSpecs!,
    if (passThroughFields != null) 'passThroughFields': passThroughFields!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Selects Features of an EntityType to read values of and specifies read
/// settings.
class GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestEntityTypeSpec {
  /// ID of the EntityType to select Features.
  ///
  /// The EntityType id is the entity_type_id specified during EntityType
  /// creation.
  ///
  /// Required.
  core.String? entityTypeId;

  /// Selectors choosing which Feature values to read from the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureSelector? featureSelector;

  /// Per-Feature settings for the batch read.
  core.List<GoogleCloudAiplatformV1beta1DestinationFeatureSetting>? settings;

  GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestEntityTypeSpec({
    this.entityTypeId,
    this.featureSelector,
    this.settings,
  });

  GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestEntityTypeSpec.fromJson(
    core.Map json_,
  ) : this(
        entityTypeId: json_['entityTypeId'] as core.String?,
        featureSelector:
            json_.containsKey('featureSelector')
                ? GoogleCloudAiplatformV1beta1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        settings:
            (json_['settings'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DestinationFeatureSetting.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityTypeId != null) 'entityTypeId': entityTypeId!,
    if (featureSelector != null) 'featureSelector': featureSelector!,
    if (settings != null) 'settings': settings!,
  };
}

/// Describe pass-through fields in read_instance source.
typedef GoogleCloudAiplatformV1beta1BatchReadFeatureValuesRequestPassThroughField =
    $BatchReadFeatureValuesRequestPassThroughField;

/// Response message for TensorboardService.BatchReadTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1beta1BatchReadTensorboardTimeSeriesDataResponse {
  /// The returned time series data.
  core.List<GoogleCloudAiplatformV1beta1TimeSeriesData>? timeSeriesData;

  GoogleCloudAiplatformV1beta1BatchReadTensorboardTimeSeriesDataResponse({
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1beta1BatchReadTensorboardTimeSeriesDataResponse.fromJson(
    core.Map json_,
  ) : this(
        timeSeriesData:
            (json_['timeSeriesData'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TimeSeriesData.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
  };
}

/// The BigQuery location for the output content.
typedef GoogleCloudAiplatformV1beta1BigQueryDestination =
    $BigQueryDestination00;

/// The BigQuery location for the input content.
typedef GoogleCloudAiplatformV1beta1BigQuerySource = $BigQuerySource;

/// Input for bleu metric.
class GoogleCloudAiplatformV1beta1BleuInput {
  /// Repeated bleu instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1BleuInstance>? instances;

  /// Spec for bleu score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1BleuSpec? metricSpec;

  GoogleCloudAiplatformV1beta1BleuInput({this.instances, this.metricSpec});

  GoogleCloudAiplatformV1beta1BleuInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1BleuInstance.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1BleuSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for bleu instance.
typedef GoogleCloudAiplatformV1beta1BleuInstance = $Instance00;

/// Bleu metric value for an instance.
typedef GoogleCloudAiplatformV1beta1BleuMetricValue = $BleuMetricValue;

/// Results for bleu metric.
class GoogleCloudAiplatformV1beta1BleuResults {
  /// Bleu metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1BleuMetricValue>? bleuMetricValues;

  GoogleCloudAiplatformV1beta1BleuResults({this.bleuMetricValues});

  GoogleCloudAiplatformV1beta1BleuResults.fromJson(core.Map json_)
    : this(
        bleuMetricValues:
            (json_['bleuMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1BleuMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bleuMetricValues != null) 'bleuMetricValues': bleuMetricValues!,
  };
}

/// Spec for bleu score metric - calculates the precision of n-grams in the
/// prediction as compared to reference - returns a score ranging between 0 to
/// 1.
typedef GoogleCloudAiplatformV1beta1BleuSpec = $BleuSpec;

/// Content blob.
typedef GoogleCloudAiplatformV1beta1Blob = $Blob;

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// https://arxiv.org/abs/2004.03383
typedef GoogleCloudAiplatformV1beta1BlurBaselineConfig = $BlurBaselineConfig;

/// A list of boolean values.
typedef GoogleCloudAiplatformV1beta1BoolArray = $BoolArray;

/// Config of GenAI caching features.
///
/// This is a singleton resource.
typedef GoogleCloudAiplatformV1beta1CacheConfig = $CacheConfig;

/// A resource used in LLM queries for users to explicitly specify what to cache
/// and how to cache.
class GoogleCloudAiplatformV1beta1CachedContent {
  /// Input only.
  ///
  /// Immutable. The content to cache
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// Creation time of the cache entry.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-generated meaningful display name of the cached content.
  ///
  /// Optional. Immutable.
  core.String? displayName;

  /// Input only.
  ///
  /// Immutable. Customer-managed encryption key spec for a `CachedContent`. If
  /// set, this `CachedContent` and all its sub-resources will be secured by
  /// this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Timestamp of when this resource is considered expired.
  ///
  /// This is *always* provided on output, regardless of what was sent on input.
  core.String? expireTime;

  /// The name of the `Model` to use for cached content.
  ///
  /// Currently, only the published Gemini base models are supported, in form of
  /// projects/{PROJECT}/locations/{LOCATION}/publishers/google/models/{MODEL}
  ///
  /// Immutable.
  core.String? model;

  /// Identifier.
  ///
  /// The server-generated resource name of the cached content Format:
  /// projects/{project}/locations/{location}/cachedContents/{cached_content}
  ///
  /// Immutable.
  core.String? name;

  /// Input only.
  ///
  /// Immutable. Developer set system instruction. Currently, text only
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Content? systemInstruction;

  /// Input only.
  ///
  /// Immutable. Tool config. This config is shared for all tools
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ToolConfig? toolConfig;

  /// Input only.
  ///
  /// Immutable. A list of `Tools` the model may use to generate the next
  /// response
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Tool>? tools;

  /// Input only.
  ///
  /// The TTL for this resource. The expiration time is computed: now + TTL.
  core.String? ttl;

  /// When the cache entry was last updated in UTC time.
  ///
  /// Output only.
  core.String? updateTime;

  /// Metadata on the usage of the cached content.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1CachedContentUsageMetadata? usageMetadata;

  GoogleCloudAiplatformV1beta1CachedContent({
    this.contents,
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.expireTime,
    this.model,
    this.name,
    this.systemInstruction,
    this.toolConfig,
    this.tools,
    this.ttl,
    this.updateTime,
    this.usageMetadata,
  });

  GoogleCloudAiplatformV1beta1CachedContent.fromJson(core.Map json_)
    : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        expireTime: json_['expireTime'] as core.String?,
        model: json_['model'] as core.String?,
        name: json_['name'] as core.String?,
        systemInstruction:
            json_.containsKey('systemInstruction')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['systemInstruction']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolConfig:
            json_.containsKey('toolConfig')
                ? GoogleCloudAiplatformV1beta1ToolConfig.fromJson(
                  json_['toolConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        tools:
            (json_['tools'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tool.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        ttl: json_['ttl'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        usageMetadata:
            json_.containsKey('usageMetadata')
                ? GoogleCloudAiplatformV1beta1CachedContentUsageMetadata.fromJson(
                  json_['usageMetadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (expireTime != null) 'expireTime': expireTime!,
    if (model != null) 'model': model!,
    if (name != null) 'name': name!,
    if (systemInstruction != null) 'systemInstruction': systemInstruction!,
    if (toolConfig != null) 'toolConfig': toolConfig!,
    if (tools != null) 'tools': tools!,
    if (ttl != null) 'ttl': ttl!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (usageMetadata != null) 'usageMetadata': usageMetadata!,
  };
}

/// Metadata on the usage of the cached content.
typedef GoogleCloudAiplatformV1beta1CachedContentUsageMetadata =
    $CachedContentUsageMetadata;

/// Request message for JobService.CancelBatchPredictionJob.
typedef GoogleCloudAiplatformV1beta1CancelBatchPredictionJobRequest = $Empty;

/// Request message for JobService.CancelCustomJob.
typedef GoogleCloudAiplatformV1beta1CancelCustomJobRequest = $Empty;

/// Request message for JobService.CancelDataLabelingJob.
typedef GoogleCloudAiplatformV1beta1CancelDataLabelingJobRequest = $Empty;

/// Request message for JobService.CancelHyperparameterTuningJob.
typedef GoogleCloudAiplatformV1beta1CancelHyperparameterTuningJobRequest =
    $Empty;

/// Request message for JobService.CancelNasJob.
typedef GoogleCloudAiplatformV1beta1CancelNasJobRequest = $Empty;

/// Request message for PipelineService.CancelPipelineJob.
typedef GoogleCloudAiplatformV1beta1CancelPipelineJobRequest = $Empty;

/// Request message for PipelineService.CancelTrainingPipeline.
typedef GoogleCloudAiplatformV1beta1CancelTrainingPipelineRequest = $Empty;

/// Request message for GenAiTuningService.CancelTuningJob.
typedef GoogleCloudAiplatformV1beta1CancelTuningJobRequest = $Empty;

/// A response candidate generated from the model.
class GoogleCloudAiplatformV1beta1Candidate {
  /// Average log probability score of the candidate.
  ///
  /// Output only.
  core.double? avgLogprobs;

  /// Source attribution of the generated content.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1CitationMetadata? citationMetadata;

  /// Content parts of the candidate.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1Content? content;

  /// Describes the reason the mode stopped generating tokens in more detail.
  ///
  /// This is only filled when `finish_reason` is set.
  ///
  /// Output only.
  core.String? finishMessage;

  /// The reason why the model stopped generating tokens.
  ///
  /// If empty, the model has not stopped generating the tokens.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "FINISH_REASON_UNSPECIFIED" : The finish reason is unspecified.
  /// - "STOP" : Token generation reached a natural stopping point or a
  /// configured stop sequence.
  /// - "MAX_TOKENS" : Token generation reached the configured maximum output
  /// tokens.
  /// - "SAFETY" : Token generation stopped because the content potentially
  /// contains safety violations. NOTE: When streaming, content is empty if
  /// content filters blocks the output.
  /// - "RECITATION" : The token generation stopped because of potential
  /// recitation.
  /// - "OTHER" : All other reasons that stopped the token generation.
  /// - "BLOCKLIST" : Token generation stopped because the content contains
  /// forbidden terms.
  /// - "PROHIBITED_CONTENT" : Token generation stopped for potentially
  /// containing prohibited content.
  /// - "SPII" : Token generation stopped because the content potentially
  /// contains Sensitive Personally Identifiable Information (SPII).
  /// - "MALFORMED_FUNCTION_CALL" : The function call generated by the model is
  /// invalid.
  /// - "IMAGE_SAFETY" : Token generation stopped because generated images has
  /// safety violations.
  /// - "IMAGE_PROHIBITED_CONTENT" : Image generation stopped because generated
  /// images has other prohibited content.
  /// - "IMAGE_RECITATION" : Image generation stopped due to recitation.
  /// - "IMAGE_OTHER" : Image generation stopped because of other miscellaneous
  /// issue.
  /// - "UNEXPECTED_TOOL_CALL" : The tool call generated by the model is
  /// invalid.
  core.String? finishReason;

  /// Metadata specifies sources used to ground generated content.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1GroundingMetadata? groundingMetadata;

  /// Index of the candidate.
  ///
  /// Output only.
  core.int? index;

  /// Log-likelihood scores for the response tokens and top tokens
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1LogprobsResult? logprobsResult;

  /// List of ratings for the safety of a response candidate.
  ///
  /// There is at most one rating per category.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1SafetyRating>? safetyRatings;

  /// Metadata related to url context retrieval tool.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1UrlContextMetadata? urlContextMetadata;

  GoogleCloudAiplatformV1beta1Candidate({
    this.avgLogprobs,
    this.citationMetadata,
    this.content,
    this.finishMessage,
    this.finishReason,
    this.groundingMetadata,
    this.index,
    this.logprobsResult,
    this.safetyRatings,
    this.urlContextMetadata,
  });

  GoogleCloudAiplatformV1beta1Candidate.fromJson(core.Map json_)
    : this(
        avgLogprobs: (json_['avgLogprobs'] as core.num?)?.toDouble(),
        citationMetadata:
            json_.containsKey('citationMetadata')
                ? GoogleCloudAiplatformV1beta1CitationMetadata.fromJson(
                  json_['citationMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        content:
            json_.containsKey('content')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        finishMessage: json_['finishMessage'] as core.String?,
        finishReason: json_['finishReason'] as core.String?,
        groundingMetadata:
            json_.containsKey('groundingMetadata')
                ? GoogleCloudAiplatformV1beta1GroundingMetadata.fromJson(
                  json_['groundingMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        index: json_['index'] as core.int?,
        logprobsResult:
            json_.containsKey('logprobsResult')
                ? GoogleCloudAiplatformV1beta1LogprobsResult.fromJson(
                  json_['logprobsResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        safetyRatings:
            (json_['safetyRatings'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SafetyRating.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        urlContextMetadata:
            json_.containsKey('urlContextMetadata')
                ? GoogleCloudAiplatformV1beta1UrlContextMetadata.fromJson(
                  json_['urlContextMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (avgLogprobs != null) 'avgLogprobs': avgLogprobs!,
    if (citationMetadata != null) 'citationMetadata': citationMetadata!,
    if (content != null) 'content': content!,
    if (finishMessage != null) 'finishMessage': finishMessage!,
    if (finishReason != null) 'finishReason': finishReason!,
    if (groundingMetadata != null) 'groundingMetadata': groundingMetadata!,
    if (index != null) 'index': index!,
    if (logprobsResult != null) 'logprobsResult': logprobsResult!,
    if (safetyRatings != null) 'safetyRatings': safetyRatings!,
    if (urlContextMetadata != null) 'urlContextMetadata': urlContextMetadata!,
  };
}

/// Request message for ModelGardenService.CheckPublisherModelEula.
typedef GoogleCloudAiplatformV1beta1CheckPublisherModelEulaAcceptanceRequest =
    $Request10;

/// Request message for VizierService.CheckTrialEarlyStoppingState.
typedef GoogleCloudAiplatformV1beta1CheckTrialEarlyStoppingStateRequest =
    $Empty;

/// Describes the machine learning model version checkpoint.
typedef GoogleCloudAiplatformV1beta1Checkpoint = $Checkpoint;

/// Source attributions for content.
class GoogleCloudAiplatformV1beta1Citation {
  /// End index into the content.
  ///
  /// Output only.
  core.int? endIndex;

  /// License of the attribution.
  ///
  /// Output only.
  core.String? license;

  /// Publication date of the attribution.
  ///
  /// Output only.
  GoogleTypeDate? publicationDate;

  /// Start index into the content.
  ///
  /// Output only.
  core.int? startIndex;

  /// Title of the attribution.
  ///
  /// Output only.
  core.String? title;

  /// Url reference of the attribution.
  ///
  /// Output only.
  core.String? uri;

  GoogleCloudAiplatformV1beta1Citation({
    this.endIndex,
    this.license,
    this.publicationDate,
    this.startIndex,
    this.title,
    this.uri,
  });

  GoogleCloudAiplatformV1beta1Citation.fromJson(core.Map json_)
    : this(
        endIndex: json_['endIndex'] as core.int?,
        license: json_['license'] as core.String?,
        publicationDate:
            json_.containsKey('publicationDate')
                ? GoogleTypeDate.fromJson(
                  json_['publicationDate']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        startIndex: json_['startIndex'] as core.int?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (license != null) 'license': license!,
    if (publicationDate != null) 'publicationDate': publicationDate!,
    if (startIndex != null) 'startIndex': startIndex!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// A collection of source attributions for a piece of content.
class GoogleCloudAiplatformV1beta1CitationMetadata {
  /// List of citations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Citation>? citations;

  GoogleCloudAiplatformV1beta1CitationMetadata({this.citations});

  GoogleCloudAiplatformV1beta1CitationMetadata.fromJson(core.Map json_)
    : this(
        citations:
            (json_['citations'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Citation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (citations != null) 'citations': citations!,
  };
}

/// Claim that is extracted from the input text and facts that support it.
typedef GoogleCloudAiplatformV1beta1Claim = $Claim;

/// Configurations (e.g. inference timeout) that are applied on your endpoints.
typedef GoogleCloudAiplatformV1beta1ClientConnectionConfig =
    $ClientConnectionConfig;

/// Result of executing the \[ExecutableCode\].
///
/// Only generated when using the \[CodeExecution\] tool, and always follows a
/// `part` containing the \[ExecutableCode\].
typedef GoogleCloudAiplatformV1beta1CodeExecutionResult = $CodeExecutionResult;

/// Input for coherence metric.
class GoogleCloudAiplatformV1beta1CoherenceInput {
  /// Coherence instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CoherenceInstance? instance;

  /// Spec for coherence score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CoherenceSpec? metricSpec;

  GoogleCloudAiplatformV1beta1CoherenceInput({this.instance, this.metricSpec});

  GoogleCloudAiplatformV1beta1CoherenceInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1CoherenceInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1CoherenceSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for coherence instance.
typedef GoogleCloudAiplatformV1beta1CoherenceInstance = $Instance01;

/// Spec for coherence result.
typedef GoogleCloudAiplatformV1beta1CoherenceResult = $CoherenceResult;

/// Spec for coherence score metric.
typedef GoogleCloudAiplatformV1beta1CoherenceSpec = $Spec00;

/// Colab image of the runtime.
typedef GoogleCloudAiplatformV1beta1ColabImage = $ColabImage;

/// Input for Comet metric.
class GoogleCloudAiplatformV1beta1CometInput {
  /// Comet instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CometInstance? instance;

  /// Spec for comet metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CometSpec? metricSpec;

  GoogleCloudAiplatformV1beta1CometInput({this.instance, this.metricSpec});

  GoogleCloudAiplatformV1beta1CometInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1CometInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1CometSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for Comet instance - The fields used for evaluation are dependent on
/// the comet version.
typedef GoogleCloudAiplatformV1beta1CometInstance = $Instance03;

/// Spec for Comet result - calculates the comet score for the given instance
/// using the version specified in the spec.
typedef GoogleCloudAiplatformV1beta1CometResult = $CometResult;

/// Spec for Comet metric.
typedef GoogleCloudAiplatformV1beta1CometSpec = $CometSpec;

/// Request message for VizierService.CompleteTrial.
class GoogleCloudAiplatformV1beta1CompleteTrialRequest {
  /// If provided, it will be used as the completed Trial's final_measurement;
  /// Otherwise, the service will auto-select a previously reported measurement
  /// as the final-measurement
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Measurement? finalMeasurement;

  /// A human readable reason why the trial was infeasible.
  ///
  /// This should only be provided if `trial_infeasible` is true.
  ///
  /// Optional.
  core.String? infeasibleReason;

  /// True if the Trial cannot be run with the given Parameter, and
  /// final_measurement will be ignored.
  ///
  /// Optional.
  core.bool? trialInfeasible;

  GoogleCloudAiplatformV1beta1CompleteTrialRequest({
    this.finalMeasurement,
    this.infeasibleReason,
    this.trialInfeasible,
  });

  GoogleCloudAiplatformV1beta1CompleteTrialRequest.fromJson(core.Map json_)
    : this(
        finalMeasurement:
            json_.containsKey('finalMeasurement')
                ? GoogleCloudAiplatformV1beta1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        infeasibleReason: json_['infeasibleReason'] as core.String?,
        trialInfeasible: json_['trialInfeasible'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
    if (infeasibleReason != null) 'infeasibleReason': infeasibleReason!,
    if (trialInfeasible != null) 'trialInfeasible': trialInfeasible!,
  };
}

/// Success and error statistics of processing multiple entities (for example,
/// DataItems or structured data rows) in batch.
typedef GoogleCloudAiplatformV1beta1CompletionStats = $CompletionStats;

/// Request message for ComputeTokens RPC call.
class GoogleCloudAiplatformV1beta1ComputeTokensRequest {
  /// Input content.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// The instances that are the input to token computing API call.
  ///
  /// Schema is identical to the prediction schema of the text model, even for
  /// the non-text models, like chat models, or Codey models.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The name of the publisher model requested to serve the prediction.
  ///
  /// Format: projects/{project}/locations/{location}/publishers / * /models / *
  ///
  /// Optional.
  core.String? model;

  GoogleCloudAiplatformV1beta1ComputeTokensRequest({
    this.contents,
    this.instances,
    this.model,
  });

  GoogleCloudAiplatformV1beta1ComputeTokensRequest.fromJson(core.Map json_)
    : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        instances:
            json_.containsKey('instances')
                ? json_['instances'] as core.List
                : null,
        model: json_['model'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (instances != null) 'instances': instances!,
    if (model != null) 'model': model!,
  };
}

/// Response message for ComputeTokens RPC call.
class GoogleCloudAiplatformV1beta1ComputeTokensResponse {
  /// Lists of tokens info from the input.
  ///
  /// A ComputeTokensRequest could have multiple instances with a prompt in each
  /// instance. We also need to return lists of tokens info for the request with
  /// multiple instances.
  core.List<GoogleCloudAiplatformV1beta1TokensInfo>? tokensInfo;

  GoogleCloudAiplatformV1beta1ComputeTokensResponse({this.tokensInfo});

  GoogleCloudAiplatformV1beta1ComputeTokensResponse.fromJson(core.Map json_)
    : this(
        tokensInfo:
            (json_['tokensInfo'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1TokensInfo.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tokensInfo != null) 'tokensInfo': tokensInfo!,
  };
}

/// The Container Registry location for the container image.
typedef GoogleCloudAiplatformV1beta1ContainerRegistryDestination =
    $ContainerRegistryDestination;

/// The spec of a Container.
class GoogleCloudAiplatformV1beta1ContainerSpec {
  /// The arguments to be passed when starting the container.
  core.List<core.String>? args;

  /// The command to be invoked when the container is started.
  ///
  /// It overrides the entrypoint instruction in Dockerfile when provided.
  core.List<core.String>? command;

  /// Environment variables to be passed to the container.
  ///
  /// Maximum limit is 100.
  core.List<GoogleCloudAiplatformV1beta1EnvVar>? env;

  /// The URI of a container image in the Container Registry that is to be run
  /// on each worker replica.
  ///
  /// Required.
  core.String? imageUri;

  GoogleCloudAiplatformV1beta1ContainerSpec({
    this.args,
    this.command,
    this.env,
    this.imageUri,
  });

  GoogleCloudAiplatformV1beta1ContainerSpec.fromJson(core.Map json_)
    : this(
        args:
            (json_['args'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        command:
            (json_['command'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        env:
            (json_['env'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1EnvVar.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        imageUri: json_['imageUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (args != null) 'args': args!,
    if (command != null) 'command': command!,
    if (env != null) 'env': env!,
    if (imageUri != null) 'imageUri': imageUri!,
  };
}

/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the
/// `Content` and a `parts` field containing multi-part data that contains the
/// content of the message turn.
class GoogleCloudAiplatformV1beta1Content {
  /// Ordered `Parts` that constitute a single message.
  ///
  /// Parts may have different IANA MIME types.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Part>? parts;

  /// The producer of the content.
  ///
  /// Must be either 'user' or 'model'. Useful to set for multi-turn
  /// conversations, otherwise can be left blank or unset.
  ///
  /// Optional.
  core.String? role;

  GoogleCloudAiplatformV1beta1Content({this.parts, this.role});

  GoogleCloudAiplatformV1beta1Content.fromJson(core.Map json_)
    : this(
        parts:
            (json_['parts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Part.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        role: json_['role'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parts != null) 'parts': parts!,
    if (role != null) 'role': role!,
  };
}

/// Map of placeholder in metric prompt template to contents of model input.
class GoogleCloudAiplatformV1beta1ContentMap {
  /// Map of placeholder to contents.
  ///
  /// Optional.
  core.Map<core.String, GoogleCloudAiplatformV1beta1ContentMapContents>? values;

  GoogleCloudAiplatformV1beta1ContentMap({this.values});

  GoogleCloudAiplatformV1beta1ContentMap.fromJson(core.Map json_)
    : this(
        values: (json_['values'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1ContentMapContents.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Repeated Content type.
class GoogleCloudAiplatformV1beta1ContentMapContents {
  /// Repeated contents.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  GoogleCloudAiplatformV1beta1ContentMapContents({this.contents});

  GoogleCloudAiplatformV1beta1ContentMapContents.fromJson(core.Map json_)
    : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
  };
}

/// A single example of a conversation with the model.
class GoogleCloudAiplatformV1beta1ContentsExample {
  /// The content of the conversation with the model that resulted in the
  /// expected output.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// The expected output for the given `contents`.
  ///
  /// To represent multi-step reasoning, this is a repeated field that contains
  /// the iterative steps of the expected output.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ContentsExampleExpectedContent>?
  expectedContents;

  GoogleCloudAiplatformV1beta1ContentsExample({
    this.contents,
    this.expectedContents,
  });

  GoogleCloudAiplatformV1beta1ContentsExample.fromJson(core.Map json_)
    : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        expectedContents:
            (json_['expectedContents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ContentsExampleExpectedContent.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (expectedContents != null) 'expectedContents': expectedContents!,
  };
}

/// A single step of the expected output.
class GoogleCloudAiplatformV1beta1ContentsExampleExpectedContent {
  /// A single step's content.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Content? content;

  GoogleCloudAiplatformV1beta1ContentsExampleExpectedContent({this.content});

  GoogleCloudAiplatformV1beta1ContentsExampleExpectedContent.fromJson(
    core.Map json_,
  ) : this(
        content:
            json_.containsKey('content')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Instance of a general context.
typedef GoogleCloudAiplatformV1beta1Context = $Context;

/// Request message for ModelService.CopyModel.
class GoogleCloudAiplatformV1beta1CopyModelRequest {
  /// Customer-managed encryption key options.
  ///
  /// If this is set, then the Model copy will be encrypted with the provided
  /// encryption key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Copy source_model into a new Model with this ID.
  ///
  /// The ID will become the final component of the model resource name. This
  /// value may be up to 63 characters, and valid characters are `[a-z0-9_-]`.
  /// The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// Specify this field to copy source_model into this existing Model as a new
  /// version.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Optional.
  core.String? parentModel;

  /// The resource name of the Model to copy.
  ///
  /// That Model must be in the same Project. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Required.
  core.String? sourceModel;

  GoogleCloudAiplatformV1beta1CopyModelRequest({
    this.encryptionSpec,
    this.modelId,
    this.parentModel,
    this.sourceModel,
  });

  GoogleCloudAiplatformV1beta1CopyModelRequest.fromJson(core.Map json_)
    : this(
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelId: json_['modelId'] as core.String?,
        parentModel: json_['parentModel'] as core.String?,
        sourceModel: json_['sourceModel'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (modelId != null) 'modelId': modelId!,
    if (parentModel != null) 'parentModel': parentModel!,
    if (sourceModel != null) 'sourceModel': sourceModel!,
  };
}

/// RagCorpus status.
typedef GoogleCloudAiplatformV1beta1CorpusStatus = $CorpusStatus;

/// Request message for CorroborateContent.
class GoogleCloudAiplatformV1beta1CorroborateContentRequest {
  /// Input content to corroborate, only text format is supported for now.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Content? content;

  /// Facts used to generate the text can also be used to corroborate the text.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Fact>? facts;

  /// Parameters that can be set to override default settings per request.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1CorroborateContentRequestParameters? parameters;

  GoogleCloudAiplatformV1beta1CorroborateContentRequest({
    this.content,
    this.facts,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1CorroborateContentRequest.fromJson(core.Map json_)
    : this(
        content:
            json_.containsKey('content')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        facts:
            (json_['facts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Fact.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1CorroborateContentRequestParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (facts != null) 'facts': facts!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Parameters that can be overrided per request.
typedef GoogleCloudAiplatformV1beta1CorroborateContentRequestParameters =
    $CorroborateContentRequestParameters;

/// Response message for CorroborateContent.
class GoogleCloudAiplatformV1beta1CorroborateContentResponse {
  /// Claims that are extracted from the input content and facts that support
  /// the claims.
  core.List<GoogleCloudAiplatformV1beta1Claim>? claims;

  /// Confidence score of corroborating content.
  ///
  /// Value is \[0,1\] with 1 is the most confidence.
  core.double? corroborationScore;

  GoogleCloudAiplatformV1beta1CorroborateContentResponse({
    this.claims,
    this.corroborationScore,
  });

  GoogleCloudAiplatformV1beta1CorroborateContentResponse.fromJson(
    core.Map json_,
  ) : this(
        claims:
            (json_['claims'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Claim.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        corroborationScore:
            (json_['corroborationScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (claims != null) 'claims': claims!,
    if (corroborationScore != null) 'corroborationScore': corroborationScore!,
  };
}

/// Request message for PredictionService.CountTokens.
class GoogleCloudAiplatformV1beta1CountTokensRequest {
  /// Input content.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// Generation config that the model will use to generate the response.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GenerationConfig? generationConfig;

  /// The instances that are the input to token counting call.
  ///
  /// Schema is identical to the prediction schema of the underlying model.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The name of the publisher model requested to serve the prediction.
  ///
  /// Format: `projects/{project}/locations/{location}/publishers / * /models /
  /// * `
  ///
  /// Optional.
  core.String? model;

  /// The user provided system instructions for the model.
  ///
  /// Note: only text should be used in parts and content in each part will be
  /// in a separate paragraph.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Content? systemInstruction;

  /// A list of `Tools` the model may use to generate the next response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Tool>? tools;

  GoogleCloudAiplatformV1beta1CountTokensRequest({
    this.contents,
    this.generationConfig,
    this.instances,
    this.model,
    this.systemInstruction,
    this.tools,
  });

  GoogleCloudAiplatformV1beta1CountTokensRequest.fromJson(core.Map json_)
    : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        generationConfig:
            json_.containsKey('generationConfig')
                ? GoogleCloudAiplatformV1beta1GenerationConfig.fromJson(
                  json_['generationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        instances:
            json_.containsKey('instances')
                ? json_['instances'] as core.List
                : null,
        model: json_['model'] as core.String?,
        systemInstruction:
            json_.containsKey('systemInstruction')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['systemInstruction']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tools:
            (json_['tools'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tool.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (generationConfig != null) 'generationConfig': generationConfig!,
    if (instances != null) 'instances': instances!,
    if (model != null) 'model': model!,
    if (systemInstruction != null) 'systemInstruction': systemInstruction!,
    if (tools != null) 'tools': tools!,
  };
}

/// Response message for PredictionService.CountTokens.
class GoogleCloudAiplatformV1beta1CountTokensResponse {
  /// List of modalities that were processed in the request input.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ModalityTokenCount>?
  promptTokensDetails;

  /// The total number of billable characters counted across all instances from
  /// the request.
  core.int? totalBillableCharacters;

  /// The total number of tokens counted across all instances from the request.
  core.int? totalTokens;

  GoogleCloudAiplatformV1beta1CountTokensResponse({
    this.promptTokensDetails,
    this.totalBillableCharacters,
    this.totalTokens,
  });

  GoogleCloudAiplatformV1beta1CountTokensResponse.fromJson(core.Map json_)
    : this(
        promptTokensDetails:
            (json_['promptTokensDetails'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModalityTokenCount.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        totalBillableCharacters: json_['totalBillableCharacters'] as core.int?,
        totalTokens: json_['totalTokens'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (promptTokensDetails != null)
      'promptTokensDetails': promptTokensDetails!,
    if (totalBillableCharacters != null)
      'totalBillableCharacters': totalBillableCharacters!,
    if (totalTokens != null) 'totalTokens': totalTokens!,
  };
}

/// Request message for CreateDeploymentResourcePool method.
class GoogleCloudAiplatformV1beta1CreateDeploymentResourcePoolRequest {
  /// The DeploymentResourcePool to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1DeploymentResourcePool? deploymentResourcePool;

  /// The ID to use for the DeploymentResourcePool, which will become the final
  /// component of the DeploymentResourcePool's resource name.
  ///
  /// The maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  ///
  /// Required.
  core.String? deploymentResourcePoolId;

  GoogleCloudAiplatformV1beta1CreateDeploymentResourcePoolRequest({
    this.deploymentResourcePool,
    this.deploymentResourcePoolId,
  });

  GoogleCloudAiplatformV1beta1CreateDeploymentResourcePoolRequest.fromJson(
    core.Map json_,
  ) : this(
        deploymentResourcePool:
            json_.containsKey('deploymentResourcePool')
                ? GoogleCloudAiplatformV1beta1DeploymentResourcePool.fromJson(
                  json_['deploymentResourcePool']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        deploymentResourcePoolId:
            json_['deploymentResourcePoolId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deploymentResourcePool != null)
      'deploymentResourcePool': deploymentResourcePool!,
    if (deploymentResourcePoolId != null)
      'deploymentResourcePoolId': deploymentResourcePoolId!,
  };
}

/// Request message for FeaturestoreService.CreateFeature.
///
/// Request message for FeatureRegistryService.CreateFeature.
class GoogleCloudAiplatformV1beta1CreateFeatureRequest {
  /// The Feature to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Feature? feature;

  /// The ID to use for the Feature, which will become the final component of
  /// the Feature's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number. The value must be
  /// unique within an EntityType/FeatureGroup.
  ///
  /// Required.
  core.String? featureId;

  /// The resource name of the EntityType or FeatureGroup to create a Feature.
  ///
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  ///
  /// Required.
  core.String? parent;

  GoogleCloudAiplatformV1beta1CreateFeatureRequest({
    this.feature,
    this.featureId,
    this.parent,
  });

  GoogleCloudAiplatformV1beta1CreateFeatureRequest.fromJson(core.Map json_)
    : this(
        feature:
            json_.containsKey('feature')
                ? GoogleCloudAiplatformV1beta1Feature.fromJson(
                  json_['feature'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        featureId: json_['featureId'] as core.String?,
        parent: json_['parent'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (feature != null) 'feature': feature!,
    if (featureId != null) 'featureId': featureId!,
    if (parent != null) 'parent': parent!,
  };
}

/// Request message for ModelMonitoringService.CreateModelMonitoringJob.
class GoogleCloudAiplatformV1beta1CreateModelMonitoringJobRequest {
  /// The ModelMonitoringJob to create
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ModelMonitoringJob? modelMonitoringJob;

  /// The ID to use for the Model Monitoring Job, which will become the final
  /// component of the model monitoring job resource name.
  ///
  /// The maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  ///
  /// Optional.
  core.String? modelMonitoringJobId;

  /// The parent of the ModelMonitoringJob.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  ///
  /// Required.
  core.String? parent;

  GoogleCloudAiplatformV1beta1CreateModelMonitoringJobRequest({
    this.modelMonitoringJob,
    this.modelMonitoringJobId,
    this.parent,
  });

  GoogleCloudAiplatformV1beta1CreateModelMonitoringJobRequest.fromJson(
    core.Map json_,
  ) : this(
        modelMonitoringJob:
            json_.containsKey('modelMonitoringJob')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringJob.fromJson(
                  json_['modelMonitoringJob']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelMonitoringJobId: json_['modelMonitoringJobId'] as core.String?,
        parent: json_['parent'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob!,
    if (modelMonitoringJobId != null)
      'modelMonitoringJobId': modelMonitoringJobId!,
    if (parent != null) 'parent': parent!,
  };
}

/// Request message for \[NotebookService.CreateNotebookExecutionJob\]
class GoogleCloudAiplatformV1beta1CreateNotebookExecutionJobRequest {
  /// The NotebookExecutionJob to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1NotebookExecutionJob? notebookExecutionJob;

  /// User specified ID for the NotebookExecutionJob.
  ///
  /// Optional.
  core.String? notebookExecutionJobId;

  /// The resource name of the Location to create the NotebookExecutionJob.
  ///
  /// Format: `projects/{project}/locations/{location}`
  ///
  /// Required.
  core.String? parent;

  GoogleCloudAiplatformV1beta1CreateNotebookExecutionJobRequest({
    this.notebookExecutionJob,
    this.notebookExecutionJobId,
    this.parent,
  });

  GoogleCloudAiplatformV1beta1CreateNotebookExecutionJobRequest.fromJson(
    core.Map json_,
  ) : this(
        notebookExecutionJob:
            json_.containsKey('notebookExecutionJob')
                ? GoogleCloudAiplatformV1beta1NotebookExecutionJob.fromJson(
                  json_['notebookExecutionJob']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        notebookExecutionJobId: json_['notebookExecutionJobId'] as core.String?,
        parent: json_['parent'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (notebookExecutionJob != null)
      'notebookExecutionJob': notebookExecutionJob!,
    if (notebookExecutionJobId != null)
      'notebookExecutionJobId': notebookExecutionJobId!,
    if (parent != null) 'parent': parent!,
  };
}

/// Request message for PipelineService.CreatePipelineJob.
class GoogleCloudAiplatformV1beta1CreatePipelineJobRequest {
  /// The resource name of the Location to create the PipelineJob in.
  ///
  /// Format: `projects/{project}/locations/{location}`
  ///
  /// Required.
  core.String? parent;

  /// The PipelineJob to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PipelineJob? pipelineJob;

  /// The ID to use for the PipelineJob, which will become the final component
  /// of the PipelineJob name.
  ///
  /// If not provided, an ID will be automatically generated. This value should
  /// be less than 128 characters, and valid characters are `/a-z-/`.
  core.String? pipelineJobId;

  GoogleCloudAiplatformV1beta1CreatePipelineJobRequest({
    this.parent,
    this.pipelineJob,
    this.pipelineJobId,
  });

  GoogleCloudAiplatformV1beta1CreatePipelineJobRequest.fromJson(core.Map json_)
    : this(
        parent: json_['parent'] as core.String?,
        pipelineJob:
            json_.containsKey('pipelineJob')
                ? GoogleCloudAiplatformV1beta1PipelineJob.fromJson(
                  json_['pipelineJob'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        pipelineJobId: json_['pipelineJobId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parent != null) 'parent': parent!,
    if (pipelineJob != null) 'pipelineJob': pipelineJob!,
    if (pipelineJobId != null) 'pipelineJobId': pipelineJobId!,
  };
}

/// Request message for TensorboardService.CreateTensorboardRun.
class GoogleCloudAiplatformV1beta1CreateTensorboardRunRequest {
  /// The resource name of the TensorboardExperiment to create the
  /// TensorboardRun in.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  ///
  /// Required.
  core.String? parent;

  /// The TensorboardRun to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TensorboardRun? tensorboardRun;

  /// The ID to use for the Tensorboard run, which becomes the final component
  /// of the Tensorboard run's resource name.
  ///
  /// This value should be 1-128 characters, and valid characters are `/a-z-/`.
  ///
  /// Required.
  core.String? tensorboardRunId;

  GoogleCloudAiplatformV1beta1CreateTensorboardRunRequest({
    this.parent,
    this.tensorboardRun,
    this.tensorboardRunId,
  });

  GoogleCloudAiplatformV1beta1CreateTensorboardRunRequest.fromJson(
    core.Map json_,
  ) : this(
        parent: json_['parent'] as core.String?,
        tensorboardRun:
            json_.containsKey('tensorboardRun')
                ? GoogleCloudAiplatformV1beta1TensorboardRun.fromJson(
                  json_['tensorboardRun']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tensorboardRunId: json_['tensorboardRunId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parent != null) 'parent': parent!,
    if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!,
    if (tensorboardRunId != null) 'tensorboardRunId': tensorboardRunId!,
  };
}

/// Request message for TensorboardService.CreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1beta1CreateTensorboardTimeSeriesRequest {
  /// The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Required.
  core.String? parent;

  /// The TensorboardTimeSeries to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TensorboardTimeSeries? tensorboardTimeSeries;

  /// The user specified unique ID to use for the TensorboardTimeSeries, which
  /// becomes the final component of the TensorboardTimeSeries's resource name.
  ///
  /// This value should match "a-z0-9{0, 127}"
  ///
  /// Optional.
  core.String? tensorboardTimeSeriesId;

  GoogleCloudAiplatformV1beta1CreateTensorboardTimeSeriesRequest({
    this.parent,
    this.tensorboardTimeSeries,
    this.tensorboardTimeSeriesId,
  });

  GoogleCloudAiplatformV1beta1CreateTensorboardTimeSeriesRequest.fromJson(
    core.Map json_,
  ) : this(
        parent: json_['parent'] as core.String?,
        tensorboardTimeSeries:
            json_.containsKey('tensorboardTimeSeries')
                ? GoogleCloudAiplatformV1beta1TensorboardTimeSeries.fromJson(
                  json_['tensorboardTimeSeries']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tensorboardTimeSeriesId:
            json_['tensorboardTimeSeriesId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parent != null) 'parent': parent!,
    if (tensorboardTimeSeries != null)
      'tensorboardTimeSeries': tensorboardTimeSeries!,
    if (tensorboardTimeSeriesId != null)
      'tensorboardTimeSeriesId': tensorboardTimeSeriesId!,
  };
}

/// The storage details for CSV output content.
class GoogleCloudAiplatformV1beta1CsvDestination {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1beta1CsvDestination({this.gcsDestination});

  GoogleCloudAiplatformV1beta1CsvDestination.fromJson(core.Map json_)
    : this(
        gcsDestination:
            json_.containsKey('gcsDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!,
  };
}

/// The storage details for CSV input content.
class GoogleCloudAiplatformV1beta1CsvSource {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  GoogleCloudAiplatformV1beta1CsvSource({this.gcsSource});

  GoogleCloudAiplatformV1beta1CsvSource.fromJson(core.Map json_)
    : this(
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!,
  };
}

/// Represents a job that runs custom workloads such as a Docker container or a
/// Python package.
///
/// A CustomJob can have multiple worker pools and each worker pool can have its
/// own machine and input spec. A CustomJob will be cleaned up once the job
/// enters terminal state (failed or succeeded).
class GoogleCloudAiplatformV1beta1CustomJob {
  /// Time when the CustomJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the CustomJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a CustomJob.
  ///
  /// If this is set, then all resources created by the CustomJob will be
  /// encrypted with the provided encryption key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Time when the CustomJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Job spec.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CustomJobSpec? jobSpec;

  /// The labels with user-defined metadata to organize CustomJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of a CustomJob.
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the CustomJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Time when the CustomJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// URIs for accessing
  /// [interactive shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node).
  ///
  /// Only available if job_spec.enable_web_access is `true`. The keys are names
  /// of each node in the training job; for example, `workerpool0-0` for the
  /// primary node, `workerpool1-0` for the first node in the second worker
  /// pool, and `workerpool1-1` for the second node in the second worker pool.
  /// The values are the URIs for each node's interactive shell.
  ///
  /// Output only.
  core.Map<core.String, core.String>? webAccessUris;

  GoogleCloudAiplatformV1beta1CustomJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.jobSpec,
    this.labels,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.updateTime,
    this.webAccessUris,
  });

  GoogleCloudAiplatformV1beta1CustomJob.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        jobSpec:
            json_.containsKey('jobSpec')
                ? GoogleCloudAiplatformV1beta1CustomJobSpec.fromJson(
                  json_['jobSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        webAccessUris: (json_['webAccessUris']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (jobSpec != null) 'jobSpec': jobSpec!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (webAccessUris != null) 'webAccessUris': webAccessUris!,
  };
}

/// Represents the spec of a CustomJob.
class GoogleCloudAiplatformV1beta1CustomJobSpec {
  /// The Cloud Storage location to store the output of this CustomJob or
  /// HyperparameterTuningJob.
  ///
  /// For HyperparameterTuningJob, the baseOutputDirectory of each child
  /// CustomJob backing a Trial is set to a subdirectory of name id under its
  /// parent HyperparameterTuningJob's baseOutputDirectory. The following Vertex
  /// AI environment variables will be passed to containers or python modules
  /// when this field is set: For CustomJob: * AIP_MODEL_DIR = `/model/` *
  /// AIP_CHECKPOINT_DIR = `/checkpoints/` * AIP_TENSORBOARD_LOG_DIR = `/logs/`
  /// For CustomJob backing a Trial of HyperparameterTuningJob: * AIP_MODEL_DIR
  /// = `//model/` * AIP_CHECKPOINT_DIR = `//checkpoints/` *
  /// AIP_TENSORBOARD_LOG_DIR = `//logs/`
  GoogleCloudAiplatformV1beta1GcsDestination? baseOutputDirectory;

  /// Whether you want Vertex AI to enable access to the customized dashboard in
  /// training chief container.
  ///
  /// If set to `true`, you can access the dashboard at the URIs given by
  /// CustomJob.web_access_uris or Trial.web_access_uris (within
  /// HyperparameterTuningJob.trials).
  ///
  /// Optional.
  core.bool? enableDashboardAccess;

  /// Whether you want Vertex AI to enable
  /// [interactive shell access](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// to training containers.
  ///
  /// If set to `true`, you can access interactive shells at the URIs given by
  /// CustomJob.web_access_uris or Trial.web_access_uris (within
  /// HyperparameterTuningJob.trials).
  ///
  /// Optional.
  core.bool? enableWebAccess;

  /// The Experiment associated with this job.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}`
  ///
  /// Optional.
  core.String? experiment;

  /// The Experiment Run associated with this job.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}-{experiment-run-name}`
  ///
  /// Optional.
  core.String? experimentRun;

  /// The name of the Model resources for which to generate a mapping to
  /// artifact URIs.
  ///
  /// Applicable only to some of the Google-provided custom jobs. Format:
  /// `projects/{project}/locations/{location}/models/{model}` In order to
  /// retrieve a specific version of the model, also provide the version ID or
  /// version alias. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` If no
  /// version ID or alias is specified, the "default" version will be returned.
  /// The "default" version alias is created for the first version of the model,
  /// and can be moved to other versions later on. There will be exactly one
  /// default version.
  ///
  /// Optional.
  core.List<core.String>? models;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to which the
  /// Job should be peered.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. To specify
  /// this field, you must have already
  /// [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  /// If this field is left unspecified, the job is not peered with any network.
  ///
  /// Optional.
  core.String? network;

  /// The ID of the PersistentResource in the same Project and Location which to
  /// run If this is specified, the job will be run on existing machines held by
  /// the PersistentResource instead of on-demand short-live machines.
  ///
  /// The network and CMEK configs on the job should be consistent with those on
  /// the PersistentResource, otherwise, the job will be rejected.
  ///
  /// Optional.
  core.String? persistentResourceId;

  /// The ID of the location to store protected artifacts.
  ///
  /// e.g. us-central1. Populate only when the location is different than
  /// CustomJob location. List of supported locations:
  /// https://cloud.google.com/vertex-ai/docs/general/locations
  core.String? protectedArtifactLocationId;

  /// Configuration for PSC-I for CustomJob.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PscInterfaceConfig? pscInterfaceConfig;

  /// A list of names for the reserved ip ranges under the VPC network that can
  /// be used for this job.
  ///
  /// If set, we will deploy the job within the provided ip ranges. Otherwise,
  /// the job will be deployed to any ip ranges under the provided VPC network.
  /// Example: \['vertex-ai-ip-range'\].
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  /// Scheduling options for a CustomJob.
  GoogleCloudAiplatformV1beta1Scheduling? scheduling;

  /// Specifies the service account for workload run-as account.
  ///
  /// Users submitting jobs must have act-as permission on this run-as account.
  /// If unspecified, the
  /// [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// for the CustomJob's project is used.
  core.String? serviceAccount;

  /// The name of a Vertex AI Tensorboard resource to which this CustomJob will
  /// upload Tensorboard logs.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  ///
  /// Optional.
  core.String? tensorboard;

  /// The spec of the worker pools including machine type and Docker image.
  ///
  /// All worker pools except the first one are optional and can be skipped by
  /// providing an empty value.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1WorkerPoolSpec>? workerPoolSpecs;

  GoogleCloudAiplatformV1beta1CustomJobSpec({
    this.baseOutputDirectory,
    this.enableDashboardAccess,
    this.enableWebAccess,
    this.experiment,
    this.experimentRun,
    this.models,
    this.network,
    this.persistentResourceId,
    this.protectedArtifactLocationId,
    this.pscInterfaceConfig,
    this.reservedIpRanges,
    this.scheduling,
    this.serviceAccount,
    this.tensorboard,
    this.workerPoolSpecs,
  });

  GoogleCloudAiplatformV1beta1CustomJobSpec.fromJson(core.Map json_)
    : this(
        baseOutputDirectory:
            json_.containsKey('baseOutputDirectory')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['baseOutputDirectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        enableDashboardAccess: json_['enableDashboardAccess'] as core.bool?,
        enableWebAccess: json_['enableWebAccess'] as core.bool?,
        experiment: json_['experiment'] as core.String?,
        experimentRun: json_['experimentRun'] as core.String?,
        models:
            (json_['models'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        network: json_['network'] as core.String?,
        persistentResourceId: json_['persistentResourceId'] as core.String?,
        protectedArtifactLocationId:
            json_['protectedArtifactLocationId'] as core.String?,
        pscInterfaceConfig:
            json_.containsKey('pscInterfaceConfig')
                ? GoogleCloudAiplatformV1beta1PscInterfaceConfig.fromJson(
                  json_['pscInterfaceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        reservedIpRanges:
            (json_['reservedIpRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        scheduling:
            json_.containsKey('scheduling')
                ? GoogleCloudAiplatformV1beta1Scheduling.fromJson(
                  json_['scheduling'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        serviceAccount: json_['serviceAccount'] as core.String?,
        tensorboard: json_['tensorboard'] as core.String?,
        workerPoolSpecs:
            (json_['workerPoolSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1WorkerPoolSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseOutputDirectory != null)
      'baseOutputDirectory': baseOutputDirectory!,
    if (enableDashboardAccess != null)
      'enableDashboardAccess': enableDashboardAccess!,
    if (enableWebAccess != null) 'enableWebAccess': enableWebAccess!,
    if (experiment != null) 'experiment': experiment!,
    if (experimentRun != null) 'experimentRun': experimentRun!,
    if (models != null) 'models': models!,
    if (network != null) 'network': network!,
    if (persistentResourceId != null)
      'persistentResourceId': persistentResourceId!,
    if (protectedArtifactLocationId != null)
      'protectedArtifactLocationId': protectedArtifactLocationId!,
    if (pscInterfaceConfig != null) 'pscInterfaceConfig': pscInterfaceConfig!,
    if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
    if (scheduling != null) 'scheduling': scheduling!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (tensorboard != null) 'tensorboard': tensorboard!,
    if (workerPoolSpecs != null) 'workerPoolSpecs': workerPoolSpecs!,
  };
}

/// Spec for custom output.
class GoogleCloudAiplatformV1beta1CustomOutput {
  /// List of raw output strings.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1RawOutput? rawOutputs;

  GoogleCloudAiplatformV1beta1CustomOutput({this.rawOutputs});

  GoogleCloudAiplatformV1beta1CustomOutput.fromJson(core.Map json_)
    : this(
        rawOutputs:
            json_.containsKey('rawOutputs')
                ? GoogleCloudAiplatformV1beta1RawOutput.fromJson(
                  json_['rawOutputs'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rawOutputs != null) 'rawOutputs': rawOutputs!,
  };
}

/// Spec for custom output format configuration.
typedef GoogleCloudAiplatformV1beta1CustomOutputFormatConfig =
    $CustomOutputFormatConfig;

/// A piece of data in a Dataset.
///
/// Could be an image, a video, a document or plain text.
typedef GoogleCloudAiplatformV1beta1DataItem = $DataItem;

/// A container for a single DataItem and Annotations on it.
class GoogleCloudAiplatformV1beta1DataItemView {
  /// The Annotations on the DataItem.
  ///
  /// If too many Annotations should be returned for the DataItem, this field
  /// will be truncated per annotations_limit in request. If it was, then the
  /// has_truncated_annotations will be set to true.
  core.List<GoogleCloudAiplatformV1beta1Annotation>? annotations;

  /// The DataItem.
  GoogleCloudAiplatformV1beta1DataItem? dataItem;

  /// True if and only if the Annotations field has been truncated.
  ///
  /// It happens if more Annotations for this DataItem met the request's
  /// annotation_filter than are allowed to be returned by annotations_limit.
  /// Note that if Annotations field is not being returned due to field mask,
  /// then this field will not be set to true no matter how many Annotations are
  /// there.
  core.bool? hasTruncatedAnnotations;

  GoogleCloudAiplatformV1beta1DataItemView({
    this.annotations,
    this.dataItem,
    this.hasTruncatedAnnotations,
  });

  GoogleCloudAiplatformV1beta1DataItemView.fromJson(core.Map json_)
    : this(
        annotations:
            (json_['annotations'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Annotation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        dataItem:
            json_.containsKey('dataItem')
                ? GoogleCloudAiplatformV1beta1DataItem.fromJson(
                  json_['dataItem'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        hasTruncatedAnnotations: json_['hasTruncatedAnnotations'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotations != null) 'annotations': annotations!,
    if (dataItem != null) 'dataItem': dataItem!,
    if (hasTruncatedAnnotations != null)
      'hasTruncatedAnnotations': hasTruncatedAnnotations!,
  };
}

/// DataLabelingJob is used to trigger a human labeling job on unlabeled data
/// from the following Dataset:
class GoogleCloudAiplatformV1beta1DataLabelingJob {
  /// Parameters that configure the active learning pipeline.
  ///
  /// Active learning will label the data incrementally via several iterations.
  /// For every iteration, it will select a batch of data based on the sampling
  /// strategy.
  GoogleCloudAiplatformV1beta1ActiveLearningConfig? activeLearningConfig;

  /// Labels to assign to annotations generated by this DataLabelingJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? annotationLabels;

  /// Timestamp when this DataLabelingJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Estimated cost(in US dollars) that the DataLabelingJob has incurred to
  /// date.
  ///
  /// Output only.
  GoogleTypeMoney? currentSpend;

  /// Dataset resource names.
  ///
  /// Right now we only support labeling from a single Dataset. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  ///
  /// Required.
  core.List<core.String>? datasets;

  /// The user-defined name of the DataLabelingJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. Display name of a DataLabelingJob.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a DataLabelingJob.
  ///
  /// If set, this DataLabelingJob will be secured by this key. Note:
  /// Annotations created in the DataLabelingJob are associated with the
  /// EncryptionSpec of the Dataset they are exported to.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// DataLabelingJob errors.
  ///
  /// It is only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Input config parameters for the DataLabelingJob.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? inputs;

  /// Points to a YAML file stored on Google Cloud Storage describing the config
  /// for a specific type of DataLabelingJob.
  ///
  /// The schema files that can be used here are found in the
  /// https://storage.googleapis.com/google-cloud-aiplatform bucket in the
  /// /schema/datalabelingjob/inputs/ folder.
  ///
  /// Required.
  core.String? inputsSchemaUri;

  /// The Google Cloud Storage location of the instruction pdf.
  ///
  /// This pdf is shared with labelers, and provides detailed description on how
  /// to label DataItems in Datasets.
  ///
  /// Required.
  core.String? instructionUri;

  /// Number of labelers to work on each DataItem.
  ///
  /// Required.
  core.int? labelerCount;

  /// Current labeling job progress percentage scaled in interval \[0, 100\],
  /// indicating the percentage of DataItems that has been finished.
  ///
  /// Output only.
  core.int? labelingProgress;

  /// The labels with user-defined metadata to organize your DataLabelingJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable. Following system labels exist for each DataLabelingJob: *
  /// "aiplatform.googleapis.com/schema": output only, its value is the
  /// inputs_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the DataLabelingJob.
  ///
  /// Output only.
  core.String? name;

  /// The SpecialistPools' resource names associated with this job.
  core.List<core.String>? specialistPools;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Timestamp when this DataLabelingJob was updated most recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1DataLabelingJob({
    this.activeLearningConfig,
    this.annotationLabels,
    this.createTime,
    this.currentSpend,
    this.datasets,
    this.displayName,
    this.encryptionSpec,
    this.error,
    this.inputs,
    this.inputsSchemaUri,
    this.instructionUri,
    this.labelerCount,
    this.labelingProgress,
    this.labels,
    this.name,
    this.specialistPools,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1DataLabelingJob.fromJson(core.Map json_)
    : this(
        activeLearningConfig:
            json_.containsKey('activeLearningConfig')
                ? GoogleCloudAiplatformV1beta1ActiveLearningConfig.fromJson(
                  json_['activeLearningConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        annotationLabels: (json_['annotationLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        createTime: json_['createTime'] as core.String?,
        currentSpend:
            json_.containsKey('currentSpend')
                ? GoogleTypeMoney.fromJson(
                  json_['currentSpend'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        datasets:
            (json_['datasets'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inputs: json_['inputs'],
        inputsSchemaUri: json_['inputsSchemaUri'] as core.String?,
        instructionUri: json_['instructionUri'] as core.String?,
        labelerCount: json_['labelerCount'] as core.int?,
        labelingProgress: json_['labelingProgress'] as core.int?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        specialistPools:
            (json_['specialistPools'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (activeLearningConfig != null)
      'activeLearningConfig': activeLearningConfig!,
    if (annotationLabels != null) 'annotationLabels': annotationLabels!,
    if (createTime != null) 'createTime': createTime!,
    if (currentSpend != null) 'currentSpend': currentSpend!,
    if (datasets != null) 'datasets': datasets!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (error != null) 'error': error!,
    if (inputs != null) 'inputs': inputs!,
    if (inputsSchemaUri != null) 'inputsSchemaUri': inputsSchemaUri!,
    if (instructionUri != null) 'instructionUri': instructionUri!,
    if (labelerCount != null) 'labelerCount': labelerCount!,
    if (labelingProgress != null) 'labelingProgress': labelingProgress!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (specialistPools != null) 'specialistPools': specialistPools!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// A collection of DataItems and Annotations on them.
class GoogleCloudAiplatformV1beta1Dataset {
  /// Timestamp when this Dataset was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The number of DataItems in this Dataset.
  ///
  /// Only apply for non-structured Dataset.
  ///
  /// Output only.
  core.String? dataItemCount;

  /// The description of the Dataset.
  core.String? description;

  /// The user-defined name of the Dataset.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Dataset.
  ///
  /// If set, this Dataset and all sub-resources of this Dataset will be secured
  /// by this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Datasets.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Dataset (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for each Dataset: *
  /// "aiplatform.googleapis.com/dataset_metadata_schema": output only, its
  /// value is the metadata_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Additional information about the Dataset.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Artifact that was created in MetadataStore when
  /// creating the Dataset.
  ///
  /// The Artifact resource name pattern is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  ///
  /// Output only.
  core.String? metadataArtifact;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Dataset.
  ///
  /// The schema is defined as an OpenAPI 3.0.2 Schema Object. The schema files
  /// that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/metadata/.
  ///
  /// Required.
  core.String? metadataSchemaUri;

  /// Reference to the public base model last used by the dataset.
  ///
  /// Only set for prompt datasets.
  ///
  /// Optional.
  core.String? modelReference;

  /// Identifier.
  ///
  /// The resource name of the Dataset. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// All SavedQueries belong to the Dataset will be returned in List/Get
  /// Dataset response.
  ///
  /// The annotation_specs field will not be populated except for UI cases which
  /// will only use annotation_spec_count. In CreateDataset request, a
  /// SavedQuery is created together if this field is set, up to one SavedQuery
  /// can be set in CreateDatasetRequest. The SavedQuery should not contain any
  /// AnnotationSpec.
  core.List<GoogleCloudAiplatformV1beta1SavedQuery>? savedQueries;

  /// Timestamp when this Dataset was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Dataset({
    this.createTime,
    this.dataItemCount,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.metadata,
    this.metadataArtifact,
    this.metadataSchemaUri,
    this.modelReference,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.savedQueries,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Dataset.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        dataItemCount: json_['dataItemCount'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        metadata: json_['metadata'],
        metadataArtifact: json_['metadataArtifact'] as core.String?,
        metadataSchemaUri: json_['metadataSchemaUri'] as core.String?,
        modelReference: json_['modelReference'] as core.String?,
        name: json_['name'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        savedQueries:
            (json_['savedQueries'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SavedQuery.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (dataItemCount != null) 'dataItemCount': dataItemCount!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (metadata != null) 'metadata': metadata!,
    if (metadataArtifact != null) 'metadataArtifact': metadataArtifact!,
    if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
    if (modelReference != null) 'modelReference': modelReference!,
    if (name != null) 'name': name!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (savedQueries != null) 'savedQueries': savedQueries!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Distribution computed over a tuning dataset.
class GoogleCloudAiplatformV1beta1DatasetDistribution {
  /// Defines the histogram bucket.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1DatasetDistributionDistributionBucket>?
  buckets;

  /// The maximum of the population values.
  ///
  /// Output only.
  core.double? max;

  /// The arithmetic mean of the values in the population.
  ///
  /// Output only.
  core.double? mean;

  /// The median of the values in the population.
  ///
  /// Output only.
  core.double? median;

  /// The minimum of the population values.
  ///
  /// Output only.
  core.double? min;

  /// The 5th percentile of the values in the population.
  ///
  /// Output only.
  core.double? p5;

  /// The 95th percentile of the values in the population.
  ///
  /// Output only.
  core.double? p95;

  /// Sum of a given population of values.
  ///
  /// Output only.
  core.double? sum;

  GoogleCloudAiplatformV1beta1DatasetDistribution({
    this.buckets,
    this.max,
    this.mean,
    this.median,
    this.min,
    this.p5,
    this.p95,
    this.sum,
  });

  GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(core.Map json_)
    : this(
        buckets:
            (json_['buckets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DatasetDistributionDistributionBucket.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        max: (json_['max'] as core.num?)?.toDouble(),
        mean: (json_['mean'] as core.num?)?.toDouble(),
        median: (json_['median'] as core.num?)?.toDouble(),
        min: (json_['min'] as core.num?)?.toDouble(),
        p5: (json_['p5'] as core.num?)?.toDouble(),
        p95: (json_['p95'] as core.num?)?.toDouble(),
        sum: (json_['sum'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (buckets != null) 'buckets': buckets!,
    if (max != null) 'max': max!,
    if (mean != null) 'mean': mean!,
    if (median != null) 'median': median!,
    if (min != null) 'min': min!,
    if (p5 != null) 'p5': p5!,
    if (p95 != null) 'p95': p95!,
    if (sum != null) 'sum': sum!,
  };
}

/// Dataset bucket used to create a histogram for the distribution given a
/// population of values.
class GoogleCloudAiplatformV1beta1DatasetDistributionDistributionBucket {
  /// Number of values in the bucket.
  ///
  /// Output only.
  core.String? count;

  /// Left bound of the bucket.
  ///
  /// Output only.
  core.double? left;

  /// Right bound of the bucket.
  ///
  /// Output only.
  core.double? right;

  GoogleCloudAiplatformV1beta1DatasetDistributionDistributionBucket({
    this.count,
    this.left,
    this.right,
  });

  GoogleCloudAiplatformV1beta1DatasetDistributionDistributionBucket.fromJson(
    core.Map json_,
  ) : this(
        count: json_['count'] as core.String?,
        left: (json_['left'] as core.num?)?.toDouble(),
        right: (json_['right'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (left != null) 'left': left!,
    if (right != null) 'right': right!,
  };
}

/// Statistics computed over a tuning dataset.
class GoogleCloudAiplatformV1beta1DatasetStats {
  /// Number of billable characters in the tuning dataset.
  ///
  /// Output only.
  core.String? totalBillableCharacterCount;

  /// Number of tuning characters in the tuning dataset.
  ///
  /// Output only.
  core.String? totalTuningCharacterCount;

  /// Number of examples in the tuning dataset.
  ///
  /// Output only.
  core.String? tuningDatasetExampleCount;

  /// Number of tuning steps for this Tuning Job.
  ///
  /// Output only.
  core.String? tuningStepCount;

  /// Sample user messages in the training dataset uri.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Content>? userDatasetExamples;

  /// Dataset distributions for the user input tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetDistribution? userInputTokenDistribution;

  /// Dataset distributions for the messages per example.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetDistribution?
  userMessagePerExampleDistribution;

  /// Dataset distributions for the user output tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetDistribution? userOutputTokenDistribution;

  GoogleCloudAiplatformV1beta1DatasetStats({
    this.totalBillableCharacterCount,
    this.totalTuningCharacterCount,
    this.tuningDatasetExampleCount,
    this.tuningStepCount,
    this.userDatasetExamples,
    this.userInputTokenDistribution,
    this.userMessagePerExampleDistribution,
    this.userOutputTokenDistribution,
  });

  GoogleCloudAiplatformV1beta1DatasetStats.fromJson(core.Map json_)
    : this(
        totalBillableCharacterCount:
            json_['totalBillableCharacterCount'] as core.String?,
        totalTuningCharacterCount:
            json_['totalTuningCharacterCount'] as core.String?,
        tuningDatasetExampleCount:
            json_['tuningDatasetExampleCount'] as core.String?,
        tuningStepCount: json_['tuningStepCount'] as core.String?,
        userDatasetExamples:
            (json_['userDatasetExamples'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        userInputTokenDistribution:
            json_.containsKey('userInputTokenDistribution')
                ? GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(
                  json_['userInputTokenDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userMessagePerExampleDistribution:
            json_.containsKey('userMessagePerExampleDistribution')
                ? GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(
                  json_['userMessagePerExampleDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userOutputTokenDistribution:
            json_.containsKey('userOutputTokenDistribution')
                ? GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(
                  json_['userOutputTokenDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (totalBillableCharacterCount != null)
      'totalBillableCharacterCount': totalBillableCharacterCount!,
    if (totalTuningCharacterCount != null)
      'totalTuningCharacterCount': totalTuningCharacterCount!,
    if (tuningDatasetExampleCount != null)
      'tuningDatasetExampleCount': tuningDatasetExampleCount!,
    if (tuningStepCount != null) 'tuningStepCount': tuningStepCount!,
    if (userDatasetExamples != null)
      'userDatasetExamples': userDatasetExamples!,
    if (userInputTokenDistribution != null)
      'userInputTokenDistribution': userInputTokenDistribution!,
    if (userMessagePerExampleDistribution != null)
      'userMessagePerExampleDistribution': userMessagePerExampleDistribution!,
    if (userOutputTokenDistribution != null)
      'userOutputTokenDistribution': userOutputTokenDistribution!,
  };
}

/// Describes the dataset version.
typedef GoogleCloudAiplatformV1beta1DatasetVersion = $DatasetVersion;

/// A description of resources that are dedicated to a DeployedModel or
/// DeployedIndex, and that need a higher degree of manual configuration.
class GoogleCloudAiplatformV1beta1DedicatedResources {
  /// The metric specifications that overrides a resource utilization metric
  /// (CPU utilization, accelerator's duty cycle, and so on) target value
  /// (default to 60 if not set).
  ///
  /// At most one entry is allowed per metric. If machine_spec.accelerator_count
  /// is above 0, the autoscaling will be based on both CPU utilization and
  /// accelerator's duty cycle metrics and scale up when either metrics exceeds
  /// its target value while scale down if both metrics are under their target
  /// value. The default target value is 60 for both metrics. If
  /// machine_spec.accelerator_count is 0, the autoscaling will be based on CPU
  /// utilization metric only with default target value 60 if not explicitly
  /// set. For example, in the case of Online Prediction, if you want to
  /// override target CPU utilization to 80, you should set
  /// autoscaling_metric_specs.metric_name to
  /// `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
  /// autoscaling_metric_specs.target to `80`.
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1beta1AutoscalingMetricSpec>?
  autoscalingMetricSpecs;

  /// If set, use DWS resource to schedule the deployment workload.
  ///
  /// reference:
  /// (https://cloud.google.com/blog/products/compute/introducing-dynamic-workload-scheduler)
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1FlexStart? flexStart;

  /// The specification of a single machine being used.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1beta1MachineSpec? machineSpec;

  /// The maximum number of replicas that may be deployed on when the traffic
  /// against it increases.
  ///
  /// If the requested value is too large, the deployment will error, but if
  /// deployment succeeds then the ability to scale to that many replicas is
  /// guaranteed (barring service outages). If traffic increases beyond what its
  /// replicas at maximum may handle, a portion of the traffic will be dropped.
  /// If this value is not provided, will use min_replica_count as the default
  /// value. The value of this field impacts the charge against Vertex CPU and
  /// GPU quotas. Specifically, you will be charged for (max_replica_count *
  /// number of cores in the selected machine type) and (max_replica_count *
  /// number of GPUs per replica in the selected machine type).
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The minimum number of machine replicas that will be always deployed on.
  ///
  /// This value must be greater than or equal to 1. If traffic increases, it
  /// may dynamically be deployed onto more replicas, and as traffic decreases,
  /// some of these extra replicas may be freed.
  ///
  /// Required. Immutable.
  core.int? minReplicaCount;

  /// Number of required available replicas for the deployment to succeed.
  ///
  /// This field is only needed when partial deployment/mutation is desired. If
  /// set, the deploy/mutate operation will succeed once available_replica_count
  /// reaches required_replica_count, and the rest of the replicas will be
  /// retried. If not set, the default required_replica_count will be
  /// min_replica_count.
  ///
  /// Optional.
  core.int? requiredReplicaCount;

  /// If true, schedule the deployment workload on
  /// [spot VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
  ///
  /// Optional.
  core.bool? spot;

  GoogleCloudAiplatformV1beta1DedicatedResources({
    this.autoscalingMetricSpecs,
    this.flexStart,
    this.machineSpec,
    this.maxReplicaCount,
    this.minReplicaCount,
    this.requiredReplicaCount,
    this.spot,
  });

  GoogleCloudAiplatformV1beta1DedicatedResources.fromJson(core.Map json_)
    : this(
        autoscalingMetricSpecs:
            (json_['autoscalingMetricSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1AutoscalingMetricSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        flexStart:
            json_.containsKey('flexStart')
                ? GoogleCloudAiplatformV1beta1FlexStart.fromJson(
                  json_['flexStart'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        machineSpec:
            json_.containsKey('machineSpec')
                ? GoogleCloudAiplatformV1beta1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        maxReplicaCount: json_['maxReplicaCount'] as core.int?,
        minReplicaCount: json_['minReplicaCount'] as core.int?,
        requiredReplicaCount: json_['requiredReplicaCount'] as core.int?,
        spot: json_['spot'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoscalingMetricSpecs != null)
      'autoscalingMetricSpecs': autoscalingMetricSpecs!,
    if (flexStart != null) 'flexStart': flexStart!,
    if (machineSpec != null) 'machineSpec': machineSpec!,
    if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
    if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
    if (requiredReplicaCount != null)
      'requiredReplicaCount': requiredReplicaCount!,
    if (spot != null) 'spot': spot!,
  };
}

/// Request message for FeaturestoreService.DeleteFeatureValues.
class GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequest {
  /// Select feature values to be deleted by specifying entities.
  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectEntity?
  selectEntity;

  /// Select feature values to be deleted by specifying time range and features.
  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectTimeRangeAndFeature?
  selectTimeRangeAndFeature;

  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequest({
    this.selectEntity,
    this.selectTimeRangeAndFeature,
  });

  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequest.fromJson(
    core.Map json_,
  ) : this(
        selectEntity:
            json_.containsKey('selectEntity')
                ? GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectEntity.fromJson(
                  json_['selectEntity'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        selectTimeRangeAndFeature:
            json_.containsKey('selectTimeRangeAndFeature')
                ? GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectTimeRangeAndFeature.fromJson(
                  json_['selectTimeRangeAndFeature']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (selectEntity != null) 'selectEntity': selectEntity!,
    if (selectTimeRangeAndFeature != null)
      'selectTimeRangeAndFeature': selectTimeRangeAndFeature!,
  };
}

/// Message to select entity.
///
/// If an entity id is selected, all the feature values corresponding to the
/// entity id will be deleted, including the entityId.
class GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectEntity {
  /// Selectors choosing feature values of which entity id to be deleted from
  /// the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1EntityIdSelector? entityIdSelector;

  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectEntity({
    this.entityIdSelector,
  });

  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectEntity.fromJson(
    core.Map json_,
  ) : this(
        entityIdSelector:
            json_.containsKey('entityIdSelector')
                ? GoogleCloudAiplatformV1beta1EntityIdSelector.fromJson(
                  json_['entityIdSelector']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityIdSelector != null) 'entityIdSelector': entityIdSelector!,
  };
}

/// Message to select time range and feature.
///
/// Values of the selected feature generated within an inclusive time range will
/// be deleted. Using this option permanently deletes the feature values from
/// the specified feature IDs within the specified time range. This might
/// include data from the online storage. If you want to retain any deleted
/// historical data in the online storage, you must re-ingest it.
class GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectTimeRangeAndFeature {
  /// Selectors choosing which feature values to be deleted from the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureSelector? featureSelector;

  /// If set, data will not be deleted from online storage.
  ///
  /// When time range is older than the data in online storage, setting this to
  /// be true will make the deletion have no impact on online serving.
  core.bool? skipOnlineStorageDelete;

  /// Select feature generated within a half-inclusive time range.
  ///
  /// The time range is lower inclusive and upper exclusive.
  ///
  /// Required.
  GoogleTypeInterval? timeRange;

  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectTimeRangeAndFeature({
    this.featureSelector,
    this.skipOnlineStorageDelete,
    this.timeRange,
  });

  GoogleCloudAiplatformV1beta1DeleteFeatureValuesRequestSelectTimeRangeAndFeature.fromJson(
    core.Map json_,
  ) : this(
        featureSelector:
            json_.containsKey('featureSelector')
                ? GoogleCloudAiplatformV1beta1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        skipOnlineStorageDelete: json_['skipOnlineStorageDelete'] as core.bool?,
        timeRange:
            json_.containsKey('timeRange')
                ? GoogleTypeInterval.fromJson(
                  json_['timeRange'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureSelector != null) 'featureSelector': featureSelector!,
    if (skipOnlineStorageDelete != null)
      'skipOnlineStorageDelete': skipOnlineStorageDelete!,
    if (timeRange != null) 'timeRange': timeRange!,
  };
}

/// Request message for IndexEndpointService.DeployIndex.
class GoogleCloudAiplatformV1beta1DeployIndexRequest {
  /// The DeployedIndex to be created within the IndexEndpoint.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1DeployedIndex? deployedIndex;

  GoogleCloudAiplatformV1beta1DeployIndexRequest({this.deployedIndex});

  GoogleCloudAiplatformV1beta1DeployIndexRequest.fromJson(core.Map json_)
    : this(
        deployedIndex:
            json_.containsKey('deployedIndex')
                ? GoogleCloudAiplatformV1beta1DeployedIndex.fromJson(
                  json_['deployedIndex'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedIndex != null) 'deployedIndex': deployedIndex!,
  };
}

/// Request message for EndpointService.DeployModel.
class GoogleCloudAiplatformV1beta1DeployModelRequest {
  /// The DeployedModel to be created within the Endpoint.
  ///
  /// Note that Endpoint.traffic_split must be updated for the DeployedModel to
  /// start receiving traffic, either as part of this call, or via
  /// EndpointService.UpdateEndpoint.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1DeployedModel? deployedModel;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If this field is non-empty, then the Endpoint's traffic_split will be
  /// overwritten with it. To refer to the ID of the just being deployed Model,
  /// a "0" should be used, and the actual ID of the new DeployedModel will be
  /// filled in its place by this method. The traffic percentage values must add
  /// up to 100. If this field is empty, then the Endpoint's traffic_split is
  /// not updated.
  core.Map<core.String, core.int>? trafficSplit;

  GoogleCloudAiplatformV1beta1DeployModelRequest({
    this.deployedModel,
    this.trafficSplit,
  });

  GoogleCloudAiplatformV1beta1DeployModelRequest.fromJson(core.Map json_)
    : this(
        deployedModel:
            json_.containsKey('deployedModel')
                ? GoogleCloudAiplatformV1beta1DeployedModel.fromJson(
                  json_['deployedModel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        trafficSplit: (json_['trafficSplit']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.int)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedModel != null) 'deployedModel': deployedModel!,
    if (trafficSplit != null) 'trafficSplit': trafficSplit!,
  };
}

/// Request message for ModelGardenService.DeployPublisherModel.
class GoogleCloudAiplatformV1beta1DeployPublisherModelRequest {
  /// Whether the user accepts the End User License Agreement (EULA) for the
  /// model.
  ///
  /// Optional.
  core.bool? acceptEula;

  /// The dedicated resources to use for the endpoint.
  ///
  /// If not set, the default resources will be used.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DedicatedResources? dedicatedResources;

  /// The user-specified display name of the endpoint.
  ///
  /// If not set, a default name will be used.
  ///
  /// Optional.
  core.String? endpointDisplayName;

  /// The Hugging Face read access token used to access the model artifacts of
  /// gated models.
  ///
  /// Optional.
  core.String? huggingFaceAccessToken;

  /// The model to deploy.
  ///
  /// Format: 1. `publishers/{publisher}/models/{publisher_model}@{version_id}`,
  /// or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`.
  /// 2. Hugging Face model ID like `google/gemma-2-2b-it`. 3. Custom model
  /// Google Cloud Storage URI like `gs://bucket`. 4. Custom model zip file like
  /// `https://example.com/a.zip`.
  ///
  /// Required.
  core.String? model;

  /// The user-specified display name of the uploaded model.
  ///
  /// If not set, a default name will be used.
  ///
  /// Optional.
  core.String? modelDisplayName;

  GoogleCloudAiplatformV1beta1DeployPublisherModelRequest({
    this.acceptEula,
    this.dedicatedResources,
    this.endpointDisplayName,
    this.huggingFaceAccessToken,
    this.model,
    this.modelDisplayName,
  });

  GoogleCloudAiplatformV1beta1DeployPublisherModelRequest.fromJson(
    core.Map json_,
  ) : this(
        acceptEula: json_['acceptEula'] as core.bool?,
        dedicatedResources:
            json_.containsKey('dedicatedResources')
                ? GoogleCloudAiplatformV1beta1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endpointDisplayName: json_['endpointDisplayName'] as core.String?,
        huggingFaceAccessToken: json_['huggingFaceAccessToken'] as core.String?,
        model: json_['model'] as core.String?,
        modelDisplayName: json_['modelDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceptEula != null) 'acceptEula': acceptEula!,
    if (dedicatedResources != null) 'dedicatedResources': dedicatedResources!,
    if (endpointDisplayName != null)
      'endpointDisplayName': endpointDisplayName!,
    if (huggingFaceAccessToken != null)
      'huggingFaceAccessToken': huggingFaceAccessToken!,
    if (model != null) 'model': model!,
    if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
  };
}

/// Request message for ModelGardenService.Deploy.
class GoogleCloudAiplatformV1beta1DeployRequest {
  /// The custom model to deploy from a Google Cloud Storage URI.
  GoogleCloudAiplatformV1beta1DeployRequestCustomModel? customModel;

  /// The deploy config to use for the deployment.
  ///
  /// If not specified, the default deploy config will be used.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DeployRequestDeployConfig? deployConfig;

  /// The endpoint config to use for the deployment.
  ///
  /// If not specified, the default endpoint config will be used.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DeployRequestEndpointConfig? endpointConfig;

  /// The Hugging Face model to deploy.
  ///
  /// Format: Hugging Face model ID like `google/gemma-2-2b-it`.
  core.String? huggingFaceModelId;

  /// The model config to use for the deployment.
  ///
  /// If not specified, the default model config will be used.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DeployRequestModelConfig? modelConfig;

  /// The Model Garden model to deploy.
  ///
  /// Format: `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`.
  core.String? publisherModelName;

  GoogleCloudAiplatformV1beta1DeployRequest({
    this.customModel,
    this.deployConfig,
    this.endpointConfig,
    this.huggingFaceModelId,
    this.modelConfig,
    this.publisherModelName,
  });

  GoogleCloudAiplatformV1beta1DeployRequest.fromJson(core.Map json_)
    : this(
        customModel:
            json_.containsKey('customModel')
                ? GoogleCloudAiplatformV1beta1DeployRequestCustomModel.fromJson(
                  json_['customModel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        deployConfig:
            json_.containsKey('deployConfig')
                ? GoogleCloudAiplatformV1beta1DeployRequestDeployConfig.fromJson(
                  json_['deployConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        endpointConfig:
            json_.containsKey('endpointConfig')
                ? GoogleCloudAiplatformV1beta1DeployRequestEndpointConfig.fromJson(
                  json_['endpointConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        huggingFaceModelId: json_['huggingFaceModelId'] as core.String?,
        modelConfig:
            json_.containsKey('modelConfig')
                ? GoogleCloudAiplatformV1beta1DeployRequestModelConfig.fromJson(
                  json_['modelConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        publisherModelName: json_['publisherModelName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customModel != null) 'customModel': customModel!,
    if (deployConfig != null) 'deployConfig': deployConfig!,
    if (endpointConfig != null) 'endpointConfig': endpointConfig!,
    if (huggingFaceModelId != null) 'huggingFaceModelId': huggingFaceModelId!,
    if (modelConfig != null) 'modelConfig': modelConfig!,
    if (publisherModelName != null) 'publisherModelName': publisherModelName!,
  };
}

/// The custom model to deploy from model weights in a Google Cloud Storage URI
/// or Model Registry model.
class GoogleCloudAiplatformV1beta1DeployRequestCustomModel {
  /// The Google Cloud Storage URI of the custom model, storing weights and
  /// config files (which can be used to infer the base model).
  ///
  /// Immutable.
  core.String? gcsUri;

  /// Use ModelConfig.model_user_id instead.
  ///
  /// Optional. Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? modelId;

  GoogleCloudAiplatformV1beta1DeployRequestCustomModel({
    this.gcsUri,
    this.modelId,
  });

  GoogleCloudAiplatformV1beta1DeployRequestCustomModel.fromJson(core.Map json_)
    : this(
        gcsUri: json_['gcsUri'] as core.String?,
        modelId: json_['modelId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsUri != null) 'gcsUri': gcsUri!,
    if (modelId != null) 'modelId': modelId!,
  };
}

/// The deploy config to use for the deployment.
class GoogleCloudAiplatformV1beta1DeployRequestDeployConfig {
  /// The dedicated resources to use for the endpoint.
  ///
  /// If not set, the default resources will be used.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DedicatedResources? dedicatedResources;

  /// If true, enable the QMT fast tryout feature for this model if possible.
  ///
  /// Optional.
  core.bool? fastTryoutEnabled;

  /// System labels for Model Garden deployments.
  ///
  /// These labels are managed by Google and for tracking purposes only.
  ///
  /// Optional.
  core.Map<core.String, core.String>? systemLabels;

  GoogleCloudAiplatformV1beta1DeployRequestDeployConfig({
    this.dedicatedResources,
    this.fastTryoutEnabled,
    this.systemLabels,
  });

  GoogleCloudAiplatformV1beta1DeployRequestDeployConfig.fromJson(core.Map json_)
    : this(
        dedicatedResources:
            json_.containsKey('dedicatedResources')
                ? GoogleCloudAiplatformV1beta1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        fastTryoutEnabled: json_['fastTryoutEnabled'] as core.bool?,
        systemLabels: (json_['systemLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dedicatedResources != null) 'dedicatedResources': dedicatedResources!,
    if (fastTryoutEnabled != null) 'fastTryoutEnabled': fastTryoutEnabled!,
    if (systemLabels != null) 'systemLabels': systemLabels!,
  };
}

/// The endpoint config to use for the deployment.
typedef GoogleCloudAiplatformV1beta1DeployRequestEndpointConfig =
    $DeployRequestEndpointConfig;

/// The model config to use for the deployment.
class GoogleCloudAiplatformV1beta1DeployRequestModelConfig {
  /// Whether the user accepts the End User License Agreement (EULA) for the
  /// model.
  ///
  /// Optional.
  core.bool? acceptEula;

  /// The specification of the container that is to be used when deploying.
  ///
  /// If not set, the default container spec will be used.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ModelContainerSpec? containerSpec;

  /// The Hugging Face read access token used to access the model artifacts of
  /// gated models.
  ///
  /// Optional.
  core.String? huggingFaceAccessToken;

  /// If true, the model will deploy with a cached version instead of directly
  /// downloading the model artifacts from Hugging Face.
  ///
  /// This is suitable for VPC-SC users with limited internet access.
  ///
  /// Optional.
  core.bool? huggingFaceCacheEnabled;

  /// The user-specified display name of the uploaded model.
  ///
  /// If not set, a default name will be used.
  ///
  /// Optional.
  core.String? modelDisplayName;

  /// The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// When not provided, Vertex AI will generate a value for this ID. When Model
  /// Registry model is provided, this field will be ignored. This value may be
  /// up to 63 characters, and valid characters are `[a-z0-9_-]`. The first
  /// character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelUserId;

  GoogleCloudAiplatformV1beta1DeployRequestModelConfig({
    this.acceptEula,
    this.containerSpec,
    this.huggingFaceAccessToken,
    this.huggingFaceCacheEnabled,
    this.modelDisplayName,
    this.modelUserId,
  });

  GoogleCloudAiplatformV1beta1DeployRequestModelConfig.fromJson(core.Map json_)
    : this(
        acceptEula: json_['acceptEula'] as core.bool?,
        containerSpec:
            json_.containsKey('containerSpec')
                ? GoogleCloudAiplatformV1beta1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        huggingFaceAccessToken: json_['huggingFaceAccessToken'] as core.String?,
        huggingFaceCacheEnabled: json_['huggingFaceCacheEnabled'] as core.bool?,
        modelDisplayName: json_['modelDisplayName'] as core.String?,
        modelUserId: json_['modelUserId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceptEula != null) 'acceptEula': acceptEula!,
    if (containerSpec != null) 'containerSpec': containerSpec!,
    if (huggingFaceAccessToken != null)
      'huggingFaceAccessToken': huggingFaceAccessToken!,
    if (huggingFaceCacheEnabled != null)
      'huggingFaceCacheEnabled': huggingFaceCacheEnabled!,
    if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
    if (modelUserId != null) 'modelUserId': modelUserId!,
  };
}

/// A deployment of an Index.
///
/// IndexEndpoints contain one or more DeployedIndexes.
class GoogleCloudAiplatformV1beta1DeployedIndex {
  /// A description of resources that the DeployedIndex uses, which to large
  /// degree are decided by Vertex AI, and optionally allows only a modest
  /// additional configuration.
  ///
  /// If min_replica_count is not set, the default value is 2 (we don't provide
  /// SLA when min_replica_count=1). If max_replica_count is not set, the
  /// default value is min_replica_count. The max allowed replica count is 1000.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AutomaticResources? automaticResources;

  /// Timestamp when the DeployedIndex was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of resources that are dedicated to the DeployedIndex, and
  /// that need a higher degree of manual configuration.
  ///
  /// The field min_replica_count must be set to a value strictly greater than
  /// 0, or else validation will fail. We don't provide SLA when
  /// min_replica_count=1. If max_replica_count is not set, the default value is
  /// min_replica_count. The max allowed replica count is 1000. Available
  /// machine types for SMALL shard: e2-standard-2 and all machine types
  /// available for MEDIUM and LARGE shard. Available machine types for MEDIUM
  /// shard: e2-standard-16 and all machine types available for LARGE shard.
  /// Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
  /// n1-standard-16 and n1-standard-32 are still available, but we recommend
  /// e2-standard-16 and e2-highmem-16 for cost efficiency.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DedicatedResources? dedicatedResources;

  /// If set, the authentication is enabled for the private endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DeployedIndexAuthConfig? deployedIndexAuthConfig;

  /// The deployment group can be no longer than 64 characters (eg: 'test',
  /// 'prod').
  ///
  /// If not set, we will use the 'default' deployment group. Creating
  /// `deployment_groups` with `reserved_ip_ranges` is a recommended practice
  /// when the peered network has multiple peering ranges. This creates your
  /// deployments from predictable IP spaces for easier traffic administration.
  /// Also, one deployment_group (except 'default') can only be used with the
  /// same reserved_ip_ranges which means if the deployment_group has been used
  /// with reserved_ip_ranges: \[a, b, c\], using it with \[a, b\] or \[d, e\]
  /// is disallowed. Note: we only support up to 5 deployment groups(not
  /// including 'default').
  ///
  /// Optional.
  core.String? deploymentGroup;

  /// The deployment tier that the index is deployed to.
  ///
  /// DEPLOYMENT_TIER_UNSPECIFIED defaults to PERFORMANCE.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DEPLOYMENT_TIER_UNSPECIFIED" : Default deployment tier.
  /// - "STORAGE" : Optimized for costs.
  core.String? deploymentTier;

  /// The display name of the DeployedIndex.
  ///
  /// If not provided upon creation, the Index's display_name is used.
  core.String? displayName;

  /// If true, private endpoint's access logs are sent to Cloud Logging.
  ///
  /// These logs are like standard server access logs, containing information
  /// like timestamp and latency for each MatchRequest. Note that logs may incur
  /// a cost, especially if the deployed index receives a high queries per
  /// second rate (QPS). Estimate your costs before enabling this option.
  ///
  /// Optional.
  core.bool? enableAccessLogging;

  /// If true, logs to Cloud Logging errors relating to datapoint upserts.
  ///
  /// Under normal operation conditions, these log entries should be very rare.
  /// However, if incompatible datapoint updates are being uploaded to an index,
  /// a high volume of log entries may be generated in a short period of time.
  /// Note that logs may incur a cost, especially if the deployed index receives
  /// a high volume of datapoint upserts. Estimate your costs before enabling
  /// this option.
  ///
  /// Optional.
  core.bool? enableDatapointUpsertLogging;

  /// The user specified ID of the DeployedIndex.
  ///
  /// The ID can be up to 128 characters long and must start with a letter and
  /// only contain letters, numbers, and underscores. The ID must be unique
  /// within the project it is created in.
  ///
  /// Required.
  core.String? id;

  /// The name of the Index this is the deployment of.
  ///
  /// We may refer to this Index as the DeployedIndex's "original" Index.
  ///
  /// Required.
  core.String? index;

  /// The DeployedIndex may depend on various data on its original Index.
  ///
  /// Additionally when certain changes to the original Index are being done
  /// (e.g. when what the Index contains is being changed) the DeployedIndex may
  /// be asynchronously updated in the background to reflect these changes. If
  /// this timestamp's value is at least the Index.update_time of the original
  /// Index, it means that this DeployedIndex and the original Index are in
  /// sync. If this timestamp is older, then to see which updates this
  /// DeployedIndex already contains (and which it does not), one must list the
  /// operations that are running on the original Index. Only the successfully
  /// completed Operations with update_time equal or before this sync time are
  /// contained in this DeployedIndex.
  ///
  /// Output only.
  core.String? indexSyncTime;

  /// Provides paths for users to send requests directly to the deployed index
  /// services running on Cloud via private services access.
  ///
  /// This field is populated if network is configured.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1IndexPrivateEndpoints? privateEndpoints;

  /// If set for PSC deployed index, PSC connection will be automatically
  /// created after deployment is done and the endpoint information is populated
  /// in private_endpoints.psc_automated_endpoints.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1PSCAutomationConfig>?
  pscAutomationConfigs;

  /// A list of reserved ip ranges under the VPC network that can be used for
  /// this DeployedIndex.
  ///
  /// If set, we will deploy the index within the provided ip ranges. Otherwise,
  /// the index might be deployed to any ip ranges under the provided VPC
  /// network. The value should be the name of the address
  /// (https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
  /// Example: \['vertex-ai-ip-range'\]. For more information about subnets and
  /// network IP ranges, please see
  /// https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  GoogleCloudAiplatformV1beta1DeployedIndex({
    this.automaticResources,
    this.createTime,
    this.dedicatedResources,
    this.deployedIndexAuthConfig,
    this.deploymentGroup,
    this.deploymentTier,
    this.displayName,
    this.enableAccessLogging,
    this.enableDatapointUpsertLogging,
    this.id,
    this.index,
    this.indexSyncTime,
    this.privateEndpoints,
    this.pscAutomationConfigs,
    this.reservedIpRanges,
  });

  GoogleCloudAiplatformV1beta1DeployedIndex.fromJson(core.Map json_)
    : this(
        automaticResources:
            json_.containsKey('automaticResources')
                ? GoogleCloudAiplatformV1beta1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        dedicatedResources:
            json_.containsKey('dedicatedResources')
                ? GoogleCloudAiplatformV1beta1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        deployedIndexAuthConfig:
            json_.containsKey('deployedIndexAuthConfig')
                ? GoogleCloudAiplatformV1beta1DeployedIndexAuthConfig.fromJson(
                  json_['deployedIndexAuthConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        deploymentGroup: json_['deploymentGroup'] as core.String?,
        deploymentTier: json_['deploymentTier'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        enableAccessLogging: json_['enableAccessLogging'] as core.bool?,
        enableDatapointUpsertLogging:
            json_['enableDatapointUpsertLogging'] as core.bool?,
        id: json_['id'] as core.String?,
        index: json_['index'] as core.String?,
        indexSyncTime: json_['indexSyncTime'] as core.String?,
        privateEndpoints:
            json_.containsKey('privateEndpoints')
                ? GoogleCloudAiplatformV1beta1IndexPrivateEndpoints.fromJson(
                  json_['privateEndpoints']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pscAutomationConfigs:
            (json_['pscAutomationConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PSCAutomationConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        reservedIpRanges:
            (json_['reservedIpRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (automaticResources != null) 'automaticResources': automaticResources!,
    if (createTime != null) 'createTime': createTime!,
    if (dedicatedResources != null) 'dedicatedResources': dedicatedResources!,
    if (deployedIndexAuthConfig != null)
      'deployedIndexAuthConfig': deployedIndexAuthConfig!,
    if (deploymentGroup != null) 'deploymentGroup': deploymentGroup!,
    if (deploymentTier != null) 'deploymentTier': deploymentTier!,
    if (displayName != null) 'displayName': displayName!,
    if (enableAccessLogging != null)
      'enableAccessLogging': enableAccessLogging!,
    if (enableDatapointUpsertLogging != null)
      'enableDatapointUpsertLogging': enableDatapointUpsertLogging!,
    if (id != null) 'id': id!,
    if (index != null) 'index': index!,
    if (indexSyncTime != null) 'indexSyncTime': indexSyncTime!,
    if (privateEndpoints != null) 'privateEndpoints': privateEndpoints!,
    if (pscAutomationConfigs != null)
      'pscAutomationConfigs': pscAutomationConfigs!,
    if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
  };
}

/// Used to set up the auth on the DeployedIndex's private endpoint.
class GoogleCloudAiplatformV1beta1DeployedIndexAuthConfig {
  /// Defines the authentication provider that the DeployedIndex uses.
  GoogleCloudAiplatformV1beta1DeployedIndexAuthConfigAuthProvider? authProvider;

  GoogleCloudAiplatformV1beta1DeployedIndexAuthConfig({this.authProvider});

  GoogleCloudAiplatformV1beta1DeployedIndexAuthConfig.fromJson(core.Map json_)
    : this(
        authProvider:
            json_.containsKey('authProvider')
                ? GoogleCloudAiplatformV1beta1DeployedIndexAuthConfigAuthProvider.fromJson(
                  json_['authProvider'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authProvider != null) 'authProvider': authProvider!,
  };
}

/// Configuration for an authentication provider, including support for \[JSON
/// Web Token
/// (JWT)\](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
typedef GoogleCloudAiplatformV1beta1DeployedIndexAuthConfigAuthProvider =
    $DeployedIndexAuthConfigAuthProvider;

/// Points to a DeployedIndex.
typedef GoogleCloudAiplatformV1beta1DeployedIndexRef = $DeployedIndexRef;

/// A deployment of a Model.
///
/// Endpoints contain one or more DeployedModels.
class GoogleCloudAiplatformV1beta1DeployedModel {
  /// A description of resources that to large degree are decided by Vertex AI,
  /// and require only a modest additional configuration.
  GoogleCloudAiplatformV1beta1AutomaticResources? automaticResources;

  /// The checkpoint id of the model.
  core.String? checkpointId;

  /// Timestamp when the DeployedModel was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  GoogleCloudAiplatformV1beta1DedicatedResources? dedicatedResources;

  /// If true, deploy the model without explainable feature, regardless the
  /// existence of Model.explanation_spec or explanation_spec.
  core.bool? disableExplanations;

  /// The display name of the DeployedModel.
  ///
  /// If not provided upon creation, the Model's display_name is used.
  core.String? displayName;

  /// If true, online prediction access logs are sent to Cloud Logging.
  ///
  /// These logs are like standard server access logs, containing information
  /// like timestamp and latency for each prediction request. Note that logs may
  /// incur a cost, especially if your project receives prediction requests at a
  /// high queries per second rate (QPS). Estimate your costs before enabling
  /// this option.
  core.bool? enableAccessLogging;

  /// If true, the container of the DeployedModel instances will send `stderr`
  /// and `stdout` streams to Cloud Logging.
  ///
  /// Only supported for custom-trained Models and AutoML Tabular Models.
  core.bool? enableContainerLogging;

  /// Explanation configuration for this DeployedModel.
  ///
  /// When deploying a Model using EndpointService.DeployModel, this value
  /// overrides the value of Model.explanation_spec. All fields of
  /// explanation_spec are optional in the request. If a field of
  /// explanation_spec is not populated, the value of the same field of
  /// Model.explanation_spec is inherited. If the corresponding
  /// Model.explanation_spec is not populated, all fields of the
  /// explanation_spec will be used for the explanation configuration.
  GoogleCloudAiplatformV1beta1ExplanationSpec? explanationSpec;

  /// Configuration for faster model deployment.
  GoogleCloudAiplatformV1beta1FasterDeploymentConfig? fasterDeploymentConfig;

  /// GDC pretrained / Gemini model name.
  ///
  /// The model name is a plain model name, e.g. gemini-1.5-flash-002.
  core.String? gdcConnectedModel;

  /// The ID of the DeployedModel.
  ///
  /// If not provided upon deployment, Vertex AI will generate a value for this
  /// ID. This value should be 1-10 characters, and valid characters are
  /// `/[0-9]/`.
  ///
  /// Immutable.
  core.String? id;

  /// The resource name of the Model that this is the deployment of.
  ///
  /// Note that the Model may be in a different location than the
  /// DeployedModel's Endpoint. The resource name may contain version id or
  /// version alias to specify the version. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` if no
  /// version is specified, the default version will be deployed.
  core.String? model;

  /// The version ID of the model that is deployed.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// Provide paths for users to send predict/explain/health requests directly
  /// to the deployed model services running on Cloud via private services
  /// access.
  ///
  /// This field is populated if network is configured.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PrivateEndpoints? privateEndpoints;

  /// Options for configuring rolling deployments.
  GoogleCloudAiplatformV1beta1RolloutOptions? rolloutOptions;

  /// The service account that the DeployedModel's container runs as.
  ///
  /// Specify the email address of the service account. If this service account
  /// is not specified, the container runs as a service account that doesn't
  /// have access to the resource project. Users deploying the Model must have
  /// the `iam.serviceAccounts.actAs` permission on this service account.
  core.String? serviceAccount;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  core.String? sharedResources;

  /// Spec for configuring speculative decoding.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1SpeculativeDecodingSpec? speculativeDecodingSpec;

  /// Runtime status of the deployed model.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DeployedModelStatus? status;

  /// System labels to apply to Model Garden deployments.
  ///
  /// System labels are managed by Google for internal use only.
  core.Map<core.String, core.String>? systemLabels;

  GoogleCloudAiplatformV1beta1DeployedModel({
    this.automaticResources,
    this.checkpointId,
    this.createTime,
    this.dedicatedResources,
    this.disableExplanations,
    this.displayName,
    this.enableAccessLogging,
    this.enableContainerLogging,
    this.explanationSpec,
    this.fasterDeploymentConfig,
    this.gdcConnectedModel,
    this.id,
    this.model,
    this.modelVersionId,
    this.privateEndpoints,
    this.rolloutOptions,
    this.serviceAccount,
    this.sharedResources,
    this.speculativeDecodingSpec,
    this.status,
    this.systemLabels,
  });

  GoogleCloudAiplatformV1beta1DeployedModel.fromJson(core.Map json_)
    : this(
        automaticResources:
            json_.containsKey('automaticResources')
                ? GoogleCloudAiplatformV1beta1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        checkpointId: json_['checkpointId'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        dedicatedResources:
            json_.containsKey('dedicatedResources')
                ? GoogleCloudAiplatformV1beta1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        disableExplanations: json_['disableExplanations'] as core.bool?,
        displayName: json_['displayName'] as core.String?,
        enableAccessLogging: json_['enableAccessLogging'] as core.bool?,
        enableContainerLogging: json_['enableContainerLogging'] as core.bool?,
        explanationSpec:
            json_.containsKey('explanationSpec')
                ? GoogleCloudAiplatformV1beta1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        fasterDeploymentConfig:
            json_.containsKey('fasterDeploymentConfig')
                ? GoogleCloudAiplatformV1beta1FasterDeploymentConfig.fromJson(
                  json_['fasterDeploymentConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gdcConnectedModel: json_['gdcConnectedModel'] as core.String?,
        id: json_['id'] as core.String?,
        model: json_['model'] as core.String?,
        modelVersionId: json_['modelVersionId'] as core.String?,
        privateEndpoints:
            json_.containsKey('privateEndpoints')
                ? GoogleCloudAiplatformV1beta1PrivateEndpoints.fromJson(
                  json_['privateEndpoints']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        rolloutOptions:
            json_.containsKey('rolloutOptions')
                ? GoogleCloudAiplatformV1beta1RolloutOptions.fromJson(
                  json_['rolloutOptions']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        serviceAccount: json_['serviceAccount'] as core.String?,
        sharedResources: json_['sharedResources'] as core.String?,
        speculativeDecodingSpec:
            json_.containsKey('speculativeDecodingSpec')
                ? GoogleCloudAiplatformV1beta1SpeculativeDecodingSpec.fromJson(
                  json_['speculativeDecodingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        status:
            json_.containsKey('status')
                ? GoogleCloudAiplatformV1beta1DeployedModelStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        systemLabels: (json_['systemLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (automaticResources != null) 'automaticResources': automaticResources!,
    if (checkpointId != null) 'checkpointId': checkpointId!,
    if (createTime != null) 'createTime': createTime!,
    if (dedicatedResources != null) 'dedicatedResources': dedicatedResources!,
    if (disableExplanations != null)
      'disableExplanations': disableExplanations!,
    if (displayName != null) 'displayName': displayName!,
    if (enableAccessLogging != null)
      'enableAccessLogging': enableAccessLogging!,
    if (enableContainerLogging != null)
      'enableContainerLogging': enableContainerLogging!,
    if (explanationSpec != null) 'explanationSpec': explanationSpec!,
    if (fasterDeploymentConfig != null)
      'fasterDeploymentConfig': fasterDeploymentConfig!,
    if (gdcConnectedModel != null) 'gdcConnectedModel': gdcConnectedModel!,
    if (id != null) 'id': id!,
    if (model != null) 'model': model!,
    if (modelVersionId != null) 'modelVersionId': modelVersionId!,
    if (privateEndpoints != null) 'privateEndpoints': privateEndpoints!,
    if (rolloutOptions != null) 'rolloutOptions': rolloutOptions!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (sharedResources != null) 'sharedResources': sharedResources!,
    if (speculativeDecodingSpec != null)
      'speculativeDecodingSpec': speculativeDecodingSpec!,
    if (status != null) 'status': status!,
    if (systemLabels != null) 'systemLabels': systemLabels!,
  };
}

/// Points to a DeployedModel.
typedef GoogleCloudAiplatformV1beta1DeployedModelRef = $DeployedModelRef;

/// Runtime status of the deployed model.
typedef GoogleCloudAiplatformV1beta1DeployedModelStatus = $DeployedModelStatus;

/// A description of resources that can be shared by multiple DeployedModels,
/// whose underlying specification consists of a DedicatedResources.
class GoogleCloudAiplatformV1beta1DeploymentResourcePool {
  /// Timestamp when this DeploymentResourcePool was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The underlying DedicatedResources that the DeploymentResourcePool uses.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1DedicatedResources? dedicatedResources;

  /// If the DeploymentResourcePool is deployed with custom-trained Models or
  /// AutoML Tabular Models, the container(s) of the DeploymentResourcePool will
  /// send `stderr` and `stdout` streams to Cloud Logging by default.
  ///
  /// Please note that the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging/pricing). User
  /// can disable container logging by setting this flag to true.
  core.bool? disableContainerLogging;

  /// Customer-managed encryption key spec for a DeploymentResourcePool.
  ///
  /// If set, this DeploymentResourcePool will be secured by this key. Endpoints
  /// and the DeploymentResourcePool they deploy in need to have the same
  /// EncryptionSpec.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// The resource name of the DeploymentResourcePool.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  ///
  /// Immutable.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// The service account that the DeploymentResourcePool's container(s) run as.
  ///
  /// Specify the email address of the service account. If this service account
  /// is not specified, the container(s) run as a service account that doesn't
  /// have access to the resource project. Users deploying the Models to this
  /// DeploymentResourcePool must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1beta1DeploymentResourcePool({
    this.createTime,
    this.dedicatedResources,
    this.disableContainerLogging,
    this.encryptionSpec,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1beta1DeploymentResourcePool.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        dedicatedResources:
            json_.containsKey('dedicatedResources')
                ? GoogleCloudAiplatformV1beta1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        disableContainerLogging: json_['disableContainerLogging'] as core.bool?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        serviceAccount: json_['serviceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (dedicatedResources != null) 'dedicatedResources': dedicatedResources!,
    if (disableContainerLogging != null)
      'disableContainerLogging': disableContainerLogging!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (name != null) 'name': name!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
  };
}

typedef GoogleCloudAiplatformV1beta1DestinationFeatureSetting =
    $DestinationFeatureSetting;

/// Request message for PredictionService.DirectPredict.
class GoogleCloudAiplatformV1beta1DirectPredictRequest {
  /// The prediction input.
  core.List<GoogleCloudAiplatformV1beta1Tensor>? inputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1beta1Tensor? parameters;

  GoogleCloudAiplatformV1beta1DirectPredictRequest({
    this.inputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1DirectPredictRequest.fromJson(core.Map json_)
    : this(
        inputs:
            (json_['inputs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tensor.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputs != null) 'inputs': inputs!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Response message for PredictionService.DirectPredict.
class GoogleCloudAiplatformV1beta1DirectPredictResponse {
  /// The prediction output.
  core.List<GoogleCloudAiplatformV1beta1Tensor>? outputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1beta1Tensor? parameters;

  GoogleCloudAiplatformV1beta1DirectPredictResponse({
    this.outputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1DirectPredictResponse.fromJson(core.Map json_)
    : this(
        outputs:
            (json_['outputs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tensor.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputs != null) 'outputs': outputs!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Request message for PredictionService.DirectRawPredict.
typedef GoogleCloudAiplatformV1beta1DirectRawPredictRequest =
    $DirectRawPredictRequest;

/// Response message for PredictionService.DirectRawPredict.
typedef GoogleCloudAiplatformV1beta1DirectRawPredictResponse =
    $DirectRawPredictResponse;

/// The input content is encapsulated and uploaded in the request.
typedef GoogleCloudAiplatformV1beta1DirectUploadSource = $Empty;

/// Represents the spec of disk options.
typedef GoogleCloudAiplatformV1beta1DiskSpec = $DiskSpec;

/// Statistics computed for datasets used for distillation.
class GoogleCloudAiplatformV1beta1DistillationDataStats {
  /// Statistics computed for the training dataset.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetStats? trainingDatasetStats;

  GoogleCloudAiplatformV1beta1DistillationDataStats({
    this.trainingDatasetStats,
  });

  GoogleCloudAiplatformV1beta1DistillationDataStats.fromJson(core.Map json_)
    : this(
        trainingDatasetStats:
            json_.containsKey('trainingDatasetStats')
                ? GoogleCloudAiplatformV1beta1DatasetStats.fromJson(
                  json_['trainingDatasetStats']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (trainingDatasetStats != null)
      'trainingDatasetStats': trainingDatasetStats!,
  };
}

/// Hyperparameters for Distillation.
class GoogleCloudAiplatformV1beta1DistillationHyperParameters {
  /// Adapter size for distillation.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ADAPTER_SIZE_UNSPECIFIED" : Adapter size is unspecified.
  /// - "ADAPTER_SIZE_ONE" : Adapter size 1.
  /// - "ADAPTER_SIZE_TWO" : Adapter size 2.
  /// - "ADAPTER_SIZE_FOUR" : Adapter size 4.
  /// - "ADAPTER_SIZE_EIGHT" : Adapter size 8.
  /// - "ADAPTER_SIZE_SIXTEEN" : Adapter size 16.
  /// - "ADAPTER_SIZE_THIRTY_TWO" : Adapter size 32.
  core.String? adapterSize;

  /// Number of complete passes the model makes over the entire training dataset
  /// during training.
  ///
  /// Optional.
  core.String? epochCount;

  /// Multiplier for adjusting the default learning rate.
  ///
  /// Optional.
  core.double? learningRateMultiplier;

  GoogleCloudAiplatformV1beta1DistillationHyperParameters({
    this.adapterSize,
    this.epochCount,
    this.learningRateMultiplier,
  });

  GoogleCloudAiplatformV1beta1DistillationHyperParameters.fromJson(
    core.Map json_,
  ) : this(
        adapterSize: json_['adapterSize'] as core.String?,
        epochCount: json_['epochCount'] as core.String?,
        learningRateMultiplier:
            (json_['learningRateMultiplier'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adapterSize != null) 'adapterSize': adapterSize!,
    if (epochCount != null) 'epochCount': epochCount!,
    if (learningRateMultiplier != null)
      'learningRateMultiplier': learningRateMultiplier!,
  };
}

/// Tuning Spec for Distillation.
class GoogleCloudAiplatformV1beta1DistillationSpec {
  /// The base teacher model that is being distilled.
  ///
  /// See
  /// [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/tuning#supported_models).
  core.String? baseTeacherModel;

  /// Hyperparameters for Distillation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DistillationHyperParameters? hyperParameters;

  /// A path in a Cloud Storage bucket, which will be treated as the root output
  /// directory of the distillation pipeline.
  ///
  /// It is used by the system to generate the paths of output artifacts.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? pipelineRootDirectory;

  /// The student model that is being tuned, e.g., "google/gemma-2b-1.1-it".
  ///
  /// Deprecated. Use base_model instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? studentModel;

  /// Cloud Storage path to file containing training dataset for tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? trainingDatasetUri;

  /// The resource name of the Tuned teacher model.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  core.String? tunedTeacherModelSource;

  /// Cloud Storage path to file containing validation dataset for tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Optional.
  core.String? validationDatasetUri;

  GoogleCloudAiplatformV1beta1DistillationSpec({
    this.baseTeacherModel,
    this.hyperParameters,
    this.pipelineRootDirectory,
    this.studentModel,
    this.trainingDatasetUri,
    this.tunedTeacherModelSource,
    this.validationDatasetUri,
  });

  GoogleCloudAiplatformV1beta1DistillationSpec.fromJson(core.Map json_)
    : this(
        baseTeacherModel: json_['baseTeacherModel'] as core.String?,
        hyperParameters:
            json_.containsKey('hyperParameters')
                ? GoogleCloudAiplatformV1beta1DistillationHyperParameters.fromJson(
                  json_['hyperParameters']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pipelineRootDirectory: json_['pipelineRootDirectory'] as core.String?,
        studentModel: json_['studentModel'] as core.String?,
        trainingDatasetUri: json_['trainingDatasetUri'] as core.String?,
        tunedTeacherModelSource:
            json_['tunedTeacherModelSource'] as core.String?,
        validationDatasetUri: json_['validationDatasetUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseTeacherModel != null) 'baseTeacherModel': baseTeacherModel!,
    if (hyperParameters != null) 'hyperParameters': hyperParameters!,
    if (pipelineRootDirectory != null)
      'pipelineRootDirectory': pipelineRootDirectory!,
    if (studentModel != null) 'studentModel': studentModel!,
    if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri!,
    if (tunedTeacherModelSource != null)
      'tunedTeacherModelSource': tunedTeacherModelSource!,
    if (validationDatasetUri != null)
      'validationDatasetUri': validationDatasetUri!,
  };
}

/// DNS peering configuration.
///
/// These configurations are used to create DNS peering zones in the Vertex
/// tenant project VPC, enabling resolution of records within the specified
/// domain hosted in the target network's Cloud DNS.
typedef GoogleCloudAiplatformV1beta1DnsPeeringConfig = $DnsPeeringConfig;

/// A list of double values.
typedef GoogleCloudAiplatformV1beta1DoubleArray = $DoubleArray;

/// Describes the options to customize dynamic retrieval.
typedef GoogleCloudAiplatformV1beta1DynamicRetrievalConfig =
    $DynamicRetrievalConfig;

/// Represents a customer-managed encryption key spec that can be applied to a
/// top-level resource.
typedef GoogleCloudAiplatformV1beta1EncryptionSpec = $EncryptionSpec00;

/// Models are deployed into it, and afterwards Endpoint is called to obtain
/// predictions and explanations.
class GoogleCloudAiplatformV1beta1Endpoint {
  /// Configurations that are applied to the endpoint for online prediction.
  GoogleCloudAiplatformV1beta1ClientConnectionConfig? clientConnectionConfig;

  /// Timestamp when this Endpoint was created.
  ///
  /// Output only.
  core.String? createTime;

  /// DNS of the dedicated endpoint.
  ///
  /// Will only be populated if dedicated_endpoint_enabled is true. Depending on
  /// the features enabled, uid might be a random number or a string. For
  /// example, if fast_tryout is enabled, uid will be fasttryout. Format:
  /// `https://{endpoint_id}.{region}-{uid}.prediction.vertexai.goog`.
  ///
  /// Output only.
  core.String? dedicatedEndpointDns;

  /// If true, the endpoint will be exposed through a dedicated DNS
  /// \[Endpoint.dedicated_endpoint_dns\].
  ///
  /// Your request to the dedicated DNS will be isolated from other users'
  /// traffic and will have better performance and reliability. Note: Once you
  /// enabled dedicated endpoint, you won't be able to send request to the
  /// shared DNS {region}-aiplatform.googleapis.com. The limitation will be
  /// removed soon.
  core.bool? dedicatedEndpointEnabled;

  /// The models deployed in this Endpoint.
  ///
  /// To add or remove DeployedModels use EndpointService.DeployModel and
  /// EndpointService.UndeployModel respectively.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1DeployedModel>? deployedModels;

  /// The description of the Endpoint.
  core.String? description;

  /// The display name of the Endpoint.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Deprecated: If true, expose the Endpoint via private service connect.
  ///
  /// Only one of the fields, network or enable_private_service_connect, can be
  /// set.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enablePrivateServiceConnect;

  /// Customer-managed encryption key spec for an Endpoint.
  ///
  /// If set, this Endpoint and all sub-resources of this Endpoint will be
  /// secured by this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Configures the Google Distributed Cloud (GDC) environment for online
  /// prediction.
  ///
  /// Only set this field when the Endpoint is to be deployed in a GDC
  /// environment.
  GoogleCloudAiplatformV1beta1GdcConfig? gdcConfig;

  /// Configuration for GenAiAdvancedFeatures.
  ///
  /// If the endpoint is serving GenAI models, advanced features like native RAG
  /// integration can be configured. Currently, only Model Garden models are
  /// supported.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfig?
  genAiAdvancedFeaturesConfig;

  /// The labels with user-defined metadata to organize your Endpoints.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the Model Monitoring job associated with this Endpoint if
  /// monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  ///
  /// Output only.
  core.String? modelDeploymentMonitoringJob;

  /// The resource name of the Endpoint.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  /// to which the Endpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If
  /// left unspecified, the Endpoint is not peered with any network. Only one of
  /// the fields, network or enable_private_service_connect, can be set.
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`. Where `{project}` is a
  /// project number, as in `12345`, and `{network}` is network name.
  ///
  /// Optional.
  core.String? network;

  /// Configures the request-response logging for online prediction.
  GoogleCloudAiplatformV1beta1PredictRequestResponseLoggingConfig?
  predictRequestResponseLoggingConfig;

  /// Configuration for private service connect.
  ///
  /// network and private_service_connect_config are mutually exclusive.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig?
  privateServiceConnectConfig;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If a DeployedModel's ID is not listed in this map, then it receives no
  /// traffic. The traffic percentage values must add up to 100, or map must be
  /// empty if the Endpoint is to not accept any traffic at a moment.
  core.Map<core.String, core.int>? trafficSplit;

  /// Timestamp when this Endpoint was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Endpoint({
    this.clientConnectionConfig,
    this.createTime,
    this.dedicatedEndpointDns,
    this.dedicatedEndpointEnabled,
    this.deployedModels,
    this.description,
    this.displayName,
    this.enablePrivateServiceConnect,
    this.encryptionSpec,
    this.etag,
    this.gdcConfig,
    this.genAiAdvancedFeaturesConfig,
    this.labels,
    this.modelDeploymentMonitoringJob,
    this.name,
    this.network,
    this.predictRequestResponseLoggingConfig,
    this.privateServiceConnectConfig,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.trafficSplit,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Endpoint.fromJson(core.Map json_)
    : this(
        clientConnectionConfig:
            json_.containsKey('clientConnectionConfig')
                ? GoogleCloudAiplatformV1beta1ClientConnectionConfig.fromJson(
                  json_['clientConnectionConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        dedicatedEndpointDns: json_['dedicatedEndpointDns'] as core.String?,
        dedicatedEndpointEnabled:
            json_['dedicatedEndpointEnabled'] as core.bool?,
        deployedModels:
            (json_['deployedModels'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1DeployedModel.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        enablePrivateServiceConnect:
            json_['enablePrivateServiceConnect'] as core.bool?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        gdcConfig:
            json_.containsKey('gdcConfig')
                ? GoogleCloudAiplatformV1beta1GdcConfig.fromJson(
                  json_['gdcConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        genAiAdvancedFeaturesConfig:
            json_.containsKey('genAiAdvancedFeaturesConfig')
                ? GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfig.fromJson(
                  json_['genAiAdvancedFeaturesConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        modelDeploymentMonitoringJob:
            json_['modelDeploymentMonitoringJob'] as core.String?,
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        predictRequestResponseLoggingConfig:
            json_.containsKey('predictRequestResponseLoggingConfig')
                ? GoogleCloudAiplatformV1beta1PredictRequestResponseLoggingConfig.fromJson(
                  json_['predictRequestResponseLoggingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        privateServiceConnectConfig:
            json_.containsKey('privateServiceConnectConfig')
                ? GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig.fromJson(
                  json_['privateServiceConnectConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        trafficSplit: (json_['trafficSplit']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.int)),
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientConnectionConfig != null)
      'clientConnectionConfig': clientConnectionConfig!,
    if (createTime != null) 'createTime': createTime!,
    if (dedicatedEndpointDns != null)
      'dedicatedEndpointDns': dedicatedEndpointDns!,
    if (dedicatedEndpointEnabled != null)
      'dedicatedEndpointEnabled': dedicatedEndpointEnabled!,
    if (deployedModels != null) 'deployedModels': deployedModels!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (enablePrivateServiceConnect != null)
      'enablePrivateServiceConnect': enablePrivateServiceConnect!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (gdcConfig != null) 'gdcConfig': gdcConfig!,
    if (genAiAdvancedFeaturesConfig != null)
      'genAiAdvancedFeaturesConfig': genAiAdvancedFeaturesConfig!,
    if (labels != null) 'labels': labels!,
    if (modelDeploymentMonitoringJob != null)
      'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (predictRequestResponseLoggingConfig != null)
      'predictRequestResponseLoggingConfig':
          predictRequestResponseLoggingConfig!,
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (trafficSplit != null) 'trafficSplit': trafficSplit!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Tool to search public web data, powered by Vertex AI Search and Sec4
/// compliance.
typedef GoogleCloudAiplatformV1beta1EnterpriseWebSearch = $EnterpriseWebSearch;

/// Selector for entityId.
///
/// Getting ids from the given source.
class GoogleCloudAiplatformV1beta1EntityIdSelector {
  /// Source of Csv
  GoogleCloudAiplatformV1beta1CsvSource? csvSource;

  /// Source column that holds entity IDs.
  ///
  /// If not provided, entity IDs are extracted from the column named entity_id.
  core.String? entityIdField;

  GoogleCloudAiplatformV1beta1EntityIdSelector({
    this.csvSource,
    this.entityIdField,
  });

  GoogleCloudAiplatformV1beta1EntityIdSelector.fromJson(core.Map json_)
    : this(
        csvSource:
            json_.containsKey('csvSource')
                ? GoogleCloudAiplatformV1beta1CsvSource.fromJson(
                  json_['csvSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        entityIdField: json_['entityIdField'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (csvSource != null) 'csvSource': csvSource!,
    if (entityIdField != null) 'entityIdField': entityIdField!,
  };
}

/// An entity type is a type of object in a system that needs to be modeled and
/// have stored information about.
///
/// For example, driver is an entity type, and driver0 is an instance of an
/// entity type driver.
class GoogleCloudAiplatformV1beta1EntityType {
  /// Timestamp when this EntityType was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the EntityType.
  ///
  /// Optional.
  core.String? description;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your EntityTypes.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one EntityType (System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The default monitoring configuration for all Features with value type
  /// (Feature.ValueType) BOOL, STRING, DOUBLE or INT64 under this EntityType.
  ///
  /// If this is populated with
  /// \[FeaturestoreMonitoringConfig.monitoring_interval\] specified, snapshot
  /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is
  /// disabled.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfig? monitoringConfig;

  /// Name of the EntityType.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// The last part entity_type is assigned by the client. The entity_type can
  /// be up to 64 characters long and can consist only of ASCII Latin letters
  /// A-Z and a-z and underscore(_), and ASCII digits 0-9 starting with a
  /// letter. The value will be unique given a featurestore.
  ///
  /// Immutable.
  core.String? name;

  /// Config for data retention policy in offline storage.
  ///
  /// TTL in days for feature values that will be stored in offline storage. The
  /// Feature Store offline storage periodically removes obsolete feature values
  /// older than `offline_storage_ttl_days` since the feature generation time.
  /// If unset (or explicitly set to 0), default to 4000 days TTL.
  ///
  /// Optional.
  core.int? offlineStorageTtlDays;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this EntityType was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1EntityType({
    this.createTime,
    this.description,
    this.etag,
    this.labels,
    this.monitoringConfig,
    this.name,
    this.offlineStorageTtlDays,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1EntityType.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        monitoringConfig:
            json_.containsKey('monitoringConfig')
                ? GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfig.fromJson(
                  json_['monitoringConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        offlineStorageTtlDays: json_['offlineStorageTtlDays'] as core.int?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (monitoringConfig != null) 'monitoringConfig': monitoringConfig!,
    if (name != null) 'name': name!,
    if (offlineStorageTtlDays != null)
      'offlineStorageTtlDays': offlineStorageTtlDays!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Represents an environment variable present in a Container or Python Module.
typedef GoogleCloudAiplatformV1beta1EnvVar = $EnvVar;

/// Model error analysis for each annotation.
class GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotation {
  /// Attributed items for a given annotation, typically representing neighbors
  /// from the training sets constrained by the query type.
  core.List<GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotationAttributedItem>?
  attributedItems;

  /// The outlier score of this annotated item.
  ///
  /// Usually defined as the min of all distances from attributed items.
  core.double? outlierScore;

  /// The threshold used to determine if this annotation is an outlier or not.
  core.double? outlierThreshold;

  /// The query type used for finding the attributed items.
  /// Possible string values are:
  /// - "QUERY_TYPE_UNSPECIFIED" : Unspecified query type for model error
  /// analysis.
  /// - "ALL_SIMILAR" : Query similar samples across all classes in the dataset.
  /// - "SAME_CLASS_SIMILAR" : Query similar samples from the same class of the
  /// input sample.
  /// - "SAME_CLASS_DISSIMILAR" : Query dissimilar samples from the same class
  /// of the input sample.
  core.String? queryType;

  GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotation({
    this.attributedItems,
    this.outlierScore,
    this.outlierThreshold,
    this.queryType,
  });

  GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotation.fromJson(core.Map json_)
    : this(
        attributedItems:
            (json_['attributedItems'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotationAttributedItem.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        outlierScore: (json_['outlierScore'] as core.num?)?.toDouble(),
        outlierThreshold: (json_['outlierThreshold'] as core.num?)?.toDouble(),
        queryType: json_['queryType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributedItems != null) 'attributedItems': attributedItems!,
    if (outlierScore != null) 'outlierScore': outlierScore!,
    if (outlierThreshold != null) 'outlierThreshold': outlierThreshold!,
    if (queryType != null) 'queryType': queryType!,
  };
}

/// Attributed items for a given annotation, typically representing neighbors
/// from the training sets constrained by the query type.
typedef GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotationAttributedItem =
    $ErrorAnalysisAnnotationAttributedItem;

/// Request message for EvaluationService.EvaluateDataset.
class GoogleCloudAiplatformV1beta1EvaluateDatasetRequest {
  /// Autorater config used for evaluation.
  ///
  /// Currently only publisher Gemini models are supported. Format:
  /// `projects/{PROJECT}/locations/{LOCATION}/publishers/google/models/{MODEL}.`
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AutoraterConfig? autoraterConfig;

  /// The dataset used for evaluation.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1EvaluationDataset? dataset;

  /// The metrics used for evaluation.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Metric>? metrics;

  /// Config for evaluation output.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1OutputConfig? outputConfig;

  GoogleCloudAiplatformV1beta1EvaluateDatasetRequest({
    this.autoraterConfig,
    this.dataset,
    this.metrics,
    this.outputConfig,
  });

  GoogleCloudAiplatformV1beta1EvaluateDatasetRequest.fromJson(core.Map json_)
    : this(
        autoraterConfig:
            json_.containsKey('autoraterConfig')
                ? GoogleCloudAiplatformV1beta1AutoraterConfig.fromJson(
                  json_['autoraterConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        dataset:
            json_.containsKey('dataset')
                ? GoogleCloudAiplatformV1beta1EvaluationDataset.fromJson(
                  json_['dataset'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metrics:
            (json_['metrics'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Metric.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        outputConfig:
            json_.containsKey('outputConfig')
                ? GoogleCloudAiplatformV1beta1OutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!,
    if (dataset != null) 'dataset': dataset!,
    if (metrics != null) 'metrics': metrics!,
    if (outputConfig != null) 'outputConfig': outputConfig!,
  };
}

/// Request message for EvaluationService.EvaluateInstances.
class GoogleCloudAiplatformV1beta1EvaluateInstancesRequest {
  /// Autorater config used for evaluation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AutoraterConfig? autoraterConfig;

  /// Instances and metric spec for bleu metric.
  GoogleCloudAiplatformV1beta1BleuInput? bleuInput;

  /// Input for coherence metric.
  GoogleCloudAiplatformV1beta1CoherenceInput? coherenceInput;

  /// Translation metrics.
  ///
  /// Input for Comet metric.
  GoogleCloudAiplatformV1beta1CometInput? cometInput;

  /// Auto metric instances.
  ///
  /// Instances and metric spec for exact match metric.
  GoogleCloudAiplatformV1beta1ExactMatchInput? exactMatchInput;

  /// LLM-based metric instance.
  ///
  /// General text generation metrics, applicable to other categories. Input for
  /// fluency metric.
  GoogleCloudAiplatformV1beta1FluencyInput? fluencyInput;

  /// Input for fulfillment metric.
  GoogleCloudAiplatformV1beta1FulfillmentInput? fulfillmentInput;

  /// Input for groundedness metric.
  GoogleCloudAiplatformV1beta1GroundednessInput? groundednessInput;

  /// Input for Metricx metric.
  GoogleCloudAiplatformV1beta1MetricxInput? metricxInput;

  /// Input for pairwise metric.
  GoogleCloudAiplatformV1beta1PairwiseMetricInput? pairwiseMetricInput;

  /// Input for pairwise question answering quality metric.
  GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInput?
  pairwiseQuestionAnsweringQualityInput;

  /// Input for pairwise summarization quality metric.
  GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInput?
  pairwiseSummarizationQualityInput;

  /// Input for pointwise metric.
  GoogleCloudAiplatformV1beta1PointwiseMetricInput? pointwiseMetricInput;

  /// Input for question answering correctness metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInput?
  questionAnsweringCorrectnessInput;

  /// Input for question answering helpfulness metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInput?
  questionAnsweringHelpfulnessInput;

  /// Input for question answering quality metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInput?
  questionAnsweringQualityInput;

  /// Input for question answering relevance metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInput?
  questionAnsweringRelevanceInput;

  /// Instances and metric spec for rouge metric.
  GoogleCloudAiplatformV1beta1RougeInput? rougeInput;

  /// Rubric Based Instruction Following metric.
  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInput?
  rubricBasedInstructionFollowingInput;

  /// Input for safety metric.
  GoogleCloudAiplatformV1beta1SafetyInput? safetyInput;

  /// Input for summarization helpfulness metric.
  GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInput?
  summarizationHelpfulnessInput;

  /// Input for summarization quality metric.
  GoogleCloudAiplatformV1beta1SummarizationQualityInput?
  summarizationQualityInput;

  /// Input for summarization verbosity metric.
  GoogleCloudAiplatformV1beta1SummarizationVerbosityInput?
  summarizationVerbosityInput;

  /// Tool call metric instances.
  ///
  /// Input for tool call valid metric.
  GoogleCloudAiplatformV1beta1ToolCallValidInput? toolCallValidInput;

  /// Input for tool name match metric.
  GoogleCloudAiplatformV1beta1ToolNameMatchInput? toolNameMatchInput;

  /// Input for tool parameter key match metric.
  GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInput?
  toolParameterKeyMatchInput;

  /// Input for tool parameter key value match metric.
  GoogleCloudAiplatformV1beta1ToolParameterKVMatchInput?
  toolParameterKvMatchInput;

  /// Input for trajectory match any order metric.
  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInput?
  trajectoryAnyOrderMatchInput;

  /// Input for trajectory exact match metric.
  GoogleCloudAiplatformV1beta1TrajectoryExactMatchInput?
  trajectoryExactMatchInput;

  /// Input for trajectory in order match metric.
  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInput?
  trajectoryInOrderMatchInput;

  /// Input for trajectory precision metric.
  GoogleCloudAiplatformV1beta1TrajectoryPrecisionInput?
  trajectoryPrecisionInput;

  /// Input for trajectory recall metric.
  GoogleCloudAiplatformV1beta1TrajectoryRecallInput? trajectoryRecallInput;

  /// Input for trajectory single tool use metric.
  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInput?
  trajectorySingleToolUseInput;

  GoogleCloudAiplatformV1beta1EvaluateInstancesRequest({
    this.autoraterConfig,
    this.bleuInput,
    this.coherenceInput,
    this.cometInput,
    this.exactMatchInput,
    this.fluencyInput,
    this.fulfillmentInput,
    this.groundednessInput,
    this.metricxInput,
    this.pairwiseMetricInput,
    this.pairwiseQuestionAnsweringQualityInput,
    this.pairwiseSummarizationQualityInput,
    this.pointwiseMetricInput,
    this.questionAnsweringCorrectnessInput,
    this.questionAnsweringHelpfulnessInput,
    this.questionAnsweringQualityInput,
    this.questionAnsweringRelevanceInput,
    this.rougeInput,
    this.rubricBasedInstructionFollowingInput,
    this.safetyInput,
    this.summarizationHelpfulnessInput,
    this.summarizationQualityInput,
    this.summarizationVerbosityInput,
    this.toolCallValidInput,
    this.toolNameMatchInput,
    this.toolParameterKeyMatchInput,
    this.toolParameterKvMatchInput,
    this.trajectoryAnyOrderMatchInput,
    this.trajectoryExactMatchInput,
    this.trajectoryInOrderMatchInput,
    this.trajectoryPrecisionInput,
    this.trajectoryRecallInput,
    this.trajectorySingleToolUseInput,
  });

  GoogleCloudAiplatformV1beta1EvaluateInstancesRequest.fromJson(core.Map json_)
    : this(
        autoraterConfig:
            json_.containsKey('autoraterConfig')
                ? GoogleCloudAiplatformV1beta1AutoraterConfig.fromJson(
                  json_['autoraterConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        bleuInput:
            json_.containsKey('bleuInput')
                ? GoogleCloudAiplatformV1beta1BleuInput.fromJson(
                  json_['bleuInput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        coherenceInput:
            json_.containsKey('coherenceInput')
                ? GoogleCloudAiplatformV1beta1CoherenceInput.fromJson(
                  json_['coherenceInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        cometInput:
            json_.containsKey('cometInput')
                ? GoogleCloudAiplatformV1beta1CometInput.fromJson(
                  json_['cometInput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        exactMatchInput:
            json_.containsKey('exactMatchInput')
                ? GoogleCloudAiplatformV1beta1ExactMatchInput.fromJson(
                  json_['exactMatchInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        fluencyInput:
            json_.containsKey('fluencyInput')
                ? GoogleCloudAiplatformV1beta1FluencyInput.fromJson(
                  json_['fluencyInput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        fulfillmentInput:
            json_.containsKey('fulfillmentInput')
                ? GoogleCloudAiplatformV1beta1FulfillmentInput.fromJson(
                  json_['fulfillmentInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        groundednessInput:
            json_.containsKey('groundednessInput')
                ? GoogleCloudAiplatformV1beta1GroundednessInput.fromJson(
                  json_['groundednessInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricxInput:
            json_.containsKey('metricxInput')
                ? GoogleCloudAiplatformV1beta1MetricxInput.fromJson(
                  json_['metricxInput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        pairwiseMetricInput:
            json_.containsKey('pairwiseMetricInput')
                ? GoogleCloudAiplatformV1beta1PairwiseMetricInput.fromJson(
                  json_['pairwiseMetricInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pairwiseQuestionAnsweringQualityInput:
            json_.containsKey('pairwiseQuestionAnsweringQualityInput')
                ? GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInput.fromJson(
                  json_['pairwiseQuestionAnsweringQualityInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pairwiseSummarizationQualityInput:
            json_.containsKey('pairwiseSummarizationQualityInput')
                ? GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInput.fromJson(
                  json_['pairwiseSummarizationQualityInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pointwiseMetricInput:
            json_.containsKey('pointwiseMetricInput')
                ? GoogleCloudAiplatformV1beta1PointwiseMetricInput.fromJson(
                  json_['pointwiseMetricInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringCorrectnessInput:
            json_.containsKey('questionAnsweringCorrectnessInput')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInput.fromJson(
                  json_['questionAnsweringCorrectnessInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringHelpfulnessInput:
            json_.containsKey('questionAnsweringHelpfulnessInput')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInput.fromJson(
                  json_['questionAnsweringHelpfulnessInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringQualityInput:
            json_.containsKey('questionAnsweringQualityInput')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInput.fromJson(
                  json_['questionAnsweringQualityInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringRelevanceInput:
            json_.containsKey('questionAnsweringRelevanceInput')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInput.fromJson(
                  json_['questionAnsweringRelevanceInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        rougeInput:
            json_.containsKey('rougeInput')
                ? GoogleCloudAiplatformV1beta1RougeInput.fromJson(
                  json_['rougeInput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        rubricBasedInstructionFollowingInput:
            json_.containsKey('rubricBasedInstructionFollowingInput')
                ? GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInput.fromJson(
                  json_['rubricBasedInstructionFollowingInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        safetyInput:
            json_.containsKey('safetyInput')
                ? GoogleCloudAiplatformV1beta1SafetyInput.fromJson(
                  json_['safetyInput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarizationHelpfulnessInput:
            json_.containsKey('summarizationHelpfulnessInput')
                ? GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInput.fromJson(
                  json_['summarizationHelpfulnessInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarizationQualityInput:
            json_.containsKey('summarizationQualityInput')
                ? GoogleCloudAiplatformV1beta1SummarizationQualityInput.fromJson(
                  json_['summarizationQualityInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarizationVerbosityInput:
            json_.containsKey('summarizationVerbosityInput')
                ? GoogleCloudAiplatformV1beta1SummarizationVerbosityInput.fromJson(
                  json_['summarizationVerbosityInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolCallValidInput:
            json_.containsKey('toolCallValidInput')
                ? GoogleCloudAiplatformV1beta1ToolCallValidInput.fromJson(
                  json_['toolCallValidInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolNameMatchInput:
            json_.containsKey('toolNameMatchInput')
                ? GoogleCloudAiplatformV1beta1ToolNameMatchInput.fromJson(
                  json_['toolNameMatchInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolParameterKeyMatchInput:
            json_.containsKey('toolParameterKeyMatchInput')
                ? GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInput.fromJson(
                  json_['toolParameterKeyMatchInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolParameterKvMatchInput:
            json_.containsKey('toolParameterKvMatchInput')
                ? GoogleCloudAiplatformV1beta1ToolParameterKVMatchInput.fromJson(
                  json_['toolParameterKvMatchInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryAnyOrderMatchInput:
            json_.containsKey('trajectoryAnyOrderMatchInput')
                ? GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInput.fromJson(
                  json_['trajectoryAnyOrderMatchInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryExactMatchInput:
            json_.containsKey('trajectoryExactMatchInput')
                ? GoogleCloudAiplatformV1beta1TrajectoryExactMatchInput.fromJson(
                  json_['trajectoryExactMatchInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryInOrderMatchInput:
            json_.containsKey('trajectoryInOrderMatchInput')
                ? GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInput.fromJson(
                  json_['trajectoryInOrderMatchInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryPrecisionInput:
            json_.containsKey('trajectoryPrecisionInput')
                ? GoogleCloudAiplatformV1beta1TrajectoryPrecisionInput.fromJson(
                  json_['trajectoryPrecisionInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryRecallInput:
            json_.containsKey('trajectoryRecallInput')
                ? GoogleCloudAiplatformV1beta1TrajectoryRecallInput.fromJson(
                  json_['trajectoryRecallInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectorySingleToolUseInput:
            json_.containsKey('trajectorySingleToolUseInput')
                ? GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInput.fromJson(
                  json_['trajectorySingleToolUseInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!,
    if (bleuInput != null) 'bleuInput': bleuInput!,
    if (coherenceInput != null) 'coherenceInput': coherenceInput!,
    if (cometInput != null) 'cometInput': cometInput!,
    if (exactMatchInput != null) 'exactMatchInput': exactMatchInput!,
    if (fluencyInput != null) 'fluencyInput': fluencyInput!,
    if (fulfillmentInput != null) 'fulfillmentInput': fulfillmentInput!,
    if (groundednessInput != null) 'groundednessInput': groundednessInput!,
    if (metricxInput != null) 'metricxInput': metricxInput!,
    if (pairwiseMetricInput != null)
      'pairwiseMetricInput': pairwiseMetricInput!,
    if (pairwiseQuestionAnsweringQualityInput != null)
      'pairwiseQuestionAnsweringQualityInput':
          pairwiseQuestionAnsweringQualityInput!,
    if (pairwiseSummarizationQualityInput != null)
      'pairwiseSummarizationQualityInput': pairwiseSummarizationQualityInput!,
    if (pointwiseMetricInput != null)
      'pointwiseMetricInput': pointwiseMetricInput!,
    if (questionAnsweringCorrectnessInput != null)
      'questionAnsweringCorrectnessInput': questionAnsweringCorrectnessInput!,
    if (questionAnsweringHelpfulnessInput != null)
      'questionAnsweringHelpfulnessInput': questionAnsweringHelpfulnessInput!,
    if (questionAnsweringQualityInput != null)
      'questionAnsweringQualityInput': questionAnsweringQualityInput!,
    if (questionAnsweringRelevanceInput != null)
      'questionAnsweringRelevanceInput': questionAnsweringRelevanceInput!,
    if (rougeInput != null) 'rougeInput': rougeInput!,
    if (rubricBasedInstructionFollowingInput != null)
      'rubricBasedInstructionFollowingInput':
          rubricBasedInstructionFollowingInput!,
    if (safetyInput != null) 'safetyInput': safetyInput!,
    if (summarizationHelpfulnessInput != null)
      'summarizationHelpfulnessInput': summarizationHelpfulnessInput!,
    if (summarizationQualityInput != null)
      'summarizationQualityInput': summarizationQualityInput!,
    if (summarizationVerbosityInput != null)
      'summarizationVerbosityInput': summarizationVerbosityInput!,
    if (toolCallValidInput != null) 'toolCallValidInput': toolCallValidInput!,
    if (toolNameMatchInput != null) 'toolNameMatchInput': toolNameMatchInput!,
    if (toolParameterKeyMatchInput != null)
      'toolParameterKeyMatchInput': toolParameterKeyMatchInput!,
    if (toolParameterKvMatchInput != null)
      'toolParameterKvMatchInput': toolParameterKvMatchInput!,
    if (trajectoryAnyOrderMatchInput != null)
      'trajectoryAnyOrderMatchInput': trajectoryAnyOrderMatchInput!,
    if (trajectoryExactMatchInput != null)
      'trajectoryExactMatchInput': trajectoryExactMatchInput!,
    if (trajectoryInOrderMatchInput != null)
      'trajectoryInOrderMatchInput': trajectoryInOrderMatchInput!,
    if (trajectoryPrecisionInput != null)
      'trajectoryPrecisionInput': trajectoryPrecisionInput!,
    if (trajectoryRecallInput != null)
      'trajectoryRecallInput': trajectoryRecallInput!,
    if (trajectorySingleToolUseInput != null)
      'trajectorySingleToolUseInput': trajectorySingleToolUseInput!,
  };
}

/// Response message for EvaluationService.EvaluateInstances.
class GoogleCloudAiplatformV1beta1EvaluateInstancesResponse {
  /// Results for bleu metric.
  GoogleCloudAiplatformV1beta1BleuResults? bleuResults;

  /// Result for coherence metric.
  GoogleCloudAiplatformV1beta1CoherenceResult? coherenceResult;

  /// Translation metrics.
  ///
  /// Result for Comet metric.
  GoogleCloudAiplatformV1beta1CometResult? cometResult;

  /// Auto metric evaluation results.
  ///
  /// Results for exact match metric.
  GoogleCloudAiplatformV1beta1ExactMatchResults? exactMatchResults;

  /// LLM-based metric evaluation result.
  ///
  /// General text generation metrics, applicable to other categories. Result
  /// for fluency metric.
  GoogleCloudAiplatformV1beta1FluencyResult? fluencyResult;

  /// Result for fulfillment metric.
  GoogleCloudAiplatformV1beta1FulfillmentResult? fulfillmentResult;

  /// Result for groundedness metric.
  GoogleCloudAiplatformV1beta1GroundednessResult? groundednessResult;

  /// Result for Metricx metric.
  GoogleCloudAiplatformV1beta1MetricxResult? metricxResult;

  /// Result for pairwise metric.
  GoogleCloudAiplatformV1beta1PairwiseMetricResult? pairwiseMetricResult;

  /// Result for pairwise question answering quality metric.
  GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityResult?
  pairwiseQuestionAnsweringQualityResult;

  /// Result for pairwise summarization quality metric.
  GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityResult?
  pairwiseSummarizationQualityResult;

  /// Generic metrics.
  ///
  /// Result for pointwise metric.
  GoogleCloudAiplatformV1beta1PointwiseMetricResult? pointwiseMetricResult;

  /// Result for question answering correctness metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessResult?
  questionAnsweringCorrectnessResult;

  /// Result for question answering helpfulness metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessResult?
  questionAnsweringHelpfulnessResult;

  /// Question answering only metrics.
  ///
  /// Result for question answering quality metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringQualityResult?
  questionAnsweringQualityResult;

  /// Result for question answering relevance metric.
  GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceResult?
  questionAnsweringRelevanceResult;

  /// Results for rouge metric.
  GoogleCloudAiplatformV1beta1RougeResults? rougeResults;

  /// Result for rubric based instruction following metric.
  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingResult?
  rubricBasedInstructionFollowingResult;

  /// Result for safety metric.
  GoogleCloudAiplatformV1beta1SafetyResult? safetyResult;

  /// Result for summarization helpfulness metric.
  GoogleCloudAiplatformV1beta1SummarizationHelpfulnessResult?
  summarizationHelpfulnessResult;

  /// Summarization only metrics.
  ///
  /// Result for summarization quality metric.
  GoogleCloudAiplatformV1beta1SummarizationQualityResult?
  summarizationQualityResult;

  /// Result for summarization verbosity metric.
  GoogleCloudAiplatformV1beta1SummarizationVerbosityResult?
  summarizationVerbosityResult;

  /// Tool call metrics.
  ///
  /// Results for tool call valid metric.
  GoogleCloudAiplatformV1beta1ToolCallValidResults? toolCallValidResults;

  /// Results for tool name match metric.
  GoogleCloudAiplatformV1beta1ToolNameMatchResults? toolNameMatchResults;

  /// Results for tool parameter key match metric.
  GoogleCloudAiplatformV1beta1ToolParameterKeyMatchResults?
  toolParameterKeyMatchResults;

  /// Results for tool parameter key value match metric.
  GoogleCloudAiplatformV1beta1ToolParameterKVMatchResults?
  toolParameterKvMatchResults;

  /// Result for trajectory any order match metric.
  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchResults?
  trajectoryAnyOrderMatchResults;

  /// Result for trajectory exact match metric.
  GoogleCloudAiplatformV1beta1TrajectoryExactMatchResults?
  trajectoryExactMatchResults;

  /// Result for trajectory in order match metric.
  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchResults?
  trajectoryInOrderMatchResults;

  /// Result for trajectory precision metric.
  GoogleCloudAiplatformV1beta1TrajectoryPrecisionResults?
  trajectoryPrecisionResults;

  /// Results for trajectory recall metric.
  GoogleCloudAiplatformV1beta1TrajectoryRecallResults? trajectoryRecallResults;

  /// Results for trajectory single tool use metric.
  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseResults?
  trajectorySingleToolUseResults;

  GoogleCloudAiplatformV1beta1EvaluateInstancesResponse({
    this.bleuResults,
    this.coherenceResult,
    this.cometResult,
    this.exactMatchResults,
    this.fluencyResult,
    this.fulfillmentResult,
    this.groundednessResult,
    this.metricxResult,
    this.pairwiseMetricResult,
    this.pairwiseQuestionAnsweringQualityResult,
    this.pairwiseSummarizationQualityResult,
    this.pointwiseMetricResult,
    this.questionAnsweringCorrectnessResult,
    this.questionAnsweringHelpfulnessResult,
    this.questionAnsweringQualityResult,
    this.questionAnsweringRelevanceResult,
    this.rougeResults,
    this.rubricBasedInstructionFollowingResult,
    this.safetyResult,
    this.summarizationHelpfulnessResult,
    this.summarizationQualityResult,
    this.summarizationVerbosityResult,
    this.toolCallValidResults,
    this.toolNameMatchResults,
    this.toolParameterKeyMatchResults,
    this.toolParameterKvMatchResults,
    this.trajectoryAnyOrderMatchResults,
    this.trajectoryExactMatchResults,
    this.trajectoryInOrderMatchResults,
    this.trajectoryPrecisionResults,
    this.trajectoryRecallResults,
    this.trajectorySingleToolUseResults,
  });

  GoogleCloudAiplatformV1beta1EvaluateInstancesResponse.fromJson(core.Map json_)
    : this(
        bleuResults:
            json_.containsKey('bleuResults')
                ? GoogleCloudAiplatformV1beta1BleuResults.fromJson(
                  json_['bleuResults'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        coherenceResult:
            json_.containsKey('coherenceResult')
                ? GoogleCloudAiplatformV1beta1CoherenceResult.fromJson(
                  json_['coherenceResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        cometResult:
            json_.containsKey('cometResult')
                ? GoogleCloudAiplatformV1beta1CometResult.fromJson(
                  json_['cometResult'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        exactMatchResults:
            json_.containsKey('exactMatchResults')
                ? GoogleCloudAiplatformV1beta1ExactMatchResults.fromJson(
                  json_['exactMatchResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        fluencyResult:
            json_.containsKey('fluencyResult')
                ? GoogleCloudAiplatformV1beta1FluencyResult.fromJson(
                  json_['fluencyResult'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        fulfillmentResult:
            json_.containsKey('fulfillmentResult')
                ? GoogleCloudAiplatformV1beta1FulfillmentResult.fromJson(
                  json_['fulfillmentResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        groundednessResult:
            json_.containsKey('groundednessResult')
                ? GoogleCloudAiplatformV1beta1GroundednessResult.fromJson(
                  json_['groundednessResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricxResult:
            json_.containsKey('metricxResult')
                ? GoogleCloudAiplatformV1beta1MetricxResult.fromJson(
                  json_['metricxResult'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        pairwiseMetricResult:
            json_.containsKey('pairwiseMetricResult')
                ? GoogleCloudAiplatformV1beta1PairwiseMetricResult.fromJson(
                  json_['pairwiseMetricResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pairwiseQuestionAnsweringQualityResult:
            json_.containsKey('pairwiseQuestionAnsweringQualityResult')
                ? GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityResult.fromJson(
                  json_['pairwiseQuestionAnsweringQualityResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pairwiseSummarizationQualityResult:
            json_.containsKey('pairwiseSummarizationQualityResult')
                ? GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityResult.fromJson(
                  json_['pairwiseSummarizationQualityResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pointwiseMetricResult:
            json_.containsKey('pointwiseMetricResult')
                ? GoogleCloudAiplatformV1beta1PointwiseMetricResult.fromJson(
                  json_['pointwiseMetricResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringCorrectnessResult:
            json_.containsKey('questionAnsweringCorrectnessResult')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessResult.fromJson(
                  json_['questionAnsweringCorrectnessResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringHelpfulnessResult:
            json_.containsKey('questionAnsweringHelpfulnessResult')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessResult.fromJson(
                  json_['questionAnsweringHelpfulnessResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringQualityResult:
            json_.containsKey('questionAnsweringQualityResult')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringQualityResult.fromJson(
                  json_['questionAnsweringQualityResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        questionAnsweringRelevanceResult:
            json_.containsKey('questionAnsweringRelevanceResult')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceResult.fromJson(
                  json_['questionAnsweringRelevanceResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        rougeResults:
            json_.containsKey('rougeResults')
                ? GoogleCloudAiplatformV1beta1RougeResults.fromJson(
                  json_['rougeResults'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        rubricBasedInstructionFollowingResult:
            json_.containsKey('rubricBasedInstructionFollowingResult')
                ? GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingResult.fromJson(
                  json_['rubricBasedInstructionFollowingResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        safetyResult:
            json_.containsKey('safetyResult')
                ? GoogleCloudAiplatformV1beta1SafetyResult.fromJson(
                  json_['safetyResult'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarizationHelpfulnessResult:
            json_.containsKey('summarizationHelpfulnessResult')
                ? GoogleCloudAiplatformV1beta1SummarizationHelpfulnessResult.fromJson(
                  json_['summarizationHelpfulnessResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarizationQualityResult:
            json_.containsKey('summarizationQualityResult')
                ? GoogleCloudAiplatformV1beta1SummarizationQualityResult.fromJson(
                  json_['summarizationQualityResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarizationVerbosityResult:
            json_.containsKey('summarizationVerbosityResult')
                ? GoogleCloudAiplatformV1beta1SummarizationVerbosityResult.fromJson(
                  json_['summarizationVerbosityResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolCallValidResults:
            json_.containsKey('toolCallValidResults')
                ? GoogleCloudAiplatformV1beta1ToolCallValidResults.fromJson(
                  json_['toolCallValidResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolNameMatchResults:
            json_.containsKey('toolNameMatchResults')
                ? GoogleCloudAiplatformV1beta1ToolNameMatchResults.fromJson(
                  json_['toolNameMatchResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolParameterKeyMatchResults:
            json_.containsKey('toolParameterKeyMatchResults')
                ? GoogleCloudAiplatformV1beta1ToolParameterKeyMatchResults.fromJson(
                  json_['toolParameterKeyMatchResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolParameterKvMatchResults:
            json_.containsKey('toolParameterKvMatchResults')
                ? GoogleCloudAiplatformV1beta1ToolParameterKVMatchResults.fromJson(
                  json_['toolParameterKvMatchResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryAnyOrderMatchResults:
            json_.containsKey('trajectoryAnyOrderMatchResults')
                ? GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchResults.fromJson(
                  json_['trajectoryAnyOrderMatchResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryExactMatchResults:
            json_.containsKey('trajectoryExactMatchResults')
                ? GoogleCloudAiplatformV1beta1TrajectoryExactMatchResults.fromJson(
                  json_['trajectoryExactMatchResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryInOrderMatchResults:
            json_.containsKey('trajectoryInOrderMatchResults')
                ? GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchResults.fromJson(
                  json_['trajectoryInOrderMatchResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryPrecisionResults:
            json_.containsKey('trajectoryPrecisionResults')
                ? GoogleCloudAiplatformV1beta1TrajectoryPrecisionResults.fromJson(
                  json_['trajectoryPrecisionResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectoryRecallResults:
            json_.containsKey('trajectoryRecallResults')
                ? GoogleCloudAiplatformV1beta1TrajectoryRecallResults.fromJson(
                  json_['trajectoryRecallResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trajectorySingleToolUseResults:
            json_.containsKey('trajectorySingleToolUseResults')
                ? GoogleCloudAiplatformV1beta1TrajectorySingleToolUseResults.fromJson(
                  json_['trajectorySingleToolUseResults']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bleuResults != null) 'bleuResults': bleuResults!,
    if (coherenceResult != null) 'coherenceResult': coherenceResult!,
    if (cometResult != null) 'cometResult': cometResult!,
    if (exactMatchResults != null) 'exactMatchResults': exactMatchResults!,
    if (fluencyResult != null) 'fluencyResult': fluencyResult!,
    if (fulfillmentResult != null) 'fulfillmentResult': fulfillmentResult!,
    if (groundednessResult != null) 'groundednessResult': groundednessResult!,
    if (metricxResult != null) 'metricxResult': metricxResult!,
    if (pairwiseMetricResult != null)
      'pairwiseMetricResult': pairwiseMetricResult!,
    if (pairwiseQuestionAnsweringQualityResult != null)
      'pairwiseQuestionAnsweringQualityResult':
          pairwiseQuestionAnsweringQualityResult!,
    if (pairwiseSummarizationQualityResult != null)
      'pairwiseSummarizationQualityResult': pairwiseSummarizationQualityResult!,
    if (pointwiseMetricResult != null)
      'pointwiseMetricResult': pointwiseMetricResult!,
    if (questionAnsweringCorrectnessResult != null)
      'questionAnsweringCorrectnessResult': questionAnsweringCorrectnessResult!,
    if (questionAnsweringHelpfulnessResult != null)
      'questionAnsweringHelpfulnessResult': questionAnsweringHelpfulnessResult!,
    if (questionAnsweringQualityResult != null)
      'questionAnsweringQualityResult': questionAnsweringQualityResult!,
    if (questionAnsweringRelevanceResult != null)
      'questionAnsweringRelevanceResult': questionAnsweringRelevanceResult!,
    if (rougeResults != null) 'rougeResults': rougeResults!,
    if (rubricBasedInstructionFollowingResult != null)
      'rubricBasedInstructionFollowingResult':
          rubricBasedInstructionFollowingResult!,
    if (safetyResult != null) 'safetyResult': safetyResult!,
    if (summarizationHelpfulnessResult != null)
      'summarizationHelpfulnessResult': summarizationHelpfulnessResult!,
    if (summarizationQualityResult != null)
      'summarizationQualityResult': summarizationQualityResult!,
    if (summarizationVerbosityResult != null)
      'summarizationVerbosityResult': summarizationVerbosityResult!,
    if (toolCallValidResults != null)
      'toolCallValidResults': toolCallValidResults!,
    if (toolNameMatchResults != null)
      'toolNameMatchResults': toolNameMatchResults!,
    if (toolParameterKeyMatchResults != null)
      'toolParameterKeyMatchResults': toolParameterKeyMatchResults!,
    if (toolParameterKvMatchResults != null)
      'toolParameterKvMatchResults': toolParameterKvMatchResults!,
    if (trajectoryAnyOrderMatchResults != null)
      'trajectoryAnyOrderMatchResults': trajectoryAnyOrderMatchResults!,
    if (trajectoryExactMatchResults != null)
      'trajectoryExactMatchResults': trajectoryExactMatchResults!,
    if (trajectoryInOrderMatchResults != null)
      'trajectoryInOrderMatchResults': trajectoryInOrderMatchResults!,
    if (trajectoryPrecisionResults != null)
      'trajectoryPrecisionResults': trajectoryPrecisionResults!,
    if (trajectoryRecallResults != null)
      'trajectoryRecallResults': trajectoryRecallResults!,
    if (trajectorySingleToolUseResults != null)
      'trajectorySingleToolUseResults': trajectorySingleToolUseResults!,
  };
}

/// True positive, false positive, or false negative.
///
/// EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
/// of `annotationSpec` dimension.
class GoogleCloudAiplatformV1beta1EvaluatedAnnotation {
  /// The data item payload that the Model predicted this EvaluatedAnnotation
  /// on.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? dataItemPayload;

  /// Annotations of model error analysis results.
  core.List<GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotation>?
  errorAnalysisAnnotations;

  /// ID of the EvaluatedDataItemView under the same ancestor ModelEvaluation.
  ///
  /// The EvaluatedDataItemView consists of all ground truths and predictions on
  /// data_item_payload.
  ///
  /// Output only.
  core.String? evaluatedDataItemViewId;

  /// Explanations of predictions.
  ///
  /// Each element of the explanations indicates the explanation for one
  /// explanation Method. The attributions list in the
  /// EvaluatedAnnotationExplanation.explanation object corresponds to the
  /// predictions list. For example, the second element in the attributions list
  /// explains the second element in the predictions list.
  core.List<GoogleCloudAiplatformV1beta1EvaluatedAnnotationExplanation>?
  explanations;

  /// The ground truth Annotations, i.e. the Annotations that exist in the test
  /// data the Model is evaluated on.
  ///
  /// For true positive, there is one and only one ground truth annotation,
  /// which matches the only prediction in predictions. For false positive,
  /// there are zero or more ground truth annotations that are similar to the
  /// only prediction in predictions, but not enough for a match. For false
  /// negative, there is one and only one ground truth annotation, which doesn't
  /// match any predictions created by the model. The schema of the ground truth
  /// is stored in ModelEvaluation.annotation_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? groundTruths;

  /// The model predicted annotations.
  ///
  /// For true positive, there is one and only one prediction, which matches the
  /// only one ground truth annotation in ground_truths. For false positive,
  /// there is one and only one prediction, which doesn't match any ground truth
  /// annotation of the corresponding data_item_view_id. For false negative,
  /// there are zero or more predictions which are similar to the only ground
  /// truth annotation in ground_truths but not enough for a match. The schema
  /// of the prediction is stored in ModelEvaluation.annotation_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  /// Type of the EvaluatedAnnotation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED" : Invalid value.
  /// - "TRUE_POSITIVE" : The EvaluatedAnnotation is a true positive. It has a
  /// prediction created by the Model and a ground truth Annotation which the
  /// prediction matches.
  /// - "FALSE_POSITIVE" : The EvaluatedAnnotation is false positive. It has a
  /// prediction created by the Model which does not match any ground truth
  /// annotation.
  /// - "FALSE_NEGATIVE" : The EvaluatedAnnotation is false negative. It has a
  /// ground truth annotation which is not matched by any of the model created
  /// predictions.
  core.String? type;

  GoogleCloudAiplatformV1beta1EvaluatedAnnotation({
    this.dataItemPayload,
    this.errorAnalysisAnnotations,
    this.evaluatedDataItemViewId,
    this.explanations,
    this.groundTruths,
    this.predictions,
    this.type,
  });

  GoogleCloudAiplatformV1beta1EvaluatedAnnotation.fromJson(core.Map json_)
    : this(
        dataItemPayload: json_['dataItemPayload'],
        errorAnalysisAnnotations:
            (json_['errorAnalysisAnnotations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ErrorAnalysisAnnotation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        evaluatedDataItemViewId:
            json_['evaluatedDataItemViewId'] as core.String?,
        explanations:
            (json_['explanations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1EvaluatedAnnotationExplanation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        groundTruths:
            json_.containsKey('groundTruths')
                ? json_['groundTruths'] as core.List
                : null,
        predictions:
            json_.containsKey('predictions')
                ? json_['predictions'] as core.List
                : null,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataItemPayload != null) 'dataItemPayload': dataItemPayload!,
    if (errorAnalysisAnnotations != null)
      'errorAnalysisAnnotations': errorAnalysisAnnotations!,
    if (evaluatedDataItemViewId != null)
      'evaluatedDataItemViewId': evaluatedDataItemViewId!,
    if (explanations != null) 'explanations': explanations!,
    if (groundTruths != null) 'groundTruths': groundTruths!,
    if (predictions != null) 'predictions': predictions!,
    if (type != null) 'type': type!,
  };
}

/// Explanation result of the prediction produced by the Model.
class GoogleCloudAiplatformV1beta1EvaluatedAnnotationExplanation {
  /// Explanation attribution response details.
  GoogleCloudAiplatformV1beta1Explanation? explanation;

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are: *
  /// `image-integrated-gradients` * `image-xrai`
  core.String? explanationType;

  GoogleCloudAiplatformV1beta1EvaluatedAnnotationExplanation({
    this.explanation,
    this.explanationType,
  });

  GoogleCloudAiplatformV1beta1EvaluatedAnnotationExplanation.fromJson(
    core.Map json_,
  ) : this(
        explanation:
            json_.containsKey('explanation')
                ? GoogleCloudAiplatformV1beta1Explanation.fromJson(
                  json_['explanation'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        explanationType: json_['explanationType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (explanation != null) 'explanation': explanation!,
    if (explanationType != null) 'explanationType': explanationType!,
  };
}

/// The dataset used for evaluation.
class GoogleCloudAiplatformV1beta1EvaluationDataset {
  /// BigQuery source holds the dataset.
  GoogleCloudAiplatformV1beta1BigQuerySource? bigquerySource;

  /// Cloud storage source holds the dataset.
  ///
  /// Currently only one Cloud Storage file path is supported.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  GoogleCloudAiplatformV1beta1EvaluationDataset({
    this.bigquerySource,
    this.gcsSource,
  });

  GoogleCloudAiplatformV1beta1EvaluationDataset.fromJson(core.Map json_)
    : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudAiplatformV1beta1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
  };
}

/// An edge describing the relationship between an Artifact and an Execution in
/// a lineage graph.
typedef GoogleCloudAiplatformV1beta1Event = $Event;

/// Actions are parts of events that are executed by the agent.
class GoogleCloudAiplatformV1beta1EventActions {
  /// Indicates that the event is updating an artifact.
  ///
  /// key is the filename, value is the version.
  ///
  /// Optional.
  core.Map<core.String, core.int>? artifactDelta;

  /// The agent is escalating to a higher level agent.
  ///
  /// Optional.
  core.bool? escalate;

  /// Will only be set by a tool response indicating tool request euc.
  ///
  /// Struct key is the function call id since one function call response (from
  /// model) could correspond to multiple function calls. Struct value is the
  /// required auth config, which can be another struct.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? requestedAuthConfigs;

  /// If true, it won't call model to summarize function response.
  ///
  /// Only used for function_response event.
  ///
  /// Optional.
  core.bool? skipSummarization;

  /// Indicates that the event is updating the state with the given delta.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? stateDelta;

  /// If set, the event transfers to the specified agent.
  ///
  /// Optional.
  core.String? transferAgent;

  /// If set, the event transfers to the specified agent.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? transferToAgent;

  GoogleCloudAiplatformV1beta1EventActions({
    this.artifactDelta,
    this.escalate,
    this.requestedAuthConfigs,
    this.skipSummarization,
    this.stateDelta,
    this.transferAgent,
    this.transferToAgent,
  });

  GoogleCloudAiplatformV1beta1EventActions.fromJson(core.Map json_)
    : this(
        artifactDelta: (json_['artifactDelta']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.int)),
        escalate: json_['escalate'] as core.bool?,
        requestedAuthConfigs:
            json_.containsKey('requestedAuthConfigs')
                ? json_['requestedAuthConfigs']
                    as core.Map<core.String, core.dynamic>
                : null,
        skipSummarization: json_['skipSummarization'] as core.bool?,
        stateDelta:
            json_.containsKey('stateDelta')
                ? json_['stateDelta'] as core.Map<core.String, core.dynamic>
                : null,
        transferAgent: json_['transferAgent'] as core.String?,
        transferToAgent: json_['transferToAgent'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactDelta != null) 'artifactDelta': artifactDelta!,
    if (escalate != null) 'escalate': escalate!,
    if (requestedAuthConfigs != null)
      'requestedAuthConfigs': requestedAuthConfigs!,
    if (skipSummarization != null) 'skipSummarization': skipSummarization!,
    if (stateDelta != null) 'stateDelta': stateDelta!,
    if (transferAgent != null) 'transferAgent': transferAgent!,
    if (transferToAgent != null) 'transferToAgent': transferToAgent!,
  };
}

/// Metadata relating to a LLM response event.
class GoogleCloudAiplatformV1beta1EventMetadata {
  /// The branch of the event.
  ///
  /// The format is like agent_1.agent_2.agent_3, where agent_1 is the parent of
  /// agent_2, and agent_2 is the parent of agent_3. Branch is used when
  /// multiple child agents shouldn't see their siblings' conversation history.
  ///
  /// Optional.
  core.String? branch;

  /// The custom metadata of the LlmResponse.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? customMetadata;

  /// Metadata returned to client when grounding is enabled.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GroundingMetadata? groundingMetadata;

  /// Flag indicating that LLM was interrupted when generating the content.
  ///
  /// Usually it's due to user interruption during a bidi streaming.
  ///
  /// Optional.
  core.bool? interrupted;

  /// Set of ids of the long running function calls.
  ///
  /// Agent client will know from this field about which function call is long
  /// running. Only valid for function call event.
  ///
  /// Optional.
  core.List<core.String>? longRunningToolIds;

  /// Indicates whether the text content is part of a unfinished text stream.
  ///
  /// Only used for streaming mode and when the content is plain text.
  ///
  /// Optional.
  core.bool? partial;

  /// Indicates whether the response from the model is complete.
  ///
  /// Only used for streaming mode.
  ///
  /// Optional.
  core.bool? turnComplete;

  GoogleCloudAiplatformV1beta1EventMetadata({
    this.branch,
    this.customMetadata,
    this.groundingMetadata,
    this.interrupted,
    this.longRunningToolIds,
    this.partial,
    this.turnComplete,
  });

  GoogleCloudAiplatformV1beta1EventMetadata.fromJson(core.Map json_)
    : this(
        branch: json_['branch'] as core.String?,
        customMetadata:
            json_.containsKey('customMetadata')
                ? json_['customMetadata'] as core.Map<core.String, core.dynamic>
                : null,
        groundingMetadata:
            json_.containsKey('groundingMetadata')
                ? GoogleCloudAiplatformV1beta1GroundingMetadata.fromJson(
                  json_['groundingMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        interrupted: json_['interrupted'] as core.bool?,
        longRunningToolIds:
            (json_['longRunningToolIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        partial: json_['partial'] as core.bool?,
        turnComplete: json_['turnComplete'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (branch != null) 'branch': branch!,
    if (customMetadata != null) 'customMetadata': customMetadata!,
    if (groundingMetadata != null) 'groundingMetadata': groundingMetadata!,
    if (interrupted != null) 'interrupted': interrupted!,
    if (longRunningToolIds != null) 'longRunningToolIds': longRunningToolIds!,
    if (partial != null) 'partial': partial!,
    if (turnComplete != null) 'turnComplete': turnComplete!,
  };
}

/// Input for exact match metric.
class GoogleCloudAiplatformV1beta1ExactMatchInput {
  /// Repeated exact match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ExactMatchInstance>? instances;

  /// Spec for exact match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ExactMatchSpec? metricSpec;

  GoogleCloudAiplatformV1beta1ExactMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1ExactMatchInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ExactMatchInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1ExactMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for exact match instance.
typedef GoogleCloudAiplatformV1beta1ExactMatchInstance = $Instance00;

/// Exact match metric value for an instance.
typedef GoogleCloudAiplatformV1beta1ExactMatchMetricValue =
    $ExactMatchMetricValue;

/// Results for exact match metric.
class GoogleCloudAiplatformV1beta1ExactMatchResults {
  /// Exact match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ExactMatchMetricValue>?
  exactMatchMetricValues;

  GoogleCloudAiplatformV1beta1ExactMatchResults({this.exactMatchMetricValues});

  GoogleCloudAiplatformV1beta1ExactMatchResults.fromJson(core.Map json_)
    : this(
        exactMatchMetricValues:
            (json_['exactMatchMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ExactMatchMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exactMatchMetricValues != null)
      'exactMatchMetricValues': exactMatchMetricValues!,
  };
}

/// Spec for exact match metric - returns 1 if prediction and reference exactly
/// matches, otherwise 0.
typedef GoogleCloudAiplatformV1beta1ExactMatchSpec = $Empty;

class GoogleCloudAiplatformV1beta1Example {
  /// Timestamp when this Example was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name for Example.
  ///
  /// Optional.
  core.String? displayName;

  /// Unique identifier of an example.
  ///
  /// If not specified when upserting new examples, the example_id will be
  /// generated.
  ///
  /// Optional. Immutable.
  core.String? exampleId;

  /// An example of chat history and its expected outcome to be used with
  /// GenerateContent.
  GoogleCloudAiplatformV1beta1StoredContentsExample? storedContentsExample;

  GoogleCloudAiplatformV1beta1Example({
    this.createTime,
    this.displayName,
    this.exampleId,
    this.storedContentsExample,
  });

  GoogleCloudAiplatformV1beta1Example.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        exampleId: json_['exampleId'] as core.String?,
        storedContentsExample:
            json_.containsKey('storedContentsExample')
                ? GoogleCloudAiplatformV1beta1StoredContentsExample.fromJson(
                  json_['storedContentsExample']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (exampleId != null) 'exampleId': exampleId!,
    if (storedContentsExample != null)
      'storedContentsExample': storedContentsExample!,
  };
}

/// Represents an executable service to manage and retrieve examples.
class GoogleCloudAiplatformV1beta1ExampleStore {
  /// Timestamp when this ExampleStore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the ExampleStore.
  ///
  /// Optional.
  core.String? description;

  /// Display name of the ExampleStore.
  ///
  /// Required.
  core.String? displayName;

  /// Example Store config.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ExampleStoreConfig? exampleStoreConfig;

  /// Identifier.
  ///
  /// The resource name of the ExampleStore. This is a unique identifier.
  /// Format:
  /// projects/{project}/locations/{location}/exampleStores/{example_store}
  core.String? name;

  /// Timestamp when this ExampleStore was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1ExampleStore({
    this.createTime,
    this.description,
    this.displayName,
    this.exampleStoreConfig,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1ExampleStore.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        exampleStoreConfig:
            json_.containsKey('exampleStoreConfig')
                ? GoogleCloudAiplatformV1beta1ExampleStoreConfig.fromJson(
                  json_['exampleStoreConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (exampleStoreConfig != null) 'exampleStoreConfig': exampleStoreConfig!,
    if (name != null) 'name': name!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Configuration for the Example Store.
class GoogleCloudAiplatformV1beta1ExampleStoreConfig {
  /// The embedding model to be used for vector embedding.
  ///
  /// Immutable. Supported models: * "text-embedding-005" *
  /// "text-multilingual-embedding-002"
  ///
  /// Required.
  core.String? vertexEmbeddingModel;

  GoogleCloudAiplatformV1beta1ExampleStoreConfig({this.vertexEmbeddingModel});

  GoogleCloudAiplatformV1beta1ExampleStoreConfig.fromJson(core.Map json_)
    : this(vertexEmbeddingModel: json_['vertexEmbeddingModel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (vertexEmbeddingModel != null)
      'vertexEmbeddingModel': vertexEmbeddingModel!,
  };
}

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
class GoogleCloudAiplatformV1beta1Examples {
  /// The Cloud Storage input instances.
  GoogleCloudAiplatformV1beta1ExamplesExampleGcsSource? exampleGcsSource;

  /// The Cloud Storage locations that contain the instances to be indexed for
  /// approximate nearest neighbor search.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  /// The full configuration for the generated index, the semantics are the same
  /// as metadata and should match
  /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? nearestNeighborSearchConfig;

  /// The number of neighbors to return when querying for examples.
  core.int? neighborCount;

  /// Simplified preset configuration, which automatically sets configuration
  /// values based on the desired query speed-precision trade-off and modality.
  GoogleCloudAiplatformV1beta1Presets? presets;

  GoogleCloudAiplatformV1beta1Examples({
    this.exampleGcsSource,
    this.gcsSource,
    this.nearestNeighborSearchConfig,
    this.neighborCount,
    this.presets,
  });

  GoogleCloudAiplatformV1beta1Examples.fromJson(core.Map json_)
    : this(
        exampleGcsSource:
            json_.containsKey('exampleGcsSource')
                ? GoogleCloudAiplatformV1beta1ExamplesExampleGcsSource.fromJson(
                  json_['exampleGcsSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        nearestNeighborSearchConfig: json_['nearestNeighborSearchConfig'],
        neighborCount: json_['neighborCount'] as core.int?,
        presets:
            json_.containsKey('presets')
                ? GoogleCloudAiplatformV1beta1Presets.fromJson(
                  json_['presets'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exampleGcsSource != null) 'exampleGcsSource': exampleGcsSource!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (nearestNeighborSearchConfig != null)
      'nearestNeighborSearchConfig': nearestNeighborSearchConfig!,
    if (neighborCount != null) 'neighborCount': neighborCount!,
    if (presets != null) 'presets': presets!,
  };
}

/// Filters for examples' array metadata fields.
///
/// An array field is example metadata where multiple values are attributed to a
/// single example.
class GoogleCloudAiplatformV1beta1ExamplesArrayFilter {
  /// The operator logic to use for filtering.
  ///
  /// Required.
  /// Possible string values are:
  /// - "ARRAY_OPERATOR_UNSPECIFIED" : Not specified. This value should not be
  /// used.
  /// - "CONTAINS_ANY" : The metadata array field in the example must contain at
  /// least one of the values.
  /// - "CONTAINS_ALL" : The metadata array field in the example must contain
  /// all of the values.
  core.String? arrayOperator;

  /// The values by which to filter examples.
  ///
  /// Required.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1beta1ExamplesArrayFilter({
    this.arrayOperator,
    this.values,
  });

  GoogleCloudAiplatformV1beta1ExamplesArrayFilter.fromJson(core.Map json_)
    : this(
        arrayOperator: json_['arrayOperator'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (arrayOperator != null) 'arrayOperator': arrayOperator!,
    if (values != null) 'values': values!,
  };
}

/// The Cloud Storage input instances.
class GoogleCloudAiplatformV1beta1ExamplesExampleGcsSource {
  /// The format in which instances are given, if not specified, assume it's
  /// JSONL format.
  ///
  /// Currently only JSONL format is supported.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Format unspecified, used when unset.
  /// - "JSONL" : Examples are stored in JSONL files.
  core.String? dataFormat;

  /// The Cloud Storage location for the input instances.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  GoogleCloudAiplatformV1beta1ExamplesExampleGcsSource({
    this.dataFormat,
    this.gcsSource,
  });

  GoogleCloudAiplatformV1beta1ExamplesExampleGcsSource.fromJson(core.Map json_)
    : this(
        dataFormat: json_['dataFormat'] as core.String?,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
  };
}

/// Overrides for example-based explanations.
class GoogleCloudAiplatformV1beta1ExamplesOverride {
  /// The number of neighbors to return that have the same crowding tag.
  core.int? crowdingCount;

  /// The format of the data being provided with each call.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Unspecified format. Must not be used.
  /// - "INSTANCES" : Provided data is a set of model inputs.
  /// - "EMBEDDINGS" : Provided data is a set of embeddings.
  core.String? dataFormat;

  /// The number of neighbors to return.
  core.int? neighborCount;

  /// Restrict the resulting nearest neighbors to respect these constraints.
  core.List<GoogleCloudAiplatformV1beta1ExamplesRestrictionsNamespace>?
  restrictions;

  /// If true, return the embeddings instead of neighbors.
  core.bool? returnEmbeddings;

  GoogleCloudAiplatformV1beta1ExamplesOverride({
    this.crowdingCount,
    this.dataFormat,
    this.neighborCount,
    this.restrictions,
    this.returnEmbeddings,
  });

  GoogleCloudAiplatformV1beta1ExamplesOverride.fromJson(core.Map json_)
    : this(
        crowdingCount: json_['crowdingCount'] as core.int?,
        dataFormat: json_['dataFormat'] as core.String?,
        neighborCount: json_['neighborCount'] as core.int?,
        restrictions:
            (json_['restrictions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ExamplesRestrictionsNamespace.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        returnEmbeddings: json_['returnEmbeddings'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (crowdingCount != null) 'crowdingCount': crowdingCount!,
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (neighborCount != null) 'neighborCount': neighborCount!,
    if (restrictions != null) 'restrictions': restrictions!,
    if (returnEmbeddings != null) 'returnEmbeddings': returnEmbeddings!,
  };
}

/// Restrictions namespace for example-based explanations overrides.
typedef GoogleCloudAiplatformV1beta1ExamplesRestrictionsNamespace =
    $ExamplesRestrictionsNamespace;

/// Code generated by the model that is meant to be executed, and the result
/// returned to the model.
///
/// Generated when using the \[CodeExecution\] tool, in which the code will be
/// automatically executed, and a corresponding \[CodeExecutionResult\] will
/// also be generated.
typedef GoogleCloudAiplatformV1beta1ExecutableCode = $ExecutableCode;

/// Request message for ExtensionExecutionService.ExecuteExtension.
class GoogleCloudAiplatformV1beta1ExecuteExtensionRequest {
  /// The desired ID of the operation to be executed in this extension as
  /// defined in ExtensionOperation.operation_id.
  ///
  /// Required.
  core.String? operationId;

  /// Request parameters that will be used for executing this operation.
  ///
  /// The struct should be in a form of map with param name as the key and
  /// actual param value as the value. E.g. If this operation requires a param
  /// "name" to be set to "abc". you can set this to something like {"name":
  /// "abc"}.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? operationParams;

  /// Auth config provided at runtime to override the default value in
  /// Extension.manifest.auth_config.
  ///
  /// The AuthConfig.auth_type should match the value in
  /// Extension.manifest.auth_config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AuthConfig? runtimeAuthConfig;

  GoogleCloudAiplatformV1beta1ExecuteExtensionRequest({
    this.operationId,
    this.operationParams,
    this.runtimeAuthConfig,
  });

  GoogleCloudAiplatformV1beta1ExecuteExtensionRequest.fromJson(core.Map json_)
    : this(
        operationId: json_['operationId'] as core.String?,
        operationParams:
            json_.containsKey('operationParams')
                ? json_['operationParams']
                    as core.Map<core.String, core.dynamic>
                : null,
        runtimeAuthConfig:
            json_.containsKey('runtimeAuthConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfig.fromJson(
                  json_['runtimeAuthConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (operationId != null) 'operationId': operationId!,
    if (operationParams != null) 'operationParams': operationParams!,
    if (runtimeAuthConfig != null) 'runtimeAuthConfig': runtimeAuthConfig!,
  };
}

/// Response message for ExtensionExecutionService.ExecuteExtension.
class GoogleCloudAiplatformV1beta1ExecuteExtensionResponse {
  /// Response content from the extension.
  ///
  /// The content should be conformant to the response.content schema in the
  /// extension's manifest/OpenAPI spec.
  core.String? content;

  GoogleCloudAiplatformV1beta1ExecuteExtensionResponse({this.content});

  GoogleCloudAiplatformV1beta1ExecuteExtensionResponse.fromJson(core.Map json_)
    : this(content: json_['content'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Instance of a general execution.
typedef GoogleCloudAiplatformV1beta1Execution = $Execution;

/// Request message for PredictionService.Explain.
class GoogleCloudAiplatformV1beta1ExplainRequest {
  /// This field is the same as the one above, but supports multiple
  /// explanations to occur in parallel.
  ///
  /// The key can be any string. Each override will be run against the model,
  /// then its explanations will be grouped together. Note - these explanations
  /// are run **In Addition** to the default Explanation in the deployed model.
  ///
  /// Optional.
  core.Map<core.String, GoogleCloudAiplatformV1beta1ExplanationSpecOverride>?
  concurrentExplanationSpecOverride;

  /// If specified, this ExplainRequest will be served by the chosen
  /// DeployedModel, overriding Endpoint.traffic_split.
  core.String? deployedModelId;

  /// If specified, overrides the explanation_spec of the DeployedModel.
  ///
  /// Can be used for explaining prediction results with different
  /// configurations, such as: - Explaining top-5 predictions results as opposed
  /// to top-1; - Increasing path count or step count of the attribution methods
  /// to reduce approximate errors; - Using different baselines for explaining
  /// the prediction results.
  GoogleCloudAiplatformV1beta1ExplanationSpecOverride? explanationSpecOverride;

  /// The instances that are the input to the explanation call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the explanation call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  GoogleCloudAiplatformV1beta1ExplainRequest({
    this.concurrentExplanationSpecOverride,
    this.deployedModelId,
    this.explanationSpecOverride,
    this.instances,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1ExplainRequest.fromJson(core.Map json_)
    : this(
        concurrentExplanationSpecOverride:
            (json_['concurrentExplanationSpecOverride']
                    as core.Map<core.String, core.dynamic>?)
                ?.map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1beta1ExplanationSpecOverride.fromJson(
                      value as core.Map<core.String, core.dynamic>,
                    ),
                  ),
                ),
        deployedModelId: json_['deployedModelId'] as core.String?,
        explanationSpecOverride:
            json_.containsKey('explanationSpecOverride')
                ? GoogleCloudAiplatformV1beta1ExplanationSpecOverride.fromJson(
                  json_['explanationSpecOverride']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        instances:
            json_.containsKey('instances')
                ? json_['instances'] as core.List
                : null,
        parameters: json_['parameters'],
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (concurrentExplanationSpecOverride != null)
      'concurrentExplanationSpecOverride': concurrentExplanationSpecOverride!,
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (explanationSpecOverride != null)
      'explanationSpecOverride': explanationSpecOverride!,
    if (instances != null) 'instances': instances!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Response message for PredictionService.Explain.
class GoogleCloudAiplatformV1beta1ExplainResponse {
  /// This field stores the results of the explanations run in parallel with The
  /// default explanation strategy/method.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ExplainResponseConcurrentExplanation
  >?
  concurrentExplanations;

  /// ID of the Endpoint's DeployedModel that served this explanation.
  core.String? deployedModelId;

  /// The explanations of the Model's PredictResponse.predictions.
  ///
  /// It has the same number of elements as instances to be explained.
  core.List<GoogleCloudAiplatformV1beta1Explanation>? explanations;

  /// The predictions that are the output of the predictions call.
  ///
  /// Same as PredictResponse.predictions.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  GoogleCloudAiplatformV1beta1ExplainResponse({
    this.concurrentExplanations,
    this.deployedModelId,
    this.explanations,
    this.predictions,
  });

  GoogleCloudAiplatformV1beta1ExplainResponse.fromJson(core.Map json_)
    : this(
        concurrentExplanations: (json_['concurrentExplanations']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1ExplainResponseConcurrentExplanation.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        deployedModelId: json_['deployedModelId'] as core.String?,
        explanations:
            (json_['explanations'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Explanation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        predictions:
            json_.containsKey('predictions')
                ? json_['predictions'] as core.List
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (concurrentExplanations != null)
      'concurrentExplanations': concurrentExplanations!,
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (explanations != null) 'explanations': explanations!,
    if (predictions != null) 'predictions': predictions!,
  };
}

/// This message is a wrapper grouping Concurrent Explanations.
class GoogleCloudAiplatformV1beta1ExplainResponseConcurrentExplanation {
  /// The explanations of the Model's PredictResponse.predictions.
  ///
  /// It has the same number of elements as instances to be explained.
  core.List<GoogleCloudAiplatformV1beta1Explanation>? explanations;

  GoogleCloudAiplatformV1beta1ExplainResponseConcurrentExplanation({
    this.explanations,
  });

  GoogleCloudAiplatformV1beta1ExplainResponseConcurrentExplanation.fromJson(
    core.Map json_,
  ) : this(
        explanations:
            (json_['explanations'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Explanation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (explanations != null) 'explanations': explanations!,
  };
}

/// Explanation of a prediction (provided in PredictResponse.predictions)
/// produced by the Model on a given instance.
class GoogleCloudAiplatformV1beta1Explanation {
  /// Feature attributions grouped by predicted outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item. Attribution.output_index can be used to identify which
  /// output this attribution is explaining. By default, we provide Shapley
  /// values for the predicted class. However, you can configure the explanation
  /// request to generate Shapley values for any other classes too. For example,
  /// if a model predicts a probability of `0.4` for approving a loan
  /// application, the model's decision is to reject the application since
  /// `p(reject) = 0.6 > p(approve) = 0.4`, and the default Shapley values would
  /// be computed for rejection decision and not approval, even though the
  /// latter might be the positive class. If users set
  /// ExplanationParameters.top_k, the attributions are sorted by
  /// instance_output_value in descending order. If
  /// ExplanationParameters.output_indices is specified, the attributions are
  /// stored by Attribution.output_index in the same order as they appear in the
  /// output_indices.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Attribution>? attributions;

  /// List of the nearest neighbors for example-based explanations.
  ///
  /// For models deployed with the examples explanations feature enabled, the
  /// attributions field is empty and instead the neighbors field is populated.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Neighbor>? neighbors;

  GoogleCloudAiplatformV1beta1Explanation({this.attributions, this.neighbors});

  GoogleCloudAiplatformV1beta1Explanation.fromJson(core.Map json_)
    : this(
        attributions:
            (json_['attributions'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Attribution.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        neighbors:
            (json_['neighbors'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Neighbor.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributions != null) 'attributions': attributions!,
    if (neighbors != null) 'neighbors': neighbors!,
  };
}

/// Metadata describing the Model's input and output for explanation.
class GoogleCloudAiplatformV1beta1ExplanationMetadata {
  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of the feature attributions.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML tabular Models always have this field populated by Vertex AI. Note:
  /// The URI given on output may be different, including the URI scheme, than
  /// the one given on input. The output URI will point to a location where the
  /// user only has a read access.
  core.String? featureAttributionsSchemaUri;

  /// Map from feature names to feature input metadata.
  ///
  /// Keys are the name of the features. Values are the specification of the
  /// feature. An empty InputMetadata is valid. It describes a text feature
  /// which has the name specified as the key in ExplanationMetadata.inputs. The
  /// baseline of the empty feature is chosen by Vertex AI. For Vertex
  /// AI-provided Tensorflow images, the key can be any friendly name of the
  /// feature. Once specified, featureAttributions are keyed by this key (if not
  /// grouped with another feature). For custom images, the key must match with
  /// the key in instance.
  ///
  /// Required.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadata
  >?
  inputs;

  /// Name of the source to generate embeddings for example based explanations.
  core.String? latentSpaceSource;

  /// Map from output names to output metadata.
  ///
  /// For Vertex AI-provided Tensorflow images, keys can be any user defined
  /// string that consists of any UTF-8 characters. For custom images, keys are
  /// the name of the output field in the prediction to be explained. Currently
  /// only one key is allowed.
  ///
  /// Required.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ExplanationMetadataOutputMetadata
  >?
  outputs;

  GoogleCloudAiplatformV1beta1ExplanationMetadata({
    this.featureAttributionsSchemaUri,
    this.inputs,
    this.latentSpaceSource,
    this.outputs,
  });

  GoogleCloudAiplatformV1beta1ExplanationMetadata.fromJson(core.Map json_)
    : this(
        featureAttributionsSchemaUri:
            json_['featureAttributionsSchemaUri'] as core.String?,
        inputs: (json_['inputs'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadata.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
        latentSpaceSource: json_['latentSpaceSource'] as core.String?,
        outputs: (json_['outputs'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1ExplanationMetadataOutputMetadata.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureAttributionsSchemaUri != null)
      'featureAttributionsSchemaUri': featureAttributionsSchemaUri!,
    if (inputs != null) 'inputs': inputs!,
    if (latentSpaceSource != null) 'latentSpaceSource': latentSpaceSource!,
    if (outputs != null) 'outputs': outputs!,
  };
}

/// Metadata of the input of a feature.
///
/// Fields other than InputMetadata.input_baselines are applicable only for
/// Models that are using Vertex AI-provided images for Tensorflow.
class GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadata {
  /// Specifies the shape of the values of the input if the input is a sparse
  /// representation.
  ///
  /// Refer to Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  core.String? denseShapeTensorName;

  /// A list of baselines for the encoded tensor.
  ///
  /// The shape of each baseline should match the shape of the encoded tensor.
  /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
  /// encoded tensor.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? encodedBaselines;

  /// Encoded tensor is a transformation of the input tensor.
  ///
  /// Must be provided if choosing Integrated Gradients attribution or XRAI
  /// attribution and the input tensor is not differentiable. An encoded tensor
  /// is generated if the input tensor is encoded by a lookup table.
  core.String? encodedTensorName;

  /// Defines how the feature is encoded into the input tensor.
  ///
  /// Defaults to IDENTITY.
  /// Possible string values are:
  /// - "ENCODING_UNSPECIFIED" : Default value. This is the same as IDENTITY.
  /// - "IDENTITY" : The tensor represents one feature.
  /// - "BAG_OF_FEATURES" : The tensor represents a bag of features where each
  /// index maps to a feature. InputMetadata.index_feature_mapping must be
  /// provided for this encoding. For example: ``` input = [27, 6.0, 150]
  /// index_feature_mapping = ["age", "height", "weight"] ```
  /// - "BAG_OF_FEATURES_SPARSE" : The tensor represents a bag of features where
  /// each index maps to a feature. Zero values in the tensor indicates feature
  /// being non-existent. InputMetadata.index_feature_mapping must be provided
  /// for this encoding. For example: ``` input = [2, 0, 5, 0, 1]
  /// index_feature_mapping = ["a", "b", "c", "d", "e"] ```
  /// - "INDICATOR" : The tensor is a list of binaries representing whether a
  /// feature exists or not (1 indicates existence).
  /// InputMetadata.index_feature_mapping must be provided for this encoding.
  /// For example: ``` input = [1, 0, 1, 0, 1] index_feature_mapping = ["a",
  /// "b", "c", "d", "e"] ```
  /// - "COMBINED_EMBEDDING" : The tensor is encoded into a 1-dimensional array
  /// represented by an encoded tensor. InputMetadata.encoded_tensor_name must
  /// be provided for this encoding. For example: ``` input = ["This", "is",
  /// "a", "test", "."] encoded = [0.1, 0.2, 0.3, 0.4, 0.5] ```
  /// - "CONCAT_EMBEDDING" : Select this encoding when the input tensor is
  /// encoded into a 2-dimensional array represented by an encoded tensor.
  /// InputMetadata.encoded_tensor_name must be provided for this encoding. The
  /// first dimension of the encoded tensor's shape is the same as the input
  /// tensor's shape. For example: ``` input = ["This", "is", "a", "test", "."]
  /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5], [0.2, 0.1, 0.4, 0.3, 0.5], [0.5,
  /// 0.1, 0.3, 0.5, 0.4], [0.5, 0.3, 0.1, 0.2, 0.4], [0.4, 0.3, 0.2, 0.5, 0.1]]
  /// ```
  core.String? encoding;

  /// The domain details of the input feature value.
  ///
  /// Like min/max, original mean or standard deviation if normalized.
  GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataFeatureValueDomain?
  featureValueDomain;

  /// Name of the group that the input belongs to.
  ///
  /// Features with the same group name will be treated as one feature when
  /// computing attributions. Features grouped together can have different
  /// shapes in value. If provided, there will be one single attribution
  /// generated in Attribution.feature_attributions, keyed by the group name.
  core.String? groupName;

  /// A list of feature names for each index in the input tensor.
  ///
  /// Required when the input InputMetadata.encoding is BAG_OF_FEATURES,
  /// BAG_OF_FEATURES_SPARSE, INDICATOR.
  core.List<core.String>? indexFeatureMapping;

  /// Specifies the index of the values of the input tensor.
  ///
  /// Required when the input tensor is a sparse representation. Refer to
  /// Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  core.String? indicesTensorName;

  /// Baseline inputs for this feature.
  ///
  /// If no baseline is specified, Vertex AI chooses the baseline for this
  /// feature. If multiple baselines are specified, Vertex AI returns the
  /// average attributions across them in Attribution.feature_attributions. For
  /// Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each
  /// baseline must match the shape of the input tensor. If a scalar is
  /// provided, we broadcast to the same shape as the input tensor. For custom
  /// images, the element of the baselines must be in the same format as the
  /// feature's input in the instance\[\]. The schema of any single instance may
  /// be specified via Endpoint's DeployedModels' Model's PredictSchemata's
  /// instance_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? inputBaselines;

  /// Name of the input tensor for this feature.
  ///
  /// Required and is only applicable to Vertex AI-provided images for
  /// Tensorflow.
  core.String? inputTensorName;

  /// Modality of the feature.
  ///
  /// Valid values are: numeric, image. Defaults to numeric.
  core.String? modality;

  /// Visualization configurations for image explanation.
  GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataVisualization?
  visualization;

  GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadata({
    this.denseShapeTensorName,
    this.encodedBaselines,
    this.encodedTensorName,
    this.encoding,
    this.featureValueDomain,
    this.groupName,
    this.indexFeatureMapping,
    this.indicesTensorName,
    this.inputBaselines,
    this.inputTensorName,
    this.modality,
    this.visualization,
  });

  GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadata.fromJson(
    core.Map json_,
  ) : this(
        denseShapeTensorName: json_['denseShapeTensorName'] as core.String?,
        encodedBaselines:
            json_.containsKey('encodedBaselines')
                ? json_['encodedBaselines'] as core.List
                : null,
        encodedTensorName: json_['encodedTensorName'] as core.String?,
        encoding: json_['encoding'] as core.String?,
        featureValueDomain:
            json_.containsKey('featureValueDomain')
                ? GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataFeatureValueDomain.fromJson(
                  json_['featureValueDomain']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        groupName: json_['groupName'] as core.String?,
        indexFeatureMapping:
            (json_['indexFeatureMapping'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        indicesTensorName: json_['indicesTensorName'] as core.String?,
        inputBaselines:
            json_.containsKey('inputBaselines')
                ? json_['inputBaselines'] as core.List
                : null,
        inputTensorName: json_['inputTensorName'] as core.String?,
        modality: json_['modality'] as core.String?,
        visualization:
            json_.containsKey('visualization')
                ? GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataVisualization.fromJson(
                  json_['visualization'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (denseShapeTensorName != null)
      'denseShapeTensorName': denseShapeTensorName!,
    if (encodedBaselines != null) 'encodedBaselines': encodedBaselines!,
    if (encodedTensorName != null) 'encodedTensorName': encodedTensorName!,
    if (encoding != null) 'encoding': encoding!,
    if (featureValueDomain != null) 'featureValueDomain': featureValueDomain!,
    if (groupName != null) 'groupName': groupName!,
    if (indexFeatureMapping != null)
      'indexFeatureMapping': indexFeatureMapping!,
    if (indicesTensorName != null) 'indicesTensorName': indicesTensorName!,
    if (inputBaselines != null) 'inputBaselines': inputBaselines!,
    if (inputTensorName != null) 'inputTensorName': inputTensorName!,
    if (modality != null) 'modality': modality!,
    if (visualization != null) 'visualization': visualization!,
  };
}

/// Domain details of the input feature value.
///
/// Provides numeric information about the feature, such as its range (min,
/// max). If the feature has been pre-processed, for example with z-scoring,
/// then it provides information about how to recover the original feature. For
/// example, if the input feature is an image and it has been pre-processed to
/// obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev
/// refer to the mean and stddev of the original feature (e.g. image tensor)
/// from which input feature (with mean = 0 and stddev = 1) was obtained.
typedef GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataFeatureValueDomain =
    $ExplanationMetadataInputMetadataFeatureValueDomain;

/// Visualization configurations for image explanation.
typedef GoogleCloudAiplatformV1beta1ExplanationMetadataInputMetadataVisualization =
    $ExplanationMetadataInputMetadataVisualization;

/// Metadata of the prediction output to be explained.
typedef GoogleCloudAiplatformV1beta1ExplanationMetadataOutputMetadata =
    $ExplanationMetadataOutputMetadata;

/// The ExplanationMetadata entries that can be overridden at online explanation
/// time.
class GoogleCloudAiplatformV1beta1ExplanationMetadataOverride {
  /// Overrides the input metadata of the features.
  ///
  /// The key is the name of the feature to be overridden. The keys specified
  /// here must exist in the input metadata to be overridden. If a feature is
  /// not specified here, the corresponding feature's input metadata is not
  /// overridden.
  ///
  /// Required.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ExplanationMetadataOverrideInputMetadataOverride
  >?
  inputs;

  GoogleCloudAiplatformV1beta1ExplanationMetadataOverride({this.inputs});

  GoogleCloudAiplatformV1beta1ExplanationMetadataOverride.fromJson(
    core.Map json_,
  ) : this(
        inputs: (json_['inputs'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1ExplanationMetadataOverrideInputMetadataOverride.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputs != null) 'inputs': inputs!,
  };
}

/// The input metadata entries to be overridden.
typedef GoogleCloudAiplatformV1beta1ExplanationMetadataOverrideInputMetadataOverride =
    $ExplanationMetadataOverrideInputMetadataOverride;

/// Parameters to configure explaining for Model's predictions.
class GoogleCloudAiplatformV1beta1ExplanationParameters {
  /// Example-based explanations that returns the nearest neighbors from the
  /// provided dataset.
  GoogleCloudAiplatformV1beta1Examples? examples;

  /// An attribution method that computes Aumann-Shapley values taking advantage
  /// of the model's fully differentiable structure.
  ///
  /// Refer to this paper for more details: https://arxiv.org/abs/1703.01365
  GoogleCloudAiplatformV1beta1IntegratedGradientsAttribution?
  integratedGradientsAttribution;

  /// If populated, only returns attributions that have output_index contained
  /// in output_indices.
  ///
  /// It must be an ndarray of integers, with the same shape of the output it's
  /// explaining. If not populated, returns attributions for top_k indices of
  /// outputs. If neither top_k nor output_indices is populated, returns the
  /// argmax index of the outputs. Only applicable to Models that predict
  /// multiple outputs (e,g, multi-class Models that predict multiple classes).
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? outputIndices;

  /// An attribution method that approximates Shapley values for features that
  /// contribute to the label being predicted.
  ///
  /// A sampling strategy is used to approximate the value rather than
  /// considering all subsets of features. Refer to this paper for model
  /// details: https://arxiv.org/abs/1306.4265.
  GoogleCloudAiplatformV1beta1SampledShapleyAttribution?
  sampledShapleyAttribution;

  /// If populated, returns attributions for top K indices of outputs (defaults
  /// to 1).
  ///
  /// Only applies to Models that predicts more than one outputs (e,g,
  /// multi-class Models). When set to -1, returns explanations for all outputs.
  core.int? topK;

  /// An attribution method that redistributes Integrated Gradients attribution
  /// to segmented regions, taking advantage of the model's fully differentiable
  /// structure.
  ///
  /// Refer to this paper for more details: https://arxiv.org/abs/1906.02825
  /// XRAI currently performs better on natural images, like a picture of a
  /// house or an animal. If the images are taken in artificial environments,
  /// like a lab or manufacturing line, or from diagnostic equipment, like
  /// x-rays or quality-control cameras, use Integrated Gradients instead.
  GoogleCloudAiplatformV1beta1XraiAttribution? xraiAttribution;

  GoogleCloudAiplatformV1beta1ExplanationParameters({
    this.examples,
    this.integratedGradientsAttribution,
    this.outputIndices,
    this.sampledShapleyAttribution,
    this.topK,
    this.xraiAttribution,
  });

  GoogleCloudAiplatformV1beta1ExplanationParameters.fromJson(core.Map json_)
    : this(
        examples:
            json_.containsKey('examples')
                ? GoogleCloudAiplatformV1beta1Examples.fromJson(
                  json_['examples'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        integratedGradientsAttribution:
            json_.containsKey('integratedGradientsAttribution')
                ? GoogleCloudAiplatformV1beta1IntegratedGradientsAttribution.fromJson(
                  json_['integratedGradientsAttribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        outputIndices:
            json_.containsKey('outputIndices')
                ? json_['outputIndices'] as core.List
                : null,
        sampledShapleyAttribution:
            json_.containsKey('sampledShapleyAttribution')
                ? GoogleCloudAiplatformV1beta1SampledShapleyAttribution.fromJson(
                  json_['sampledShapleyAttribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        topK: json_['topK'] as core.int?,
        xraiAttribution:
            json_.containsKey('xraiAttribution')
                ? GoogleCloudAiplatformV1beta1XraiAttribution.fromJson(
                  json_['xraiAttribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (examples != null) 'examples': examples!,
    if (integratedGradientsAttribution != null)
      'integratedGradientsAttribution': integratedGradientsAttribution!,
    if (outputIndices != null) 'outputIndices': outputIndices!,
    if (sampledShapleyAttribution != null)
      'sampledShapleyAttribution': sampledShapleyAttribution!,
    if (topK != null) 'topK': topK!,
    if (xraiAttribution != null) 'xraiAttribution': xraiAttribution!,
  };
}

/// Specification of Model explanation.
class GoogleCloudAiplatformV1beta1ExplanationSpec {
  /// Metadata describing the Model's input and output for explanation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ExplanationMetadata? metadata;

  /// Parameters that configure explaining of the Model's predictions.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ExplanationParameters? parameters;

  GoogleCloudAiplatformV1beta1ExplanationSpec({this.metadata, this.parameters});

  GoogleCloudAiplatformV1beta1ExplanationSpec.fromJson(core.Map json_)
    : this(
        metadata:
            json_.containsKey('metadata')
                ? GoogleCloudAiplatformV1beta1ExplanationMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1ExplanationParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadata != null) 'metadata': metadata!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// The ExplanationSpec entries that can be overridden at online explanation
/// time.
class GoogleCloudAiplatformV1beta1ExplanationSpecOverride {
  /// The example-based explanations parameter overrides.
  GoogleCloudAiplatformV1beta1ExamplesOverride? examplesOverride;

  /// The metadata to be overridden.
  ///
  /// If not specified, no metadata is overridden.
  GoogleCloudAiplatformV1beta1ExplanationMetadataOverride? metadata;

  /// The parameters to be overridden.
  ///
  /// Note that the attribution method cannot be changed. If not specified, no
  /// parameter is overridden.
  GoogleCloudAiplatformV1beta1ExplanationParameters? parameters;

  GoogleCloudAiplatformV1beta1ExplanationSpecOverride({
    this.examplesOverride,
    this.metadata,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1ExplanationSpecOverride.fromJson(core.Map json_)
    : this(
        examplesOverride:
            json_.containsKey('examplesOverride')
                ? GoogleCloudAiplatformV1beta1ExamplesOverride.fromJson(
                  json_['examplesOverride']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        metadata:
            json_.containsKey('metadata')
                ? GoogleCloudAiplatformV1beta1ExplanationMetadataOverride.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1ExplanationParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (examplesOverride != null) 'examplesOverride': examplesOverride!,
    if (metadata != null) 'metadata': metadata!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Describes what part of the Dataset is to be exported, the destination of the
/// export and how to export.
class GoogleCloudAiplatformV1beta1ExportDataConfig {
  /// An expression for filtering what part of the Dataset is to be exported.
  ///
  /// Only Annotations that match this filter will be exported. The filter
  /// syntax is the same as in ListAnnotations.
  core.String? annotationsFilter;

  /// Split based on fractions defining the size of each set.
  GoogleCloudAiplatformV1beta1ExportFractionSplit? fractionSplit;

  /// The Google Cloud Storage location where the output is to be written to.
  ///
  /// In the given directory a new directory will be created with name:
  /// `export-data--` where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601
  /// format. All export output will be written into that directory. Inside that
  /// directory, annotations with the same schema will be grouped into sub
  /// directories which are named with the corresponding annotations' schema
  /// title. Inside these sub directories, a schema.yaml will be created to
  /// describe the output format.
  GoogleCloudAiplatformV1beta1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1beta1ExportDataConfig({
    this.annotationsFilter,
    this.fractionSplit,
    this.gcsDestination,
  });

  GoogleCloudAiplatformV1beta1ExportDataConfig.fromJson(core.Map json_)
    : this(
        annotationsFilter: json_['annotationsFilter'] as core.String?,
        fractionSplit:
            json_.containsKey('fractionSplit')
                ? GoogleCloudAiplatformV1beta1ExportFractionSplit.fromJson(
                  json_['fractionSplit'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsDestination:
            json_.containsKey('gcsDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationsFilter != null) 'annotationsFilter': annotationsFilter!,
    if (fractionSplit != null) 'fractionSplit': fractionSplit!,
    if (gcsDestination != null) 'gcsDestination': gcsDestination!,
  };
}

/// Request message for DatasetService.ExportData.
class GoogleCloudAiplatformV1beta1ExportDataRequest {
  /// The desired output location.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ExportDataConfig? exportConfig;

  GoogleCloudAiplatformV1beta1ExportDataRequest({this.exportConfig});

  GoogleCloudAiplatformV1beta1ExportDataRequest.fromJson(core.Map json_)
    : this(
        exportConfig:
            json_.containsKey('exportConfig')
                ? GoogleCloudAiplatformV1beta1ExportDataConfig.fromJson(
                  json_['exportConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportConfig != null) 'exportConfig': exportConfig!,
  };
}

/// Request message for FeaturestoreService.ExportFeatureValues.
class GoogleCloudAiplatformV1beta1ExportFeatureValuesRequest {
  /// Specifies destination location and format.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureValueDestination? destination;

  /// Selects Features to export values of.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureSelector? featureSelector;

  /// Exports all historical values of all entities of the EntityType within a
  /// time range
  GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestFullExport? fullExport;

  /// Per-Feature export settings.
  core.List<GoogleCloudAiplatformV1beta1DestinationFeatureSetting>? settings;

  /// Exports the latest Feature values of all entities of the EntityType within
  /// a time range.
  GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestSnapshotExport?
  snapshotExport;

  GoogleCloudAiplatformV1beta1ExportFeatureValuesRequest({
    this.destination,
    this.featureSelector,
    this.fullExport,
    this.settings,
    this.snapshotExport,
  });

  GoogleCloudAiplatformV1beta1ExportFeatureValuesRequest.fromJson(
    core.Map json_,
  ) : this(
        destination:
            json_.containsKey('destination')
                ? GoogleCloudAiplatformV1beta1FeatureValueDestination.fromJson(
                  json_['destination'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        featureSelector:
            json_.containsKey('featureSelector')
                ? GoogleCloudAiplatformV1beta1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        fullExport:
            json_.containsKey('fullExport')
                ? GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestFullExport.fromJson(
                  json_['fullExport'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        settings:
            (json_['settings'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DestinationFeatureSetting.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        snapshotExport:
            json_.containsKey('snapshotExport')
                ? GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestSnapshotExport.fromJson(
                  json_['snapshotExport']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destination != null) 'destination': destination!,
    if (featureSelector != null) 'featureSelector': featureSelector!,
    if (fullExport != null) 'fullExport': fullExport!,
    if (settings != null) 'settings': settings!,
    if (snapshotExport != null) 'snapshotExport': snapshotExport!,
  };
}

/// Describes exporting all historical Feature values of all entities of the
/// EntityType between \[start_time, end_time\].
typedef GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestFullExport =
    $ExportFeatureValuesRequestFullExport;

/// Describes exporting the latest Feature values of all entities of the
/// EntityType between \[start_time, snapshot_time\].
typedef GoogleCloudAiplatformV1beta1ExportFeatureValuesRequestSnapshotExport =
    $ExportFeatureValuesRequestSnapshotExport;

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions.
///
/// Any of `training_fraction`, `validation_fraction` and `test_fraction` may
/// optionally be provided, they must sum to up to 1. If the provided ones sum
/// to less than 1, the remainder is assigned to sets as decided by Vertex AI.
/// If none of the fractions are set, by default roughly 80% of data is used for
/// training, 10% for validation, and 10% for test.
typedef GoogleCloudAiplatformV1beta1ExportFractionSplit = $FractionSplit;

/// Request message for ModelService.ExportModel.
class GoogleCloudAiplatformV1beta1ExportModelRequest {
  /// The desired output location and configuration.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ExportModelRequestOutputConfig? outputConfig;

  GoogleCloudAiplatformV1beta1ExportModelRequest({this.outputConfig});

  GoogleCloudAiplatformV1beta1ExportModelRequest.fromJson(core.Map json_)
    : this(
        outputConfig:
            json_.containsKey('outputConfig')
                ? GoogleCloudAiplatformV1beta1ExportModelRequestOutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputConfig != null) 'outputConfig': outputConfig!,
  };
}

/// Output configuration for the Model export.
class GoogleCloudAiplatformV1beta1ExportModelRequestOutputConfig {
  /// The Cloud Storage location where the Model artifact is to be written to.
  ///
  /// Under the directory given as the destination a new one with name
  /// "`model-export--`", where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ
  /// ISO-8601 format, will be created. Inside, the Model and any of its
  /// supporting files will be written. This field should only be set when the
  /// `exportableContent` field of the \[Model.supported_export_formats\] object
  /// contains `ARTIFACT`.
  GoogleCloudAiplatformV1beta1GcsDestination? artifactDestination;

  /// The ID of the format in which the Model must be exported.
  ///
  /// Each Model lists the export formats it supports. If no value is provided
  /// here, then the first from the list of the Model's supported formats is
  /// used by default.
  core.String? exportFormatId;

  /// The Google Container Registry or Artifact Registry uri where the Model
  /// container image will be copied to.
  ///
  /// This field should only be set when the `exportableContent` field of the
  /// \[Model.supported_export_formats\] object contains `IMAGE`.
  GoogleCloudAiplatformV1beta1ContainerRegistryDestination? imageDestination;

  GoogleCloudAiplatformV1beta1ExportModelRequestOutputConfig({
    this.artifactDestination,
    this.exportFormatId,
    this.imageDestination,
  });

  GoogleCloudAiplatformV1beta1ExportModelRequestOutputConfig.fromJson(
    core.Map json_,
  ) : this(
        artifactDestination:
            json_.containsKey('artifactDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['artifactDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        exportFormatId: json_['exportFormatId'] as core.String?,
        imageDestination:
            json_.containsKey('imageDestination')
                ? GoogleCloudAiplatformV1beta1ContainerRegistryDestination.fromJson(
                  json_['imageDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactDestination != null)
      'artifactDestination': artifactDestination!,
    if (exportFormatId != null) 'exportFormatId': exportFormatId!,
    if (imageDestination != null) 'imageDestination': imageDestination!,
  };
}

/// Request message for ModelGardenService.ExportPublisherModel.
class GoogleCloudAiplatformV1beta1ExportPublisherModelRequest {
  /// The target where we are exporting the model weights to
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GcsDestination? destination;

  GoogleCloudAiplatformV1beta1ExportPublisherModelRequest({this.destination});

  GoogleCloudAiplatformV1beta1ExportPublisherModelRequest.fromJson(
    core.Map json_,
  ) : this(
        destination:
            json_.containsKey('destination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['destination'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destination != null) 'destination': destination!,
  };
}

/// Request message for TensorboardService.ExportTensorboardTimeSeriesData.
typedef GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataRequest =
    $ExportTensorboardTimeSeriesDataRequest;

/// Response message for TensorboardService.ExportTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataResponse {
  /// A token, which can be sent as page_token to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The returned time series data points.
  core.List<GoogleCloudAiplatformV1beta1TimeSeriesDataPoint>?
  timeSeriesDataPoints;

  GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataResponse({
    this.nextPageToken,
    this.timeSeriesDataPoints,
  });

  GoogleCloudAiplatformV1beta1ExportTensorboardTimeSeriesDataResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        timeSeriesDataPoints:
            (json_['timeSeriesDataPoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TimeSeriesDataPoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (timeSeriesDataPoints != null)
      'timeSeriesDataPoints': timeSeriesDataPoints!,
  };
}

/// Extensions are tools for large language models to access external data, run
/// computations, etc.
class GoogleCloudAiplatformV1beta1Extension {
  /// Timestamp when this Extension was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the Extension.
  ///
  /// Optional.
  core.String? description;

  /// The display name of the Extension.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Supported operations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ExtensionOperation>?
  extensionOperations;

  /// Manifest of the Extension.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ExtensionManifest? manifest;

  /// Identifier.
  ///
  /// The resource name of the Extension.
  core.String? name;

  /// The PrivateServiceConnect config for the extension.
  ///
  /// If specified, the service endpoints associated with the Extension should
  /// be
  /// [registered with private network access in the provided Service Directory](https://cloud.google.com/service-directory/docs/configuring-private-network-access).
  /// If the service contains more than one endpoint with a network, the service
  /// will arbitrarilty choose one of the endpoints to use for extension
  /// execution.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ExtensionPrivateServiceConnectConfig?
  privateServiceConnectConfig;

  /// Runtime config controlling the runtime behavior of this Extension.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RuntimeConfig? runtimeConfig;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Examples to illustrate the usage of the extension as a tool.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1ToolUseExample>? toolUseExamples;

  /// Timestamp when this Extension was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Extension({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.extensionOperations,
    this.manifest,
    this.name,
    this.privateServiceConnectConfig,
    this.runtimeConfig,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.toolUseExamples,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Extension.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        extensionOperations:
            (json_['extensionOperations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ExtensionOperation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        manifest:
            json_.containsKey('manifest')
                ? GoogleCloudAiplatformV1beta1ExtensionManifest.fromJson(
                  json_['manifest'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        privateServiceConnectConfig:
            json_.containsKey('privateServiceConnectConfig')
                ? GoogleCloudAiplatformV1beta1ExtensionPrivateServiceConnectConfig.fromJson(
                  json_['privateServiceConnectConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        runtimeConfig:
            json_.containsKey('runtimeConfig')
                ? GoogleCloudAiplatformV1beta1RuntimeConfig.fromJson(
                  json_['runtimeConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        toolUseExamples:
            (json_['toolUseExamples'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolUseExample.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (extensionOperations != null)
      'extensionOperations': extensionOperations!,
    if (manifest != null) 'manifest': manifest!,
    if (name != null) 'name': name!,
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!,
    if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (toolUseExamples != null) 'toolUseExamples': toolUseExamples!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Manifest spec of an Extension needed for runtime execution.
class GoogleCloudAiplatformV1beta1ExtensionManifest {
  /// The API specification shown to the LLM.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1beta1ExtensionManifestApiSpec? apiSpec;

  /// Type of auth supported by this extension.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1beta1AuthConfig? authConfig;

  /// The natural language description shown to the LLM.
  ///
  /// It should describe the usage of the extension, and is essential for the
  /// LLM to perform reasoning. e.g., if the extension is a data store, you can
  /// let the LLM know what data it contains.
  ///
  /// Required.
  core.String? description;

  /// Extension name shown to the LLM.
  ///
  /// The name can be up to 128 characters long.
  ///
  /// Required.
  core.String? name;

  GoogleCloudAiplatformV1beta1ExtensionManifest({
    this.apiSpec,
    this.authConfig,
    this.description,
    this.name,
  });

  GoogleCloudAiplatformV1beta1ExtensionManifest.fromJson(core.Map json_)
    : this(
        apiSpec:
            json_.containsKey('apiSpec')
                ? GoogleCloudAiplatformV1beta1ExtensionManifestApiSpec.fromJson(
                  json_['apiSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        authConfig:
            json_.containsKey('authConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfig.fromJson(
                  json_['authConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiSpec != null) 'apiSpec': apiSpec!,
    if (authConfig != null) 'authConfig': authConfig!,
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
  };
}

/// The API specification shown to the LLM.
class GoogleCloudAiplatformV1beta1ExtensionManifestApiSpec {
  /// Cloud Storage URI pointing to the OpenAPI spec.
  core.String? openApiGcsUri;

  /// The API spec in Open API standard and YAML format.
  core.String? openApiYaml;

  GoogleCloudAiplatformV1beta1ExtensionManifestApiSpec({
    this.openApiGcsUri,
    this.openApiYaml,
  });

  GoogleCloudAiplatformV1beta1ExtensionManifestApiSpec.fromJson(core.Map json_)
    : this(
        openApiGcsUri: json_['openApiGcsUri'] as core.String?,
        openApiYaml: json_['openApiYaml'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (openApiGcsUri != null) 'openApiGcsUri': openApiGcsUri!,
    if (openApiYaml != null) 'openApiYaml': openApiYaml!,
  };
}

/// Operation of an extension.
class GoogleCloudAiplatformV1beta1ExtensionOperation {
  /// Structured representation of a function declaration as defined by the
  /// OpenAPI Spec.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1FunctionDeclaration? functionDeclaration;

  /// Operation ID that uniquely identifies the operations among the extension.
  ///
  /// See: "Operation Object" in https://swagger.io/specification/. This field
  /// is parsed from the OpenAPI spec. For HTTP extensions, if it does not exist
  /// in the spec, we will generate one from the HTTP method and path.
  core.String? operationId;

  GoogleCloudAiplatformV1beta1ExtensionOperation({
    this.functionDeclaration,
    this.operationId,
  });

  GoogleCloudAiplatformV1beta1ExtensionOperation.fromJson(core.Map json_)
    : this(
        functionDeclaration:
            json_.containsKey('functionDeclaration')
                ? GoogleCloudAiplatformV1beta1FunctionDeclaration.fromJson(
                  json_['functionDeclaration']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        operationId: json_['operationId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (functionDeclaration != null)
      'functionDeclaration': functionDeclaration!,
    if (operationId != null) 'operationId': operationId!,
  };
}

/// PrivateExtensionConfig configuration for the extension.
class GoogleCloudAiplatformV1beta1ExtensionPrivateServiceConnectConfig {
  /// The Service Directory resource name in which the service endpoints
  /// associated to the extension are registered.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location_id}/namespaces/{namespace_id}/services/{service_id}`
  /// - The Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// should be granted `servicedirectory.viewer` and
  /// `servicedirectory.pscAuthorizedService` roles on the resource.
  ///
  /// Required.
  core.String? serviceDirectory;

  GoogleCloudAiplatformV1beta1ExtensionPrivateServiceConnectConfig({
    this.serviceDirectory,
  });

  GoogleCloudAiplatformV1beta1ExtensionPrivateServiceConnectConfig.fromJson(
    core.Map json_,
  ) : this(serviceDirectory: json_['serviceDirectory'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceDirectory != null) 'serviceDirectory': serviceDirectory!,
  };
}

/// Retrieve from data source powered by external API for grounding.
///
/// The external API is not owned by Google, but need to follow the pre-defined
/// API spec.
class GoogleCloudAiplatformV1beta1ExternalApi {
  /// The authentication config to access the API.
  ///
  /// Deprecated. Please use auth_config instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1ApiAuth? apiAuth;

  /// The API spec that the external API implements.
  /// Possible string values are:
  /// - "API_SPEC_UNSPECIFIED" : Unspecified API spec. This value should not be
  /// used.
  /// - "SIMPLE_SEARCH" : Simple search API spec.
  /// - "ELASTIC_SEARCH" : Elastic search API spec.
  core.String? apiSpec;

  /// The authentication config to access the API.
  GoogleCloudAiplatformV1beta1AuthConfig? authConfig;

  /// Parameters for the elastic search API.
  GoogleCloudAiplatformV1beta1ExternalApiElasticSearchParams?
  elasticSearchParams;

  /// The endpoint of the external API.
  ///
  /// The system will call the API at this endpoint to retrieve the data for
  /// grounding. Example: https://acme.com:443/search
  core.String? endpoint;

  /// Parameters for the simple search API.
  GoogleCloudAiplatformV1beta1ExternalApiSimpleSearchParams? simpleSearchParams;

  GoogleCloudAiplatformV1beta1ExternalApi({
    this.apiAuth,
    this.apiSpec,
    this.authConfig,
    this.elasticSearchParams,
    this.endpoint,
    this.simpleSearchParams,
  });

  GoogleCloudAiplatformV1beta1ExternalApi.fromJson(core.Map json_)
    : this(
        apiAuth:
            json_.containsKey('apiAuth')
                ? GoogleCloudAiplatformV1beta1ApiAuth.fromJson(
                  json_['apiAuth'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        apiSpec: json_['apiSpec'] as core.String?,
        authConfig:
            json_.containsKey('authConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfig.fromJson(
                  json_['authConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        elasticSearchParams:
            json_.containsKey('elasticSearchParams')
                ? GoogleCloudAiplatformV1beta1ExternalApiElasticSearchParams.fromJson(
                  json_['elasticSearchParams']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endpoint: json_['endpoint'] as core.String?,
        simpleSearchParams:
            json_.containsKey('simpleSearchParams')
                ? GoogleCloudAiplatformV1beta1ExternalApiSimpleSearchParams.fromJson(
                  json_['simpleSearchParams']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiAuth != null) 'apiAuth': apiAuth!,
    if (apiSpec != null) 'apiSpec': apiSpec!,
    if (authConfig != null) 'authConfig': authConfig!,
    if (elasticSearchParams != null)
      'elasticSearchParams': elasticSearchParams!,
    if (endpoint != null) 'endpoint': endpoint!,
    if (simpleSearchParams != null) 'simpleSearchParams': simpleSearchParams!,
  };
}

/// The search parameters to use for the ELASTIC_SEARCH spec.
typedef GoogleCloudAiplatformV1beta1ExternalApiElasticSearchParams =
    $ExternalApiElasticSearchParams;

/// The search parameters to use for SIMPLE_SEARCH spec.
typedef GoogleCloudAiplatformV1beta1ExternalApiSimpleSearchParams = $Empty;

/// The fact used in grounding.
class GoogleCloudAiplatformV1beta1Fact {
  /// If present, chunk properties.
  GoogleCloudAiplatformV1beta1RagChunk? chunk;

  /// Query that is used to retrieve this fact.
  core.String? query;

  /// If present, according to the underlying Vector DB and the selected metric
  /// type, the score can be either the distance or the similarity between the
  /// query and the fact and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the fact. The larger the distance, the less
  /// relevant the fact is to the query. The range is \[0, 2\], while 0 means
  /// the most relevant and 2 means the least relevant.
  core.double? score;

  /// If present, the summary/snippet of the fact.
  core.String? summary;

  /// If present, it refers to the title of this fact.
  core.String? title;

  /// If present, this uri links to the source of the fact.
  core.String? uri;

  /// If present, the distance between the query vector and this fact vector.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? vectorDistance;

  GoogleCloudAiplatformV1beta1Fact({
    this.chunk,
    this.query,
    this.score,
    this.summary,
    this.title,
    this.uri,
    this.vectorDistance,
  });

  GoogleCloudAiplatformV1beta1Fact.fromJson(core.Map json_)
    : this(
        chunk:
            json_.containsKey('chunk')
                ? GoogleCloudAiplatformV1beta1RagChunk.fromJson(
                  json_['chunk'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        query: json_['query'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
        summary: json_['summary'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
        vectorDistance: (json_['vectorDistance'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunk != null) 'chunk': chunk!,
    if (query != null) 'query': query!,
    if (score != null) 'score': score!,
    if (summary != null) 'summary': summary!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
    if (vectorDistance != null) 'vectorDistance': vectorDistance!,
  };
}

/// Configuration for faster model deployment.
typedef GoogleCloudAiplatformV1beta1FasterDeploymentConfig =
    $FasterDeploymentConfig;

/// Feature Metadata information.
///
/// For example, color is a feature that describes an apple.
class GoogleCloudAiplatformV1beta1Feature {
  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Timestamp when this EntityType was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Feature.
  core.String? description;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// If not set, use the monitoring_config defined for the EntityType this
  /// Feature belongs to. Only Features with type (Feature.ValueType) BOOL,
  /// STRING, DOUBLE or INT64 can enable monitoring. If set to true, all types
  /// of data monitoring are disabled despite the config on EntityType.
  ///
  /// Optional.
  core.bool? disableMonitoring;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Only applicable for Vertex AI Feature Store.
  ///
  /// The list of historical stats and anomalies.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1FeatureStatsAndAnomaly>?
  featureStatsAndAnomaly;

  /// The labels with user-defined metadata to organize your Features.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one Feature (System labels
  /// are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Deprecated: The custom monitoring configuration for this Feature, if not
  /// set, use the monitoring_config defined for the EntityType this Feature
  /// belongs to. Only Features with type (Feature.ValueType) BOOL, STRING,
  /// DOUBLE or INT64 can enable monitoring. If this is populated with
  /// FeaturestoreMonitoringConfig.disabled = true, snapshot analysis monitoring
  /// is disabled; if FeaturestoreMonitoringConfig.monitoring_interval
  /// specified, snapshot analysis monitoring is enabled. Otherwise, snapshot
  /// analysis monitoring config is same as the EntityType's this Feature
  /// belongs to.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfig? monitoringConfig;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// A list of historical SnapshotAnalysis stats requested by user, sorted by
  /// FeatureStatsAnomaly.start_time descending.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1FeatureStatsAnomaly>? monitoringStats;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// The list of historical stats and anomalies with specified objectives.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1FeatureMonitoringStatsAnomaly>?
  monitoringStatsAnomalies;

  /// Name of the Feature.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  ///
  /// Immutable.
  core.String? name;

  /// Entity responsible for maintaining this feature.
  ///
  /// Can be comma separated list of email addresses or URIs.
  core.String? pointOfContact;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Timestamp when this EntityType was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Type of Feature value.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "BOOL" : Used for Feature that is a boolean.
  /// - "BOOL_ARRAY" : Used for Feature that is a list of boolean.
  /// - "DOUBLE" : Used for Feature that is double.
  /// - "DOUBLE_ARRAY" : Used for Feature that is a list of double.
  /// - "INT64" : Used for Feature that is INT64.
  /// - "INT64_ARRAY" : Used for Feature that is a list of INT64.
  /// - "STRING" : Used for Feature that is string.
  /// - "STRING_ARRAY" : Used for Feature that is a list of String.
  /// - "BYTES" : Used for Feature that is bytes.
  /// - "STRUCT" : Used for Feature that is struct.
  core.String? valueType;

  /// Only applicable for Vertex AI Feature Store.
  ///
  /// The name of the BigQuery Table/View column hosting data for this version.
  /// If no value is provided, will use feature_id.
  core.String? versionColumnName;

  GoogleCloudAiplatformV1beta1Feature({
    this.createTime,
    this.description,
    this.disableMonitoring,
    this.etag,
    this.featureStatsAndAnomaly,
    this.labels,
    this.monitoringConfig,
    this.monitoringStats,
    this.monitoringStatsAnomalies,
    this.name,
    this.pointOfContact,
    this.updateTime,
    this.valueType,
    this.versionColumnName,
  });

  GoogleCloudAiplatformV1beta1Feature.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        disableMonitoring: json_['disableMonitoring'] as core.bool?,
        etag: json_['etag'] as core.String?,
        featureStatsAndAnomaly:
            (json_['featureStatsAndAnomaly'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureStatsAndAnomaly.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        monitoringConfig:
            json_.containsKey('monitoringConfig')
                ? GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfig.fromJson(
                  json_['monitoringConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        monitoringStats:
            (json_['monitoringStats'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureStatsAnomaly.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        monitoringStatsAnomalies:
            (json_['monitoringStatsAnomalies'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureMonitoringStatsAnomaly.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        name: json_['name'] as core.String?,
        pointOfContact: json_['pointOfContact'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        valueType: json_['valueType'] as core.String?,
        versionColumnName: json_['versionColumnName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (disableMonitoring != null) 'disableMonitoring': disableMonitoring!,
    if (etag != null) 'etag': etag!,
    if (featureStatsAndAnomaly != null)
      'featureStatsAndAnomaly': featureStatsAndAnomaly!,
    if (labels != null) 'labels': labels!,
    if (monitoringConfig != null) 'monitoringConfig': monitoringConfig!,
    if (monitoringStats != null) 'monitoringStats': monitoringStats!,
    if (monitoringStatsAnomalies != null)
      'monitoringStatsAnomalies': monitoringStatsAnomalies!,
    if (name != null) 'name': name!,
    if (pointOfContact != null) 'pointOfContact': pointOfContact!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (valueType != null) 'valueType': valueType!,
    if (versionColumnName != null) 'versionColumnName': versionColumnName!,
  };
}

/// Vertex AI Feature Group.
class GoogleCloudAiplatformV1beta1FeatureGroup {
  /// Indicates that features for this group come from BigQuery Table/View.
  ///
  /// By default treats the source as a sparse time series source. The BigQuery
  /// source table or view must have at least one entity ID column and a column
  /// named `feature_timestamp`.
  GoogleCloudAiplatformV1beta1FeatureGroupBigQuery? bigQuery;

  /// Timestamp when this FeatureGroup was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the FeatureGroup.
  ///
  /// Optional.
  core.String? description;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your FeatureGroup.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one FeatureGroup(System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureGroup. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  core.String? name;

  /// A Service Account unique to this FeatureGroup.
  ///
  /// The role bigquery.dataViewer should be granted to this service account to
  /// allow Vertex AI Feature Store to access source data while running jobs
  /// under this FeatureGroup.
  ///
  /// Output only.
  core.String? serviceAccountEmail;

  /// Service agent type used during jobs under a FeatureGroup.
  ///
  /// By default, the Vertex AI Service Agent is used. When using an IAM Policy
  /// to isolate this FeatureGroup within a project, a separate service account
  /// should be provisioned by setting this field to
  /// `SERVICE_AGENT_TYPE_FEATURE_GROUP`. This will generate a separate service
  /// account to access the BigQuery source table.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SERVICE_AGENT_TYPE_UNSPECIFIED" : By default, the project-level Vertex
  /// AI Service Agent is enabled.
  /// - "SERVICE_AGENT_TYPE_PROJECT" : Specifies the project-level Vertex AI
  /// Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  /// - "SERVICE_AGENT_TYPE_FEATURE_GROUP" : Enable a FeatureGroup service
  /// account to be created by Vertex AI and output in the field
  /// `service_account_email`. This service account will be used to read from
  /// the source BigQuery table during jobs under a FeatureGroup.
  core.String? serviceAgentType;

  /// Timestamp when this FeatureGroup was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1FeatureGroup({
    this.bigQuery,
    this.createTime,
    this.description,
    this.etag,
    this.labels,
    this.name,
    this.serviceAccountEmail,
    this.serviceAgentType,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1FeatureGroup.fromJson(core.Map json_)
    : this(
        bigQuery:
            json_.containsKey('bigQuery')
                ? GoogleCloudAiplatformV1beta1FeatureGroupBigQuery.fromJson(
                  json_['bigQuery'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
        serviceAgentType: json_['serviceAgentType'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigQuery != null) 'bigQuery': bigQuery!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
    if (serviceAgentType != null) 'serviceAgentType': serviceAgentType!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Input source type for BigQuery Tables and Views.
class GoogleCloudAiplatformV1beta1FeatureGroupBigQuery {
  /// The BigQuery source URI that points to either a BigQuery Table or View.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1beta1BigQuerySource? bigQuerySource;

  /// If set, all feature values will be fetched from a single row per unique
  /// entityId including nulls.
  ///
  /// If not set, will collapse all rows for each unique entityId into a singe
  /// row with any non-null values if present, if no non-null values are present
  /// will sync null. ex: If source has schema `(entity_id, feature_timestamp,
  /// f0, f1)` and the following rows: `(e1, 2020-01-01T10:00:00.123Z, 10, 15)`
  /// `(e1, 2020-02-01T10:00:00.123Z, 20, null)` If dense is set, `(e1, 20,
  /// null)` is synced to online stores. If dense is not set, `(e1, 20, 15)` is
  /// synced to online stores.
  ///
  /// Optional.
  core.bool? dense;

  /// Columns to construct entity_id / row keys.
  ///
  /// If not provided defaults to `entity_id`.
  ///
  /// Optional.
  core.List<core.String>? entityIdColumns;

  /// Set if the data source is not a time-series.
  ///
  /// Optional.
  core.bool? staticDataSource;

  /// If the source is a time-series source, this can be set to control how
  /// downstream sources (ex: FeatureView ) will treat time-series sources.
  ///
  /// If not set, will treat the source as a time-series source with
  /// `feature_timestamp` as timestamp column and no scan boundary.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureGroupBigQueryTimeSeries? timeSeries;

  GoogleCloudAiplatformV1beta1FeatureGroupBigQuery({
    this.bigQuerySource,
    this.dense,
    this.entityIdColumns,
    this.staticDataSource,
    this.timeSeries,
  });

  GoogleCloudAiplatformV1beta1FeatureGroupBigQuery.fromJson(core.Map json_)
    : this(
        bigQuerySource:
            json_.containsKey('bigQuerySource')
                ? GoogleCloudAiplatformV1beta1BigQuerySource.fromJson(
                  json_['bigQuerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        dense: json_['dense'] as core.bool?,
        entityIdColumns:
            (json_['entityIdColumns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        staticDataSource: json_['staticDataSource'] as core.bool?,
        timeSeries:
            json_.containsKey('timeSeries')
                ? GoogleCloudAiplatformV1beta1FeatureGroupBigQueryTimeSeries.fromJson(
                  json_['timeSeries'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!,
    if (dense != null) 'dense': dense!,
    if (entityIdColumns != null) 'entityIdColumns': entityIdColumns!,
    if (staticDataSource != null) 'staticDataSource': staticDataSource!,
    if (timeSeries != null) 'timeSeries': timeSeries!,
  };
}

typedef GoogleCloudAiplatformV1beta1FeatureGroupBigQueryTimeSeries =
    $FeatureGroupBigQueryTimeSeries;

/// Vertex AI Feature Monitor.
class GoogleCloudAiplatformV1beta1FeatureMonitor {
  /// Timestamp when this FeatureMonitor was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the FeatureMonitor.
  ///
  /// Optional.
  core.String? description;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Feature selection config for the FeatureMonitor.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureSelectionConfig? featureSelectionConfig;

  /// The labels with user-defined metadata to organize your FeatureMonitor.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one FeatureMonitor(System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureMonitor. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}/featureMonitors/{featureMonitor}`
  core.String? name;

  /// Schedule config for the FeatureMonitor.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ScheduleConfig? scheduleConfig;

  /// Timestamp when this FeatureMonitor was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1FeatureMonitor({
    this.createTime,
    this.description,
    this.etag,
    this.featureSelectionConfig,
    this.labels,
    this.name,
    this.scheduleConfig,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1FeatureMonitor.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        etag: json_['etag'] as core.String?,
        featureSelectionConfig:
            json_.containsKey('featureSelectionConfig')
                ? GoogleCloudAiplatformV1beta1FeatureSelectionConfig.fromJson(
                  json_['featureSelectionConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        scheduleConfig:
            json_.containsKey('scheduleConfig')
                ? GoogleCloudAiplatformV1beta1ScheduleConfig.fromJson(
                  json_['scheduleConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (etag != null) 'etag': etag!,
    if (featureSelectionConfig != null)
      'featureSelectionConfig': featureSelectionConfig!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (scheduleConfig != null) 'scheduleConfig': scheduleConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Vertex AI Feature Monitor Job.
class GoogleCloudAiplatformV1beta1FeatureMonitorJob {
  /// Timestamp when this FeatureMonitorJob was created.
  ///
  /// Creation of a FeatureMonitorJob means that the job is pending / waiting
  /// for sufficient resources but may not have started running yet.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the FeatureMonitor.
  ///
  /// Optional.
  core.String? description;

  /// FeatureMonitorJob ID comparing to which the drift is calculated.
  ///
  /// Output only.
  core.String? driftBaseFeatureMonitorJobId;

  /// Data snapshot time comparing to which the drift is calculated.
  ///
  /// Output only.
  core.String? driftBaseSnapshotTime;

  /// Feature selection config used when creating FeatureMonitorJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1FeatureSelectionConfig? featureSelectionConfig;

  /// Final status of the FeatureMonitorJob.
  ///
  /// Output only.
  GoogleRpcStatus? finalStatus;

  /// Summary from the FeatureMonitorJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1FeatureMonitorJobJobSummary? jobSummary;

  /// The labels with user-defined metadata to organize your FeatureMonitorJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one FeatureMonitor(System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureMonitorJob. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}/featureMonitorJobs/{feature_monitor_job}`.
  core.String? name;

  /// Trigger type of the Feature Monitor Job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "FEATURE_MONITOR_JOB_TRIGGER_UNSPECIFIED" : Trigger type unspecified.
  /// - "FEATURE_MONITOR_JOB_TRIGGER_PERIODIC" : Triggered by periodic schedule.
  /// - "FEATURE_MONITOR_JOB_TRIGGER_ON_DEMAND" : Triggered on demand by
  /// CreateFeatureMonitorJob request.
  core.String? triggerType;

  GoogleCloudAiplatformV1beta1FeatureMonitorJob({
    this.createTime,
    this.description,
    this.driftBaseFeatureMonitorJobId,
    this.driftBaseSnapshotTime,
    this.featureSelectionConfig,
    this.finalStatus,
    this.jobSummary,
    this.labels,
    this.name,
    this.triggerType,
  });

  GoogleCloudAiplatformV1beta1FeatureMonitorJob.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        driftBaseFeatureMonitorJobId:
            json_['driftBaseFeatureMonitorJobId'] as core.String?,
        driftBaseSnapshotTime: json_['driftBaseSnapshotTime'] as core.String?,
        featureSelectionConfig:
            json_.containsKey('featureSelectionConfig')
                ? GoogleCloudAiplatformV1beta1FeatureSelectionConfig.fromJson(
                  json_['featureSelectionConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        finalStatus:
            json_.containsKey('finalStatus')
                ? GoogleRpcStatus.fromJson(
                  json_['finalStatus'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        jobSummary:
            json_.containsKey('jobSummary')
                ? GoogleCloudAiplatformV1beta1FeatureMonitorJobJobSummary.fromJson(
                  json_['jobSummary'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        triggerType: json_['triggerType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (driftBaseFeatureMonitorJobId != null)
      'driftBaseFeatureMonitorJobId': driftBaseFeatureMonitorJobId!,
    if (driftBaseSnapshotTime != null)
      'driftBaseSnapshotTime': driftBaseSnapshotTime!,
    if (featureSelectionConfig != null)
      'featureSelectionConfig': featureSelectionConfig!,
    if (finalStatus != null) 'finalStatus': finalStatus!,
    if (jobSummary != null) 'jobSummary': jobSummary!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (triggerType != null) 'triggerType': triggerType!,
  };
}

/// Summary from the FeatureMonitorJob.
class GoogleCloudAiplatformV1beta1FeatureMonitorJobJobSummary {
  /// Features and their stats and anomalies
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1FeatureStatsAndAnomaly>?
  featureStatsAndAnomalies;

  /// BigQuery slot milliseconds consumed.
  ///
  /// Output only.
  core.String? totalSlotMs;

  GoogleCloudAiplatformV1beta1FeatureMonitorJobJobSummary({
    this.featureStatsAndAnomalies,
    this.totalSlotMs,
  });

  GoogleCloudAiplatformV1beta1FeatureMonitorJobJobSummary.fromJson(
    core.Map json_,
  ) : this(
        featureStatsAndAnomalies:
            (json_['featureStatsAndAnomalies'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureStatsAndAnomaly.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        totalSlotMs: json_['totalSlotMs'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureStatsAndAnomalies != null)
      'featureStatsAndAnomalies': featureStatsAndAnomalies!,
    if (totalSlotMs != null) 'totalSlotMs': totalSlotMs!,
  };
}

/// A list of historical SnapshotAnalysis or ImportFeaturesAnalysis stats
/// requested by user, sorted by FeatureStatsAnomaly.start_time descending.
class GoogleCloudAiplatformV1beta1FeatureMonitoringStatsAnomaly {
  /// The stats and anomalies generated at specific timestamp.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1FeatureStatsAnomaly? featureStatsAnomaly;

  /// The objective for each stats.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OBJECTIVE_UNSPECIFIED" : If it's OBJECTIVE_UNSPECIFIED,
  /// monitoring_stats will be empty.
  /// - "IMPORT_FEATURE_ANALYSIS" : Stats are generated by Import Feature
  /// Analysis.
  /// - "SNAPSHOT_ANALYSIS" : Stats are generated by Snapshot Analysis.
  core.String? objective;

  GoogleCloudAiplatformV1beta1FeatureMonitoringStatsAnomaly({
    this.featureStatsAnomaly,
    this.objective,
  });

  GoogleCloudAiplatformV1beta1FeatureMonitoringStatsAnomaly.fromJson(
    core.Map json_,
  ) : this(
        featureStatsAnomaly:
            json_.containsKey('featureStatsAnomaly')
                ? GoogleCloudAiplatformV1beta1FeatureStatsAnomaly.fromJson(
                  json_['featureStatsAnomaly']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        objective: json_['objective'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureStatsAnomaly != null)
      'featureStatsAnomaly': featureStatsAnomaly!,
    if (objective != null) 'objective': objective!,
  };
}

/// Noise sigma by features.
///
/// Noise sigma represents the standard deviation of the gaussian kernel that
/// will be used to add noise to interpolated inputs prior to computing
/// gradients.
class GoogleCloudAiplatformV1beta1FeatureNoiseSigma {
  /// Noise sigma per feature.
  ///
  /// No noise is added to features that are not set.
  core.List<GoogleCloudAiplatformV1beta1FeatureNoiseSigmaNoiseSigmaForFeature>?
  noiseSigma;

  GoogleCloudAiplatformV1beta1FeatureNoiseSigma({this.noiseSigma});

  GoogleCloudAiplatformV1beta1FeatureNoiseSigma.fromJson(core.Map json_)
    : this(
        noiseSigma:
            (json_['noiseSigma'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureNoiseSigmaNoiseSigmaForFeature.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (noiseSigma != null) 'noiseSigma': noiseSigma!,
  };
}

/// Noise sigma for a single feature.
typedef GoogleCloudAiplatformV1beta1FeatureNoiseSigmaNoiseSigmaForFeature =
    $FeatureNoiseSigmaNoiseSigmaForFeature;

/// Vertex AI Feature Online Store provides a centralized repository for serving
/// ML features and embedding indexes at low latency.
///
/// The Feature Online Store is a top-level container.
class GoogleCloudAiplatformV1beta1FeatureOnlineStore {
  /// Contains settings for the Cloud Bigtable instance that will be created to
  /// serve featureValues for all FeatureViews under this FeatureOnlineStore.
  GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtable? bigtable;

  /// Timestamp when this FeatureOnlineStore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The dedicated serving endpoint for this FeatureOnlineStore, which is
  /// different from common Vertex service endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureOnlineStoreDedicatedServingEndpoint?
  dedicatedServingEndpoint;

  /// Deprecated: This field is no longer needed anymore and embedding
  /// management is automatically enabled when specifying Optimized storage
  /// type.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1FeatureOnlineStoreEmbeddingManagement?
  embeddingManagement;

  /// Customer-managed encryption key spec for data storage.
  ///
  /// If set, online store will be secured by this key.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your FeatureOnlineStore.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label
  /// keys are prefixed with "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureOnlineStore. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
  core.String? name;

  /// Contains settings for the Optimized store that will be created to serve
  /// featureValues for all FeatureViews under this FeatureOnlineStore.
  ///
  /// When choose Optimized storage type, need to set
  /// PrivateServiceConnectConfig.enable_private_service_connect to use private
  /// endpoint. Otherwise will use public endpoint by default.
  GoogleCloudAiplatformV1beta1FeatureOnlineStoreOptimized? optimized;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// State of the featureOnlineStore.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value. This value is unused.
  /// - "STABLE" : State when the featureOnlineStore configuration is not being
  /// updated and the fields reflect the current configuration of the
  /// featureOnlineStore. The featureOnlineStore is usable in this state.
  /// - "UPDATING" : The state of the featureOnlineStore configuration when it
  /// is being updated. During an update, the fields reflect either the original
  /// configuration or the updated configuration of the featureOnlineStore. The
  /// featureOnlineStore is still usable in this state.
  core.String? state;

  /// Timestamp when this FeatureOnlineStore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1FeatureOnlineStore({
    this.bigtable,
    this.createTime,
    this.dedicatedServingEndpoint,
    this.embeddingManagement,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.optimized,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1FeatureOnlineStore.fromJson(core.Map json_)
    : this(
        bigtable:
            json_.containsKey('bigtable')
                ? GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtable.fromJson(
                  json_['bigtable'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        dedicatedServingEndpoint:
            json_.containsKey('dedicatedServingEndpoint')
                ? GoogleCloudAiplatformV1beta1FeatureOnlineStoreDedicatedServingEndpoint.fromJson(
                  json_['dedicatedServingEndpoint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        embeddingManagement:
            json_.containsKey('embeddingManagement')
                ? GoogleCloudAiplatformV1beta1FeatureOnlineStoreEmbeddingManagement.fromJson(
                  json_['embeddingManagement']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        optimized:
            json_.containsKey('optimized')
                ? GoogleCloudAiplatformV1beta1FeatureOnlineStoreOptimized.fromJson(
                  json_['optimized'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigtable != null) 'bigtable': bigtable!,
    if (createTime != null) 'createTime': createTime!,
    if (dedicatedServingEndpoint != null)
      'dedicatedServingEndpoint': dedicatedServingEndpoint!,
    if (embeddingManagement != null)
      'embeddingManagement': embeddingManagement!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (optimized != null) 'optimized': optimized!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

class GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtable {
  /// Autoscaling config applied to Bigtable Instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtableAutoScaling?
  autoScaling;

  GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtable({this.autoScaling});

  GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtable.fromJson(
    core.Map json_,
  ) : this(
        autoScaling:
            json_.containsKey('autoScaling')
                ? GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtableAutoScaling.fromJson(
                  json_['autoScaling'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoScaling != null) 'autoScaling': autoScaling!,
  };
}

typedef GoogleCloudAiplatformV1beta1FeatureOnlineStoreBigtableAutoScaling =
    $FeatureOnlineStoreBigtableAutoScaling;

/// The dedicated serving endpoint for this FeatureOnlineStore.
///
/// Only need to set when you choose Optimized storage type. Public endpoint is
/// provisioned by default.
class GoogleCloudAiplatformV1beta1FeatureOnlineStoreDedicatedServingEndpoint {
  /// Private service connect config.
  ///
  /// The private service connection is available only for Optimized storage
  /// type, not for embedding management now. If
  /// PrivateServiceConnectConfig.enable_private_service_connect set to true,
  /// customers will use private service connection to send request. Otherwise,
  /// the connection will set to public endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig?
  privateServiceConnectConfig;

  /// This field will be populated with the domain name to use for this
  /// FeatureOnlineStore
  ///
  /// Output only.
  core.String? publicEndpointDomainName;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled and after FeatureViewSync
  /// is created.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1beta1FeatureOnlineStoreDedicatedServingEndpoint({
    this.privateServiceConnectConfig,
    this.publicEndpointDomainName,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1beta1FeatureOnlineStoreDedicatedServingEndpoint.fromJson(
    core.Map json_,
  ) : this(
        privateServiceConnectConfig:
            json_.containsKey('privateServiceConnectConfig')
                ? GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig.fromJson(
                  json_['privateServiceConnectConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        publicEndpointDomainName:
            json_['publicEndpointDomainName'] as core.String?,
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!,
    if (publicEndpointDomainName != null)
      'publicEndpointDomainName': publicEndpointDomainName!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Deprecated: This sub message is no longer needed anymore and embedding
/// management is automatically enabled when specifying Optimized storage type.
///
/// Contains settings for embedding management.
class GoogleCloudAiplatformV1beta1FeatureOnlineStoreEmbeddingManagement {
  /// Whether to enable embedding management in this FeatureOnlineStore.
  ///
  /// It's immutable after creation to ensure the FeatureOnlineStore
  /// availability.
  ///
  /// Optional. Immutable.
  core.bool? enabled;

  GoogleCloudAiplatformV1beta1FeatureOnlineStoreEmbeddingManagement({
    this.enabled,
  });

  GoogleCloudAiplatformV1beta1FeatureOnlineStoreEmbeddingManagement.fromJson(
    core.Map json_,
  ) : this(enabled: json_['enabled'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enabled != null) 'enabled': enabled!,
  };
}

/// Optimized storage type
typedef GoogleCloudAiplatformV1beta1FeatureOnlineStoreOptimized = $Empty;

/// Feature selection configuration for the FeatureMonitor.
class GoogleCloudAiplatformV1beta1FeatureSelectionConfig {
  /// A list of features to be monitored and each feature's drift threshold.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1FeatureSelectionConfigFeatureConfig>?
  featureConfigs;

  GoogleCloudAiplatformV1beta1FeatureSelectionConfig({this.featureConfigs});

  GoogleCloudAiplatformV1beta1FeatureSelectionConfig.fromJson(core.Map json_)
    : this(
        featureConfigs:
            (json_['featureConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureSelectionConfigFeatureConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureConfigs != null) 'featureConfigs': featureConfigs!,
  };
}

/// Feature configuration.
class GoogleCloudAiplatformV1beta1FeatureSelectionConfigFeatureConfig {
  /// Drift threshold.
  ///
  /// If calculated difference with baseline data larger than threshold, it will
  /// be considered as the feature has drift. If not present, the threshold will
  /// be default to 0.3. Must be in range \[0, 1).
  ///
  /// Optional.
  core.double? driftThreshold;

  /// The ID of the feature resource.
  ///
  /// Final component of the Feature's resource name.
  ///
  /// Required.
  core.String? featureId;

  GoogleCloudAiplatformV1beta1FeatureSelectionConfigFeatureConfig({
    this.driftThreshold,
    this.featureId,
  });

  GoogleCloudAiplatformV1beta1FeatureSelectionConfigFeatureConfig.fromJson(
    core.Map json_,
  ) : this(
        driftThreshold: (json_['driftThreshold'] as core.num?)?.toDouble(),
        featureId: json_['featureId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (driftThreshold != null) 'driftThreshold': driftThreshold!,
    if (featureId != null) 'featureId': featureId!,
  };
}

/// Selector for Features of an EntityType.
class GoogleCloudAiplatformV1beta1FeatureSelector {
  /// Matches Features based on ID.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1IdMatcher? idMatcher;

  GoogleCloudAiplatformV1beta1FeatureSelector({this.idMatcher});

  GoogleCloudAiplatformV1beta1FeatureSelector.fromJson(core.Map json_)
    : this(
        idMatcher:
            json_.containsKey('idMatcher')
                ? GoogleCloudAiplatformV1beta1IdMatcher.fromJson(
                  json_['idMatcher'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (idMatcher != null) 'idMatcher': idMatcher!,
  };
}

/// Stats and Anomaly generated by FeatureMonitorJobs.
///
/// Anomaly only includes Drift.
class GoogleCloudAiplatformV1beta1FeatureStatsAndAnomaly {
  /// Deviation from the current stats to baseline stats.
  ///
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by JensenShannon divergence.
  core.double? distributionDeviation;

  /// If set to true, indicates current stats is detected as and comparing with
  /// baseline stats.
  core.bool? driftDetected;

  /// This is the threshold used when detecting drifts, which is set in
  /// FeatureMonitor.FeatureSelectionConfig.FeatureConfig.drift_threshold
  core.double? driftDetectionThreshold;

  /// Feature Id.
  core.String? featureId;

  /// The ID of the FeatureMonitor that this FeatureStatsAndAnomaly generated
  /// according to.
  core.String? featureMonitorId;

  /// The ID of the FeatureMonitorJob that generated this
  /// FeatureStatsAndAnomaly.
  core.String? featureMonitorJobId;

  /// Feature stats.
  ///
  /// e.g. histogram buckets. In the format of
  /// tensorflow.metadata.v0.DatasetFeatureStatistics.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? featureStats;

  /// The timestamp we take snapshot for feature values to generate stats.
  core.String? statsTime;

  GoogleCloudAiplatformV1beta1FeatureStatsAndAnomaly({
    this.distributionDeviation,
    this.driftDetected,
    this.driftDetectionThreshold,
    this.featureId,
    this.featureMonitorId,
    this.featureMonitorJobId,
    this.featureStats,
    this.statsTime,
  });

  GoogleCloudAiplatformV1beta1FeatureStatsAndAnomaly.fromJson(core.Map json_)
    : this(
        distributionDeviation:
            (json_['distributionDeviation'] as core.num?)?.toDouble(),
        driftDetected: json_['driftDetected'] as core.bool?,
        driftDetectionThreshold:
            (json_['driftDetectionThreshold'] as core.num?)?.toDouble(),
        featureId: json_['featureId'] as core.String?,
        featureMonitorId: json_['featureMonitorId'] as core.String?,
        featureMonitorJobId: json_['featureMonitorJobId'] as core.String?,
        featureStats: json_['featureStats'],
        statsTime: json_['statsTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (distributionDeviation != null)
      'distributionDeviation': distributionDeviation!,
    if (driftDetected != null) 'driftDetected': driftDetected!,
    if (driftDetectionThreshold != null)
      'driftDetectionThreshold': driftDetectionThreshold!,
    if (featureId != null) 'featureId': featureId!,
    if (featureMonitorId != null) 'featureMonitorId': featureMonitorId!,
    if (featureMonitorJobId != null)
      'featureMonitorJobId': featureMonitorJobId!,
    if (featureStats != null) 'featureStats': featureStats!,
    if (statsTime != null) 'statsTime': statsTime!,
  };
}

/// Stats and Anomaly generated at specific timestamp for specific Feature.
///
/// The start_time and end_time are used to define the time range of the dataset
/// that current stats belongs to, e.g. prediction traffic is bucketed into
/// prediction datasets by time window. If the Dataset is not defined by time
/// window, start_time = end_time. Timestamp of the stats and anomalies always
/// refers to end_time. Raw stats and anomalies are stored in stats_uri or
/// anomaly_uri in the tensorflow defined protos. Field data_stats contains
/// almost identical information with the raw stats in Vertex AI defined proto,
/// for UI to display.
typedef GoogleCloudAiplatformV1beta1FeatureStatsAnomaly = $FeatureStatsAnomaly;

/// Value for a feature.
class GoogleCloudAiplatformV1beta1FeatureValue {
  /// A list of bool type feature value.
  GoogleCloudAiplatformV1beta1BoolArray? boolArrayValue;

  /// Bool type feature value.
  core.bool? boolValue;

  /// Bytes feature value.
  core.String? bytesValue;
  core.List<core.int> get bytesValueAsBytes =>
      convert.base64.decode(bytesValue!);

  set bytesValueAsBytes(core.List<core.int> bytes_) {
    bytesValue = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// A list of double type feature value.
  GoogleCloudAiplatformV1beta1DoubleArray? doubleArrayValue;

  /// Double type feature value.
  core.double? doubleValue;

  /// A list of int64 type feature value.
  GoogleCloudAiplatformV1beta1Int64Array? int64ArrayValue;

  /// Int64 feature value.
  core.String? int64Value;

  /// Metadata of feature value.
  GoogleCloudAiplatformV1beta1FeatureValueMetadata? metadata;

  /// A list of string type feature value.
  GoogleCloudAiplatformV1beta1StringArray? stringArrayValue;

  /// String feature value.
  core.String? stringValue;

  /// A struct type feature value.
  GoogleCloudAiplatformV1beta1StructValue? structValue;

  GoogleCloudAiplatformV1beta1FeatureValue({
    this.boolArrayValue,
    this.boolValue,
    this.bytesValue,
    this.doubleArrayValue,
    this.doubleValue,
    this.int64ArrayValue,
    this.int64Value,
    this.metadata,
    this.stringArrayValue,
    this.stringValue,
    this.structValue,
  });

  GoogleCloudAiplatformV1beta1FeatureValue.fromJson(core.Map json_)
    : this(
        boolArrayValue:
            json_.containsKey('boolArrayValue')
                ? GoogleCloudAiplatformV1beta1BoolArray.fromJson(
                  json_['boolArrayValue']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        boolValue: json_['boolValue'] as core.bool?,
        bytesValue: json_['bytesValue'] as core.String?,
        doubleArrayValue:
            json_.containsKey('doubleArrayValue')
                ? GoogleCloudAiplatformV1beta1DoubleArray.fromJson(
                  json_['doubleArrayValue']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
        int64ArrayValue:
            json_.containsKey('int64ArrayValue')
                ? GoogleCloudAiplatformV1beta1Int64Array.fromJson(
                  json_['int64ArrayValue']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        int64Value: json_['int64Value'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? GoogleCloudAiplatformV1beta1FeatureValueMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        stringArrayValue:
            json_.containsKey('stringArrayValue')
                ? GoogleCloudAiplatformV1beta1StringArray.fromJson(
                  json_['stringArrayValue']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        stringValue: json_['stringValue'] as core.String?,
        structValue:
            json_.containsKey('structValue')
                ? GoogleCloudAiplatformV1beta1StructValue.fromJson(
                  json_['structValue'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boolArrayValue != null) 'boolArrayValue': boolArrayValue!,
    if (boolValue != null) 'boolValue': boolValue!,
    if (bytesValue != null) 'bytesValue': bytesValue!,
    if (doubleArrayValue != null) 'doubleArrayValue': doubleArrayValue!,
    if (doubleValue != null) 'doubleValue': doubleValue!,
    if (int64ArrayValue != null) 'int64ArrayValue': int64ArrayValue!,
    if (int64Value != null) 'int64Value': int64Value!,
    if (metadata != null) 'metadata': metadata!,
    if (stringArrayValue != null) 'stringArrayValue': stringArrayValue!,
    if (stringValue != null) 'stringValue': stringValue!,
    if (structValue != null) 'structValue': structValue!,
  };
}

/// A destination location for Feature values and format.
class GoogleCloudAiplatformV1beta1FeatureValueDestination {
  /// Output in BigQuery format.
  ///
  /// BigQueryDestination.output_uri in
  /// FeatureValueDestination.bigquery_destination must refer to a table.
  GoogleCloudAiplatformV1beta1BigQueryDestination? bigqueryDestination;

  /// Output in CSV format.
  ///
  /// Array Feature value types are not allowed in CSV format.
  GoogleCloudAiplatformV1beta1CsvDestination? csvDestination;

  /// Output in TFRecord format.
  ///
  /// Below are the mapping from Feature value type in Featurestore to Feature
  /// value type in TFRecord: Value type in Featurestore | Value type in
  /// TFRecord DOUBLE, DOUBLE_ARRAY | FLOAT_LIST INT64, INT64_ARRAY | INT64_LIST
  /// STRING, STRING_ARRAY, BYTES | BYTES_LIST true -\> byte_string("true"),
  /// false -\> byte_string("false") BOOL, BOOL_ARRAY (true, false) | BYTES_LIST
  GoogleCloudAiplatformV1beta1TFRecordDestination? tfrecordDestination;

  GoogleCloudAiplatformV1beta1FeatureValueDestination({
    this.bigqueryDestination,
    this.csvDestination,
    this.tfrecordDestination,
  });

  GoogleCloudAiplatformV1beta1FeatureValueDestination.fromJson(core.Map json_)
    : this(
        bigqueryDestination:
            json_.containsKey('bigqueryDestination')
                ? GoogleCloudAiplatformV1beta1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        csvDestination:
            json_.containsKey('csvDestination')
                ? GoogleCloudAiplatformV1beta1CsvDestination.fromJson(
                  json_['csvDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tfrecordDestination:
            json_.containsKey('tfrecordDestination')
                ? GoogleCloudAiplatformV1beta1TFRecordDestination.fromJson(
                  json_['tfrecordDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!,
    if (csvDestination != null) 'csvDestination': csvDestination!,
    if (tfrecordDestination != null)
      'tfrecordDestination': tfrecordDestination!,
  };
}

/// Container for list of values.
class GoogleCloudAiplatformV1beta1FeatureValueList {
  /// A list of feature values.
  ///
  /// All of them should be the same data type.
  core.List<GoogleCloudAiplatformV1beta1FeatureValue>? values;

  GoogleCloudAiplatformV1beta1FeatureValueList({this.values});

  GoogleCloudAiplatformV1beta1FeatureValueList.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1FeatureValue.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// Metadata of feature value.
typedef GoogleCloudAiplatformV1beta1FeatureValueMetadata =
    $FeatureValueMetadata;

/// FeatureView is representation of values that the FeatureOnlineStore will
/// serve based on its syncConfig.
class GoogleCloudAiplatformV1beta1FeatureView {
  /// Configures how data is supposed to be extracted from a BigQuery source to
  /// be loaded onto the FeatureOnlineStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewBigQuerySource? bigQuerySource;

  /// Timestamp when this FeatureView was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Configures the features from a Feature Registry source that need to be
  /// loaded onto the FeatureOnlineStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySource?
  featureRegistrySource;

  /// Configuration for index preparation for vector search.
  ///
  /// It contains the required configurations to create an index from source
  /// data, so that approximate nearest neighbor (a.k.a ANN) algorithms search
  /// can be performed during online serving.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewIndexConfig? indexConfig;

  /// The labels with user-defined metadata to organize your FeatureViews.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label
  /// keys are prefixed with "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureView. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  core.String? name;

  /// Configuration for FeatureView created under Optimized FeatureOnlineStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewOptimizedConfig? optimizedConfig;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// A Service Account unique to this FeatureView.
  ///
  /// The role bigquery.dataViewer should be granted to this service account to
  /// allow Vertex AI Feature Store to sync data to the online store.
  ///
  /// Output only.
  core.String? serviceAccountEmail;

  /// Service agent type used during data sync.
  ///
  /// By default, the Vertex AI Service Agent is used. When using an IAM Policy
  /// to isolate this FeatureView within a project, a separate service account
  /// should be provisioned by setting this field to
  /// `SERVICE_AGENT_TYPE_FEATURE_VIEW`. This will generate a separate service
  /// account to access the BigQuery source table.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SERVICE_AGENT_TYPE_UNSPECIFIED" : By default, the project-level Vertex
  /// AI Service Agent is enabled.
  /// - "SERVICE_AGENT_TYPE_PROJECT" : Indicates the project-level Vertex AI
  /// Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used during sync jobs.
  /// - "SERVICE_AGENT_TYPE_FEATURE_VIEW" : Enable a FeatureView service account
  /// to be created by Vertex AI and output in the field
  /// `service_account_email`. This service account will be used to read from
  /// the source BigQuery table during sync.
  core.String? serviceAgentType;

  /// Configures when data is to be synced/updated for this FeatureView.
  ///
  /// At the end of the sync the latest featureValues for each entityId of this
  /// FeatureView are made ready for online serving.
  GoogleCloudAiplatformV1beta1FeatureViewSyncConfig? syncConfig;

  /// Timestamp when this FeatureView was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Deprecated: please use FeatureView.index_config instead.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfig? vectorSearchConfig;

  /// The Vertex RAG Source that the FeatureView is linked to.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewVertexRagSource? vertexRagSource;

  GoogleCloudAiplatformV1beta1FeatureView({
    this.bigQuerySource,
    this.createTime,
    this.etag,
    this.featureRegistrySource,
    this.indexConfig,
    this.labels,
    this.name,
    this.optimizedConfig,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccountEmail,
    this.serviceAgentType,
    this.syncConfig,
    this.updateTime,
    this.vectorSearchConfig,
    this.vertexRagSource,
  });

  GoogleCloudAiplatformV1beta1FeatureView.fromJson(core.Map json_)
    : this(
        bigQuerySource:
            json_.containsKey('bigQuerySource')
                ? GoogleCloudAiplatformV1beta1FeatureViewBigQuerySource.fromJson(
                  json_['bigQuerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        etag: json_['etag'] as core.String?,
        featureRegistrySource:
            json_.containsKey('featureRegistrySource')
                ? GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySource.fromJson(
                  json_['featureRegistrySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        indexConfig:
            json_.containsKey('indexConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewIndexConfig.fromJson(
                  json_['indexConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        optimizedConfig:
            json_.containsKey('optimizedConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewOptimizedConfig.fromJson(
                  json_['optimizedConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
        serviceAgentType: json_['serviceAgentType'] as core.String?,
        syncConfig:
            json_.containsKey('syncConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewSyncConfig.fromJson(
                  json_['syncConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
        vectorSearchConfig:
            json_.containsKey('vectorSearchConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfig.fromJson(
                  json_['vectorSearchConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexRagSource:
            json_.containsKey('vertexRagSource')
                ? GoogleCloudAiplatformV1beta1FeatureViewVertexRagSource.fromJson(
                  json_['vertexRagSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!,
    if (createTime != null) 'createTime': createTime!,
    if (etag != null) 'etag': etag!,
    if (featureRegistrySource != null)
      'featureRegistrySource': featureRegistrySource!,
    if (indexConfig != null) 'indexConfig': indexConfig!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (optimizedConfig != null) 'optimizedConfig': optimizedConfig!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (serviceAccountEmail != null)
      'serviceAccountEmail': serviceAccountEmail!,
    if (serviceAgentType != null) 'serviceAgentType': serviceAgentType!,
    if (syncConfig != null) 'syncConfig': syncConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (vectorSearchConfig != null) 'vectorSearchConfig': vectorSearchConfig!,
    if (vertexRagSource != null) 'vertexRagSource': vertexRagSource!,
  };
}

typedef GoogleCloudAiplatformV1beta1FeatureViewBigQuerySource =
    $FeatureViewBigQuerySource;

/// Lookup key for a feature view.
class GoogleCloudAiplatformV1beta1FeatureViewDataKey {
  /// The actual Entity ID will be composed from this struct.
  ///
  /// This should match with the way ID is defined in the FeatureView spec.
  GoogleCloudAiplatformV1beta1FeatureViewDataKeyCompositeKey? compositeKey;

  /// String key to use for lookup.
  core.String? key;

  GoogleCloudAiplatformV1beta1FeatureViewDataKey({this.compositeKey, this.key});

  GoogleCloudAiplatformV1beta1FeatureViewDataKey.fromJson(core.Map json_)
    : this(
        compositeKey:
            json_.containsKey('compositeKey')
                ? GoogleCloudAiplatformV1beta1FeatureViewDataKeyCompositeKey.fromJson(
                  json_['compositeKey'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        key: json_['key'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (compositeKey != null) 'compositeKey': compositeKey!,
    if (key != null) 'key': key!,
  };
}

/// ID that is comprised from several parts (columns).
typedef GoogleCloudAiplatformV1beta1FeatureViewDataKeyCompositeKey =
    $FeatureViewDataKeyCompositeKey;

/// Request message for FeatureOnlineStoreService.FeatureViewDirectWrite.
class GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequest {
  /// The data keys and associated feature values.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValues
  >?
  dataKeyAndFeatureValues;

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequest({
    this.dataKeyAndFeatureValues,
  });

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequest.fromJson(
    core.Map json_,
  ) : this(
        dataKeyAndFeatureValues:
            (json_['dataKeyAndFeatureValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValues.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataKeyAndFeatureValues != null)
      'dataKeyAndFeatureValues': dataKeyAndFeatureValues!,
  };
}

/// A data key and associated feature values to write to the feature view.
class GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValues {
  /// The data key.
  GoogleCloudAiplatformV1beta1FeatureViewDataKey? dataKey;

  /// List of features to write.
  core.List<
    GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeature
  >?
  features;

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValues({
    this.dataKey,
    this.features,
  });

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValues.fromJson(
    core.Map json_,
  ) : this(
        dataKey:
            json_.containsKey('dataKey')
                ? GoogleCloudAiplatformV1beta1FeatureViewDataKey.fromJson(
                  json_['dataKey'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        features:
            (json_['features'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeature.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataKey != null) 'dataKey': dataKey!,
    if (features != null) 'features': features!,
  };
}

/// Feature name & value pair.
class GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeature {
  /// Feature short name.
  core.String? name;

  /// Feature value.
  ///
  /// A user provided timestamp may be set in the
  /// `FeatureValue.metadata.generate_time` field.
  GoogleCloudAiplatformV1beta1FeatureValue? value;

  /// Feature value and timestamp.
  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeatureFeatureValueAndTimestamp?
  valueAndTimestamp;

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeature({
    this.name,
    this.value,
    this.valueAndTimestamp,
  });

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeature.fromJson(
    core.Map json_,
  ) : this(
        name: json_['name'] as core.String?,
        value:
            json_.containsKey('value')
                ? GoogleCloudAiplatformV1beta1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        valueAndTimestamp:
            json_.containsKey('valueAndTimestamp')
                ? GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeatureFeatureValueAndTimestamp.fromJson(
                  json_['valueAndTimestamp']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
    if (valueAndTimestamp != null) 'valueAndTimestamp': valueAndTimestamp!,
  };
}

/// Feature value and timestamp.
class GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeatureFeatureValueAndTimestamp {
  /// The feature timestamp to store with this value.
  ///
  /// If not set, then the Feature Store server will generate a timestamp when
  /// it receives the write request.
  core.String? timestamp;

  /// The feature value.
  GoogleCloudAiplatformV1beta1FeatureValue? value;

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeatureFeatureValueAndTimestamp({
    this.timestamp,
    this.value,
  });

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteRequestDataKeyAndFeatureValuesFeatureFeatureValueAndTimestamp.fromJson(
    core.Map json_,
  ) : this(
        timestamp: json_['timestamp'] as core.String?,
        value:
            json_.containsKey('value')
                ? GoogleCloudAiplatformV1beta1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (timestamp != null) 'timestamp': timestamp!,
    if (value != null) 'value': value!,
  };
}

/// Response message for FeatureOnlineStoreService.FeatureViewDirectWrite.
class GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponse {
  /// Response status for the keys listed in
  /// FeatureViewDirectWriteResponse.write_responses.
  ///
  /// The error only applies to the listed data keys - the stream will remain
  /// open for further FeatureOnlineStoreService.FeatureViewDirectWriteRequest
  /// requests. Partial failures (e.g. if the first 10 keys of a request fail,
  /// but the rest succeed) from a single request may result in multiple
  /// responses - there will be one response for the successful request keys and
  /// one response for the failing request keys.
  GoogleRpcStatus? status;

  /// Details about write for each key.
  ///
  /// If status is not OK, WriteResponse.data_key will have the key with error,
  /// but WriteResponse.online_store_write_time will not be present.
  core.List<
    GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponseWriteResponse
  >?
  writeResponses;

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponse({
    this.status,
    this.writeResponses,
  });

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponse.fromJson(
    core.Map json_,
  ) : this(
        status:
            json_.containsKey('status')
                ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        writeResponses:
            (json_['writeResponses'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponseWriteResponse.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (status != null) 'status': status!,
    if (writeResponses != null) 'writeResponses': writeResponses!,
  };
}

/// Details about the write for each key.
class GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponseWriteResponse {
  /// What key is this write response associated with.
  GoogleCloudAiplatformV1beta1FeatureViewDataKey? dataKey;

  /// When the feature values were written to the online store.
  ///
  /// If FeatureViewDirectWriteResponse.status is not OK, this field is not
  /// populated.
  core.String? onlineStoreWriteTime;

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponseWriteResponse({
    this.dataKey,
    this.onlineStoreWriteTime,
  });

  GoogleCloudAiplatformV1beta1FeatureViewDirectWriteResponseWriteResponse.fromJson(
    core.Map json_,
  ) : this(
        dataKey:
            json_.containsKey('dataKey')
                ? GoogleCloudAiplatformV1beta1FeatureViewDataKey.fromJson(
                  json_['dataKey'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        onlineStoreWriteTime: json_['onlineStoreWriteTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataKey != null) 'dataKey': dataKey!,
    if (onlineStoreWriteTime != null)
      'onlineStoreWriteTime': onlineStoreWriteTime!,
  };
}

/// A Feature Registry source for features that need to be synced to Online
/// Store.
class GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySource {
  /// List of features that need to be synced to Online Store.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySourceFeatureGroup
  >?
  featureGroups;

  /// The project number of the parent project of the Feature Groups.
  ///
  /// Optional.
  core.String? projectNumber;

  GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySource({
    this.featureGroups,
    this.projectNumber,
  });

  GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySource.fromJson(
    core.Map json_,
  ) : this(
        featureGroups:
            (json_['featureGroups'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySourceFeatureGroup.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        projectNumber: json_['projectNumber'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureGroups != null) 'featureGroups': featureGroups!,
    if (projectNumber != null) 'projectNumber': projectNumber!,
  };
}

/// Features belonging to a single feature group that will be synced to Online
/// Store.
typedef GoogleCloudAiplatformV1beta1FeatureViewFeatureRegistrySourceFeatureGroup =
    $FeatureViewFeatureRegistrySourceFeatureGroup;

/// Configuration for vector indexing.
class GoogleCloudAiplatformV1beta1FeatureViewIndexConfig {
  /// Configuration options for using brute force search, which simply
  /// implements the standard linear search in the database for each query.
  ///
  /// It is primarily meant for benchmarking and to generate the ground truth
  /// for approximate search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewIndexConfigBruteForceConfig?
  bruteForceConfig;

  /// Column of crowding.
  ///
  /// This column contains crowding attribute which is a constraint on a
  /// neighbor list produced by FeatureOnlineStoreService.SearchNearestEntities
  /// to diversify search results. If
  /// NearestNeighborQuery.per_crowding_attribute_neighbor_count is set to K in
  /// SearchNearestEntitiesRequest, it's guaranteed that no more than K entities
  /// of the same crowding attribute are returned in the response.
  ///
  /// Optional.
  core.String? crowdingColumn;

  /// The distance measure used in nearest neighbor search.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DISTANCE_MEASURE_TYPE_UNSPECIFIED" : Should not be set.
  /// - "SQUARED_L2_DISTANCE" : Euclidean (L_2) Distance.
  /// - "COSINE_DISTANCE" : Cosine Distance. Defined as 1 - cosine similarity.
  /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead of
  /// COSINE distance. Our algorithms have been more optimized for DOT_PRODUCT
  /// distance which, when combined with UNIT_L2_NORM, is mathematically
  /// equivalent to COSINE distance and results in the same ranking.
  /// - "DOT_PRODUCT_DISTANCE" : Dot Product Distance. Defined as a negative of
  /// the dot product.
  core.String? distanceMeasureType;

  /// Column of embedding.
  ///
  /// This column contains the source data to create index for vector search.
  /// embedding_column must be set when using vector search.
  ///
  /// Optional.
  core.String? embeddingColumn;

  /// The number of dimensions of the input embedding.
  ///
  /// Optional.
  core.int? embeddingDimension;

  /// Columns of features that're used to filter vector search results.
  ///
  /// Optional.
  core.List<core.String>? filterColumns;

  /// Configuration options for the tree-AH algorithm (Shallow tree + Asymmetric
  /// Hashing).
  ///
  /// Please refer to this paper for more details:
  /// https://arxiv.org/abs/1908.10396
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewIndexConfigTreeAHConfig? treeAhConfig;

  GoogleCloudAiplatformV1beta1FeatureViewIndexConfig({
    this.bruteForceConfig,
    this.crowdingColumn,
    this.distanceMeasureType,
    this.embeddingColumn,
    this.embeddingDimension,
    this.filterColumns,
    this.treeAhConfig,
  });

  GoogleCloudAiplatformV1beta1FeatureViewIndexConfig.fromJson(core.Map json_)
    : this(
        bruteForceConfig:
            json_.containsKey('bruteForceConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewIndexConfigBruteForceConfig.fromJson(
                  json_['bruteForceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        crowdingColumn: json_['crowdingColumn'] as core.String?,
        distanceMeasureType: json_['distanceMeasureType'] as core.String?,
        embeddingColumn: json_['embeddingColumn'] as core.String?,
        embeddingDimension: json_['embeddingDimension'] as core.int?,
        filterColumns:
            (json_['filterColumns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        treeAhConfig:
            json_.containsKey('treeAhConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewIndexConfigTreeAHConfig.fromJson(
                  json_['treeAhConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bruteForceConfig != null) 'bruteForceConfig': bruteForceConfig!,
    if (crowdingColumn != null) 'crowdingColumn': crowdingColumn!,
    if (distanceMeasureType != null)
      'distanceMeasureType': distanceMeasureType!,
    if (embeddingColumn != null) 'embeddingColumn': embeddingColumn!,
    if (embeddingDimension != null) 'embeddingDimension': embeddingDimension!,
    if (filterColumns != null) 'filterColumns': filterColumns!,
    if (treeAhConfig != null) 'treeAhConfig': treeAhConfig!,
  };
}

/// Configuration options for using brute force search.
typedef GoogleCloudAiplatformV1beta1FeatureViewIndexConfigBruteForceConfig =
    $Empty;

/// Configuration options for the tree-AH algorithm.
typedef GoogleCloudAiplatformV1beta1FeatureViewIndexConfigTreeAHConfig =
    $ConfigTreeAHConfig;

/// Configuration for FeatureViews created in Optimized FeatureOnlineStore.
class GoogleCloudAiplatformV1beta1FeatureViewOptimizedConfig {
  /// A description of resources that the FeatureView uses, which to large
  /// degree are decided by Vertex AI, and optionally allows only a modest
  /// additional configuration.
  ///
  /// If min_replica_count is not set, the default value is 2. If
  /// max_replica_count is not set, the default value is 6. The max allowed
  /// replica count is 1000.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1AutomaticResources? automaticResources;

  GoogleCloudAiplatformV1beta1FeatureViewOptimizedConfig({
    this.automaticResources,
  });

  GoogleCloudAiplatformV1beta1FeatureViewOptimizedConfig.fromJson(
    core.Map json_,
  ) : this(
        automaticResources:
            json_.containsKey('automaticResources')
                ? GoogleCloudAiplatformV1beta1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (automaticResources != null) 'automaticResources': automaticResources!,
  };
}

/// FeatureViewSync is a representation of sync operation which copies data from
/// data source to Feature View in Online Store.
class GoogleCloudAiplatformV1beta1FeatureViewSync {
  /// Time when this FeatureViewSync is created.
  ///
  /// Creation of a FeatureViewSync means that the job is pending / waiting for
  /// sufficient resources but may not have started the actual data transfer
  /// yet.
  ///
  /// Output only.
  core.String? createTime;

  /// Final status of the FeatureViewSync.
  ///
  /// Output only.
  GoogleRpcStatus? finalStatus;

  /// Identifier.
  ///
  /// Name of the FeatureViewSync. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  core.String? name;

  /// Time when this FeatureViewSync is finished.
  ///
  /// Output only.
  GoogleTypeInterval? runTime;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Summary of the sync job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1FeatureViewSyncSyncSummary? syncSummary;

  GoogleCloudAiplatformV1beta1FeatureViewSync({
    this.createTime,
    this.finalStatus,
    this.name,
    this.runTime,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.syncSummary,
  });

  GoogleCloudAiplatformV1beta1FeatureViewSync.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        finalStatus:
            json_.containsKey('finalStatus')
                ? GoogleRpcStatus.fromJson(
                  json_['finalStatus'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        runTime:
            json_.containsKey('runTime')
                ? GoogleTypeInterval.fromJson(
                  json_['runTime'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        syncSummary:
            json_.containsKey('syncSummary')
                ? GoogleCloudAiplatformV1beta1FeatureViewSyncSyncSummary.fromJson(
                  json_['syncSummary'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (finalStatus != null) 'finalStatus': finalStatus!,
    if (name != null) 'name': name!,
    if (runTime != null) 'runTime': runTime!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (syncSummary != null) 'syncSummary': syncSummary!,
  };
}

/// Configuration for Sync.
///
/// Only one option is set.
typedef GoogleCloudAiplatformV1beta1FeatureViewSyncConfig =
    $FeatureViewSyncConfig;

/// Summary from the Sync job.
///
/// For continuous syncs, the summary is updated periodically. For batch syncs,
/// it gets updated on completion of the sync.
typedef GoogleCloudAiplatformV1beta1FeatureViewSyncSyncSummary =
    $FeatureViewSyncSyncSummary;

/// Use IndexConfig instead.
///
/// Deprecated.
class GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfig {
  /// Configuration options for using brute force search, which simply
  /// implements the standard linear search in the database for each query.
  ///
  /// It is primarily meant for benchmarking and to generate the ground truth
  /// for approximate search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigBruteForceConfig?
  bruteForceConfig;

  /// Column of crowding.
  ///
  /// This column contains crowding attribute which is a constraint on a
  /// neighbor list produced by FeatureOnlineStoreService.SearchNearestEntities
  /// to diversify search results. If
  /// NearestNeighborQuery.per_crowding_attribute_neighbor_count is set to K in
  /// SearchNearestEntitiesRequest, it's guaranteed that no more than K entities
  /// of the same crowding attribute are returned in the response.
  ///
  /// Optional.
  core.String? crowdingColumn;

  /// The distance measure used in nearest neighbor search.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DISTANCE_MEASURE_TYPE_UNSPECIFIED" : Should not be set.
  /// - "SQUARED_L2_DISTANCE" : Euclidean (L_2) Distance.
  /// - "COSINE_DISTANCE" : Cosine Distance. Defined as 1 - cosine similarity.
  /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead of
  /// COSINE distance. Our algorithms have been more optimized for DOT_PRODUCT
  /// distance which, when combined with UNIT_L2_NORM, is mathematically
  /// equivalent to COSINE distance and results in the same ranking.
  /// - "DOT_PRODUCT_DISTANCE" : Dot Product Distance. Defined as a negative of
  /// the dot product.
  core.String? distanceMeasureType;

  /// Column of embedding.
  ///
  /// This column contains the source data to create index for vector search.
  /// embedding_column must be set when using vector search.
  ///
  /// Optional.
  core.String? embeddingColumn;

  /// The number of dimensions of the input embedding.
  ///
  /// Optional.
  core.int? embeddingDimension;

  /// Columns of features that're used to filter vector search results.
  ///
  /// Optional.
  core.List<core.String>? filterColumns;

  /// Configuration options for the tree-AH algorithm (Shallow tree + Asymmetric
  /// Hashing).
  ///
  /// Please refer to this paper for more details:
  /// https://arxiv.org/abs/1908.10396
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigTreeAHConfig?
  treeAhConfig;

  GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfig({
    this.bruteForceConfig,
    this.crowdingColumn,
    this.distanceMeasureType,
    this.embeddingColumn,
    this.embeddingDimension,
    this.filterColumns,
    this.treeAhConfig,
  });

  GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfig.fromJson(
    core.Map json_,
  ) : this(
        bruteForceConfig:
            json_.containsKey('bruteForceConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigBruteForceConfig.fromJson(
                  json_['bruteForceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        crowdingColumn: json_['crowdingColumn'] as core.String?,
        distanceMeasureType: json_['distanceMeasureType'] as core.String?,
        embeddingColumn: json_['embeddingColumn'] as core.String?,
        embeddingDimension: json_['embeddingDimension'] as core.int?,
        filterColumns:
            (json_['filterColumns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        treeAhConfig:
            json_.containsKey('treeAhConfig')
                ? GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigTreeAHConfig.fromJson(
                  json_['treeAhConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bruteForceConfig != null) 'bruteForceConfig': bruteForceConfig!,
    if (crowdingColumn != null) 'crowdingColumn': crowdingColumn!,
    if (distanceMeasureType != null)
      'distanceMeasureType': distanceMeasureType!,
    if (embeddingColumn != null) 'embeddingColumn': embeddingColumn!,
    if (embeddingDimension != null) 'embeddingDimension': embeddingDimension!,
    if (filterColumns != null) 'filterColumns': filterColumns!,
    if (treeAhConfig != null) 'treeAhConfig': treeAhConfig!,
  };
}

typedef GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigBruteForceConfig =
    $Empty;
typedef GoogleCloudAiplatformV1beta1FeatureViewVectorSearchConfigTreeAHConfig =
    $ConfigTreeAHConfig;

/// A Vertex Rag source for features that need to be synced to Online Store.
typedef GoogleCloudAiplatformV1beta1FeatureViewVertexRagSource =
    $FeatureViewVertexRagSource;

/// Vertex AI Feature Store provides a centralized repository for organizing,
/// storing, and serving ML features.
///
/// The Featurestore is a top-level container for your features and their
/// values.
class GoogleCloudAiplatformV1beta1Featurestore {
  /// Timestamp when this Featurestore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Customer-managed encryption key spec for data storage.
  ///
  /// If set, both of the online and offline data storage will be secured by
  /// this key.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Featurestore.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one Featurestore(System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Name of the Featurestore.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  ///
  /// Output only.
  core.String? name;

  /// Config for online storage resources.
  ///
  /// The field should not co-exist with the field of
  /// `OnlineStoreReplicationConfig`. If both of it and
  /// OnlineStoreReplicationConfig are unset, the feature store will not have an
  /// online store and cannot be used for online serving.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfig?
  onlineServingConfig;

  /// TTL in days for feature values that will be stored in online serving
  /// storage.
  ///
  /// The Feature Store online storage periodically removes obsolete feature
  /// values older than `online_storage_ttl_days` since the feature generation
  /// time. Note that `online_storage_ttl_days` should be less than or equal to
  /// `offline_storage_ttl_days` for each EntityType under a featurestore. If
  /// not set, default to 4000 days
  ///
  /// Optional.
  core.int? onlineStorageTtlDays;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// State of the featurestore.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value. This value is unused.
  /// - "STABLE" : State when the featurestore configuration is not being
  /// updated and the fields reflect the current configuration of the
  /// featurestore. The featurestore is usable in this state.
  /// - "UPDATING" : The state of the featurestore configuration when it is
  /// being updated. During an update, the fields reflect either the original
  /// configuration or the updated configuration of the featurestore. For
  /// example, `online_serving_config.fixed_node_count` can take minutes to
  /// update. While the update is in progress, the featurestore is in the
  /// UPDATING state, and the value of `fixed_node_count` can be the original
  /// value or the updated value, depending on the progress of the operation.
  /// Until the update completes, the actual number of nodes can still be the
  /// original value of `fixed_node_count`. The featurestore is still usable in
  /// this state.
  core.String? state;

  /// Timestamp when this Featurestore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Featurestore({
    this.createTime,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.onlineServingConfig,
    this.onlineStorageTtlDays,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Featurestore.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        onlineServingConfig:
            json_.containsKey('onlineServingConfig')
                ? GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfig.fromJson(
                  json_['onlineServingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        onlineStorageTtlDays: json_['onlineStorageTtlDays'] as core.int?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (onlineServingConfig != null)
      'onlineServingConfig': onlineServingConfig!,
    if (onlineStorageTtlDays != null)
      'onlineStorageTtlDays': onlineStorageTtlDays!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Configuration of how features in Featurestore are monitored.
class GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfig {
  /// Threshold for categorical features of anomaly detection.
  ///
  /// This is shared by all types of Featurestore Monitoring for categorical
  /// features (i.e. Features with type (Feature.ValueType) BOOL or STRING).
  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigThresholdConfig?
  categoricalThresholdConfig;

  /// The config for ImportFeatures Analysis Based Feature Monitoring.
  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigImportFeaturesAnalysis?
  importFeaturesAnalysis;

  /// Threshold for numerical features of anomaly detection.
  ///
  /// This is shared by all objectives of Featurestore Monitoring for numerical
  /// features (i.e. Features with type (Feature.ValueType) DOUBLE or INT64).
  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigThresholdConfig?
  numericalThresholdConfig;

  /// The config for Snapshot Analysis Based Feature Monitoring.
  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigSnapshotAnalysis?
  snapshotAnalysis;

  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfig({
    this.categoricalThresholdConfig,
    this.importFeaturesAnalysis,
    this.numericalThresholdConfig,
    this.snapshotAnalysis,
  });

  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfig.fromJson(
    core.Map json_,
  ) : this(
        categoricalThresholdConfig:
            json_.containsKey('categoricalThresholdConfig')
                ? GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigThresholdConfig.fromJson(
                  json_['categoricalThresholdConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        importFeaturesAnalysis:
            json_.containsKey('importFeaturesAnalysis')
                ? GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigImportFeaturesAnalysis.fromJson(
                  json_['importFeaturesAnalysis']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        numericalThresholdConfig:
            json_.containsKey('numericalThresholdConfig')
                ? GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigThresholdConfig.fromJson(
                  json_['numericalThresholdConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        snapshotAnalysis:
            json_.containsKey('snapshotAnalysis')
                ? GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigSnapshotAnalysis.fromJson(
                  json_['snapshotAnalysis']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (categoricalThresholdConfig != null)
      'categoricalThresholdConfig': categoricalThresholdConfig!,
    if (importFeaturesAnalysis != null)
      'importFeaturesAnalysis': importFeaturesAnalysis!,
    if (numericalThresholdConfig != null)
      'numericalThresholdConfig': numericalThresholdConfig!,
    if (snapshotAnalysis != null) 'snapshotAnalysis': snapshotAnalysis!,
  };
}

/// Configuration of the Featurestore's ImportFeature Analysis Based Monitoring.
///
/// This type of analysis generates statistics for values of each Feature
/// imported by every ImportFeatureValues operation.
typedef GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigImportFeaturesAnalysis =
    $FeaturestoreMonitoringConfigImportFeaturesAnalysis;

/// Configuration of the Featurestore's Snapshot Analysis Based Monitoring.
///
/// This type of analysis generates statistics for each Feature based on a
/// snapshot of the latest feature value of each entities every
/// monitoring_interval.
class GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigSnapshotAnalysis {
  /// The monitoring schedule for snapshot analysis.
  ///
  /// For EntityType-level config: unset / disabled = true indicates disabled by
  /// default for Features under it; otherwise by default enable snapshot
  /// analysis monitoring with monitoring_interval for Features under it.
  /// Feature-level config: disabled = true indicates disabled regardless of the
  /// EntityType-level config; unset monitoring_interval indicates going with
  /// EntityType-level config; otherwise run snapshot analysis monitoring with
  /// monitoring_interval regardless of the EntityType-level config. Explicitly
  /// Disable the snapshot analysis based monitoring.
  core.bool? disabled;

  /// Configuration of the snapshot analysis based monitoring pipeline running
  /// interval.
  ///
  /// The value is rolled up to full day. If both monitoring_interval_days and
  /// the deprecated `monitoring_interval` field are set when creating/updating
  /// EntityTypes/Features, monitoring_interval_days will be used.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? monitoringInterval;

  /// Configuration of the snapshot analysis based monitoring pipeline running
  /// interval.
  ///
  /// The value indicates number of days.
  core.int? monitoringIntervalDays;

  /// Customized export features time window for snapshot analysis.
  ///
  /// Unit is one day. Default value is 3 weeks. Minimum value is 1 day. Maximum
  /// value is 4000 days.
  core.int? stalenessDays;

  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigSnapshotAnalysis({
    this.disabled,
    this.monitoringInterval,
    this.monitoringIntervalDays,
    this.stalenessDays,
  });

  GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigSnapshotAnalysis.fromJson(
    core.Map json_,
  ) : this(
        disabled: json_['disabled'] as core.bool?,
        monitoringInterval: json_['monitoringInterval'] as core.String?,
        monitoringIntervalDays: json_['monitoringIntervalDays'] as core.int?,
        stalenessDays: json_['stalenessDays'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disabled != null) 'disabled': disabled!,
    if (monitoringInterval != null) 'monitoringInterval': monitoringInterval!,
    if (monitoringIntervalDays != null)
      'monitoringIntervalDays': monitoringIntervalDays!,
    if (stalenessDays != null) 'stalenessDays': stalenessDays!,
  };
}

/// The config for Featurestore Monitoring threshold.
typedef GoogleCloudAiplatformV1beta1FeaturestoreMonitoringConfigThresholdConfig =
    $FeaturestoreMonitoringConfigThresholdConfig;

/// OnlineServingConfig specifies the details for provisioning online serving
/// resources.
class GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfig {
  /// The number of nodes for the online store.
  ///
  /// The number of nodes doesn't scale automatically, but you can manually
  /// update the number of nodes. If set to 0, the featurestore will not have an
  /// online store and cannot be used for online serving.
  core.int? fixedNodeCount;

  /// Online serving scaling configuration.
  ///
  /// Only one of `fixed_node_count` and `scaling` can be set. Setting one will
  /// reset the other.
  GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfigScaling? scaling;

  GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfig({
    this.fixedNodeCount,
    this.scaling,
  });

  GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfig.fromJson(
    core.Map json_,
  ) : this(
        fixedNodeCount: json_['fixedNodeCount'] as core.int?,
        scaling:
            json_.containsKey('scaling')
                ? GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfigScaling.fromJson(
                  json_['scaling'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fixedNodeCount != null) 'fixedNodeCount': fixedNodeCount!,
    if (scaling != null) 'scaling': scaling!,
  };
}

/// Online serving scaling configuration.
///
/// If min_node_count and max_node_count are set to the same value, the cluster
/// will be configured with the fixed number of node (no auto-scaling).
typedef GoogleCloudAiplatformV1beta1FeaturestoreOnlineServingConfigScaling =
    $FeaturestoreOnlineServingConfigScaling;

/// Request message for ExampleStoreService.FetchExamples.
class GoogleCloudAiplatformV1beta1FetchExamplesRequest {
  /// Example IDs to fetch.
  ///
  /// If both metadata filters and Example IDs are specified, then both ID and
  /// metadata filtering will be applied.
  ///
  /// Optional.
  core.List<core.String>? exampleIds;

  /// The maximum number of examples to return.
  ///
  /// The service may return fewer than this value. If unspecified, at most 100
  /// examples will be returned.
  ///
  /// Optional.
  core.int? pageSize;

  /// The next_page_token value returned from a previous list
  /// ExampleStoreService.FetchExamplesResponse call.
  ///
  /// Optional.
  core.String? pageToken;

  /// The metadata filters for StoredContentsExamples.
  GoogleCloudAiplatformV1beta1StoredContentsExampleFilter?
  storedContentsExampleFilter;

  GoogleCloudAiplatformV1beta1FetchExamplesRequest({
    this.exampleIds,
    this.pageSize,
    this.pageToken,
    this.storedContentsExampleFilter,
  });

  GoogleCloudAiplatformV1beta1FetchExamplesRequest.fromJson(core.Map json_)
    : this(
        exampleIds:
            (json_['exampleIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
        storedContentsExampleFilter:
            json_.containsKey('storedContentsExampleFilter')
                ? GoogleCloudAiplatformV1beta1StoredContentsExampleFilter.fromJson(
                  json_['storedContentsExampleFilter']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exampleIds != null) 'exampleIds': exampleIds!,
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
    if (storedContentsExampleFilter != null)
      'storedContentsExampleFilter': storedContentsExampleFilter!,
  };
}

/// Response message for ExampleStoreService.FetchExamples.
class GoogleCloudAiplatformV1beta1FetchExamplesResponse {
  /// The examples in the Example Store that satisfy the metadata filters.
  core.List<GoogleCloudAiplatformV1beta1Example>? examples;

  /// A token, which can be sent as FetchExamplesRequest.page_token to retrieve
  /// the next page.
  ///
  /// Absence of this field indicates there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1FetchExamplesResponse({
    this.examples,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1FetchExamplesResponse.fromJson(core.Map json_)
    : this(
        examples:
            (json_['examples'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Example.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (examples != null) 'examples': examples!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Request message for FeatureOnlineStoreService.FetchFeatureValues.
///
/// All the features under the requested feature view will be returned.
class GoogleCloudAiplatformV1beta1FetchFeatureValuesRequest {
  /// Response data format.
  ///
  /// If not set, FeatureViewDataFormat.KEY_VALUE will be used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED" : Not set. Will be treated as the
  /// KeyValue format.
  /// - "KEY_VALUE" : Return response data in key-value format.
  /// - "PROTO_STRUCT" : Return response data in proto Struct format.
  core.String? dataFormat;

  /// The request key to fetch feature values for.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FeatureViewDataKey? dataKey;

  /// Specify response data format.
  ///
  /// If not set, KeyValue format will be used. Deprecated. Use
  /// FetchFeatureValuesRequest.data_format.
  /// Possible string values are:
  /// - "FORMAT_UNSPECIFIED" : Not set. Will be treated as the KeyValue format.
  /// - "KEY_VALUE" : Return response data in key-value format.
  /// - "PROTO_STRUCT" : Return response data in proto Struct format.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? format;

  /// Simple ID.
  ///
  /// The whole string will be used as is to identify Entity to fetch feature
  /// values for.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? id;

  GoogleCloudAiplatformV1beta1FetchFeatureValuesRequest({
    this.dataFormat,
    this.dataKey,
    this.format,
    this.id,
  });

  GoogleCloudAiplatformV1beta1FetchFeatureValuesRequest.fromJson(core.Map json_)
    : this(
        dataFormat: json_['dataFormat'] as core.String?,
        dataKey:
            json_.containsKey('dataKey')
                ? GoogleCloudAiplatformV1beta1FeatureViewDataKey.fromJson(
                  json_['dataKey'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        format: json_['format'] as core.String?,
        id: json_['id'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (dataKey != null) 'dataKey': dataKey!,
    if (format != null) 'format': format!,
    if (id != null) 'id': id!,
  };
}

/// Response message for FeatureOnlineStoreService.FetchFeatureValues
class GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse {
  /// The data key associated with this response.
  ///
  /// Will only be populated for
  /// FeatureOnlineStoreService.StreamingFetchFeatureValues RPCs.
  GoogleCloudAiplatformV1beta1FeatureViewDataKey? dataKey;

  /// Feature values in KeyValue format.
  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairList?
  keyValues;

  /// Feature values in proto Struct format.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? protoStruct;

  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse({
    this.dataKey,
    this.keyValues,
    this.protoStruct,
  });

  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse.fromJson(
    core.Map json_,
  ) : this(
        dataKey:
            json_.containsKey('dataKey')
                ? GoogleCloudAiplatformV1beta1FeatureViewDataKey.fromJson(
                  json_['dataKey'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        keyValues:
            json_.containsKey('keyValues')
                ? GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairList.fromJson(
                  json_['keyValues'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        protoStruct:
            json_.containsKey('protoStruct')
                ? json_['protoStruct'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataKey != null) 'dataKey': dataKey!,
    if (keyValues != null) 'keyValues': keyValues!,
    if (protoStruct != null) 'protoStruct': protoStruct!,
  };
}

/// Response structure in the format of key (feature name) and (feature) value
/// pair.
class GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairList {
  /// List of feature names and values.
  core.List<
    GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair
  >?
  features;

  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairList({
    this.features,
  });

  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairList.fromJson(
    core.Map json_,
  ) : this(
        features:
            (json_['features'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (features != null) 'features': features!,
  };
}

/// Feature name & value pair.
class GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair {
  /// Feature short name.
  core.String? name;

  /// Feature value.
  GoogleCloudAiplatformV1beta1FeatureValue? value;

  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair({
    this.name,
    this.value,
  });

  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair.fromJson(
    core.Map json_,
  ) : this(
        name: json_['name'] as core.String?,
        value:
            json_.containsKey('value')
                ? GoogleCloudAiplatformV1beta1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Request message for PredictionService.FetchPredictOperation.
typedef GoogleCloudAiplatformV1beta1FetchPredictOperationRequest =
    $FetchPredictOperationRequest;

/// URI based data.
typedef GoogleCloudAiplatformV1beta1FileData = $FileData;

/// RagFile status.
typedef GoogleCloudAiplatformV1beta1FileStatus = $FileStatus;

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored.
///
/// Currently only supported for Datasets containing DataItems. If any of the
/// filters in this message are to match nothing, then they can be set as '-'
/// (the minus sign). Supported only for unstructured Datasets.
typedef GoogleCloudAiplatformV1beta1FilterSplit = $FilterSplit;

/// The request message for MatchService.FindNeighbors.
class GoogleCloudAiplatformV1beta1FindNeighborsRequest {
  /// The ID of the DeployedIndex that will serve the request.
  ///
  /// This request is sent to a specific IndexEndpoint, as per the
  /// IndexEndpoint.network. That IndexEndpoint also has
  /// IndexEndpoint.deployed_indexes, and each such index has a DeployedIndex.id
  /// field. The value of the field below must equal one of the DeployedIndex.id
  /// fields of the IndexEndpoint that is being called for this request.
  core.String? deployedIndexId;

  /// The list of queries.
  core.List<GoogleCloudAiplatformV1beta1FindNeighborsRequestQuery>? queries;

  /// If set to true, the full datapoints (including all vector values and
  /// restricts) of the nearest neighbors are returned.
  ///
  /// Note that returning full datapoint will significantly increase the latency
  /// and cost of the query.
  core.bool? returnFullDatapoint;

  GoogleCloudAiplatformV1beta1FindNeighborsRequest({
    this.deployedIndexId,
    this.queries,
    this.returnFullDatapoint,
  });

  GoogleCloudAiplatformV1beta1FindNeighborsRequest.fromJson(core.Map json_)
    : this(
        deployedIndexId: json_['deployedIndexId'] as core.String?,
        queries:
            (json_['queries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FindNeighborsRequestQuery.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        returnFullDatapoint: json_['returnFullDatapoint'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
    if (queries != null) 'queries': queries!,
    if (returnFullDatapoint != null)
      'returnFullDatapoint': returnFullDatapoint!,
  };
}

/// A query to find a number of the nearest neighbors (most similar vectors) of
/// a vector.
class GoogleCloudAiplatformV1beta1FindNeighborsRequestQuery {
  /// The number of neighbors to find via approximate search before exact
  /// reordering is performed.
  ///
  /// If not set, the default value from scam config is used; if set, this value
  /// must be \> 0.
  core.int? approximateNeighborCount;

  /// The datapoint/vector whose nearest neighbors should be searched for.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1IndexDatapoint? datapoint;

  /// The fraction of the number of leaves to search, set at query time allows
  /// user to tune search performance.
  ///
  /// This value increase result in both search accuracy and latency increase.
  /// The value should be between 0.0 and 1.0. If not set or set to 0.0, query
  /// uses the default value specified in
  /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
  core.double? fractionLeafNodesToSearchOverride;

  /// The number of nearest neighbors to be retrieved from database for each
  /// query.
  ///
  /// If not set, will use the default from the service configuration
  /// (https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config).
  core.int? neighborCount;

  /// Crowding is a constraint on a neighbor list produced by nearest neighbor
  /// search requiring that no more than some value k' of the k neighbors
  /// returned have the same value of crowding_attribute.
  ///
  /// It's used for improving result diversity. This field is the maximum number
  /// of matches with the same crowding tag.
  core.int? perCrowdingAttributeNeighborCount;

  /// Represents RRF algorithm that combines search results.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FindNeighborsRequestQueryRRF? rrf;

  GoogleCloudAiplatformV1beta1FindNeighborsRequestQuery({
    this.approximateNeighborCount,
    this.datapoint,
    this.fractionLeafNodesToSearchOverride,
    this.neighborCount,
    this.perCrowdingAttributeNeighborCount,
    this.rrf,
  });

  GoogleCloudAiplatformV1beta1FindNeighborsRequestQuery.fromJson(core.Map json_)
    : this(
        approximateNeighborCount:
            json_['approximateNeighborCount'] as core.int?,
        datapoint:
            json_.containsKey('datapoint')
                ? GoogleCloudAiplatformV1beta1IndexDatapoint.fromJson(
                  json_['datapoint'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        fractionLeafNodesToSearchOverride:
            (json_['fractionLeafNodesToSearchOverride'] as core.num?)
                ?.toDouble(),
        neighborCount: json_['neighborCount'] as core.int?,
        perCrowdingAttributeNeighborCount:
            json_['perCrowdingAttributeNeighborCount'] as core.int?,
        rrf:
            json_.containsKey('rrf')
                ? GoogleCloudAiplatformV1beta1FindNeighborsRequestQueryRRF.fromJson(
                  json_['rrf'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (approximateNeighborCount != null)
      'approximateNeighborCount': approximateNeighborCount!,
    if (datapoint != null) 'datapoint': datapoint!,
    if (fractionLeafNodesToSearchOverride != null)
      'fractionLeafNodesToSearchOverride': fractionLeafNodesToSearchOverride!,
    if (neighborCount != null) 'neighborCount': neighborCount!,
    if (perCrowdingAttributeNeighborCount != null)
      'perCrowdingAttributeNeighborCount': perCrowdingAttributeNeighborCount!,
    if (rrf != null) 'rrf': rrf!,
  };
}

/// Parameters for RRF algorithm that combines search results.
typedef GoogleCloudAiplatformV1beta1FindNeighborsRequestQueryRRF =
    $FindNeighborsRequestQueryRRF;

/// The response message for MatchService.FindNeighbors.
class GoogleCloudAiplatformV1beta1FindNeighborsResponse {
  /// The nearest neighbors of the query datapoints.
  core.List<GoogleCloudAiplatformV1beta1FindNeighborsResponseNearestNeighbors>?
  nearestNeighbors;

  GoogleCloudAiplatformV1beta1FindNeighborsResponse({this.nearestNeighbors});

  GoogleCloudAiplatformV1beta1FindNeighborsResponse.fromJson(core.Map json_)
    : this(
        nearestNeighbors:
            (json_['nearestNeighbors'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FindNeighborsResponseNearestNeighbors.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nearestNeighbors != null) 'nearestNeighbors': nearestNeighbors!,
  };
}

/// Nearest neighbors for one query.
class GoogleCloudAiplatformV1beta1FindNeighborsResponseNearestNeighbors {
  /// The ID of the query datapoint.
  core.String? id;

  /// All its neighbors.
  core.List<GoogleCloudAiplatformV1beta1FindNeighborsResponseNeighbor>?
  neighbors;

  GoogleCloudAiplatformV1beta1FindNeighborsResponseNearestNeighbors({
    this.id,
    this.neighbors,
  });

  GoogleCloudAiplatformV1beta1FindNeighborsResponseNearestNeighbors.fromJson(
    core.Map json_,
  ) : this(
        id: json_['id'] as core.String?,
        neighbors:
            (json_['neighbors'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FindNeighborsResponseNeighbor.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (id != null) 'id': id!,
    if (neighbors != null) 'neighbors': neighbors!,
  };
}

/// A neighbor of the query vector.
class GoogleCloudAiplatformV1beta1FindNeighborsResponseNeighbor {
  /// The datapoint of the neighbor.
  ///
  /// Note that full datapoints are returned only when "return_full_datapoint"
  /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
  /// fields are populated.
  GoogleCloudAiplatformV1beta1IndexDatapoint? datapoint;

  /// The distance between the neighbor and the dense embedding query.
  core.double? distance;

  /// The distance between the neighbor and the query sparse_embedding.
  core.double? sparseDistance;

  GoogleCloudAiplatformV1beta1FindNeighborsResponseNeighbor({
    this.datapoint,
    this.distance,
    this.sparseDistance,
  });

  GoogleCloudAiplatformV1beta1FindNeighborsResponseNeighbor.fromJson(
    core.Map json_,
  ) : this(
        datapoint:
            json_.containsKey('datapoint')
                ? GoogleCloudAiplatformV1beta1IndexDatapoint.fromJson(
                  json_['datapoint'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        distance: (json_['distance'] as core.num?)?.toDouble(),
        sparseDistance: (json_['sparseDistance'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datapoint != null) 'datapoint': datapoint!,
    if (distance != null) 'distance': distance!,
    if (sparseDistance != null) 'sparseDistance': sparseDistance!,
  };
}

/// FlexStart is used to schedule the deployment workload on DWS resource.
///
/// It contains the max duration of the deployment.
class GoogleCloudAiplatformV1beta1FlexStart {
  /// The max duration of the deployment is max_runtime_duration.
  ///
  /// The deployment will be terminated after the duration. The
  /// max_runtime_duration can be set up to 7 days.
  core.String? maxRuntimeDuration;

  GoogleCloudAiplatformV1beta1FlexStart({this.maxRuntimeDuration});

  GoogleCloudAiplatformV1beta1FlexStart.fromJson(core.Map json_)
    : this(maxRuntimeDuration: json_['maxRuntimeDuration'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxRuntimeDuration != null) 'maxRuntimeDuration': maxRuntimeDuration!,
  };
}

/// Input for fluency metric.
class GoogleCloudAiplatformV1beta1FluencyInput {
  /// Fluency instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FluencyInstance? instance;

  /// Spec for fluency score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FluencySpec? metricSpec;

  GoogleCloudAiplatformV1beta1FluencyInput({this.instance, this.metricSpec});

  GoogleCloudAiplatformV1beta1FluencyInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1FluencyInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1FluencySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for fluency instance.
typedef GoogleCloudAiplatformV1beta1FluencyInstance = $Instance01;

/// Spec for fluency result.
typedef GoogleCloudAiplatformV1beta1FluencyResult = $FluencyResult;

/// Spec for fluency score metric.
typedef GoogleCloudAiplatformV1beta1FluencySpec = $Spec00;

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions.
///
/// Any of `training_fraction`, `validation_fraction` and `test_fraction` may
/// optionally be provided, they must sum to up to 1. If the provided ones sum
/// to less than 1, the remainder is assigned to sets as decided by Vertex AI.
/// If none of the fractions are set, by default roughly 80% of data is used for
/// training, 10% for validation, and 10% for test.
typedef GoogleCloudAiplatformV1beta1FractionSplit = $FractionSplit;

/// Input for fulfillment metric.
class GoogleCloudAiplatformV1beta1FulfillmentInput {
  /// Fulfillment instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FulfillmentInstance? instance;

  /// Spec for fulfillment score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FulfillmentSpec? metricSpec;

  GoogleCloudAiplatformV1beta1FulfillmentInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1FulfillmentInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1FulfillmentInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1FulfillmentSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for fulfillment instance.
typedef GoogleCloudAiplatformV1beta1FulfillmentInstance = $FulfillmentInstance;

/// Spec for fulfillment result.
typedef GoogleCloudAiplatformV1beta1FulfillmentResult = $FulfillmentResult;

/// Spec for fulfillment metric.
typedef GoogleCloudAiplatformV1beta1FulfillmentSpec = $Spec00;

/// A predicted \[FunctionCall\] returned from the model that contains a string
/// representing the \[FunctionDeclaration.name\] and a structured JSON object
/// containing the parameters and their values.
typedef GoogleCloudAiplatformV1beta1FunctionCall =
    $GoogleCloudAiplatformV1beta1FunctionCall;

/// Function calling config.
typedef GoogleCloudAiplatformV1beta1FunctionCallingConfig =
    $FunctionCallingConfig;

/// Structured representation of a function declaration as defined by the
/// [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3).
///
/// Included in this declaration are the function name, description, parameters
/// and response type. This FunctionDeclaration is a representation of a block
/// of code that can be used as a `Tool` by the model and executed by the
/// client.
class GoogleCloudAiplatformV1beta1FunctionDeclaration {
  /// Description and purpose of the function.
  ///
  /// Model uses it to decide how and whether to call the function.
  ///
  /// Optional.
  core.String? description;

  /// The name of the function to call.
  ///
  /// Must start with a letter or an underscore. Must be a-z, A-Z, 0-9, or
  /// contain underscores, dots and dashes, with a maximum length of 64.
  ///
  /// Required.
  core.String? name;

  /// Describes the parameters to this function in JSON Schema Object format.
  ///
  /// Reflects the Open API 3.03 Parameter Object. string Key: the name of the
  /// parameter. Parameter names are case sensitive. Schema Value: the Schema
  /// defining the type used for the parameter. For function with no parameters,
  /// this can be left unset. Parameter names must start with a letter or an
  /// underscore and must only contain chars a-z, A-Z, 0-9, or underscores with
  /// a maximum length of 64. Example with 1 required and 1 optional parameter:
  /// type: OBJECT properties: param1: type: STRING param2: type: INTEGER
  /// required: - param1
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Schema? parameters;

  /// Describes the parameters to the function in JSON Schema format.
  ///
  /// The schema must describe an object where the properties are the parameters
  /// to the function. For example: ``` { "type": "object", "properties": {
  /// "name": { "type": "string" }, "age": { "type": "integer" } },
  /// "additionalProperties": false, "required": ["name", "age"],
  /// "propertyOrdering": ["name", "age"] } ``` This field is mutually exclusive
  /// with `parameters`.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parametersJsonSchema;

  /// Describes the output from this function in JSON Schema format.
  ///
  /// Reflects the Open API 3.03 Response Object. The Schema defines the type
  /// used for the response value of the function.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Schema? response;

  /// Describes the output from this function in JSON Schema format.
  ///
  /// The value specified by the schema is the response value of the function.
  /// This field is mutually exclusive with `response`.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? responseJsonSchema;

  GoogleCloudAiplatformV1beta1FunctionDeclaration({
    this.description,
    this.name,
    this.parameters,
    this.parametersJsonSchema,
    this.response,
    this.responseJsonSchema,
  });

  GoogleCloudAiplatformV1beta1FunctionDeclaration.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        name: json_['name'] as core.String?,
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1Schema.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        parametersJsonSchema: json_['parametersJsonSchema'],
        response:
            json_.containsKey('response')
                ? GoogleCloudAiplatformV1beta1Schema.fromJson(
                  json_['response'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        responseJsonSchema: json_['responseJsonSchema'],
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (name != null) 'name': name!,
    if (parameters != null) 'parameters': parameters!,
    if (parametersJsonSchema != null)
      'parametersJsonSchema': parametersJsonSchema!,
    if (response != null) 'response': response!,
    if (responseJsonSchema != null) 'responseJsonSchema': responseJsonSchema!,
  };
}

/// The result output from a \[FunctionCall\] that contains a string
/// representing the \[FunctionDeclaration.name\] and a structured JSON object
/// containing any output from the function is used as context to the model.
///
/// This should contain the result of a \[FunctionCall\] made based on model
/// prediction.
typedef GoogleCloudAiplatformV1beta1FunctionResponse =
    $GoogleCloudAiplatformV1beta1FunctionResponse;

/// The Google Cloud Storage location where the output is to be written to.
typedef GoogleCloudAiplatformV1beta1GcsDestination = $GcsDestination02;

/// The Google Cloud Storage location for the input content.
typedef GoogleCloudAiplatformV1beta1GcsSource = $GcsSource04;

/// Google Distributed Cloud (GDC) config.
typedef GoogleCloudAiplatformV1beta1GdcConfig = $GdcConfig;

/// Format for Gemini examples used for Vertex Multimodal datasets.
class GoogleCloudAiplatformV1beta1GeminiExample {
  /// The name of the cached content used as context to serve the prediction.
  ///
  /// Note: only used in explicit caching, where users can have control over
  /// caching (e.g. what content to cache) and enjoy guaranteed cost savings.
  /// Format:
  /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
  ///
  /// Optional.
  core.String? cachedContent;

  /// The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn
  /// queries, this is a repeated field that contains conversation history +
  /// latest request.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// Generation config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GenerationConfig? generationConfig;

  /// The labels with user-defined metadata for the request.
  ///
  /// It is used for billing and reporting only. Label keys and values can be no
  /// longer than 63 characters (Unicode codepoints) and can only contain
  /// lowercase letters, numeric characters, underscores, and dashes.
  /// International characters are allowed. Label values are optional. Label
  /// keys must start with a letter.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The fully qualified name of the publisher model or tuned model endpoint to
  /// use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Optional.
  core.String? model;

  /// Per request settings for blocking unsafe content.
  ///
  /// Enforced on GenerateContentResponse.candidates.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1SafetySetting>? safetySettings;

  /// The user provided system instructions for the model.
  ///
  /// Note: only text should be used in parts and content in each part will be
  /// in a separate paragraph.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Content? systemInstruction;

  /// Tool config.
  ///
  /// This config is shared for all tools provided in the request.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ToolConfig? toolConfig;

  /// A list of `Tools` the model may use to generate the next response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Tool>? tools;

  GoogleCloudAiplatformV1beta1GeminiExample({
    this.cachedContent,
    this.contents,
    this.generationConfig,
    this.labels,
    this.model,
    this.safetySettings,
    this.systemInstruction,
    this.toolConfig,
    this.tools,
  });

  GoogleCloudAiplatformV1beta1GeminiExample.fromJson(core.Map json_)
    : this(
        cachedContent: json_['cachedContent'] as core.String?,
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        generationConfig:
            json_.containsKey('generationConfig')
                ? GoogleCloudAiplatformV1beta1GenerationConfig.fromJson(
                  json_['generationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        model: json_['model'] as core.String?,
        safetySettings:
            (json_['safetySettings'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SafetySetting.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        systemInstruction:
            json_.containsKey('systemInstruction')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['systemInstruction']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolConfig:
            json_.containsKey('toolConfig')
                ? GoogleCloudAiplatformV1beta1ToolConfig.fromJson(
                  json_['toolConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        tools:
            (json_['tools'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tool.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cachedContent != null) 'cachedContent': cachedContent!,
    if (contents != null) 'contents': contents!,
    if (generationConfig != null) 'generationConfig': generationConfig!,
    if (labels != null) 'labels': labels!,
    if (model != null) 'model': model!,
    if (safetySettings != null) 'safetySettings': safetySettings!,
    if (systemInstruction != null) 'systemInstruction': systemInstruction!,
    if (toolConfig != null) 'toolConfig': toolConfig!,
    if (tools != null) 'tools': tools!,
  };
}

/// Input example for preference optimization.
class GoogleCloudAiplatformV1beta1GeminiPreferenceExample {
  /// List of completions for a given prompt.
  core.List<GoogleCloudAiplatformV1beta1GeminiPreferenceExampleCompletion>?
  completions;

  /// Multi-turn contents that represents the Prompt.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  GoogleCloudAiplatformV1beta1GeminiPreferenceExample({
    this.completions,
    this.contents,
  });

  GoogleCloudAiplatformV1beta1GeminiPreferenceExample.fromJson(core.Map json_)
    : this(
        completions:
            (json_['completions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GeminiPreferenceExampleCompletion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completions != null) 'completions': completions!,
    if (contents != null) 'contents': contents!,
  };
}

/// Completion and its preference score.
class GoogleCloudAiplatformV1beta1GeminiPreferenceExampleCompletion {
  /// Single turn completion for the given prompt.
  GoogleCloudAiplatformV1beta1Content? completion;

  /// The score for the given completion.
  core.double? score;

  GoogleCloudAiplatformV1beta1GeminiPreferenceExampleCompletion({
    this.completion,
    this.score,
  });

  GoogleCloudAiplatformV1beta1GeminiPreferenceExampleCompletion.fromJson(
    core.Map json_,
  ) : this(
        completion:
            json_.containsKey('completion')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['completion'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (completion != null) 'completion': completion!,
    if (score != null) 'score': score!,
  };
}

/// Configuration for how to read Gemini requests from a multimodal dataset.
class GoogleCloudAiplatformV1beta1GeminiRequestReadConfig {
  /// Column name in the dataset table that contains already fully assembled
  /// Gemini requests.
  ///
  /// Optional.
  core.String? assembledRequestColumnName;

  /// Gemini request template with placeholders.
  GoogleCloudAiplatformV1beta1GeminiTemplateConfig? templateConfig;

  GoogleCloudAiplatformV1beta1GeminiRequestReadConfig({
    this.assembledRequestColumnName,
    this.templateConfig,
  });

  GoogleCloudAiplatformV1beta1GeminiRequestReadConfig.fromJson(core.Map json_)
    : this(
        assembledRequestColumnName:
            json_['assembledRequestColumnName'] as core.String?,
        templateConfig:
            json_.containsKey('templateConfig')
                ? GoogleCloudAiplatformV1beta1GeminiTemplateConfig.fromJson(
                  json_['templateConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assembledRequestColumnName != null)
      'assembledRequestColumnName': assembledRequestColumnName!,
    if (templateConfig != null) 'templateConfig': templateConfig!,
  };
}

/// Template configuration to create Gemini examples from a multimodal dataset.
class GoogleCloudAiplatformV1beta1GeminiTemplateConfig {
  /// Map of template parameters to the columns in the dataset table.
  ///
  /// Required.
  core.Map<core.String, core.String>? fieldMapping;

  /// The template that will be used for assembling the request to use for
  /// downstream applications.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GeminiExample? geminiExample;

  GoogleCloudAiplatformV1beta1GeminiTemplateConfig({
    this.fieldMapping,
    this.geminiExample,
  });

  GoogleCloudAiplatformV1beta1GeminiTemplateConfig.fromJson(core.Map json_)
    : this(
        fieldMapping: (json_['fieldMapping']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        geminiExample:
            json_.containsKey('geminiExample')
                ? GoogleCloudAiplatformV1beta1GeminiExample.fromJson(
                  json_['geminiExample'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldMapping != null) 'fieldMapping': fieldMapping!,
    if (geminiExample != null) 'geminiExample': geminiExample!,
  };
}

/// Configuration for GenAiAdvancedFeatures.
class GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfig {
  /// Configuration for Retrieval Augmented Generation feature.
  GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfigRagConfig? ragConfig;

  GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfig({this.ragConfig});

  GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfig.fromJson(
    core.Map json_,
  ) : this(
        ragConfig:
            json_.containsKey('ragConfig')
                ? GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfigRagConfig.fromJson(
                  json_['ragConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragConfig != null) 'ragConfig': ragConfig!,
  };
}

/// Configuration for Retrieval Augmented Generation feature.
typedef GoogleCloudAiplatformV1beta1GenAiAdvancedFeaturesConfigRagConfig =
    $GenAiAdvancedFeaturesConfigRagConfig;

/// Request message for NotebookInternalService.GenerateAccessToken.
typedef GoogleCloudAiplatformV1beta1GenerateAccessTokenRequest =
    $GenerateAccessTokenRequest00;

/// Response message for NotebookInternalService.GenerateToken.
class GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse {
  /// Short-lived access token string which may be used to access Google APIs.
  core.String? accessToken;

  /// The time in seconds when the access token expires.
  ///
  /// Typically that's 3600.
  core.int? expiresIn;

  /// Space-separated list of scopes contained in the returned token.
  ///
  /// https://cloud.google.com/docs/authentication/token-types#access-contents
  core.String? scope;

  /// Type of the returned access token (e.g. "Bearer").
  ///
  /// It specifies how the token must be used. Bearer tokens may be used by any
  /// entity without proof of identity.
  core.String? tokenType;

  GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse({
    this.accessToken,
    this.expiresIn,
    this.scope,
    this.tokenType,
  });

  GoogleCloudAiplatformV1beta1GenerateAccessTokenResponse.fromJson(
    core.Map json_,
  ) : this(
        accessToken: json_['accessToken'] as core.String?,
        expiresIn: json_['expiresIn'] as core.int?,
        scope: json_['scope'] as core.String?,
        tokenType: json_['tokenType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessToken != null) 'accessToken': accessToken!,
    if (expiresIn != null) 'expiresIn': expiresIn!,
    if (scope != null) 'scope': scope!,
    if (tokenType != null) 'tokenType': tokenType!,
  };
}

/// Request message for \[PredictionService.GenerateContent\].
class GoogleCloudAiplatformV1beta1GenerateContentRequest {
  /// The name of the cached content used as context to serve the prediction.
  ///
  /// Note: only used in explicit caching, where users can have control over
  /// caching (e.g. what content to cache) and enjoy guaranteed cost savings.
  /// Format:
  /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
  ///
  /// Optional.
  core.String? cachedContent;

  /// The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn
  /// queries, this is a repeated field that contains conversation history +
  /// latest request.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// Generation config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GenerationConfig? generationConfig;

  /// The labels with user-defined metadata for the request.
  ///
  /// It is used for billing and reporting only. Label keys and values can be no
  /// longer than 63 characters (Unicode codepoints) and can only contain
  /// lowercase letters, numeric characters, underscores, and dashes.
  /// International characters are allowed. Label values are optional. Label
  /// keys must start with a letter.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Per request settings for blocking unsafe content.
  ///
  /// Enforced on GenerateContentResponse.candidates.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1SafetySetting>? safetySettings;

  /// The user provided system instructions for the model.
  ///
  /// Note: only text should be used in parts and content in each part will be
  /// in a separate paragraph.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Content? systemInstruction;

  /// Tool config.
  ///
  /// This config is shared for all tools provided in the request.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ToolConfig? toolConfig;

  /// A list of `Tools` the model may use to generate the next response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Tool>? tools;

  GoogleCloudAiplatformV1beta1GenerateContentRequest({
    this.cachedContent,
    this.contents,
    this.generationConfig,
    this.labels,
    this.safetySettings,
    this.systemInstruction,
    this.toolConfig,
    this.tools,
  });

  GoogleCloudAiplatformV1beta1GenerateContentRequest.fromJson(core.Map json_)
    : this(
        cachedContent: json_['cachedContent'] as core.String?,
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        generationConfig:
            json_.containsKey('generationConfig')
                ? GoogleCloudAiplatformV1beta1GenerationConfig.fromJson(
                  json_['generationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        safetySettings:
            (json_['safetySettings'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SafetySetting.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        systemInstruction:
            json_.containsKey('systemInstruction')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['systemInstruction']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        toolConfig:
            json_.containsKey('toolConfig')
                ? GoogleCloudAiplatformV1beta1ToolConfig.fromJson(
                  json_['toolConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        tools:
            (json_['tools'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tool.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cachedContent != null) 'cachedContent': cachedContent!,
    if (contents != null) 'contents': contents!,
    if (generationConfig != null) 'generationConfig': generationConfig!,
    if (labels != null) 'labels': labels!,
    if (safetySettings != null) 'safetySettings': safetySettings!,
    if (systemInstruction != null) 'systemInstruction': systemInstruction!,
    if (toolConfig != null) 'toolConfig': toolConfig!,
    if (tools != null) 'tools': tools!,
  };
}

/// Response message for \[PredictionService.GenerateContent\].
class GoogleCloudAiplatformV1beta1GenerateContentResponse {
  /// Generated candidates.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Candidate>? candidates;

  /// Timestamp when the request is made to the server.
  ///
  /// Output only.
  core.String? createTime;

  /// The model version used to generate the response.
  ///
  /// Output only.
  core.String? modelVersion;

  /// Content filter results for a prompt sent in the request.
  ///
  /// Note: Sent only in the first stream chunk. Only happens when no candidates
  /// were generated due to content violations.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1GenerateContentResponsePromptFeedback?
  promptFeedback;

  /// response_id is used to identify each response.
  ///
  /// It is the encoding of the event_id.
  ///
  /// Output only.
  core.String? responseId;

  /// Usage metadata about the response(s).
  GoogleCloudAiplatformV1beta1GenerateContentResponseUsageMetadata?
  usageMetadata;

  GoogleCloudAiplatformV1beta1GenerateContentResponse({
    this.candidates,
    this.createTime,
    this.modelVersion,
    this.promptFeedback,
    this.responseId,
    this.usageMetadata,
  });

  GoogleCloudAiplatformV1beta1GenerateContentResponse.fromJson(core.Map json_)
    : this(
        candidates:
            (json_['candidates'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Candidate.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        createTime: json_['createTime'] as core.String?,
        modelVersion: json_['modelVersion'] as core.String?,
        promptFeedback:
            json_.containsKey('promptFeedback')
                ? GoogleCloudAiplatformV1beta1GenerateContentResponsePromptFeedback.fromJson(
                  json_['promptFeedback']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        responseId: json_['responseId'] as core.String?,
        usageMetadata:
            json_.containsKey('usageMetadata')
                ? GoogleCloudAiplatformV1beta1GenerateContentResponseUsageMetadata.fromJson(
                  json_['usageMetadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (candidates != null) 'candidates': candidates!,
    if (createTime != null) 'createTime': createTime!,
    if (modelVersion != null) 'modelVersion': modelVersion!,
    if (promptFeedback != null) 'promptFeedback': promptFeedback!,
    if (responseId != null) 'responseId': responseId!,
    if (usageMetadata != null) 'usageMetadata': usageMetadata!,
  };
}

/// Content filter results for a prompt sent in the request.
class GoogleCloudAiplatformV1beta1GenerateContentResponsePromptFeedback {
  /// Blocked reason.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "BLOCKED_REASON_UNSPECIFIED" : Unspecified blocked reason.
  /// - "SAFETY" : Candidates blocked due to safety.
  /// - "OTHER" : Candidates blocked due to other reason.
  /// - "BLOCKLIST" : Candidates blocked due to the terms which are included
  /// from the terminology blocklist.
  /// - "PROHIBITED_CONTENT" : Candidates blocked due to prohibited content.
  /// - "IMAGE_SAFETY" : Candidates blocked due to unsafe image generation
  /// content.
  core.String? blockReason;

  /// A readable block reason message.
  ///
  /// Output only.
  core.String? blockReasonMessage;

  /// Safety ratings.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1SafetyRating>? safetyRatings;

  GoogleCloudAiplatformV1beta1GenerateContentResponsePromptFeedback({
    this.blockReason,
    this.blockReasonMessage,
    this.safetyRatings,
  });

  GoogleCloudAiplatformV1beta1GenerateContentResponsePromptFeedback.fromJson(
    core.Map json_,
  ) : this(
        blockReason: json_['blockReason'] as core.String?,
        blockReasonMessage: json_['blockReasonMessage'] as core.String?,
        safetyRatings:
            (json_['safetyRatings'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SafetyRating.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blockReason != null) 'blockReason': blockReason!,
    if (blockReasonMessage != null) 'blockReasonMessage': blockReasonMessage!,
    if (safetyRatings != null) 'safetyRatings': safetyRatings!,
  };
}

/// Usage metadata about response(s).
class GoogleCloudAiplatformV1beta1GenerateContentResponseUsageMetadata {
  /// List of modalities of the cached content in the request input.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ModalityTokenCount>? cacheTokensDetails;

  /// Number of tokens in the cached part in the input (the cached content).
  ///
  /// Output only.
  core.int? cachedContentTokenCount;

  /// Number of tokens in the response(s).
  core.int? candidatesTokenCount;

  /// List of modalities that were returned in the response.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ModalityTokenCount>?
  candidatesTokensDetails;

  /// Number of tokens in the request.
  ///
  /// When `cached_content` is set, this is still the total effective prompt
  /// size meaning this includes the number of tokens in the cached content.
  core.int? promptTokenCount;

  /// List of modalities that were processed in the request input.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ModalityTokenCount>?
  promptTokensDetails;

  /// Number of tokens present in thoughts output.
  ///
  /// Output only.
  core.int? thoughtsTokenCount;

  /// Number of tokens present in tool-use prompt(s).
  ///
  /// Output only.
  core.int? toolUsePromptTokenCount;

  /// List of modalities that were processed for tool-use request inputs.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ModalityTokenCount>?
  toolUsePromptTokensDetails;

  /// Total token count for prompt, response candidates, and tool-use prompts
  /// (if present).
  core.int? totalTokenCount;

  /// Traffic type.
  ///
  /// This shows whether a request consumes Pay-As-You-Go or Provisioned
  /// Throughput quota.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TRAFFIC_TYPE_UNSPECIFIED" : Unspecified request traffic type.
  /// - "ON_DEMAND" : Type for Pay-As-You-Go traffic.
  /// - "PROVISIONED_THROUGHPUT" : Type for Provisioned Throughput traffic.
  core.String? trafficType;

  GoogleCloudAiplatformV1beta1GenerateContentResponseUsageMetadata({
    this.cacheTokensDetails,
    this.cachedContentTokenCount,
    this.candidatesTokenCount,
    this.candidatesTokensDetails,
    this.promptTokenCount,
    this.promptTokensDetails,
    this.thoughtsTokenCount,
    this.toolUsePromptTokenCount,
    this.toolUsePromptTokensDetails,
    this.totalTokenCount,
    this.trafficType,
  });

  GoogleCloudAiplatformV1beta1GenerateContentResponseUsageMetadata.fromJson(
    core.Map json_,
  ) : this(
        cacheTokensDetails:
            (json_['cacheTokensDetails'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModalityTokenCount.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        cachedContentTokenCount: json_['cachedContentTokenCount'] as core.int?,
        candidatesTokenCount: json_['candidatesTokenCount'] as core.int?,
        candidatesTokensDetails:
            (json_['candidatesTokensDetails'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModalityTokenCount.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        promptTokenCount: json_['promptTokenCount'] as core.int?,
        promptTokensDetails:
            (json_['promptTokensDetails'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModalityTokenCount.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        thoughtsTokenCount: json_['thoughtsTokenCount'] as core.int?,
        toolUsePromptTokenCount: json_['toolUsePromptTokenCount'] as core.int?,
        toolUsePromptTokensDetails:
            (json_['toolUsePromptTokensDetails'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModalityTokenCount.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        totalTokenCount: json_['totalTokenCount'] as core.int?,
        trafficType: json_['trafficType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cacheTokensDetails != null) 'cacheTokensDetails': cacheTokensDetails!,
    if (cachedContentTokenCount != null)
      'cachedContentTokenCount': cachedContentTokenCount!,
    if (candidatesTokenCount != null)
      'candidatesTokenCount': candidatesTokenCount!,
    if (candidatesTokensDetails != null)
      'candidatesTokensDetails': candidatesTokensDetails!,
    if (promptTokenCount != null) 'promptTokenCount': promptTokenCount!,
    if (promptTokensDetails != null)
      'promptTokensDetails': promptTokensDetails!,
    if (thoughtsTokenCount != null) 'thoughtsTokenCount': thoughtsTokenCount!,
    if (toolUsePromptTokenCount != null)
      'toolUsePromptTokenCount': toolUsePromptTokenCount!,
    if (toolUsePromptTokensDetails != null)
      'toolUsePromptTokensDetails': toolUsePromptTokensDetails!,
    if (totalTokenCount != null) 'totalTokenCount': totalTokenCount!,
    if (trafficType != null) 'trafficType': trafficType!,
  };
}

/// Request message for MemoryBankService.GenerateMemories.
class GoogleCloudAiplatformV1beta1GenerateMemoriesRequest {
  /// Defines a direct source of content as the source content from which to
  /// generate memories.
  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSource?
  directContentsSource;

  /// Defines a direct source of memories that should be uploaded to Memory
  /// Bank.
  ///
  /// This is similar to `CreateMemory`, but it allows for consolidation between
  /// these new memories and existing memories for the same scope.
  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSource?
  directMemoriesSource;

  /// If true, generated memories will not be consolidated with existing
  /// memories; all generated memories will be added as new memories regardless
  /// of whether they are duplicates of or contradictory to existing memories.
  ///
  /// By default, memory consolidation is enabled.
  ///
  /// Optional.
  core.bool? disableConsolidation;

  /// The scope of the memories that should be generated.
  ///
  /// Memories will be consolidated across memories with the same scope. Must be
  /// provided unless the scope is defined in the source content. If `scope` is
  /// provided, it will override the scope defined in the source content. Scope
  /// values cannot contain the wildcard character '*'.
  ///
  /// Optional.
  core.Map<core.String, core.String>? scope;

  /// Defines a Vertex Session as the source content from which to generate
  /// memories.
  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestVertexSessionSource?
  vertexSessionSource;

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequest({
    this.directContentsSource,
    this.directMemoriesSource,
    this.disableConsolidation,
    this.scope,
    this.vertexSessionSource,
  });

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequest.fromJson(core.Map json_)
    : this(
        directContentsSource:
            json_.containsKey('directContentsSource')
                ? GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSource.fromJson(
                  json_['directContentsSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        directMemoriesSource:
            json_.containsKey('directMemoriesSource')
                ? GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSource.fromJson(
                  json_['directMemoriesSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        disableConsolidation: json_['disableConsolidation'] as core.bool?,
        scope: (json_['scope'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        vertexSessionSource:
            json_.containsKey('vertexSessionSource')
                ? GoogleCloudAiplatformV1beta1GenerateMemoriesRequestVertexSessionSource.fromJson(
                  json_['vertexSessionSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (directContentsSource != null)
      'directContentsSource': directContentsSource!,
    if (directMemoriesSource != null)
      'directMemoriesSource': directMemoriesSource!,
    if (disableConsolidation != null)
      'disableConsolidation': disableConsolidation!,
    if (scope != null) 'scope': scope!,
    if (vertexSessionSource != null)
      'vertexSessionSource': vertexSessionSource!,
  };
}

/// Defines a direct source of content from which to generate the memories.
class GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSource {
  /// The source content (i.e. chat history) to generate memories from.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSourceEvent
  >?
  events;

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSource({
    this.events,
  });

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSource.fromJson(
    core.Map json_,
  ) : this(
        events:
            (json_['events'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSourceEvent.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (events != null) 'events': events!,
  };
}

/// A single piece of conversation from which to generate memories.
class GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSourceEvent {
  /// A single piece of content from which to generate memories.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Content? content;

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSourceEvent({
    this.content,
  });

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectContentsSourceEvent.fromJson(
    core.Map json_,
  ) : this(
        content:
            json_.containsKey('content')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Defines a direct source of memories that should be uploaded to Memory Bank
/// with consolidation.
class GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSource {
  /// The direct memories to upload to Memory Bank.
  ///
  /// At most 5 direct memories are allowed per request.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSourceDirectMemory
  >?
  directMemories;

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSource({
    this.directMemories,
  });

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSource.fromJson(
    core.Map json_,
  ) : this(
        directMemories:
            (json_['directMemories'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSourceDirectMemory.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (directMemories != null) 'directMemories': directMemories!,
  };
}

/// A direct memory to upload to Memory Bank.
class GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSourceDirectMemory {
  /// The fact to consolidate with existing memories.
  ///
  /// Required.
  core.String? fact;

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSourceDirectMemory({
    this.fact,
  });

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestDirectMemoriesSourceDirectMemory.fromJson(
    core.Map json_,
  ) : this(fact: json_['fact'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (fact != null) 'fact': fact!,
  };
}

/// Defines an Agent Engine Session from which to generate the memories.
///
/// If `scope` is not provided, the scope will be extracted from the Session
/// (i.e. {"user_id": sesison.user_id}).
class GoogleCloudAiplatformV1beta1GenerateMemoriesRequestVertexSessionSource {
  /// End time (exclusive) of the time range.
  ///
  /// If not set, the end time is unbounded.
  ///
  /// Optional.
  core.String? endTime;

  /// The resource name of the Session to generate memories for.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  ///
  /// Required.
  core.String? session;

  /// Time range to define which session events should be used to generate
  /// memories.
  ///
  /// Start time (inclusive) of the time range. If not set, the start time is
  /// unbounded.
  ///
  /// Optional.
  core.String? startTime;

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestVertexSessionSource({
    this.endTime,
    this.session,
    this.startTime,
  });

  GoogleCloudAiplatformV1beta1GenerateMemoriesRequestVertexSessionSource.fromJson(
    core.Map json_,
  ) : this(
        endTime: json_['endTime'] as core.String?,
        session: json_['session'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (session != null) 'session': session!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Generation config.
class GoogleCloudAiplatformV1beta1GenerationConfig {
  /// If enabled, audio timestamp will be included in the request to the model.
  ///
  /// Optional.
  core.bool? audioTimestamp;

  /// Number of candidates to generate.
  ///
  /// Optional.
  core.int? candidateCount;

  /// If enabled, the model will detect emotions and adapt its responses
  /// accordingly.
  ///
  /// Optional.
  core.bool? enableAffectiveDialog;

  /// Frequency penalties.
  ///
  /// Optional.
  core.double? frequencyPenalty;

  /// Logit probabilities.
  ///
  /// Optional.
  core.int? logprobs;

  /// The maximum number of output tokens to generate per message.
  ///
  /// Optional.
  core.int? maxOutputTokens;

  /// If specified, the media resolution specified will be used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MEDIA_RESOLUTION_UNSPECIFIED" : Media resolution has not been set.
  /// - "MEDIA_RESOLUTION_LOW" : Media resolution set to low (64 tokens).
  /// - "MEDIA_RESOLUTION_MEDIUM" : Media resolution set to medium (256 tokens).
  /// - "MEDIA_RESOLUTION_HIGH" : Media resolution set to high (zoomed reframing
  /// with 256 tokens).
  core.String? mediaResolution;

  /// Config for model selection.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GenerationConfigModelConfig? modelConfig;

  /// Positive penalties.
  ///
  /// Optional.
  core.double? presencePenalty;

  /// Output schema of the generated response.
  ///
  /// This is an alternative to `response_schema` that accepts
  /// [JSON Schema](https://json-schema.org/). If set, `response_schema` must be
  /// omitted, but `response_mime_type` is required. While the full JSON Schema
  /// may be sent, not all features are supported. Specifically, only the
  /// following properties are supported: - `$id` - `$defs` - `$ref` - `$anchor`
  /// - `type` - `format` - `title` - `description` - `enum` (for strings and
  /// numbers) - `items` - `prefixItems` - `minItems` - `maxItems` - `minimum` -
  /// `maximum` - `anyOf` - `oneOf` (interpreted the same as `anyOf`) -
  /// `properties` - `additionalProperties` - `required` The non-standard
  /// `propertyOrdering` property may also be set. Cyclic references are
  /// unrolled to a limited degree and, as such, may only be used within
  /// non-required properties. (Nullable properties are not sufficient.) If
  /// `$ref` is set on a sub-schema, no other properties, except for than those
  /// starting as a `$`, may be set.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? responseJsonSchema;

  /// If true, export the logprobs results in response.
  ///
  /// Optional.
  core.bool? responseLogprobs;

  /// Output response mimetype of the generated candidate text.
  ///
  /// Supported mimetype: - `text/plain`: (default) Text output. -
  /// `application/json`: JSON response in the candidates. The model needs to be
  /// prompted to output the appropriate response type, otherwise the behavior
  /// is undefined. This is a preview feature.
  ///
  /// Optional.
  core.String? responseMimeType;

  /// The modalities of the response.
  ///
  /// Optional.
  core.List<core.String>? responseModalities;

  /// The `Schema` object allows the definition of input and output data types.
  ///
  /// These types can be objects, but also primitives and arrays. Represents a
  /// select subset of an
  /// [OpenAPI 3.0 schema object](https://spec.openapis.org/oas/v3.0.3#schema).
  /// If set, a compatible response_mime_type must also be set. Compatible
  /// mimetypes: `application/json`: Schema for JSON response.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Schema? responseSchema;

  /// Routing configuration.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfig? routingConfig;

  /// Seed.
  ///
  /// Optional.
  core.int? seed;

  /// The speech generation config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1SpeechConfig? speechConfig;

  /// Stop sequences.
  ///
  /// Optional.
  core.List<core.String>? stopSequences;

  /// Controls the randomness of predictions.
  ///
  /// Optional.
  core.double? temperature;

  /// Config for thinking features.
  ///
  /// An error will be returned if this field is set for models that don't
  /// support thinking.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GenerationConfigThinkingConfig? thinkingConfig;

  /// If specified, top-k sampling will be used.
  ///
  /// Optional.
  core.double? topK;

  /// If specified, nucleus sampling will be used.
  ///
  /// Optional.
  core.double? topP;

  GoogleCloudAiplatformV1beta1GenerationConfig({
    this.audioTimestamp,
    this.candidateCount,
    this.enableAffectiveDialog,
    this.frequencyPenalty,
    this.logprobs,
    this.maxOutputTokens,
    this.mediaResolution,
    this.modelConfig,
    this.presencePenalty,
    this.responseJsonSchema,
    this.responseLogprobs,
    this.responseMimeType,
    this.responseModalities,
    this.responseSchema,
    this.routingConfig,
    this.seed,
    this.speechConfig,
    this.stopSequences,
    this.temperature,
    this.thinkingConfig,
    this.topK,
    this.topP,
  });

  GoogleCloudAiplatformV1beta1GenerationConfig.fromJson(core.Map json_)
    : this(
        audioTimestamp: json_['audioTimestamp'] as core.bool?,
        candidateCount: json_['candidateCount'] as core.int?,
        enableAffectiveDialog: json_['enableAffectiveDialog'] as core.bool?,
        frequencyPenalty: (json_['frequencyPenalty'] as core.num?)?.toDouble(),
        logprobs: json_['logprobs'] as core.int?,
        maxOutputTokens: json_['maxOutputTokens'] as core.int?,
        mediaResolution: json_['mediaResolution'] as core.String?,
        modelConfig:
            json_.containsKey('modelConfig')
                ? GoogleCloudAiplatformV1beta1GenerationConfigModelConfig.fromJson(
                  json_['modelConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        presencePenalty: (json_['presencePenalty'] as core.num?)?.toDouble(),
        responseJsonSchema: json_['responseJsonSchema'],
        responseLogprobs: json_['responseLogprobs'] as core.bool?,
        responseMimeType: json_['responseMimeType'] as core.String?,
        responseModalities:
            (json_['responseModalities'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        responseSchema:
            json_.containsKey('responseSchema')
                ? GoogleCloudAiplatformV1beta1Schema.fromJson(
                  json_['responseSchema']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        routingConfig:
            json_.containsKey('routingConfig')
                ? GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfig.fromJson(
                  json_['routingConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        seed: json_['seed'] as core.int?,
        speechConfig:
            json_.containsKey('speechConfig')
                ? GoogleCloudAiplatformV1beta1SpeechConfig.fromJson(
                  json_['speechConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        stopSequences:
            (json_['stopSequences'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        temperature: (json_['temperature'] as core.num?)?.toDouble(),
        thinkingConfig:
            json_.containsKey('thinkingConfig')
                ? GoogleCloudAiplatformV1beta1GenerationConfigThinkingConfig.fromJson(
                  json_['thinkingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        topK: (json_['topK'] as core.num?)?.toDouble(),
        topP: (json_['topP'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audioTimestamp != null) 'audioTimestamp': audioTimestamp!,
    if (candidateCount != null) 'candidateCount': candidateCount!,
    if (enableAffectiveDialog != null)
      'enableAffectiveDialog': enableAffectiveDialog!,
    if (frequencyPenalty != null) 'frequencyPenalty': frequencyPenalty!,
    if (logprobs != null) 'logprobs': logprobs!,
    if (maxOutputTokens != null) 'maxOutputTokens': maxOutputTokens!,
    if (mediaResolution != null) 'mediaResolution': mediaResolution!,
    if (modelConfig != null) 'modelConfig': modelConfig!,
    if (presencePenalty != null) 'presencePenalty': presencePenalty!,
    if (responseJsonSchema != null) 'responseJsonSchema': responseJsonSchema!,
    if (responseLogprobs != null) 'responseLogprobs': responseLogprobs!,
    if (responseMimeType != null) 'responseMimeType': responseMimeType!,
    if (responseModalities != null) 'responseModalities': responseModalities!,
    if (responseSchema != null) 'responseSchema': responseSchema!,
    if (routingConfig != null) 'routingConfig': routingConfig!,
    if (seed != null) 'seed': seed!,
    if (speechConfig != null) 'speechConfig': speechConfig!,
    if (stopSequences != null) 'stopSequences': stopSequences!,
    if (temperature != null) 'temperature': temperature!,
    if (thinkingConfig != null) 'thinkingConfig': thinkingConfig!,
    if (topK != null) 'topK': topK!,
    if (topP != null) 'topP': topP!,
  };
}

/// Config for model selection.
typedef GoogleCloudAiplatformV1beta1GenerationConfigModelConfig =
    $GoogleCloudAiplatformV1beta1GenerationConfigModelConfig;

/// The configuration for routing the request to a specific model.
class GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfig {
  /// Automated routing.
  GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigAutoRoutingMode?
  autoMode;

  /// Manual routing.
  GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigManualRoutingMode?
  manualMode;

  GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfig({
    this.autoMode,
    this.manualMode,
  });

  GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfig.fromJson(
    core.Map json_,
  ) : this(
        autoMode:
            json_.containsKey('autoMode')
                ? GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigAutoRoutingMode.fromJson(
                  json_['autoMode'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        manualMode:
            json_.containsKey('manualMode')
                ? GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigManualRoutingMode.fromJson(
                  json_['manualMode'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoMode != null) 'autoMode': autoMode!,
    if (manualMode != null) 'manualMode': manualMode!,
  };
}

/// When automated routing is specified, the routing will be determined by the
/// pretrained routing model and customer provided model routing preference.
typedef GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigAutoRoutingMode =
    $GenerationConfigRoutingConfigAutoRoutingMode;

/// When manual routing is set, the specified model will be used directly.
typedef GoogleCloudAiplatformV1beta1GenerationConfigRoutingConfigManualRoutingMode =
    $GenerationConfigRoutingConfigManualRoutingMode;

/// Config for thinking features.
typedef GoogleCloudAiplatformV1beta1GenerationConfigThinkingConfig =
    $GenerationConfigThinkingConfig;

/// Contains information about the source of the models generated from
/// Generative AI Studio.
typedef GoogleCloudAiplatformV1beta1GenieSource = $GenieSource;

/// The Google Drive location for the input content.
class GoogleCloudAiplatformV1beta1GoogleDriveSource {
  /// Google Drive resource IDs.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1GoogleDriveSourceResourceId>?
  resourceIds;

  GoogleCloudAiplatformV1beta1GoogleDriveSource({this.resourceIds});

  GoogleCloudAiplatformV1beta1GoogleDriveSource.fromJson(core.Map json_)
    : this(
        resourceIds:
            (json_['resourceIds'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GoogleDriveSourceResourceId.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (resourceIds != null) 'resourceIds': resourceIds!,
  };
}

/// The type and ID of the Google Drive resource.
typedef GoogleCloudAiplatformV1beta1GoogleDriveSourceResourceId =
    $GoogleDriveSourceResourceId;

/// Tool to retrieve public maps data for grounding, powered by Google.
class GoogleCloudAiplatformV1beta1GoogleMaps {
  /// The authentication config to access the API.
  ///
  /// Deprecated. Please use auth_config instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1ApiAuth? apiAuth;

  /// The authentication config to access the API.
  ///
  /// Only API key is supported.
  GoogleCloudAiplatformV1beta1AuthConfig? authConfig;

  GoogleCloudAiplatformV1beta1GoogleMaps({this.apiAuth, this.authConfig});

  GoogleCloudAiplatformV1beta1GoogleMaps.fromJson(core.Map json_)
    : this(
        apiAuth:
            json_.containsKey('apiAuth')
                ? GoogleCloudAiplatformV1beta1ApiAuth.fromJson(
                  json_['apiAuth'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        authConfig:
            json_.containsKey('authConfig')
                ? GoogleCloudAiplatformV1beta1AuthConfig.fromJson(
                  json_['authConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiAuth != null) 'apiAuth': apiAuth!,
    if (authConfig != null) 'authConfig': authConfig!,
  };
}

/// Tool to retrieve public web data for grounding, powered by Google.
class GoogleCloudAiplatformV1beta1GoogleSearchRetrieval {
  /// Specifies the dynamic retrieval configuration for the given source.
  GoogleCloudAiplatformV1beta1DynamicRetrievalConfig? dynamicRetrievalConfig;

  GoogleCloudAiplatformV1beta1GoogleSearchRetrieval({
    this.dynamicRetrievalConfig,
  });

  GoogleCloudAiplatformV1beta1GoogleSearchRetrieval.fromJson(core.Map json_)
    : this(
        dynamicRetrievalConfig:
            json_.containsKey('dynamicRetrievalConfig')
                ? GoogleCloudAiplatformV1beta1DynamicRetrievalConfig.fromJson(
                  json_['dynamicRetrievalConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dynamicRetrievalConfig != null)
      'dynamicRetrievalConfig': dynamicRetrievalConfig!,
  };
}

/// Input for groundedness metric.
class GoogleCloudAiplatformV1beta1GroundednessInput {
  /// Groundedness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GroundednessInstance? instance;

  /// Spec for groundedness metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GroundednessSpec? metricSpec;

  GoogleCloudAiplatformV1beta1GroundednessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1GroundednessInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1GroundednessInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1GroundednessSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for groundedness instance.
typedef GoogleCloudAiplatformV1beta1GroundednessInstance =
    $GroundednessInstance;

/// Spec for groundedness result.
typedef GoogleCloudAiplatformV1beta1GroundednessResult = $GroundednessResult;

/// Spec for groundedness metric.
typedef GoogleCloudAiplatformV1beta1GroundednessSpec = $Spec00;

/// Grounding chunk.
class GoogleCloudAiplatformV1beta1GroundingChunk {
  /// Grounding chunk from Google Maps.
  GoogleCloudAiplatformV1beta1GroundingChunkMaps? maps;

  /// Grounding chunk from context retrieved by the retrieval tools.
  GoogleCloudAiplatformV1beta1GroundingChunkRetrievedContext? retrievedContext;

  /// Grounding chunk from the web.
  GoogleCloudAiplatformV1beta1GroundingChunkWeb? web;

  GoogleCloudAiplatformV1beta1GroundingChunk({
    this.maps,
    this.retrievedContext,
    this.web,
  });

  GoogleCloudAiplatformV1beta1GroundingChunk.fromJson(core.Map json_)
    : this(
        maps:
            json_.containsKey('maps')
                ? GoogleCloudAiplatformV1beta1GroundingChunkMaps.fromJson(
                  json_['maps'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        retrievedContext:
            json_.containsKey('retrievedContext')
                ? GoogleCloudAiplatformV1beta1GroundingChunkRetrievedContext.fromJson(
                  json_['retrievedContext']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        web:
            json_.containsKey('web')
                ? GoogleCloudAiplatformV1beta1GroundingChunkWeb.fromJson(
                  json_['web'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maps != null) 'maps': maps!,
    if (retrievedContext != null) 'retrievedContext': retrievedContext!,
    if (web != null) 'web': web!,
  };
}

/// Chunk from Google Maps.
class GoogleCloudAiplatformV1beta1GroundingChunkMaps {
  /// Sources used to generate the place answer.
  ///
  /// This includes review snippets and photos that were used to generate the
  /// answer, as well as uris to flag content.
  GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSources?
  placeAnswerSources;

  /// This Place's resource name, in `places/{place_id}` format.
  ///
  /// Can be used to look up the Place.
  core.String? placeId;

  /// Text of the chunk.
  core.String? text;

  /// Title of the chunk.
  core.String? title;

  /// URI reference of the chunk.
  core.String? uri;

  GoogleCloudAiplatformV1beta1GroundingChunkMaps({
    this.placeAnswerSources,
    this.placeId,
    this.text,
    this.title,
    this.uri,
  });

  GoogleCloudAiplatformV1beta1GroundingChunkMaps.fromJson(core.Map json_)
    : this(
        placeAnswerSources:
            json_.containsKey('placeAnswerSources')
                ? GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSources.fromJson(
                  json_['placeAnswerSources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        placeId: json_['placeId'] as core.String?,
        text: json_['text'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (placeAnswerSources != null) 'placeAnswerSources': placeAnswerSources!,
    if (placeId != null) 'placeId': placeId!,
    if (text != null) 'text': text!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Sources used to generate the place answer.
class GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSources {
  /// A link where users can flag a problem with the generated answer.
  core.String? flagContentUri;

  /// Snippets of reviews that are used to generate the answer.
  core.List<
    GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesReviewSnippet
  >?
  reviewSnippets;

  GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSources({
    this.flagContentUri,
    this.reviewSnippets,
  });

  GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSources.fromJson(
    core.Map json_,
  ) : this(
        flagContentUri: json_['flagContentUri'] as core.String?,
        reviewSnippets:
            (json_['reviewSnippets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesReviewSnippet.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (flagContentUri != null) 'flagContentUri': flagContentUri!,
    if (reviewSnippets != null) 'reviewSnippets': reviewSnippets!,
  };
}

/// Author attribution for a photo or review.
typedef GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution =
    $AuthorAttribution;

/// Encapsulates a review snippet.
class GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesReviewSnippet {
  /// This review's author.
  GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution?
  authorAttribution;

  /// A link where users can flag a problem with the review.
  core.String? flagContentUri;

  /// A link to show the review on Google Maps.
  core.String? googleMapsUri;

  /// A string of formatted recent time, expressing the review time relative to
  /// the current time in a form appropriate for the language and country.
  core.String? relativePublishTimeDescription;

  /// A reference representing this place review which may be used to look up
  /// this place review again.
  core.String? review;

  GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesReviewSnippet({
    this.authorAttribution,
    this.flagContentUri,
    this.googleMapsUri,
    this.relativePublishTimeDescription,
    this.review,
  });

  GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesReviewSnippet.fromJson(
    core.Map json_,
  ) : this(
        authorAttribution:
            json_.containsKey('authorAttribution')
                ? GoogleCloudAiplatformV1beta1GroundingChunkMapsPlaceAnswerSourcesAuthorAttribution.fromJson(
                  json_['authorAttribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        flagContentUri: json_['flagContentUri'] as core.String?,
        googleMapsUri: json_['googleMapsUri'] as core.String?,
        relativePublishTimeDescription:
            json_['relativePublishTimeDescription'] as core.String?,
        review: json_['review'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (authorAttribution != null) 'authorAttribution': authorAttribution!,
    if (flagContentUri != null) 'flagContentUri': flagContentUri!,
    if (googleMapsUri != null) 'googleMapsUri': googleMapsUri!,
    if (relativePublishTimeDescription != null)
      'relativePublishTimeDescription': relativePublishTimeDescription!,
    if (review != null) 'review': review!,
  };
}

/// Chunk from context retrieved by the retrieval tools.
class GoogleCloudAiplatformV1beta1GroundingChunkRetrievedContext {
  /// Additional context for the RAG retrieval result.
  ///
  /// This is only populated when using the RAG retrieval tool.
  GoogleCloudAiplatformV1beta1RagChunk? ragChunk;

  /// Text of the attribution.
  core.String? text;

  /// Title of the attribution.
  core.String? title;

  /// URI reference of the attribution.
  core.String? uri;

  GoogleCloudAiplatformV1beta1GroundingChunkRetrievedContext({
    this.ragChunk,
    this.text,
    this.title,
    this.uri,
  });

  GoogleCloudAiplatformV1beta1GroundingChunkRetrievedContext.fromJson(
    core.Map json_,
  ) : this(
        ragChunk:
            json_.containsKey('ragChunk')
                ? GoogleCloudAiplatformV1beta1RagChunk.fromJson(
                  json_['ragChunk'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        text: json_['text'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragChunk != null) 'ragChunk': ragChunk!,
    if (text != null) 'text': text!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Chunk from the web.
typedef GoogleCloudAiplatformV1beta1GroundingChunkWeb = $GroundingChunkWeb;

/// Metadata returned to client when grounding is enabled.
class GoogleCloudAiplatformV1beta1GroundingMetadata {
  /// Resource name of the Google Maps widget context token to be used with the
  /// PlacesContextElement widget to render contextual data.
  ///
  /// This is populated only for Google Maps grounding.
  ///
  /// Optional. Output only.
  core.String? googleMapsWidgetContextToken;

  /// List of supporting references retrieved from specified grounding source.
  core.List<GoogleCloudAiplatformV1beta1GroundingChunk>? groundingChunks;

  /// List of grounding support.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1GroundingSupport>? groundingSupports;

  /// Retrieval metadata.
  ///
  /// Optional. Output only.
  GoogleCloudAiplatformV1beta1RetrievalMetadata? retrievalMetadata;

  /// Queries executed by the retrieval tools.
  ///
  /// Optional.
  core.List<core.String>? retrievalQueries;

  /// Google search entry for the following-up web searches.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1SearchEntryPoint? searchEntryPoint;

  /// Web search queries for the following-up web search.
  ///
  /// Optional.
  core.List<core.String>? webSearchQueries;

  GoogleCloudAiplatformV1beta1GroundingMetadata({
    this.googleMapsWidgetContextToken,
    this.groundingChunks,
    this.groundingSupports,
    this.retrievalMetadata,
    this.retrievalQueries,
    this.searchEntryPoint,
    this.webSearchQueries,
  });

  GoogleCloudAiplatformV1beta1GroundingMetadata.fromJson(core.Map json_)
    : this(
        googleMapsWidgetContextToken:
            json_['googleMapsWidgetContextToken'] as core.String?,
        groundingChunks:
            (json_['groundingChunks'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GroundingChunk.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        groundingSupports:
            (json_['groundingSupports'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GroundingSupport.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        retrievalMetadata:
            json_.containsKey('retrievalMetadata')
                ? GoogleCloudAiplatformV1beta1RetrievalMetadata.fromJson(
                  json_['retrievalMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        retrievalQueries:
            (json_['retrievalQueries'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        searchEntryPoint:
            json_.containsKey('searchEntryPoint')
                ? GoogleCloudAiplatformV1beta1SearchEntryPoint.fromJson(
                  json_['searchEntryPoint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        webSearchQueries:
            (json_['webSearchQueries'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (googleMapsWidgetContextToken != null)
      'googleMapsWidgetContextToken': googleMapsWidgetContextToken!,
    if (groundingChunks != null) 'groundingChunks': groundingChunks!,
    if (groundingSupports != null) 'groundingSupports': groundingSupports!,
    if (retrievalMetadata != null) 'retrievalMetadata': retrievalMetadata!,
    if (retrievalQueries != null) 'retrievalQueries': retrievalQueries!,
    if (searchEntryPoint != null) 'searchEntryPoint': searchEntryPoint!,
    if (webSearchQueries != null) 'webSearchQueries': webSearchQueries!,
  };
}

/// Grounding support.
class GoogleCloudAiplatformV1beta1GroundingSupport {
  /// Confidence score of the support references.
  ///
  /// Ranges from 0 to 1. 1 is the most confident. For Gemini 2.0 and before,
  /// this list must have the same size as the grounding_chunk_indices. For
  /// Gemini 2.5 and after, this list will be empty and should be ignored.
  core.List<core.double>? confidenceScores;

  /// A list of indices (into 'grounding_chunk') specifying the citations
  /// associated with the claim.
  ///
  /// For instance \[1,3,4\] means that grounding_chunk\[1\],
  /// grounding_chunk\[3\], grounding_chunk\[4\] are the retrieved content
  /// attributed to the claim.
  core.List<core.int>? groundingChunkIndices;

  /// Segment of the content this support belongs to.
  GoogleCloudAiplatformV1beta1Segment? segment;

  GoogleCloudAiplatformV1beta1GroundingSupport({
    this.confidenceScores,
    this.groundingChunkIndices,
    this.segment,
  });

  GoogleCloudAiplatformV1beta1GroundingSupport.fromJson(core.Map json_)
    : this(
        confidenceScores:
            (json_['confidenceScores'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
        groundingChunkIndices:
            (json_['groundingChunkIndices'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        segment:
            json_.containsKey('segment')
                ? GoogleCloudAiplatformV1beta1Segment.fromJson(
                  json_['segment'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (confidenceScores != null) 'confidenceScores': confidenceScores!,
    if (groundingChunkIndices != null)
      'groundingChunkIndices': groundingChunkIndices!,
    if (segment != null) 'segment': segment!,
  };
}

/// Represents a HyperparameterTuningJob.
///
/// A HyperparameterTuningJob has a Study specification and multiple CustomJobs
/// with identical CustomJob specification.
class GoogleCloudAiplatformV1beta1HyperparameterTuningJob {
  /// Time when the HyperparameterTuningJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the HyperparameterTuningJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a HyperparameterTuningJob.
  ///
  /// If this is set, then all resources created by the HyperparameterTuningJob
  /// will be encrypted with the provided encryption key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Time when the HyperparameterTuningJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize
  /// HyperparameterTuningJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The number of failed Trials that need to be seen before failing the
  /// HyperparameterTuningJob.
  ///
  /// If set to 0, Vertex AI decides how many Trials must fail before the whole
  /// job fails.
  core.int? maxFailedTrialCount;

  /// The desired total number of Trials.
  ///
  /// Required.
  core.int? maxTrialCount;

  /// Resource name of the HyperparameterTuningJob.
  ///
  /// Output only.
  core.String? name;

  /// The desired number of Trials to run in parallel.
  ///
  /// Required.
  core.int? parallelTrialCount;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the HyperparameterTuningJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Study configuration of the HyperparameterTuningJob.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1StudySpec? studySpec;

  /// The spec of a trial job.
  ///
  /// The same spec applies to the CustomJobs created in all the trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CustomJobSpec? trialJobSpec;

  /// Trials of the HyperparameterTuningJob.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Trial>? trials;

  /// Time when the HyperparameterTuningJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1HyperparameterTuningJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.labels,
    this.maxFailedTrialCount,
    this.maxTrialCount,
    this.name,
    this.parallelTrialCount,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.studySpec,
    this.trialJobSpec,
    this.trials,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1HyperparameterTuningJob.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        maxFailedTrialCount: json_['maxFailedTrialCount'] as core.int?,
        maxTrialCount: json_['maxTrialCount'] as core.int?,
        name: json_['name'] as core.String?,
        parallelTrialCount: json_['parallelTrialCount'] as core.int?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        studySpec:
            json_.containsKey('studySpec')
                ? GoogleCloudAiplatformV1beta1StudySpec.fromJson(
                  json_['studySpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        trialJobSpec:
            json_.containsKey('trialJobSpec')
                ? GoogleCloudAiplatformV1beta1CustomJobSpec.fromJson(
                  json_['trialJobSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        trials:
            (json_['trials'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Trial.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (labels != null) 'labels': labels!,
    if (maxFailedTrialCount != null)
      'maxFailedTrialCount': maxFailedTrialCount!,
    if (maxTrialCount != null) 'maxTrialCount': maxTrialCount!,
    if (name != null) 'name': name!,
    if (parallelTrialCount != null) 'parallelTrialCount': parallelTrialCount!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (studySpec != null) 'studySpec': studySpec!,
    if (trialJobSpec != null) 'trialJobSpec': trialJobSpec!,
    if (trials != null) 'trials': trials!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Matcher for Features of an EntityType by Feature ID.
typedef GoogleCloudAiplatformV1beta1IdMatcher = $IdMatcher;

/// Describes the location from where we import data into a Dataset, together
/// with the labels that will be applied to the DataItems and the Annotations.
class GoogleCloudAiplatformV1beta1ImportDataConfig {
  /// Labels that will be applied to newly imported Annotations.
  ///
  /// If two Annotations are identical, one of them will be deduped. Two
  /// Annotations are considered identical if their payload, payload_schema_uri
  /// and all of their labels are the same. These labels will be overridden by
  /// Annotation labels specified inside index file referenced by
  /// import_schema_uri, e.g. jsonl file.
  core.Map<core.String, core.String>? annotationLabels;

  /// Labels that will be applied to newly imported DataItems.
  ///
  /// If an identical DataItem as one being imported already exists in the
  /// Dataset, then these labels will be appended to these of the already
  /// existing one, and if labels with identical key is imported before, the old
  /// label value will be overwritten. If two DataItems are identical in the
  /// same import data operation, the labels will be combined and if key
  /// collision happens in this case, one of the values will be picked randomly.
  /// Two DataItems are considered identical if their content bytes are
  /// identical (e.g. image bytes or pdf bytes). These labels will be overridden
  /// by Annotation labels specified inside index file referenced by
  /// import_schema_uri, e.g. jsonl file.
  core.Map<core.String, core.String>? dataItemLabels;

  /// The Google Cloud Storage location for the input content.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  /// Points to a YAML file stored on Google Cloud Storage describing the import
  /// format.
  ///
  /// Validation will be done against the schema. The schema is defined as an
  /// [OpenAPI 3.0.2 Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  ///
  /// Required.
  core.String? importSchemaUri;

  GoogleCloudAiplatformV1beta1ImportDataConfig({
    this.annotationLabels,
    this.dataItemLabels,
    this.gcsSource,
    this.importSchemaUri,
  });

  GoogleCloudAiplatformV1beta1ImportDataConfig.fromJson(core.Map json_)
    : this(
        annotationLabels: (json_['annotationLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        dataItemLabels: (json_['dataItemLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        importSchemaUri: json_['importSchemaUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationLabels != null) 'annotationLabels': annotationLabels!,
    if (dataItemLabels != null) 'dataItemLabels': dataItemLabels!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (importSchemaUri != null) 'importSchemaUri': importSchemaUri!,
  };
}

/// Request message for DatasetService.ImportData.
class GoogleCloudAiplatformV1beta1ImportDataRequest {
  /// The desired input locations.
  ///
  /// The contents of all input locations will be imported in one batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ImportDataConfig>? importConfigs;

  GoogleCloudAiplatformV1beta1ImportDataRequest({this.importConfigs});

  GoogleCloudAiplatformV1beta1ImportDataRequest.fromJson(core.Map json_)
    : this(
        importConfigs:
            (json_['importConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ImportDataConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (importConfigs != null) 'importConfigs': importConfigs!,
  };
}

/// Request message for FeaturestoreService.ImportFeatureValues.
class GoogleCloudAiplatformV1beta1ImportFeatureValuesRequest {
  GoogleCloudAiplatformV1beta1AvroSource? avroSource;
  GoogleCloudAiplatformV1beta1BigQuerySource? bigquerySource;
  GoogleCloudAiplatformV1beta1CsvSource? csvSource;

  /// If true, API doesn't start ingestion analysis pipeline.
  core.bool? disableIngestionAnalysis;

  /// If set, data will not be imported for online serving.
  ///
  /// This is typically used for backfilling, where Feature generation
  /// timestamps are not in the timestamp range needed for online serving.
  core.bool? disableOnlineServing;

  /// Source column that holds entity IDs.
  ///
  /// If not provided, entity IDs are extracted from the column named entity_id.
  core.String? entityIdField;

  /// Specifications defining which Feature values to import from the entity.
  ///
  /// The request fails if no feature_specs are provided, and having multiple
  /// feature_specs for one Feature is not allowed.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ImportFeatureValuesRequestFeatureSpec>?
  featureSpecs;

  /// Single Feature timestamp for all entities being imported.
  ///
  /// The timestamp must not have higher than millisecond precision.
  core.String? featureTime;

  /// Source column that holds the Feature timestamp for all Feature values in
  /// each entity.
  core.String? featureTimeField;

  /// Specifies the number of workers that are used to write data to the
  /// Featurestore.
  ///
  /// Consider the online serving capacity that you require to achieve the
  /// desired import throughput without interfering with online serving. The
  /// value must be positive, and less than or equal to 100. If not set,
  /// defaults to using 1 worker. The low count ensures minimal impact on online
  /// serving performance.
  core.int? workerCount;

  GoogleCloudAiplatformV1beta1ImportFeatureValuesRequest({
    this.avroSource,
    this.bigquerySource,
    this.csvSource,
    this.disableIngestionAnalysis,
    this.disableOnlineServing,
    this.entityIdField,
    this.featureSpecs,
    this.featureTime,
    this.featureTimeField,
    this.workerCount,
  });

  GoogleCloudAiplatformV1beta1ImportFeatureValuesRequest.fromJson(
    core.Map json_,
  ) : this(
        avroSource:
            json_.containsKey('avroSource')
                ? GoogleCloudAiplatformV1beta1AvroSource.fromJson(
                  json_['avroSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudAiplatformV1beta1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        csvSource:
            json_.containsKey('csvSource')
                ? GoogleCloudAiplatformV1beta1CsvSource.fromJson(
                  json_['csvSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        disableIngestionAnalysis:
            json_['disableIngestionAnalysis'] as core.bool?,
        disableOnlineServing: json_['disableOnlineServing'] as core.bool?,
        entityIdField: json_['entityIdField'] as core.String?,
        featureSpecs:
            (json_['featureSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ImportFeatureValuesRequestFeatureSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        featureTime: json_['featureTime'] as core.String?,
        featureTimeField: json_['featureTimeField'] as core.String?,
        workerCount: json_['workerCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (avroSource != null) 'avroSource': avroSource!,
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (csvSource != null) 'csvSource': csvSource!,
    if (disableIngestionAnalysis != null)
      'disableIngestionAnalysis': disableIngestionAnalysis!,
    if (disableOnlineServing != null)
      'disableOnlineServing': disableOnlineServing!,
    if (entityIdField != null) 'entityIdField': entityIdField!,
    if (featureSpecs != null) 'featureSpecs': featureSpecs!,
    if (featureTime != null) 'featureTime': featureTime!,
    if (featureTimeField != null) 'featureTimeField': featureTimeField!,
    if (workerCount != null) 'workerCount': workerCount!,
  };
}

/// Defines the Feature value(s) to import.
typedef GoogleCloudAiplatformV1beta1ImportFeatureValuesRequestFeatureSpec =
    $ImportFeatureValuesRequestFeatureSpec;

/// Request message for IndexService.ImportIndex.
class GoogleCloudAiplatformV1beta1ImportIndexRequest {
  /// Configuration for importing data from an external source.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfig? config;

  /// If true, completely replace existing index data.
  ///
  /// Must be true for streaming update indexes.
  ///
  /// Optional.
  core.bool? isCompleteOverwrite;

  GoogleCloudAiplatformV1beta1ImportIndexRequest({
    this.config,
    this.isCompleteOverwrite,
  });

  GoogleCloudAiplatformV1beta1ImportIndexRequest.fromJson(core.Map json_)
    : this(
        config:
            json_.containsKey('config')
                ? GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfig.fromJson(
                  json_['config'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        isCompleteOverwrite: json_['isCompleteOverwrite'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (config != null) 'config': config!,
    if (isCompleteOverwrite != null)
      'isCompleteOverwrite': isCompleteOverwrite!,
  };
}

/// Configuration for importing data from an external source.
class GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfig {
  /// Configuration for importing data from a BigQuery table.
  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigBigQuerySourceConfig?
  bigQuerySourceConfig;

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfig({
    this.bigQuerySourceConfig,
  });

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfig.fromJson(
    core.Map json_,
  ) : this(
        bigQuerySourceConfig:
            json_.containsKey('bigQuerySourceConfig')
                ? GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigBigQuerySourceConfig.fromJson(
                  json_['bigQuerySourceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigQuerySourceConfig != null)
      'bigQuerySourceConfig': bigQuerySourceConfig!,
  };
}

/// Configuration for importing data from a BigQuery table.
class GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigBigQuerySourceConfig {
  /// Mapping of datapoint fields to BigQuery column names.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMapping?
  datapointFieldMapping;

  /// The path to the BigQuery table containing the index data, in the format of
  /// `bq://..`.
  ///
  /// Required.
  core.String? tablePath;

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigBigQuerySourceConfig({
    this.datapointFieldMapping,
    this.tablePath,
  });

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigBigQuerySourceConfig.fromJson(
    core.Map json_,
  ) : this(
        datapointFieldMapping:
            json_.containsKey('datapointFieldMapping')
                ? GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMapping.fromJson(
                  json_['datapointFieldMapping']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tablePath: json_['tablePath'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datapointFieldMapping != null)
      'datapointFieldMapping': datapointFieldMapping!,
    if (tablePath != null) 'tablePath': tablePath!,
  };
}

/// Mapping of datapoint fields to column names for columnar data sources.
class GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMapping {
  /// The column with the vector embeddings for each data point.
  ///
  /// Required.
  core.String? embeddingColumn;

  /// The column with unique identifiers for each data point.
  ///
  /// Required.
  core.String? idColumn;

  /// List of columns containing metadata to be included in the index.
  ///
  /// Optional.
  core.List<core.String>? metadataColumns;

  /// List of restricts for numeric values.
  ///
  /// Optional.
  core.List<
    GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingNumericRestrict
  >?
  numericRestricts;

  /// List of restricts for string values.
  ///
  /// Optional.
  core.List<
    GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingRestrict
  >?
  restricts;

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMapping({
    this.embeddingColumn,
    this.idColumn,
    this.metadataColumns,
    this.numericRestricts,
    this.restricts,
  });

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMapping.fromJson(
    core.Map json_,
  ) : this(
        embeddingColumn: json_['embeddingColumn'] as core.String?,
        idColumn: json_['idColumn'] as core.String?,
        metadataColumns:
            (json_['metadataColumns'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        numericRestricts:
            (json_['numericRestricts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingNumericRestrict.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        restricts:
            (json_['restricts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingRestrict.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (embeddingColumn != null) 'embeddingColumn': embeddingColumn!,
    if (idColumn != null) 'idColumn': idColumn!,
    if (metadataColumns != null) 'metadataColumns': metadataColumns!,
    if (numericRestricts != null) 'numericRestricts': numericRestricts!,
    if (restricts != null) 'restricts': restricts!,
  };
}

/// Restrictions on numeric values.
class GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingNumericRestrict {
  /// The namespace of the restrict.
  ///
  /// Required.
  core.String? namespace;

  /// The column containing the numeric value.
  ///
  /// Optional.
  core.String? valueColumn;

  /// Numeric type of the restrict.
  ///
  /// Must be consistent for all datapoints within the namespace.
  ///
  /// Required.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : Should not be used.
  /// - "INT" : Represents 64 bit integer.
  /// - "FLOAT" : Represents 32 bit float.
  /// - "DOUBLE" : Represents 64 bit float.
  core.String? valueType;

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingNumericRestrict({
    this.namespace,
    this.valueColumn,
    this.valueType,
  });

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingNumericRestrict.fromJson(
    core.Map json_,
  ) : this(
        namespace: json_['namespace'] as core.String?,
        valueColumn: json_['valueColumn'] as core.String?,
        valueType: json_['valueType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (namespace != null) 'namespace': namespace!,
    if (valueColumn != null) 'valueColumn': valueColumn!,
    if (valueType != null) 'valueType': valueType!,
  };
}

/// Restrictions on string values.
class GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingRestrict {
  /// The columns containing the allow values.
  ///
  /// Optional.
  core.List<core.String>? allowColumn;

  /// The columns containing the deny values.
  ///
  /// Optional.
  core.List<core.String>? denyColumn;

  /// The namespace of the restrict in the index.
  ///
  /// Required.
  core.String? namespace;

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingRestrict({
    this.allowColumn,
    this.denyColumn,
    this.namespace,
  });

  GoogleCloudAiplatformV1beta1ImportIndexRequestConnectorConfigDatapointFieldMappingRestrict.fromJson(
    core.Map json_,
  ) : this(
        allowColumn:
            (json_['allowColumn'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        denyColumn:
            (json_['denyColumn'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        namespace: json_['namespace'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowColumn != null) 'allowColumn': allowColumn!,
    if (denyColumn != null) 'denyColumn': denyColumn!,
    if (namespace != null) 'namespace': namespace!,
  };
}

/// Request message for ModelService.ImportModelEvaluation
class GoogleCloudAiplatformV1beta1ImportModelEvaluationRequest {
  /// Model evaluation resource to be imported.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ModelEvaluation? modelEvaluation;

  GoogleCloudAiplatformV1beta1ImportModelEvaluationRequest({
    this.modelEvaluation,
  });

  GoogleCloudAiplatformV1beta1ImportModelEvaluationRequest.fromJson(
    core.Map json_,
  ) : this(
        modelEvaluation:
            json_.containsKey('modelEvaluation')
                ? GoogleCloudAiplatformV1beta1ModelEvaluation.fromJson(
                  json_['modelEvaluation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelEvaluation != null) 'modelEvaluation': modelEvaluation!,
  };
}

/// Config for importing RagFiles.
class GoogleCloudAiplatformV1beta1ImportRagFilesConfig {
  /// Google Cloud Storage location.
  ///
  /// Supports importing individual files as well as entire Google Cloud Storage
  /// directories. Sample formats: -
  /// `gs://bucket_name/my_directory/object_name/my_file.txt` -
  /// `gs://bucket_name/my_directory`
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  /// The max number of queries per minute that the indexing pipeline job is
  /// allowed to make to the embedding model specified in the project.
  ///
  /// Please follow the quota usage guideline of the embedding model you use to
  /// set the value properly.If this value is not specified,
  /// max_embedding_requests_per_min will be used by indexing pipeline job as
  /// the global limit.
  ///
  /// Optional.
  core.int? globalMaxEmbeddingRequestsPerMin;

  /// Google Drive location.
  ///
  /// Supports importing individual files as well as Google Drive folders.
  GoogleCloudAiplatformV1beta1GoogleDriveSource? googleDriveSource;

  /// The BigQuery destination to write import result to.
  ///
  /// It should be a bigquery table resource name (e.g.
  /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
  /// table does not exist, it will be created with the expected schema. If the
  /// table exists, the schema will be validated and data will be added to this
  /// existing table.
  GoogleCloudAiplatformV1beta1BigQueryDestination? importResultBigquerySink;

  /// The Cloud Storage path to write import result to.
  GoogleCloudAiplatformV1beta1GcsDestination? importResultGcsSink;

  /// Jira queries with their corresponding authentication.
  GoogleCloudAiplatformV1beta1JiraSource? jiraSource;

  /// The max number of queries per minute that this job is allowed to make to
  /// the embedding model specified on the corpus.
  ///
  /// This value is specific to this job and not shared across other import
  /// jobs. Consult the Quotas page on the project to set an appropriate value
  /// here. If unspecified, a default value of 1,000 QPM would be used.
  ///
  /// Optional.
  core.int? maxEmbeddingRequestsPerMin;

  /// The BigQuery destination to write partial failures to.
  ///
  /// It should be a bigquery table resource name (e.g.
  /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
  /// table does not exist, it will be created with the expected schema. If the
  /// table exists, the schema will be validated and data will be added to this
  /// existing table. Deprecated. Prefer to use `import_result_bq_sink`.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1BigQueryDestination? partialFailureBigquerySink;

  /// The Cloud Storage path to write partial failures to.
  ///
  /// Deprecated. Prefer to use `import_result_gcs_sink`.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1GcsDestination? partialFailureGcsSink;

  /// Specifies the size and overlap of chunks after importing RagFiles.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1RagFileChunkingConfig? ragFileChunkingConfig;

  /// Specifies the metadata config for RagFiles.
  ///
  /// Including paths for metadata schema and metadata.
  GoogleCloudAiplatformV1beta1RagFileMetadataConfig? ragFileMetadataConfig;

  /// Specifies the parsing config for RagFiles.
  ///
  /// RAG will use the default parser if this field is not set.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagFileParsingConfig? ragFileParsingConfig;

  /// Specifies the transformation config for RagFiles.
  GoogleCloudAiplatformV1beta1RagFileTransformationConfig?
  ragFileTransformationConfig;

  /// Rebuilds the ANN index to optimize for recall on the imported data.
  ///
  /// Only applicable for RagCorpora running on RagManagedDb with
  /// `retrieval_strategy` set to `ANN`. The rebuild will be performed using the
  /// existing ANN config set on the RagCorpus. To change the ANN config, please
  /// use the UpdateRagCorpus API. Default is false, i.e., index is not rebuilt.
  core.bool? rebuildAnnIndex;

  /// SharePoint sources.
  GoogleCloudAiplatformV1beta1SharePointSources? sharePointSources;

  /// Slack channels with their corresponding access tokens.
  GoogleCloudAiplatformV1beta1SlackSource? slackSource;

  GoogleCloudAiplatformV1beta1ImportRagFilesConfig({
    this.gcsSource,
    this.globalMaxEmbeddingRequestsPerMin,
    this.googleDriveSource,
    this.importResultBigquerySink,
    this.importResultGcsSink,
    this.jiraSource,
    this.maxEmbeddingRequestsPerMin,
    this.partialFailureBigquerySink,
    this.partialFailureGcsSink,
    this.ragFileChunkingConfig,
    this.ragFileMetadataConfig,
    this.ragFileParsingConfig,
    this.ragFileTransformationConfig,
    this.rebuildAnnIndex,
    this.sharePointSources,
    this.slackSource,
  });

  GoogleCloudAiplatformV1beta1ImportRagFilesConfig.fromJson(core.Map json_)
    : this(
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        globalMaxEmbeddingRequestsPerMin:
            json_['globalMaxEmbeddingRequestsPerMin'] as core.int?,
        googleDriveSource:
            json_.containsKey('googleDriveSource')
                ? GoogleCloudAiplatformV1beta1GoogleDriveSource.fromJson(
                  json_['googleDriveSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        importResultBigquerySink:
            json_.containsKey('importResultBigquerySink')
                ? GoogleCloudAiplatformV1beta1BigQueryDestination.fromJson(
                  json_['importResultBigquerySink']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        importResultGcsSink:
            json_.containsKey('importResultGcsSink')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['importResultGcsSink']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        jiraSource:
            json_.containsKey('jiraSource')
                ? GoogleCloudAiplatformV1beta1JiraSource.fromJson(
                  json_['jiraSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        maxEmbeddingRequestsPerMin:
            json_['maxEmbeddingRequestsPerMin'] as core.int?,
        partialFailureBigquerySink:
            json_.containsKey('partialFailureBigquerySink')
                ? GoogleCloudAiplatformV1beta1BigQueryDestination.fromJson(
                  json_['partialFailureBigquerySink']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        partialFailureGcsSink:
            json_.containsKey('partialFailureGcsSink')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['partialFailureGcsSink']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFileChunkingConfig:
            json_.containsKey('ragFileChunkingConfig')
                ? GoogleCloudAiplatformV1beta1RagFileChunkingConfig.fromJson(
                  json_['ragFileChunkingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFileMetadataConfig:
            json_.containsKey('ragFileMetadataConfig')
                ? GoogleCloudAiplatformV1beta1RagFileMetadataConfig.fromJson(
                  json_['ragFileMetadataConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFileParsingConfig:
            json_.containsKey('ragFileParsingConfig')
                ? GoogleCloudAiplatformV1beta1RagFileParsingConfig.fromJson(
                  json_['ragFileParsingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFileTransformationConfig:
            json_.containsKey('ragFileTransformationConfig')
                ? GoogleCloudAiplatformV1beta1RagFileTransformationConfig.fromJson(
                  json_['ragFileTransformationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        rebuildAnnIndex: json_['rebuildAnnIndex'] as core.bool?,
        sharePointSources:
            json_.containsKey('sharePointSources')
                ? GoogleCloudAiplatformV1beta1SharePointSources.fromJson(
                  json_['sharePointSources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        slackSource:
            json_.containsKey('slackSource')
                ? GoogleCloudAiplatformV1beta1SlackSource.fromJson(
                  json_['slackSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (globalMaxEmbeddingRequestsPerMin != null)
      'globalMaxEmbeddingRequestsPerMin': globalMaxEmbeddingRequestsPerMin!,
    if (googleDriveSource != null) 'googleDriveSource': googleDriveSource!,
    if (importResultBigquerySink != null)
      'importResultBigquerySink': importResultBigquerySink!,
    if (importResultGcsSink != null)
      'importResultGcsSink': importResultGcsSink!,
    if (jiraSource != null) 'jiraSource': jiraSource!,
    if (maxEmbeddingRequestsPerMin != null)
      'maxEmbeddingRequestsPerMin': maxEmbeddingRequestsPerMin!,
    if (partialFailureBigquerySink != null)
      'partialFailureBigquerySink': partialFailureBigquerySink!,
    if (partialFailureGcsSink != null)
      'partialFailureGcsSink': partialFailureGcsSink!,
    if (ragFileChunkingConfig != null)
      'ragFileChunkingConfig': ragFileChunkingConfig!,
    if (ragFileMetadataConfig != null)
      'ragFileMetadataConfig': ragFileMetadataConfig!,
    if (ragFileParsingConfig != null)
      'ragFileParsingConfig': ragFileParsingConfig!,
    if (ragFileTransformationConfig != null)
      'ragFileTransformationConfig': ragFileTransformationConfig!,
    if (rebuildAnnIndex != null) 'rebuildAnnIndex': rebuildAnnIndex!,
    if (sharePointSources != null) 'sharePointSources': sharePointSources!,
    if (slackSource != null) 'slackSource': slackSource!,
  };
}

/// Request message for VertexRagDataService.ImportRagFiles.
class GoogleCloudAiplatformV1beta1ImportRagFilesRequest {
  /// The config for the RagFiles to be synced and imported into the RagCorpus.
  ///
  /// VertexRagDataService.ImportRagFiles.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ImportRagFilesConfig? importRagFilesConfig;

  GoogleCloudAiplatformV1beta1ImportRagFilesRequest({
    this.importRagFilesConfig,
  });

  GoogleCloudAiplatformV1beta1ImportRagFilesRequest.fromJson(core.Map json_)
    : this(
        importRagFilesConfig:
            json_.containsKey('importRagFilesConfig')
                ? GoogleCloudAiplatformV1beta1ImportRagFilesConfig.fromJson(
                  json_['importRagFilesConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (importRagFilesConfig != null)
      'importRagFilesConfig': importRagFilesConfig!,
  };
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
class GoogleCloudAiplatformV1beta1Index {
  /// Timestamp when this Index was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The pointers to DeployedIndexes created from this Index.
  ///
  /// An Index can be only deleted if all its DeployedIndexes had been
  /// undeployed first.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1DeployedIndexRef>? deployedIndexes;

  /// The description of the Index.
  core.String? description;

  /// The display name of the Index.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for an Index.
  ///
  /// If set, this Index and all sub-resources of this Index will be secured by
  /// this key.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Stats of the index resource.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1IndexStats? indexStats;

  /// The update method to use with this Index.
  ///
  /// If not set, BATCH_UPDATE will be used by default.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "INDEX_UPDATE_METHOD_UNSPECIFIED" : Should not be used.
  /// - "BATCH_UPDATE" : BatchUpdate: user can call UpdateIndex with files on
  /// Cloud Storage of Datapoints to update.
  /// - "STREAM_UPDATE" : StreamUpdate: user can call
  /// UpsertDatapoints/DeleteDatapoints to update the Index and the updates will
  /// be applied in corresponding DeployedIndexes in nearly real-time.
  core.String? indexUpdateMethod;

  /// The labels with user-defined metadata to organize your Indexes.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// An additional information about the Index; the schema of the metadata can
  /// be found in metadata_schema.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Index, that is specific to it.
  ///
  /// Unset if the Index does not have any additional information. The schema is
  /// defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  ///
  /// Immutable.
  core.String? metadataSchemaUri;

  /// The resource name of the Index.
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this Index was most recently updated.
  ///
  /// This also includes any update to the contents of the Index. Note that
  /// Operations working on this Index may have their
  /// Operations.metadata.generic_metadata.update_time a little after the value
  /// of this timestamp, yet that does not mean their results are not already
  /// reflected in the Index. Result of any successfully completed Operation on
  /// the Index is reflected in it.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Index({
    this.createTime,
    this.deployedIndexes,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.indexStats,
    this.indexUpdateMethod,
    this.labels,
    this.metadata,
    this.metadataSchemaUri,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Index.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        deployedIndexes:
            (json_['deployedIndexes'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DeployedIndexRef.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        indexStats:
            json_.containsKey('indexStats')
                ? GoogleCloudAiplatformV1beta1IndexStats.fromJson(
                  json_['indexStats'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        indexUpdateMethod: json_['indexUpdateMethod'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        metadata: json_['metadata'],
        metadataSchemaUri: json_['metadataSchemaUri'] as core.String?,
        name: json_['name'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (deployedIndexes != null) 'deployedIndexes': deployedIndexes!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (indexStats != null) 'indexStats': indexStats!,
    if (indexUpdateMethod != null) 'indexUpdateMethod': indexUpdateMethod!,
    if (labels != null) 'labels': labels!,
    if (metadata != null) 'metadata': metadata!,
    if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
    if (name != null) 'name': name!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// A datapoint of Index.
class GoogleCloudAiplatformV1beta1IndexDatapoint {
  /// CrowdingTag of the datapoint, the number of neighbors to return in each
  /// crowding can be configured during query.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1IndexDatapointCrowdingTag? crowdingTag;

  /// Unique identifier of the datapoint.
  ///
  /// Required.
  core.String? datapointId;

  /// The key-value map of additional metadata for the datapoint.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? embeddingMetadata;

  /// Feature embedding vector for dense index.
  ///
  /// An array of numbers with the length of
  /// \[NearestNeighborSearchConfig.dimensions\].
  ///
  /// Required.
  core.List<core.double>? featureVector;

  /// List of Restrict of the datapoint, used to perform "restricted searches"
  /// where boolean rule are used to filter the subset of the database eligible
  /// for matching.
  ///
  /// This uses numeric comparisons.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1IndexDatapointNumericRestriction>?
  numericRestricts;

  /// List of Restrict of the datapoint, used to perform "restricted searches"
  /// where boolean rule are used to filter the subset of the database eligible
  /// for matching.
  ///
  /// This uses categorical tokens. See:
  /// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1IndexDatapointRestriction>? restricts;

  /// Feature embedding vector for sparse index.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1IndexDatapointSparseEmbedding? sparseEmbedding;

  GoogleCloudAiplatformV1beta1IndexDatapoint({
    this.crowdingTag,
    this.datapointId,
    this.embeddingMetadata,
    this.featureVector,
    this.numericRestricts,
    this.restricts,
    this.sparseEmbedding,
  });

  GoogleCloudAiplatformV1beta1IndexDatapoint.fromJson(core.Map json_)
    : this(
        crowdingTag:
            json_.containsKey('crowdingTag')
                ? GoogleCloudAiplatformV1beta1IndexDatapointCrowdingTag.fromJson(
                  json_['crowdingTag'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        datapointId: json_['datapointId'] as core.String?,
        embeddingMetadata:
            json_.containsKey('embeddingMetadata')
                ? json_['embeddingMetadata']
                    as core.Map<core.String, core.dynamic>
                : null,
        featureVector:
            (json_['featureVector'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
        numericRestricts:
            (json_['numericRestricts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1IndexDatapointNumericRestriction.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        restricts:
            (json_['restricts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1IndexDatapointRestriction.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        sparseEmbedding:
            json_.containsKey('sparseEmbedding')
                ? GoogleCloudAiplatformV1beta1IndexDatapointSparseEmbedding.fromJson(
                  json_['sparseEmbedding']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (crowdingTag != null) 'crowdingTag': crowdingTag!,
    if (datapointId != null) 'datapointId': datapointId!,
    if (embeddingMetadata != null) 'embeddingMetadata': embeddingMetadata!,
    if (featureVector != null) 'featureVector': featureVector!,
    if (numericRestricts != null) 'numericRestricts': numericRestricts!,
    if (restricts != null) 'restricts': restricts!,
    if (sparseEmbedding != null) 'sparseEmbedding': sparseEmbedding!,
  };
}

/// Crowding tag is a constraint on a neighbor list produced by nearest neighbor
/// search requiring that no more than some value k' of the k neighbors returned
/// have the same value of crowding_attribute.
typedef GoogleCloudAiplatformV1beta1IndexDatapointCrowdingTag =
    $IndexDatapointCrowdingTag;

/// This field allows restricts to be based on numeric comparisons rather than
/// categorical tokens.
typedef GoogleCloudAiplatformV1beta1IndexDatapointNumericRestriction =
    $IndexDatapointNumericRestriction;

/// Restriction of a datapoint which describe its attributes(tokens) from each
/// of several attribute categories(namespaces).
typedef GoogleCloudAiplatformV1beta1IndexDatapointRestriction =
    $IndexDatapointRestriction;

/// Feature embedding vector for sparse index.
///
/// An array of numbers whose values are located in the specified dimensions.
typedef GoogleCloudAiplatformV1beta1IndexDatapointSparseEmbedding =
    $IndexDatapointSparseEmbedding;

/// Indexes are deployed into it.
///
/// An IndexEndpoint can have multiple DeployedIndexes.
class GoogleCloudAiplatformV1beta1IndexEndpoint {
  /// Timestamp when this IndexEndpoint was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The indexes deployed in this endpoint.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1DeployedIndex>? deployedIndexes;

  /// The description of the IndexEndpoint.
  core.String? description;

  /// The display name of the IndexEndpoint.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Deprecated: If true, expose the IndexEndpoint via private service connect.
  ///
  /// Only one of the fields, network or enable_private_service_connect, can be
  /// set.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enablePrivateServiceConnect;

  /// Customer-managed encryption key spec for an IndexEndpoint.
  ///
  /// If set, this IndexEndpoint and all sub-resources of this IndexEndpoint
  /// will be secured by this key.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your IndexEndpoints.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the IndexEndpoint.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
  /// to which the IndexEndpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If
  /// left unspecified, the Endpoint is not peered with any network. network and
  /// private_service_connect_config are mutually exclusive.
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in '12345', and {network} is network name.
  ///
  /// Optional.
  core.String? network;

  /// Configuration for private service connect.
  ///
  /// network and private_service_connect_config are mutually exclusive.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig?
  privateServiceConnectConfig;

  /// If public_endpoint_enabled is true, this field will be populated with the
  /// domain name to use for this index endpoint.
  ///
  /// Output only.
  core.String? publicEndpointDomainName;

  /// If true, the deployed index will be accessible through public endpoint.
  ///
  /// Optional.
  core.bool? publicEndpointEnabled;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this IndexEndpoint was last updated.
  ///
  /// This timestamp is not updated when the endpoint's DeployedIndexes are
  /// updated, e.g. due to updates of the original Indexes they are the
  /// deployments of.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1IndexEndpoint({
    this.createTime,
    this.deployedIndexes,
    this.description,
    this.displayName,
    this.enablePrivateServiceConnect,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.network,
    this.privateServiceConnectConfig,
    this.publicEndpointDomainName,
    this.publicEndpointEnabled,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1IndexEndpoint.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        deployedIndexes:
            (json_['deployedIndexes'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1DeployedIndex.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        enablePrivateServiceConnect:
            json_['enablePrivateServiceConnect'] as core.bool?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        privateServiceConnectConfig:
            json_.containsKey('privateServiceConnectConfig')
                ? GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig.fromJson(
                  json_['privateServiceConnectConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        publicEndpointDomainName:
            json_['publicEndpointDomainName'] as core.String?,
        publicEndpointEnabled: json_['publicEndpointEnabled'] as core.bool?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (deployedIndexes != null) 'deployedIndexes': deployedIndexes!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (enablePrivateServiceConnect != null)
      'enablePrivateServiceConnect': enablePrivateServiceConnect!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!,
    if (publicEndpointDomainName != null)
      'publicEndpointDomainName': publicEndpointDomainName!,
    if (publicEndpointEnabled != null)
      'publicEndpointEnabled': publicEndpointEnabled!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// IndexPrivateEndpoints proto is used to provide paths for users to send
/// requests via private endpoints (e.g. private service access, private service
/// connect).
///
/// To send request via private service access, use match_grpc_address. To send
/// request via private service connect, use service_attachment.
class GoogleCloudAiplatformV1beta1IndexPrivateEndpoints {
  /// The ip address used to send match gRPC requests.
  ///
  /// Output only.
  core.String? matchGrpcAddress;

  /// PscAutomatedEndpoints is populated if private service connect is enabled
  /// if PscAutomatedConfig is set.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1PscAutomatedEndpoints>?
  pscAutomatedEndpoints;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1beta1IndexPrivateEndpoints({
    this.matchGrpcAddress,
    this.pscAutomatedEndpoints,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1beta1IndexPrivateEndpoints.fromJson(core.Map json_)
    : this(
        matchGrpcAddress: json_['matchGrpcAddress'] as core.String?,
        pscAutomatedEndpoints:
            (json_['pscAutomatedEndpoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PscAutomatedEndpoints.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (matchGrpcAddress != null) 'matchGrpcAddress': matchGrpcAddress!,
    if (pscAutomatedEndpoints != null)
      'pscAutomatedEndpoints': pscAutomatedEndpoints!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Stats of the Index.
typedef GoogleCloudAiplatformV1beta1IndexStats = $IndexStats;

/// Specifies Vertex AI owned input data to be used for training, and possibly
/// evaluating, the Model.
class GoogleCloudAiplatformV1beta1InputDataConfig {
  /// Applicable only to custom training with Datasets that have DataItems and
  /// Annotations.
  ///
  /// Cloud Storage URI that points to a YAML file describing the annotation
  /// schema. The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/ , note that the
  /// chosen schema must be consistent with metadata of the Dataset specified by
  /// dataset_id. Only Annotations that both match this schema and belong to
  /// DataItems not ignored by the split method are used in respectively
  /// training, validation or test role, depending on the role of the DataItem
  /// they are on. When used in conjunction with annotations_filter, the
  /// Annotations used for training are filtered by both annotations_filter and
  /// annotation_schema_uri.
  core.String? annotationSchemaUri;

  /// Applicable only to Datasets that have DataItems and Annotations.
  ///
  /// A filter on Annotations of the Dataset. Only Annotations that both match
  /// this filter and belong to DataItems not ignored by the split method are
  /// used in respectively training, validation or test role, depending on the
  /// role of the DataItem they are on (for the auto-assigned that role is
  /// decided by Vertex AI). A filter with same syntax as the one used in
  /// ListAnnotations may be used, but note here it filters across all
  /// Annotations of the Dataset, and not just within a single DataItem.
  core.String? annotationsFilter;

  /// Only applicable to custom training with tabular Dataset with BigQuery
  /// source.
  ///
  /// The BigQuery project location where the training data is to be written to.
  /// In the given project a new dataset is created with name `dataset___` where
  /// timestamp is in YYYY_MM_DDThh_mm_ss_sssZ format. All training input data
  /// is written into that dataset. In the dataset three tables are created,
  /// `training`, `validation` and `test`. * AIP_DATA_FORMAT = "bigquery". *
  /// AIP_TRAINING_DATA_URI = "bigquery_destination.dataset___.training" *
  /// AIP_VALIDATION_DATA_URI = "bigquery_destination.dataset___.validation" *
  /// AIP_TEST_DATA_URI = "bigquery_destination.dataset___.test"
  GoogleCloudAiplatformV1beta1BigQueryDestination? bigqueryDestination;

  /// The ID of the Dataset in the same Project and Location which data will be
  /// used to train the Model.
  ///
  /// The Dataset must use schema compatible with Model being trained, and what
  /// is compatible should be described in the used TrainingPipeline's
  /// training_task_definition. For tabular Datasets, all their data is exported
  /// to training, to pick and choose from.
  ///
  /// Required.
  core.String? datasetId;

  /// Split based on the provided filters for each set.
  GoogleCloudAiplatformV1beta1FilterSplit? filterSplit;

  /// Split based on fractions defining the size of each set.
  GoogleCloudAiplatformV1beta1FractionSplit? fractionSplit;

  /// The Cloud Storage location where the training data is to be written to.
  ///
  /// In the given directory a new directory is created with name: `dataset---`
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All
  /// training input data is written into that directory. The Vertex AI
  /// environment variables representing Cloud Storage data URIs are represented
  /// in the Cloud Storage wildcard format to support sharded data. e.g.:
  /// "gs://.../training-*.jsonl" * AIP_DATA_FORMAT = "jsonl" for non-tabular
  /// data, "csv" for tabular data * AIP_TRAINING_DATA_URI =
  /// "gcs_destination/dataset---/training-*.${AIP_DATA_FORMAT}" *
  /// AIP_VALIDATION_DATA_URI =
  /// "gcs_destination/dataset---/validation-*.${AIP_DATA_FORMAT}" *
  /// AIP_TEST_DATA_URI = "gcs_destination/dataset---/test-*.${AIP_DATA_FORMAT}"
  GoogleCloudAiplatformV1beta1GcsDestination? gcsDestination;

  /// Whether to persist the ML use assignment to data item system labels.
  core.bool? persistMlUseAssignment;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on a predefined key.
  GoogleCloudAiplatformV1beta1PredefinedSplit? predefinedSplit;

  /// Only applicable to Datasets that have SavedQueries.
  ///
  /// The ID of a SavedQuery (annotation set) under the Dataset specified by
  /// dataset_id used for filtering Annotations for training. Only Annotations
  /// that are associated with this SavedQuery are used in respectively
  /// training. When used in conjunction with annotations_filter, the
  /// Annotations used for training are filtered by both saved_query_id and
  /// annotations_filter. Only one of saved_query_id and annotation_schema_uri
  /// should be specified as both of them represent the same thing: problem
  /// type.
  core.String? savedQueryId;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the distribution of the specified column.
  GoogleCloudAiplatformV1beta1StratifiedSplit? stratifiedSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the timestamp of the input data pieces.
  GoogleCloudAiplatformV1beta1TimestampSplit? timestampSplit;

  GoogleCloudAiplatformV1beta1InputDataConfig({
    this.annotationSchemaUri,
    this.annotationsFilter,
    this.bigqueryDestination,
    this.datasetId,
    this.filterSplit,
    this.fractionSplit,
    this.gcsDestination,
    this.persistMlUseAssignment,
    this.predefinedSplit,
    this.savedQueryId,
    this.stratifiedSplit,
    this.timestampSplit,
  });

  GoogleCloudAiplatformV1beta1InputDataConfig.fromJson(core.Map json_)
    : this(
        annotationSchemaUri: json_['annotationSchemaUri'] as core.String?,
        annotationsFilter: json_['annotationsFilter'] as core.String?,
        bigqueryDestination:
            json_.containsKey('bigqueryDestination')
                ? GoogleCloudAiplatformV1beta1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        datasetId: json_['datasetId'] as core.String?,
        filterSplit:
            json_.containsKey('filterSplit')
                ? GoogleCloudAiplatformV1beta1FilterSplit.fromJson(
                  json_['filterSplit'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        fractionSplit:
            json_.containsKey('fractionSplit')
                ? GoogleCloudAiplatformV1beta1FractionSplit.fromJson(
                  json_['fractionSplit'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsDestination:
            json_.containsKey('gcsDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        persistMlUseAssignment: json_['persistMlUseAssignment'] as core.bool?,
        predefinedSplit:
            json_.containsKey('predefinedSplit')
                ? GoogleCloudAiplatformV1beta1PredefinedSplit.fromJson(
                  json_['predefinedSplit']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        savedQueryId: json_['savedQueryId'] as core.String?,
        stratifiedSplit:
            json_.containsKey('stratifiedSplit')
                ? GoogleCloudAiplatformV1beta1StratifiedSplit.fromJson(
                  json_['stratifiedSplit']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        timestampSplit:
            json_.containsKey('timestampSplit')
                ? GoogleCloudAiplatformV1beta1TimestampSplit.fromJson(
                  json_['timestampSplit']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationSchemaUri != null)
      'annotationSchemaUri': annotationSchemaUri!,
    if (annotationsFilter != null) 'annotationsFilter': annotationsFilter!,
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!,
    if (datasetId != null) 'datasetId': datasetId!,
    if (filterSplit != null) 'filterSplit': filterSplit!,
    if (fractionSplit != null) 'fractionSplit': fractionSplit!,
    if (gcsDestination != null) 'gcsDestination': gcsDestination!,
    if (persistMlUseAssignment != null)
      'persistMlUseAssignment': persistMlUseAssignment!,
    if (predefinedSplit != null) 'predefinedSplit': predefinedSplit!,
    if (savedQueryId != null) 'savedQueryId': savedQueryId!,
    if (stratifiedSplit != null) 'stratifiedSplit': stratifiedSplit!,
    if (timestampSplit != null) 'timestampSplit': timestampSplit!,
  };
}

/// A list of int64 values.
typedef GoogleCloudAiplatformV1beta1Int64Array = $Int64Array;

/// An attribution method that computes the Aumann-Shapley value taking
/// advantage of the model's fully differentiable structure.
///
/// Refer to this paper for more details: https://arxiv.org/abs/1703.01365
class GoogleCloudAiplatformV1beta1IntegratedGradientsAttribution {
  /// Config for IG with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image)
  /// is motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  GoogleCloudAiplatformV1beta1BlurBaselineConfig? blurBaselineConfig;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding noise can help
  /// improve the computed gradients. Refer to this paper for more details:
  /// https://arxiv.org/pdf/1706.03825.pdf
  GoogleCloudAiplatformV1beta1SmoothGradConfig? smoothGradConfig;

  /// The number of steps for approximating the path integral.
  ///
  /// A good value to start is 50 and gradually increase until the sum to diff
  /// property is within the desired error range. Valid range of its value is
  /// \[1, 100\], inclusively.
  ///
  /// Required.
  core.int? stepCount;

  GoogleCloudAiplatformV1beta1IntegratedGradientsAttribution({
    this.blurBaselineConfig,
    this.smoothGradConfig,
    this.stepCount,
  });

  GoogleCloudAiplatformV1beta1IntegratedGradientsAttribution.fromJson(
    core.Map json_,
  ) : this(
        blurBaselineConfig:
            json_.containsKey('blurBaselineConfig')
                ? GoogleCloudAiplatformV1beta1BlurBaselineConfig.fromJson(
                  json_['blurBaselineConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        smoothGradConfig:
            json_.containsKey('smoothGradConfig')
                ? GoogleCloudAiplatformV1beta1SmoothGradConfig.fromJson(
                  json_['smoothGradConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        stepCount: json_['stepCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blurBaselineConfig != null) 'blurBaselineConfig': blurBaselineConfig!,
    if (smoothGradConfig != null) 'smoothGradConfig': smoothGradConfig!,
    if (stepCount != null) 'stepCount': stepCount!,
  };
}

/// Request message for \[InternalOsServiceStateInstance\].
class GoogleCloudAiplatformV1beta1InternalOsServiceStateInstance {
  /// internal service name.
  ///
  /// Required.
  /// Possible string values are:
  /// - "INTERNAL_OS_SERVICE_ENUM_UNSPECIFIED" : Service name unknown.
  /// - "DOCKER_SERVICE_STATE" : Represents the internal os docker client.
  /// - "CONTROL_PLANE_API_DNS_STATE" : Represents resolving DNS for the control
  /// plane api endpoint.
  /// - "PROXY_REGISTRATION_DNS_STATE" : Represents resolving DNS for the proxy
  /// registration endpoint.
  /// - "JUPYTER_STATE" : Represents the jupyter endpoint.
  /// - "JUPYTER_API_STATE" : Represents the jupyter/api endpoint.
  /// - "EUC_METADATA_API_STATE" : Represents the EUC metadata server API
  /// endpoint.
  /// - "EUC_AGENT_API_STATE" : Represents the EUC agent server API endpoint.
  /// - "IDLE_SHUTDOWN_AGENT_STATE" : Represents the idle shutdown agent sidecar
  /// container.
  /// - "PROXY_AGENT_STATE" : Represents the proxy agent sidecar container.
  /// - "GCR_DNS_STATE" : Represents resolving DNS for the gcr.io endpoint.
  /// - "GUEST_ATTRIBUTE_STATE" : Represents if the guest attribute service is
  /// enabled.
  core.String? serviceName;

  /// internal service state.
  ///
  /// Required.
  /// Possible string values are:
  /// - "UNKNOWN" : Health status is unknown: not initialized or failed to
  /// retrieve.
  /// - "HEALTHY" : The resource is healthy.
  /// - "UNHEALTHY" : The resource is unhealthy.
  core.String? serviceState;

  GoogleCloudAiplatformV1beta1InternalOsServiceStateInstance({
    this.serviceName,
    this.serviceState,
  });

  GoogleCloudAiplatformV1beta1InternalOsServiceStateInstance.fromJson(
    core.Map json_,
  ) : this(
        serviceName: json_['serviceName'] as core.String?,
        serviceState: json_['serviceState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (serviceName != null) 'serviceName': serviceName!,
    if (serviceState != null) 'serviceState': serviceState!,
  };
}

/// The Jira source for the ImportRagFilesRequest.
class GoogleCloudAiplatformV1beta1JiraSource {
  /// The Jira queries.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1JiraSourceJiraQueries>? jiraQueries;

  GoogleCloudAiplatformV1beta1JiraSource({this.jiraQueries});

  GoogleCloudAiplatformV1beta1JiraSource.fromJson(core.Map json_)
    : this(
        jiraQueries:
            (json_['jiraQueries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1JiraSourceJiraQueries.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (jiraQueries != null) 'jiraQueries': jiraQueries!,
  };
}

/// JiraQueries contains the Jira queries and corresponding authentication.
class GoogleCloudAiplatformV1beta1JiraSourceJiraQueries {
  /// The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the Jira
  /// API key.
  ///
  /// See
  /// [Manage API tokens for your Atlassian account](https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/).
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig? apiKeyConfig;

  /// A list of custom Jira queries to import.
  ///
  /// For information about JQL (Jira Query Language), see
  /// https://support.atlassian.com/jira-service-management-cloud/docs/use-advanced-search-with-jira-query-language-jql/
  core.List<core.String>? customQueries;

  /// The Jira email address.
  ///
  /// Required.
  core.String? email;

  /// A list of Jira projects to import in their entirety.
  core.List<core.String>? projects;

  /// The Jira server URI.
  ///
  /// Required.
  core.String? serverUri;

  GoogleCloudAiplatformV1beta1JiraSourceJiraQueries({
    this.apiKeyConfig,
    this.customQueries,
    this.email,
    this.projects,
    this.serverUri,
  });

  GoogleCloudAiplatformV1beta1JiraSourceJiraQueries.fromJson(core.Map json_)
    : this(
        apiKeyConfig:
            json_.containsKey('apiKeyConfig')
                ? GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig.fromJson(
                  json_['apiKeyConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        customQueries:
            (json_['customQueries'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        email: json_['email'] as core.String?,
        projects:
            (json_['projects'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        serverUri: json_['serverUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!,
    if (customQueries != null) 'customQueries': customQueries!,
    if (email != null) 'email': email!,
    if (projects != null) 'projects': projects!,
    if (serverUri != null) 'serverUri': serverUri!,
  };
}

/// Contains information about the Large Model.
typedef GoogleCloudAiplatformV1beta1LargeModelReference = $LargeModelReference;

/// A subgraph of the overall lineage graph.
///
/// Event edges connect Artifact and Execution nodes.
class GoogleCloudAiplatformV1beta1LineageSubgraph {
  /// The Artifact nodes in the subgraph.
  core.List<GoogleCloudAiplatformV1beta1Artifact>? artifacts;

  /// The Event edges between Artifacts and Executions in the subgraph.
  core.List<GoogleCloudAiplatformV1beta1Event>? events;

  /// The Execution nodes in the subgraph.
  core.List<GoogleCloudAiplatformV1beta1Execution>? executions;

  GoogleCloudAiplatformV1beta1LineageSubgraph({
    this.artifacts,
    this.events,
    this.executions,
  });

  GoogleCloudAiplatformV1beta1LineageSubgraph.fromJson(core.Map json_)
    : this(
        artifacts:
            (json_['artifacts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Artifact.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        events:
            (json_['events'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Event.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        executions:
            (json_['executions'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Execution.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifacts != null) 'artifacts': artifacts!,
    if (events != null) 'events': events!,
    if (executions != null) 'executions': executions!,
  };
}

/// Response message for DatasetService.ListAnnotations.
class GoogleCloudAiplatformV1beta1ListAnnotationsResponse {
  /// A list of Annotations that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1beta1Annotation>? annotations;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListAnnotationsResponse({
    this.annotations,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListAnnotationsResponse.fromJson(core.Map json_)
    : this(
        annotations:
            (json_['annotations'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Annotation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotations != null) 'annotations': annotations!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for MetadataService.ListArtifacts.
class GoogleCloudAiplatformV1beta1ListArtifactsResponse {
  /// The Artifacts retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1beta1Artifact>? artifacts;

  /// A token, which can be sent as ListArtifactsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListArtifactsResponse({
    this.artifacts,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListArtifactsResponse.fromJson(core.Map json_)
    : this(
        artifacts:
            (json_['artifacts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Artifact.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifacts != null) 'artifacts': artifacts!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for JobService.ListBatchPredictionJobs
class GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse {
  /// List of BatchPredictionJobs in the requested page.
  core.List<GoogleCloudAiplatformV1beta1BatchPredictionJob>?
  batchPredictionJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListBatchPredictionJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse({
    this.batchPredictionJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListBatchPredictionJobsResponse.fromJson(
    core.Map json_,
  ) : this(
        batchPredictionJobs:
            (json_['batchPredictionJobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1BatchPredictionJob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (batchPredictionJobs != null)
      'batchPredictionJobs': batchPredictionJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response with a list of CachedContents.
class GoogleCloudAiplatformV1beta1ListCachedContentsResponse {
  /// List of cached contents.
  core.List<GoogleCloudAiplatformV1beta1CachedContent>? cachedContents;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListCachedContentsResponse({
    this.cachedContents,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListCachedContentsResponse.fromJson(
    core.Map json_,
  ) : this(
        cachedContents:
            (json_['cachedContents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1CachedContent.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cachedContents != null) 'cachedContents': cachedContents!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for MetadataService.ListContexts.
class GoogleCloudAiplatformV1beta1ListContextsResponse {
  /// The Contexts retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1beta1Context>? contexts;

  /// A token, which can be sent as ListContextsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListContextsResponse({
    this.contexts,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListContextsResponse.fromJson(core.Map json_)
    : this(
        contexts:
            (json_['contexts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Context.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contexts != null) 'contexts': contexts!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for JobService.ListCustomJobs
class GoogleCloudAiplatformV1beta1ListCustomJobsResponse {
  /// List of CustomJobs in the requested page.
  core.List<GoogleCloudAiplatformV1beta1CustomJob>? customJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListCustomJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListCustomJobsResponse({
    this.customJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListCustomJobsResponse.fromJson(core.Map json_)
    : this(
        customJobs:
            (json_['customJobs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1CustomJob.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customJobs != null) 'customJobs': customJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for DatasetService.ListDataItems.
class GoogleCloudAiplatformV1beta1ListDataItemsResponse {
  /// A list of DataItems that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1beta1DataItem>? dataItems;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListDataItemsResponse({
    this.dataItems,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListDataItemsResponse.fromJson(core.Map json_)
    : this(
        dataItems:
            (json_['dataItems'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1DataItem.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataItems != null) 'dataItems': dataItems!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for JobService.ListDataLabelingJobs.
class GoogleCloudAiplatformV1beta1ListDataLabelingJobsResponse {
  /// A list of DataLabelingJobs that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1beta1DataLabelingJob>? dataLabelingJobs;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListDataLabelingJobsResponse({
    this.dataLabelingJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListDataLabelingJobsResponse.fromJson(
    core.Map json_,
  ) : this(
        dataLabelingJobs:
            (json_['dataLabelingJobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DataLabelingJob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataLabelingJobs != null) 'dataLabelingJobs': dataLabelingJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for DatasetService.ListDatasetVersions.
class GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse {
  /// A list of DatasetVersions that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1beta1DatasetVersion>? datasetVersions;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse({
    this.datasetVersions,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListDatasetVersionsResponse.fromJson(
    core.Map json_,
  ) : this(
        datasetVersions:
            (json_['datasetVersions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DatasetVersion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datasetVersions != null) 'datasetVersions': datasetVersions!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for DatasetService.ListDatasets.
class GoogleCloudAiplatformV1beta1ListDatasetsResponse {
  /// A list of Datasets that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1beta1Dataset>? datasets;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListDatasetsResponse({
    this.datasets,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListDatasetsResponse.fromJson(core.Map json_)
    : this(
        datasets:
            (json_['datasets'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Dataset.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datasets != null) 'datasets': datasets!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ListDeploymentResourcePools method.
class GoogleCloudAiplatformV1beta1ListDeploymentResourcePoolsResponse {
  /// The DeploymentResourcePools from the specified location.
  core.List<GoogleCloudAiplatformV1beta1DeploymentResourcePool>?
  deploymentResourcePools;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListDeploymentResourcePoolsResponse({
    this.deploymentResourcePools,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListDeploymentResourcePoolsResponse.fromJson(
    core.Map json_,
  ) : this(
        deploymentResourcePools:
            (json_['deploymentResourcePools'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DeploymentResourcePool.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deploymentResourcePools != null)
      'deploymentResourcePools': deploymentResourcePools!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for EndpointService.ListEndpoints.
class GoogleCloudAiplatformV1beta1ListEndpointsResponse {
  /// List of Endpoints in the requested page.
  core.List<GoogleCloudAiplatformV1beta1Endpoint>? endpoints;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListEndpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListEndpointsResponse({
    this.endpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListEndpointsResponse.fromJson(core.Map json_)
    : this(
        endpoints:
            (json_['endpoints'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Endpoint.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpoints != null) 'endpoints': endpoints!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeaturestoreService.ListEntityTypes.
class GoogleCloudAiplatformV1beta1ListEntityTypesResponse {
  /// The EntityTypes matching the request.
  core.List<GoogleCloudAiplatformV1beta1EntityType>? entityTypes;

  /// A token, which can be sent as ListEntityTypesRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListEntityTypesResponse({
    this.entityTypes,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListEntityTypesResponse.fromJson(core.Map json_)
    : this(
        entityTypes:
            (json_['entityTypes'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1EntityType.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityTypes != null) 'entityTypes': entityTypes!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for SessionService.ListEvents.
class GoogleCloudAiplatformV1beta1ListEventsResponse {
  /// A token, which can be sent as ListEventsRequest.page_token to retrieve the
  /// next page.
  ///
  /// Absence of this field indicates there are no subsequent pages.
  core.String? nextPageToken;

  /// A list of events matching the request.
  ///
  /// Ordered by timestamp in ascending order.
  core.List<GoogleCloudAiplatformV1beta1SessionEvent>? sessionEvents;

  GoogleCloudAiplatformV1beta1ListEventsResponse({
    this.nextPageToken,
    this.sessionEvents,
  });

  GoogleCloudAiplatformV1beta1ListEventsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        sessionEvents:
            (json_['sessionEvents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SessionEvent.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (sessionEvents != null) 'sessionEvents': sessionEvents!,
  };
}

/// Response message for ExampleStoreService.ListExampleStores.
class GoogleCloudAiplatformV1beta1ListExampleStoresResponse {
  /// List of ExampleStore in the requested page.
  core.List<GoogleCloudAiplatformV1beta1ExampleStore>? exampleStores;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListExampleStoresRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListExampleStoresResponse({
    this.exampleStores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListExampleStoresResponse.fromJson(core.Map json_)
    : this(
        exampleStores:
            (json_['exampleStores'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1ExampleStore.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exampleStores != null) 'exampleStores': exampleStores!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for MetadataService.ListExecutions.
class GoogleCloudAiplatformV1beta1ListExecutionsResponse {
  /// The Executions retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1beta1Execution>? executions;

  /// A token, which can be sent as ListExecutionsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListExecutionsResponse({
    this.executions,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListExecutionsResponse.fromJson(core.Map json_)
    : this(
        executions:
            (json_['executions'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Execution.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (executions != null) 'executions': executions!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ExtensionRegistryService.ListExtensions
class GoogleCloudAiplatformV1beta1ListExtensionsResponse {
  /// List of Extension in the requested page.
  core.List<GoogleCloudAiplatformV1beta1Extension>? extensions;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListExtensionsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListExtensionsResponse({
    this.extensions,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListExtensionsResponse.fromJson(core.Map json_)
    : this(
        extensions:
            (json_['extensions'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Extension.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extensions != null) 'extensions': extensions!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeatureRegistryService.ListFeatureGroups.
class GoogleCloudAiplatformV1beta1ListFeatureGroupsResponse {
  /// The FeatureGroups matching the request.
  core.List<GoogleCloudAiplatformV1beta1FeatureGroup>? featureGroups;

  /// A token, which can be sent as ListFeatureGroupsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeatureGroupsResponse({
    this.featureGroups,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeatureGroupsResponse.fromJson(core.Map json_)
    : this(
        featureGroups:
            (json_['featureGroups'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1FeatureGroup.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureGroups != null) 'featureGroups': featureGroups!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeatureRegistryService.ListFeatureMonitorJobs.
class GoogleCloudAiplatformV1beta1ListFeatureMonitorJobsResponse {
  /// The FeatureMonitorJobs matching the request.
  core.List<GoogleCloudAiplatformV1beta1FeatureMonitorJob>? featureMonitorJobs;

  /// A token, which can be sent as ListFeatureMonitorJobsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeatureMonitorJobsResponse({
    this.featureMonitorJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeatureMonitorJobsResponse.fromJson(
    core.Map json_,
  ) : this(
        featureMonitorJobs:
            (json_['featureMonitorJobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureMonitorJob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureMonitorJobs != null) 'featureMonitorJobs': featureMonitorJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeatureRegistryService.ListFeatureMonitors.
class GoogleCloudAiplatformV1beta1ListFeatureMonitorsResponse {
  /// The FeatureMonitors matching the request.
  core.List<GoogleCloudAiplatformV1beta1FeatureMonitor>? featureMonitors;

  /// A token, which can be sent as ListFeatureMonitorsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeatureMonitorsResponse({
    this.featureMonitors,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeatureMonitorsResponse.fromJson(
    core.Map json_,
  ) : this(
        featureMonitors:
            (json_['featureMonitors'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureMonitor.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureMonitors != null) 'featureMonitors': featureMonitors!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeatureOnlineStoreAdminService.ListFeatureOnlineStores.
class GoogleCloudAiplatformV1beta1ListFeatureOnlineStoresResponse {
  /// The FeatureOnlineStores matching the request.
  core.List<GoogleCloudAiplatformV1beta1FeatureOnlineStore>?
  featureOnlineStores;

  /// A token, which can be sent as ListFeatureOnlineStoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeatureOnlineStoresResponse({
    this.featureOnlineStores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeatureOnlineStoresResponse.fromJson(
    core.Map json_,
  ) : this(
        featureOnlineStores:
            (json_['featureOnlineStores'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureOnlineStore.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureOnlineStores != null)
      'featureOnlineStores': featureOnlineStores!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeatureOnlineStoreAdminService.ListFeatureViewSyncs.
class GoogleCloudAiplatformV1beta1ListFeatureViewSyncsResponse {
  /// The FeatureViewSyncs matching the request.
  core.List<GoogleCloudAiplatformV1beta1FeatureViewSync>? featureViewSyncs;

  /// A token, which can be sent as ListFeatureViewSyncsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeatureViewSyncsResponse({
    this.featureViewSyncs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeatureViewSyncsResponse.fromJson(
    core.Map json_,
  ) : this(
        featureViewSyncs:
            (json_['featureViewSyncs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureViewSync.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureViewSyncs != null) 'featureViewSyncs': featureViewSyncs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeatureOnlineStoreAdminService.ListFeatureViews.
class GoogleCloudAiplatformV1beta1ListFeatureViewsResponse {
  /// The FeatureViews matching the request.
  core.List<GoogleCloudAiplatformV1beta1FeatureView>? featureViews;

  /// A token, which can be sent as ListFeatureViewsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeatureViewsResponse({
    this.featureViews,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeatureViewsResponse.fromJson(core.Map json_)
    : this(
        featureViews:
            (json_['featureViews'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1FeatureView.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureViews != null) 'featureViews': featureViews!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeaturestoreService.ListFeatures.
///
/// Response message for FeatureRegistryService.ListFeatures.
class GoogleCloudAiplatformV1beta1ListFeaturesResponse {
  /// The Features matching the request.
  core.List<GoogleCloudAiplatformV1beta1Feature>? features;

  /// A token, which can be sent as ListFeaturesRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeaturesResponse({
    this.features,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeaturesResponse.fromJson(core.Map json_)
    : this(
        features:
            (json_['features'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Feature.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (features != null) 'features': features!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for FeaturestoreService.ListFeaturestores.
class GoogleCloudAiplatformV1beta1ListFeaturestoresResponse {
  /// The Featurestores matching the request.
  core.List<GoogleCloudAiplatformV1beta1Featurestore>? featurestores;

  /// A token, which can be sent as ListFeaturestoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListFeaturestoresResponse({
    this.featurestores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListFeaturestoresResponse.fromJson(core.Map json_)
    : this(
        featurestores:
            (json_['featurestores'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Featurestore.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featurestores != null) 'featurestores': featurestores!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for JobService.ListHyperparameterTuningJobs
class GoogleCloudAiplatformV1beta1ListHyperparameterTuningJobsResponse {
  /// List of HyperparameterTuningJobs in the requested page.
  ///
  /// HyperparameterTuningJob.trials of the jobs will be not be returned.
  core.List<GoogleCloudAiplatformV1beta1HyperparameterTuningJob>?
  hyperparameterTuningJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListHyperparameterTuningJobsRequest.page_token to obtain that
  /// page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListHyperparameterTuningJobsResponse({
    this.hyperparameterTuningJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListHyperparameterTuningJobsResponse.fromJson(
    core.Map json_,
  ) : this(
        hyperparameterTuningJobs:
            (json_['hyperparameterTuningJobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1HyperparameterTuningJob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperparameterTuningJobs != null)
      'hyperparameterTuningJobs': hyperparameterTuningJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for IndexEndpointService.ListIndexEndpoints.
class GoogleCloudAiplatformV1beta1ListIndexEndpointsResponse {
  /// List of IndexEndpoints in the requested page.
  core.List<GoogleCloudAiplatformV1beta1IndexEndpoint>? indexEndpoints;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListIndexEndpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListIndexEndpointsResponse({
    this.indexEndpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListIndexEndpointsResponse.fromJson(
    core.Map json_,
  ) : this(
        indexEndpoints:
            (json_['indexEndpoints'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1IndexEndpoint.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (indexEndpoints != null) 'indexEndpoints': indexEndpoints!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for IndexService.ListIndexes.
class GoogleCloudAiplatformV1beta1ListIndexesResponse {
  /// List of indexes in the requested page.
  core.List<GoogleCloudAiplatformV1beta1Index>? indexes;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListIndexesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListIndexesResponse({
    this.indexes,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListIndexesResponse.fromJson(core.Map json_)
    : this(
        indexes:
            (json_['indexes'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Index.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (indexes != null) 'indexes': indexes!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for MemoryBankService.ListMemories.
class GoogleCloudAiplatformV1beta1ListMemoriesResponse {
  /// List of Memories in the requested page.
  core.List<GoogleCloudAiplatformV1beta1Memory>? memories;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListMemoriesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListMemoriesResponse({
    this.memories,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListMemoriesResponse.fromJson(core.Map json_)
    : this(
        memories:
            (json_['memories'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Memory.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (memories != null) 'memories': memories!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for MetadataService.ListMetadataSchemas.
class GoogleCloudAiplatformV1beta1ListMetadataSchemasResponse {
  /// The MetadataSchemas found for the MetadataStore.
  core.List<GoogleCloudAiplatformV1beta1MetadataSchema>? metadataSchemas;

  /// A token, which can be sent as ListMetadataSchemasRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListMetadataSchemasResponse({
    this.metadataSchemas,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListMetadataSchemasResponse.fromJson(
    core.Map json_,
  ) : this(
        metadataSchemas:
            (json_['metadataSchemas'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1MetadataSchema.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadataSchemas != null) 'metadataSchemas': metadataSchemas!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for MetadataService.ListMetadataStores.
class GoogleCloudAiplatformV1beta1ListMetadataStoresResponse {
  /// The MetadataStores found for the Location.
  core.List<GoogleCloudAiplatformV1beta1MetadataStore>? metadataStores;

  /// A token, which can be sent as ListMetadataStoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListMetadataStoresResponse({
    this.metadataStores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListMetadataStoresResponse.fromJson(
    core.Map json_,
  ) : this(
        metadataStores:
            (json_['metadataStores'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1MetadataStore.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadataStores != null) 'metadataStores': metadataStores!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for JobService.ListModelDeploymentMonitoringJobs.
class GoogleCloudAiplatformV1beta1ListModelDeploymentMonitoringJobsResponse {
  /// A list of ModelDeploymentMonitoringJobs that matches the specified filter
  /// in the request.
  core.List<GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob>?
  modelDeploymentMonitoringJobs;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelDeploymentMonitoringJobsResponse({
    this.modelDeploymentMonitoringJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelDeploymentMonitoringJobsResponse.fromJson(
    core.Map json_,
  ) : this(
        modelDeploymentMonitoringJobs:
            (json_['modelDeploymentMonitoringJobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelDeploymentMonitoringJobs != null)
      'modelDeploymentMonitoringJobs': modelDeploymentMonitoringJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ModelService.ListModelEvaluationSlices.
class GoogleCloudAiplatformV1beta1ListModelEvaluationSlicesResponse {
  /// List of ModelEvaluations in the requested page.
  core.List<GoogleCloudAiplatformV1beta1ModelEvaluationSlice>?
  modelEvaluationSlices;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelEvaluationSlicesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelEvaluationSlicesResponse({
    this.modelEvaluationSlices,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelEvaluationSlicesResponse.fromJson(
    core.Map json_,
  ) : this(
        modelEvaluationSlices:
            (json_['modelEvaluationSlices'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelEvaluationSlice.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelEvaluationSlices != null)
      'modelEvaluationSlices': modelEvaluationSlices!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ModelService.ListModelEvaluations.
class GoogleCloudAiplatformV1beta1ListModelEvaluationsResponse {
  /// List of ModelEvaluations in the requested page.
  core.List<GoogleCloudAiplatformV1beta1ModelEvaluation>? modelEvaluations;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelEvaluationsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelEvaluationsResponse({
    this.modelEvaluations,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelEvaluationsResponse.fromJson(
    core.Map json_,
  ) : this(
        modelEvaluations:
            (json_['modelEvaluations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelEvaluation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelEvaluations != null) 'modelEvaluations': modelEvaluations!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ModelMonitoringService.ListModelMonitoringJobs.
class GoogleCloudAiplatformV1beta1ListModelMonitoringJobsResponse {
  /// A list of ModelMonitoringJobs that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringJob>?
  modelMonitoringJobs;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelMonitoringJobsResponse({
    this.modelMonitoringJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelMonitoringJobsResponse.fromJson(
    core.Map json_,
  ) : this(
        modelMonitoringJobs:
            (json_['modelMonitoringJobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringJob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelMonitoringJobs != null)
      'modelMonitoringJobs': modelMonitoringJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ModelMonitoringService.ListModelMonitors
class GoogleCloudAiplatformV1beta1ListModelMonitorsResponse {
  /// List of ModelMonitor in the requested page.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitor>? modelMonitors;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListModelMonitorsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelMonitorsResponse({
    this.modelMonitors,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelMonitorsResponse.fromJson(core.Map json_)
    : this(
        modelMonitors:
            (json_['modelMonitors'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1ModelMonitor.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelMonitors != null) 'modelMonitors': modelMonitors!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ModelService.ListModelVersionCheckpoints
class GoogleCloudAiplatformV1beta1ListModelVersionCheckpointsResponse {
  /// List of Model Version checkpoints.
  core.List<GoogleCloudAiplatformV1beta1ModelVersionCheckpoint>? checkpoints;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListModelVersionCheckpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelVersionCheckpointsResponse({
    this.checkpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelVersionCheckpointsResponse.fromJson(
    core.Map json_,
  ) : this(
        checkpoints:
            (json_['checkpoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelVersionCheckpoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkpoints != null) 'checkpoints': checkpoints!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ModelService.ListModelVersions
class GoogleCloudAiplatformV1beta1ListModelVersionsResponse {
  /// List of Model versions in the requested page.
  ///
  /// In the returned Model name field, version ID instead of regvision tag will
  /// be included.
  core.List<GoogleCloudAiplatformV1beta1Model>? models;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListModelVersionsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelVersionsResponse({
    this.models,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelVersionsResponse.fromJson(core.Map json_)
    : this(
        models:
            (json_['models'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Model.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (models != null) 'models': models!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for ModelService.ListModels
class GoogleCloudAiplatformV1beta1ListModelsResponse {
  /// List of Models in the requested page.
  core.List<GoogleCloudAiplatformV1beta1Model>? models;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListModelsResponse({
    this.models,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListModelsResponse.fromJson(core.Map json_)
    : this(
        models:
            (json_['models'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Model.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (models != null) 'models': models!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for JobService.ListNasJobs
class GoogleCloudAiplatformV1beta1ListNasJobsResponse {
  /// List of NasJobs in the requested page.
  ///
  /// NasJob.nas_job_output of the jobs will not be returned.
  core.List<GoogleCloudAiplatformV1beta1NasJob>? nasJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListNasJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListNasJobsResponse({
    this.nasJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListNasJobsResponse.fromJson(core.Map json_)
    : this(
        nasJobs:
            (json_['nasJobs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1NasJob.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nasJobs != null) 'nasJobs': nasJobs!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for JobService.ListNasTrialDetails
class GoogleCloudAiplatformV1beta1ListNasTrialDetailsResponse {
  /// List of top NasTrials in the requested page.
  core.List<GoogleCloudAiplatformV1beta1NasTrialDetail>? nasTrialDetails;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListNasTrialDetailsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1ListNasTrialDetailsResponse({
    this.nasTrialDetails,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1ListNasTrialDetailsResponse.fromJson(
    core.Map json_,
  ) : this(
        nasTrialDetails:
            (json_['nasTrialDetails'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1NasTrialDetail.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nasTrialDetails != null) 'nasTrialDetails': nasTrialDetails!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for \[NotebookService.CreateNotebookExecutionJob\]
class GoogleCloudAiplatformV1beta1ListNotebookExecutionJobsResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookExecutionJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of NotebookExecutionJobs in the requested page.
  core.List<GoogleCloudAiplatformV1beta1NotebookExecutionJob>?
  notebookExecutionJobs;

  GoogleCloudAiplatformV1beta1ListNotebookExecutionJobsResponse({
    this.nextPageToken,
    this.notebookExecutionJobs,
  });

  GoogleCloudAiplatformV1beta1ListNotebookExecutionJobsResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        notebookExecutionJobs:
            (json_['notebookExecutionJobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1NotebookExecutionJob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (notebookExecutionJobs != null)
      'notebookExecutionJobs': notebookExecutionJobs!,
  };
}

/// Response message for NotebookService.ListNotebookRuntimeTemplates.
class GoogleCloudAiplatformV1beta1ListNotebookRuntimeTemplatesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookRuntimeTemplatesRequest.page_token to obtain that
  /// page.
  core.String? nextPageToken;

  /// List of NotebookRuntimeTemplates in the requested page.
  core.List<GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate>?
  notebookRuntimeTemplates;

  GoogleCloudAiplatformV1beta1ListNotebookRuntimeTemplatesResponse({
    this.nextPageToken,
    this.notebookRuntimeTemplates,
  });

  GoogleCloudAiplatformV1beta1ListNotebookRuntimeTemplatesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        notebookRuntimeTemplates:
            (json_['notebookRuntimeTemplates'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (notebookRuntimeTemplates != null)
      'notebookRuntimeTemplates': notebookRuntimeTemplates!,
  };
}

/// Response message for NotebookService.ListNotebookRuntimes.
class GoogleCloudAiplatformV1beta1ListNotebookRuntimesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookRuntimesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of NotebookRuntimes in the requested page.
  core.List<GoogleCloudAiplatformV1beta1NotebookRuntime>? notebookRuntimes;

  GoogleCloudAiplatformV1beta1ListNotebookRuntimesResponse({
    this.nextPageToken,
    this.notebookRuntimes,
  });

  GoogleCloudAiplatformV1beta1ListNotebookRuntimesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        notebookRuntimes:
            (json_['notebookRuntimes'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1NotebookRuntime.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (notebookRuntimes != null) 'notebookRuntimes': notebookRuntimes!,
  };
}

/// Request message for VizierService.ListOptimalTrials.
typedef GoogleCloudAiplatformV1beta1ListOptimalTrialsRequest = $Empty;

/// Response message for VizierService.ListOptimalTrials.
class GoogleCloudAiplatformV1beta1ListOptimalTrialsResponse {
  /// The pareto-optimal Trials for multiple objective Study or the optimal
  /// trial for single objective Study.
  ///
  /// The definition of pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  core.List<GoogleCloudAiplatformV1beta1Trial>? optimalTrials;

  GoogleCloudAiplatformV1beta1ListOptimalTrialsResponse({this.optimalTrials});

  GoogleCloudAiplatformV1beta1ListOptimalTrialsResponse.fromJson(core.Map json_)
    : this(
        optimalTrials:
            (json_['optimalTrials'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Trial.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (optimalTrials != null) 'optimalTrials': optimalTrials!,
  };
}

/// Response message for PersistentResourceService.ListPersistentResources
class GoogleCloudAiplatformV1beta1ListPersistentResourcesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListPersistentResourcesRequest.page_token to obtain that page.
  core.String? nextPageToken;
  core.List<GoogleCloudAiplatformV1beta1PersistentResource>?
  persistentResources;

  GoogleCloudAiplatformV1beta1ListPersistentResourcesResponse({
    this.nextPageToken,
    this.persistentResources,
  });

  GoogleCloudAiplatformV1beta1ListPersistentResourcesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        persistentResources:
            (json_['persistentResources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PersistentResource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (persistentResources != null)
      'persistentResources': persistentResources!,
  };
}

/// Response message for PipelineService.ListPipelineJobs
class GoogleCloudAiplatformV1beta1ListPipelineJobsResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListPipelineJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of PipelineJobs in the requested page.
  core.List<GoogleCloudAiplatformV1beta1PipelineJob>? pipelineJobs;

  GoogleCloudAiplatformV1beta1ListPipelineJobsResponse({
    this.nextPageToken,
    this.pipelineJobs,
  });

  GoogleCloudAiplatformV1beta1ListPipelineJobsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        pipelineJobs:
            (json_['pipelineJobs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1PipelineJob.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (pipelineJobs != null) 'pipelineJobs': pipelineJobs!,
  };
}

/// Response message for ModelGardenService.ListPublisherModels.
class GoogleCloudAiplatformV1beta1ListPublisherModelsResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListPublisherModels.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of PublisherModels in the requested page.
  core.List<GoogleCloudAiplatformV1beta1PublisherModel>? publisherModels;

  GoogleCloudAiplatformV1beta1ListPublisherModelsResponse({
    this.nextPageToken,
    this.publisherModels,
  });

  GoogleCloudAiplatformV1beta1ListPublisherModelsResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        publisherModels:
            (json_['publisherModels'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PublisherModel.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (publisherModels != null) 'publisherModels': publisherModels!,
  };
}

/// Response message for VertexRagDataService.ListRagCorpora.
class GoogleCloudAiplatformV1beta1ListRagCorporaResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListRagCorporaRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of RagCorpora in the requested page.
  core.List<GoogleCloudAiplatformV1beta1RagCorpus>? ragCorpora;

  GoogleCloudAiplatformV1beta1ListRagCorporaResponse({
    this.nextPageToken,
    this.ragCorpora,
  });

  GoogleCloudAiplatformV1beta1ListRagCorporaResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        ragCorpora:
            (json_['ragCorpora'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1RagCorpus.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (ragCorpora != null) 'ragCorpora': ragCorpora!,
  };
}

/// Response message for VertexRagDataService.ListRagFiles.
class GoogleCloudAiplatformV1beta1ListRagFilesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListRagFilesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of RagFiles in the requested page.
  core.List<GoogleCloudAiplatformV1beta1RagFile>? ragFiles;

  GoogleCloudAiplatformV1beta1ListRagFilesResponse({
    this.nextPageToken,
    this.ragFiles,
  });

  GoogleCloudAiplatformV1beta1ListRagFilesResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        ragFiles:
            (json_['ragFiles'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1RagFile.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (ragFiles != null) 'ragFiles': ragFiles!,
  };
}

/// Response message for ReasoningEngineService.ListReasoningEngines
class GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListReasoningEnginesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of ReasoningEngines in the requested page.
  core.List<GoogleCloudAiplatformV1beta1ReasoningEngine>? reasoningEngines;

  GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse({
    this.nextPageToken,
    this.reasoningEngines,
  });

  GoogleCloudAiplatformV1beta1ListReasoningEnginesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        reasoningEngines:
            (json_['reasoningEngines'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ReasoningEngine.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (reasoningEngines != null) 'reasoningEngines': reasoningEngines!,
  };
}

/// Response message for DatasetService.ListSavedQueries.
class GoogleCloudAiplatformV1beta1ListSavedQueriesResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of SavedQueries that match the specified filter in the request.
  core.List<GoogleCloudAiplatformV1beta1SavedQuery>? savedQueries;

  GoogleCloudAiplatformV1beta1ListSavedQueriesResponse({
    this.nextPageToken,
    this.savedQueries,
  });

  GoogleCloudAiplatformV1beta1ListSavedQueriesResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        savedQueries:
            (json_['savedQueries'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SavedQuery.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (savedQueries != null) 'savedQueries': savedQueries!,
  };
}

/// Response message for ScheduleService.ListSchedules
class GoogleCloudAiplatformV1beta1ListSchedulesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListSchedulesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of Schedules in the requested page.
  core.List<GoogleCloudAiplatformV1beta1Schedule>? schedules;

  GoogleCloudAiplatformV1beta1ListSchedulesResponse({
    this.nextPageToken,
    this.schedules,
  });

  GoogleCloudAiplatformV1beta1ListSchedulesResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        schedules:
            (json_['schedules'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Schedule.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (schedules != null) 'schedules': schedules!,
  };
}

/// Response message for SessionService.ListSessions.
class GoogleCloudAiplatformV1beta1ListSessionsResponse {
  /// A token, which can be sent as ListSessionsRequest.page_token to retrieve
  /// the next page.
  ///
  /// Absence of this field indicates there are no subsequent pages.
  core.String? nextPageToken;

  /// A list of sessions matching the request.
  core.List<GoogleCloudAiplatformV1beta1Session>? sessions;

  GoogleCloudAiplatformV1beta1ListSessionsResponse({
    this.nextPageToken,
    this.sessions,
  });

  GoogleCloudAiplatformV1beta1ListSessionsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        sessions:
            (json_['sessions'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Session.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (sessions != null) 'sessions': sessions!,
  };
}

/// Response message for SpecialistPoolService.ListSpecialistPools.
class GoogleCloudAiplatformV1beta1ListSpecialistPoolsResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of SpecialistPools that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1beta1SpecialistPool>? specialistPools;

  GoogleCloudAiplatformV1beta1ListSpecialistPoolsResponse({
    this.nextPageToken,
    this.specialistPools,
  });

  GoogleCloudAiplatformV1beta1ListSpecialistPoolsResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        specialistPools:
            (json_['specialistPools'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1SpecialistPool.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (specialistPools != null) 'specialistPools': specialistPools!,
  };
}

/// Response message for VizierService.ListStudies.
class GoogleCloudAiplatformV1beta1ListStudiesResponse {
  /// Passes this token as the `page_token` field of the request for a
  /// subsequent call.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The studies associated with the project.
  core.List<GoogleCloudAiplatformV1beta1Study>? studies;

  GoogleCloudAiplatformV1beta1ListStudiesResponse({
    this.nextPageToken,
    this.studies,
  });

  GoogleCloudAiplatformV1beta1ListStudiesResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        studies:
            (json_['studies'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Study.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (studies != null) 'studies': studies!,
  };
}

/// Response message for TensorboardService.ListTensorboardExperiments.
class GoogleCloudAiplatformV1beta1ListTensorboardExperimentsResponse {
  /// A token, which can be sent as ListTensorboardExperimentsRequest.page_token
  /// to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardExperiments mathching the request.
  core.List<GoogleCloudAiplatformV1beta1TensorboardExperiment>?
  tensorboardExperiments;

  GoogleCloudAiplatformV1beta1ListTensorboardExperimentsResponse({
    this.nextPageToken,
    this.tensorboardExperiments,
  });

  GoogleCloudAiplatformV1beta1ListTensorboardExperimentsResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        tensorboardExperiments:
            (json_['tensorboardExperiments'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TensorboardExperiment.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (tensorboardExperiments != null)
      'tensorboardExperiments': tensorboardExperiments!,
  };
}

/// Response message for TensorboardService.ListTensorboardRuns.
class GoogleCloudAiplatformV1beta1ListTensorboardRunsResponse {
  /// A token, which can be sent as ListTensorboardRunsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardRuns mathching the request.
  core.List<GoogleCloudAiplatformV1beta1TensorboardRun>? tensorboardRuns;

  GoogleCloudAiplatformV1beta1ListTensorboardRunsResponse({
    this.nextPageToken,
    this.tensorboardRuns,
  });

  GoogleCloudAiplatformV1beta1ListTensorboardRunsResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        tensorboardRuns:
            (json_['tensorboardRuns'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TensorboardRun.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (tensorboardRuns != null) 'tensorboardRuns': tensorboardRuns!,
  };
}

/// Response message for TensorboardService.ListTensorboardTimeSeries.
class GoogleCloudAiplatformV1beta1ListTensorboardTimeSeriesResponse {
  /// A token, which can be sent as ListTensorboardTimeSeriesRequest.page_token
  /// to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardTimeSeries mathching the request.
  core.List<GoogleCloudAiplatformV1beta1TensorboardTimeSeries>?
  tensorboardTimeSeries;

  GoogleCloudAiplatformV1beta1ListTensorboardTimeSeriesResponse({
    this.nextPageToken,
    this.tensorboardTimeSeries,
  });

  GoogleCloudAiplatformV1beta1ListTensorboardTimeSeriesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        tensorboardTimeSeries:
            (json_['tensorboardTimeSeries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TensorboardTimeSeries.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (tensorboardTimeSeries != null)
      'tensorboardTimeSeries': tensorboardTimeSeries!,
  };
}

/// Response message for TensorboardService.ListTensorboards.
class GoogleCloudAiplatformV1beta1ListTensorboardsResponse {
  /// A token, which can be sent as ListTensorboardsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The Tensorboards mathching the request.
  core.List<GoogleCloudAiplatformV1beta1Tensorboard>? tensorboards;

  GoogleCloudAiplatformV1beta1ListTensorboardsResponse({
    this.nextPageToken,
    this.tensorboards,
  });

  GoogleCloudAiplatformV1beta1ListTensorboardsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        tensorboards:
            (json_['tensorboards'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tensorboard.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (tensorboards != null) 'tensorboards': tensorboards!,
  };
}

/// Response message for PipelineService.ListTrainingPipelines
class GoogleCloudAiplatformV1beta1ListTrainingPipelinesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListTrainingPipelinesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of TrainingPipelines in the requested page.
  core.List<GoogleCloudAiplatformV1beta1TrainingPipeline>? trainingPipelines;

  GoogleCloudAiplatformV1beta1ListTrainingPipelinesResponse({
    this.nextPageToken,
    this.trainingPipelines,
  });

  GoogleCloudAiplatformV1beta1ListTrainingPipelinesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        trainingPipelines:
            (json_['trainingPipelines'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrainingPipeline.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (trainingPipelines != null) 'trainingPipelines': trainingPipelines!,
  };
}

/// Response message for VizierService.ListTrials.
class GoogleCloudAiplatformV1beta1ListTrialsResponse {
  /// Pass this token as the `page_token` field of the request for a subsequent
  /// call.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The Trials associated with the Study.
  core.List<GoogleCloudAiplatformV1beta1Trial>? trials;

  GoogleCloudAiplatformV1beta1ListTrialsResponse({
    this.nextPageToken,
    this.trials,
  });

  GoogleCloudAiplatformV1beta1ListTrialsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        trials:
            (json_['trials'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Trial.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (trials != null) 'trials': trials!,
  };
}

/// Response message for GenAiTuningService.ListTuningJobs
class GoogleCloudAiplatformV1beta1ListTuningJobsResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListTuningJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of TuningJobs in the requested page.
  core.List<GoogleCloudAiplatformV1beta1TuningJob>? tuningJobs;

  GoogleCloudAiplatformV1beta1ListTuningJobsResponse({
    this.nextPageToken,
    this.tuningJobs,
  });

  GoogleCloudAiplatformV1beta1ListTuningJobsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        tuningJobs:
            (json_['tuningJobs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1TuningJob.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (tuningJobs != null) 'tuningJobs': tuningJobs!,
  };
}

/// Logprobs Result
class GoogleCloudAiplatformV1beta1LogprobsResult {
  /// Length = total number of decoding steps.
  ///
  /// The chosen candidates may or may not be in top_candidates.
  core.List<GoogleCloudAiplatformV1beta1LogprobsResultCandidate>?
  chosenCandidates;

  /// Length = total number of decoding steps.
  core.List<GoogleCloudAiplatformV1beta1LogprobsResultTopCandidates>?
  topCandidates;

  GoogleCloudAiplatformV1beta1LogprobsResult({
    this.chosenCandidates,
    this.topCandidates,
  });

  GoogleCloudAiplatformV1beta1LogprobsResult.fromJson(core.Map json_)
    : this(
        chosenCandidates:
            (json_['chosenCandidates'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1LogprobsResultCandidate.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        topCandidates:
            (json_['topCandidates'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1LogprobsResultTopCandidates.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chosenCandidates != null) 'chosenCandidates': chosenCandidates!,
    if (topCandidates != null) 'topCandidates': topCandidates!,
  };
}

/// Candidate for the logprobs token and score.
typedef GoogleCloudAiplatformV1beta1LogprobsResultCandidate =
    $LogprobsResultCandidate;

/// Candidates with top log probabilities at each decoding step.
class GoogleCloudAiplatformV1beta1LogprobsResultTopCandidates {
  /// Sorted by log probability in descending order.
  core.List<GoogleCloudAiplatformV1beta1LogprobsResultCandidate>? candidates;

  GoogleCloudAiplatformV1beta1LogprobsResultTopCandidates({this.candidates});

  GoogleCloudAiplatformV1beta1LogprobsResultTopCandidates.fromJson(
    core.Map json_,
  ) : this(
        candidates:
            (json_['candidates'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1LogprobsResultCandidate.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (candidates != null) 'candidates': candidates!,
  };
}

/// Request message for VizierService.LookupStudy.
typedef GoogleCloudAiplatformV1beta1LookupStudyRequest = $LookupStudyRequest;

/// Specification of a single machine.
class GoogleCloudAiplatformV1beta1MachineSpec {
  /// The number of accelerators to attach to the machine.
  core.int? acceleratorCount;

  /// The type of accelerator(s) that may be attached to the machine as per
  /// accelerator_count.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "ACCELERATOR_TYPE_UNSPECIFIED" : Unspecified accelerator type, which
  /// means no accelerator.
  /// - "NVIDIA_TESLA_K80" : Deprecated: Nvidia Tesla K80 GPU has reached end of
  /// support, see https://cloud.google.com/compute/docs/eol/k80-eol.
  /// - "NVIDIA_TESLA_P100" : Nvidia Tesla P100 GPU.
  /// - "NVIDIA_TESLA_V100" : Nvidia Tesla V100 GPU.
  /// - "NVIDIA_TESLA_P4" : Nvidia Tesla P4 GPU.
  /// - "NVIDIA_TESLA_T4" : Nvidia Tesla T4 GPU.
  /// - "NVIDIA_TESLA_A100" : Nvidia Tesla A100 GPU.
  /// - "NVIDIA_A100_80GB" : Nvidia A100 80GB GPU.
  /// - "NVIDIA_L4" : Nvidia L4 GPU.
  /// - "NVIDIA_H100_80GB" : Nvidia H100 80Gb GPU.
  /// - "NVIDIA_H100_MEGA_80GB" : Nvidia H100 Mega 80Gb GPU.
  /// - "NVIDIA_H200_141GB" : Nvidia H200 141Gb GPU.
  /// - "NVIDIA_B200" : Nvidia B200 GPU.
  /// - "NVIDIA_GB200" : Nvidia GB200 GPU.
  /// - "TPU_V2" : TPU v2.
  /// - "TPU_V3" : TPU v3.
  /// - "TPU_V4_POD" : TPU v4.
  /// - "TPU_V5_LITEPOD" : TPU v5.
  core.String? acceleratorType;

  /// The type of the machine.
  ///
  /// See the
  /// [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
  /// See the
  /// [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
  /// For DeployedModel this field is optional, and the default value is
  /// `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this
  /// field is required.
  ///
  /// Immutable.
  core.String? machineType;

  /// The number of nodes per replica for multihost GPU deployments.
  ///
  /// Optional. Immutable.
  core.int? multihostGpuNodeCount;

  /// Configuration controlling how this resource pool consumes reservation.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1ReservationAffinity? reservationAffinity;

  /// The topology of the TPUs.
  ///
  /// Corresponds to the TPU topologies available from GKE. (Example:
  /// tpu_topology: "2x2x1").
  ///
  /// Immutable.
  core.String? tpuTopology;

  GoogleCloudAiplatformV1beta1MachineSpec({
    this.acceleratorCount,
    this.acceleratorType,
    this.machineType,
    this.multihostGpuNodeCount,
    this.reservationAffinity,
    this.tpuTopology,
  });

  GoogleCloudAiplatformV1beta1MachineSpec.fromJson(core.Map json_)
    : this(
        acceleratorCount: json_['acceleratorCount'] as core.int?,
        acceleratorType: json_['acceleratorType'] as core.String?,
        machineType: json_['machineType'] as core.String?,
        multihostGpuNodeCount: json_['multihostGpuNodeCount'] as core.int?,
        reservationAffinity:
            json_.containsKey('reservationAffinity')
                ? GoogleCloudAiplatformV1beta1ReservationAffinity.fromJson(
                  json_['reservationAffinity']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tpuTopology: json_['tpuTopology'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
    if (acceleratorType != null) 'acceleratorType': acceleratorType!,
    if (machineType != null) 'machineType': machineType!,
    if (multihostGpuNodeCount != null)
      'multihostGpuNodeCount': multihostGpuNodeCount!,
    if (reservationAffinity != null)
      'reservationAffinity': reservationAffinity!,
    if (tpuTopology != null) 'tpuTopology': tpuTopology!,
  };
}

/// Manual batch tuning parameters.
typedef GoogleCloudAiplatformV1beta1ManualBatchTuningParameters =
    $ManualBatchTuningParameters;

/// A message representing a Measurement of a Trial.
///
/// A Measurement contains the Metrics got by executing a Trial using suggested
/// hyperparameter values.
class GoogleCloudAiplatformV1beta1Measurement {
  /// Time that the Trial has been running at the point of this Measurement.
  ///
  /// Output only.
  core.String? elapsedDuration;

  /// A list of metrics got by evaluating the objective functions using
  /// suggested Parameter values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1MeasurementMetric>? metrics;

  /// The number of steps the machine learning model has been trained for.
  ///
  /// Must be non-negative.
  ///
  /// Output only.
  core.String? stepCount;

  GoogleCloudAiplatformV1beta1Measurement({
    this.elapsedDuration,
    this.metrics,
    this.stepCount,
  });

  GoogleCloudAiplatformV1beta1Measurement.fromJson(core.Map json_)
    : this(
        elapsedDuration: json_['elapsedDuration'] as core.String?,
        metrics:
            (json_['metrics'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1MeasurementMetric.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        stepCount: json_['stepCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (elapsedDuration != null) 'elapsedDuration': elapsedDuration!,
    if (metrics != null) 'metrics': metrics!,
    if (stepCount != null) 'stepCount': stepCount!,
  };
}

/// A message representing a metric in the measurement.
typedef GoogleCloudAiplatformV1beta1MeasurementMetric = $MeasurementMetric;

/// A memory.
class GoogleCloudAiplatformV1beta1Memory {
  /// Timestamp when this Memory was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Memory.
  ///
  /// Optional.
  core.String? description;

  /// Display name of the Memory.
  ///
  /// Optional.
  core.String? displayName;

  /// Semantic knowledge extracted from the source content.
  ///
  /// Required.
  core.String? fact;

  /// Identifier.
  ///
  /// The resource name of the Memory. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  core.String? name;

  /// The scope of the Memory.
  ///
  /// Memories are isolated within their scope. The scope is defined when
  /// creating or generating memories. Scope values cannot contain the wildcard
  /// character '*'.
  ///
  /// Required. Immutable.
  core.Map<core.String, core.String>? scope;

  /// Timestamp when this Memory was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Memory({
    this.createTime,
    this.description,
    this.displayName,
    this.fact,
    this.name,
    this.scope,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Memory.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        fact: json_['fact'] as core.String?,
        name: json_['name'] as core.String?,
        scope: (json_['scope'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (fact != null) 'fact': fact!,
    if (name != null) 'name': name!,
    if (scope != null) 'scope': scope!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Request message for ModelService.MergeVersionAliases.
typedef GoogleCloudAiplatformV1beta1MergeVersionAliasesRequest =
    $MergeVersionAliasesRequest;

/// Instance of a general MetadataSchema.
typedef GoogleCloudAiplatformV1beta1MetadataSchema = $MetadataSchema;

/// Instance of a metadata store.
///
/// Contains a set of metadata that can be queried.
class GoogleCloudAiplatformV1beta1MetadataStore {
  /// Timestamp when this MetadataStore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Dataplex integration settings.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1MetadataStoreDataplexConfig? dataplexConfig;

  /// Description of the MetadataStore.
  core.String? description;

  /// Customer-managed encryption key spec for a Metadata Store.
  ///
  /// If set, this Metadata Store and all sub-resources of this Metadata Store
  /// are secured using this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// The resource name of the MetadataStore instance.
  ///
  /// Output only.
  core.String? name;

  /// State information of the MetadataStore.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1MetadataStoreMetadataStoreState? state;

  /// Timestamp when this MetadataStore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1MetadataStore({
    this.createTime,
    this.dataplexConfig,
    this.description,
    this.encryptionSpec,
    this.name,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1MetadataStore.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        dataplexConfig:
            json_.containsKey('dataplexConfig')
                ? GoogleCloudAiplatformV1beta1MetadataStoreDataplexConfig.fromJson(
                  json_['dataplexConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        description: json_['description'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        state:
            json_.containsKey('state')
                ? GoogleCloudAiplatformV1beta1MetadataStoreMetadataStoreState.fromJson(
                  json_['state'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (dataplexConfig != null) 'dataplexConfig': dataplexConfig!,
    if (description != null) 'description': description!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Represents Dataplex integration settings.
typedef GoogleCloudAiplatformV1beta1MetadataStoreDataplexConfig =
    $MetadataStoreDataplexConfig;

/// Represents state information for a MetadataStore.
typedef GoogleCloudAiplatformV1beta1MetadataStoreMetadataStoreState =
    $MetadataStoreMetadataStoreState;

/// The metric used for running evaluations.
class GoogleCloudAiplatformV1beta1Metric {
  /// The aggregation metrics to use.
  ///
  /// Optional.
  core.List<core.String>? aggregationMetrics;

  /// Spec for bleu metric.
  GoogleCloudAiplatformV1beta1BleuSpec? bleuSpec;

  /// Spec for exact match metric.
  GoogleCloudAiplatformV1beta1ExactMatchSpec? exactMatchSpec;

  /// Spec for pairwise metric.
  GoogleCloudAiplatformV1beta1PairwiseMetricSpec? pairwiseMetricSpec;

  /// Spec for pointwise metric.
  GoogleCloudAiplatformV1beta1PointwiseMetricSpec? pointwiseMetricSpec;

  /// Spec for rouge metric.
  GoogleCloudAiplatformV1beta1RougeSpec? rougeSpec;

  GoogleCloudAiplatformV1beta1Metric({
    this.aggregationMetrics,
    this.bleuSpec,
    this.exactMatchSpec,
    this.pairwiseMetricSpec,
    this.pointwiseMetricSpec,
    this.rougeSpec,
  });

  GoogleCloudAiplatformV1beta1Metric.fromJson(core.Map json_)
    : this(
        aggregationMetrics:
            (json_['aggregationMetrics'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        bleuSpec:
            json_.containsKey('bleuSpec')
                ? GoogleCloudAiplatformV1beta1BleuSpec.fromJson(
                  json_['bleuSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        exactMatchSpec:
            json_.containsKey('exactMatchSpec')
                ? GoogleCloudAiplatformV1beta1ExactMatchSpec.fromJson(
                  json_['exactMatchSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pairwiseMetricSpec:
            json_.containsKey('pairwiseMetricSpec')
                ? GoogleCloudAiplatformV1beta1PairwiseMetricSpec.fromJson(
                  json_['pairwiseMetricSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pointwiseMetricSpec:
            json_.containsKey('pointwiseMetricSpec')
                ? GoogleCloudAiplatformV1beta1PointwiseMetricSpec.fromJson(
                  json_['pointwiseMetricSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        rougeSpec:
            json_.containsKey('rougeSpec')
                ? GoogleCloudAiplatformV1beta1RougeSpec.fromJson(
                  json_['rougeSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aggregationMetrics != null) 'aggregationMetrics': aggregationMetrics!,
    if (bleuSpec != null) 'bleuSpec': bleuSpec!,
    if (exactMatchSpec != null) 'exactMatchSpec': exactMatchSpec!,
    if (pairwiseMetricSpec != null) 'pairwiseMetricSpec': pairwiseMetricSpec!,
    if (pointwiseMetricSpec != null)
      'pointwiseMetricSpec': pointwiseMetricSpec!,
    if (rougeSpec != null) 'rougeSpec': rougeSpec!,
  };
}

/// Input for MetricX metric.
class GoogleCloudAiplatformV1beta1MetricxInput {
  /// Metricx instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1MetricxInstance? instance;

  /// Spec for Metricx metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1MetricxSpec? metricSpec;

  GoogleCloudAiplatformV1beta1MetricxInput({this.instance, this.metricSpec});

  GoogleCloudAiplatformV1beta1MetricxInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1MetricxInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1MetricxSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for MetricX instance - The fields used for evaluation are dependent on
/// the MetricX version.
typedef GoogleCloudAiplatformV1beta1MetricxInstance = $Instance03;

/// Spec for MetricX result - calculates the MetricX score for the given
/// instance using the version specified in the spec.
typedef GoogleCloudAiplatformV1beta1MetricxResult = $MetricxResult;

/// Spec for MetricX metric.
typedef GoogleCloudAiplatformV1beta1MetricxSpec = $MetricxSpec;

/// Represents one resource that exists in automl.googleapis.com,
/// datalabeling.googleapis.com or ml.googleapis.com.
class GoogleCloudAiplatformV1beta1MigratableResource {
  /// Represents one Dataset in automl.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1MigratableResourceAutomlDataset? automlDataset;

  /// Represents one Model in automl.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1MigratableResourceAutomlModel? automlModel;

  /// Represents one Dataset in datalabeling.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDataset?
  dataLabelingDataset;

  /// Timestamp when the last migration attempt on this MigratableResource
  /// started.
  ///
  /// Will not be set if there's no migration attempt on this
  /// MigratableResource.
  ///
  /// Output only.
  core.String? lastMigrateTime;

  /// Timestamp when this MigratableResource was last updated.
  ///
  /// Output only.
  core.String? lastUpdateTime;

  /// Represents one Version in ml.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1MigratableResourceMlEngineModelVersion?
  mlEngineModelVersion;

  GoogleCloudAiplatformV1beta1MigratableResource({
    this.automlDataset,
    this.automlModel,
    this.dataLabelingDataset,
    this.lastMigrateTime,
    this.lastUpdateTime,
    this.mlEngineModelVersion,
  });

  GoogleCloudAiplatformV1beta1MigratableResource.fromJson(core.Map json_)
    : this(
        automlDataset:
            json_.containsKey('automlDataset')
                ? GoogleCloudAiplatformV1beta1MigratableResourceAutomlDataset.fromJson(
                  json_['automlDataset'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        automlModel:
            json_.containsKey('automlModel')
                ? GoogleCloudAiplatformV1beta1MigratableResourceAutomlModel.fromJson(
                  json_['automlModel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        dataLabelingDataset:
            json_.containsKey('dataLabelingDataset')
                ? GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDataset.fromJson(
                  json_['dataLabelingDataset']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        lastMigrateTime: json_['lastMigrateTime'] as core.String?,
        lastUpdateTime: json_['lastUpdateTime'] as core.String?,
        mlEngineModelVersion:
            json_.containsKey('mlEngineModelVersion')
                ? GoogleCloudAiplatformV1beta1MigratableResourceMlEngineModelVersion.fromJson(
                  json_['mlEngineModelVersion']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (automlDataset != null) 'automlDataset': automlDataset!,
    if (automlModel != null) 'automlModel': automlModel!,
    if (dataLabelingDataset != null)
      'dataLabelingDataset': dataLabelingDataset!,
    if (lastMigrateTime != null) 'lastMigrateTime': lastMigrateTime!,
    if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!,
    if (mlEngineModelVersion != null)
      'mlEngineModelVersion': mlEngineModelVersion!,
  };
}

/// Represents one Dataset in automl.googleapis.com.
typedef GoogleCloudAiplatformV1beta1MigratableResourceAutomlDataset =
    $MigratableResourceAutomlDataset;

/// Represents one Model in automl.googleapis.com.
typedef GoogleCloudAiplatformV1beta1MigratableResourceAutomlModel =
    $MigratableResourceAutomlModel;

/// Represents one Dataset in datalabeling.googleapis.com.
class GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDataset {
  /// The migratable AnnotatedDataset in datalabeling.googleapis.com belongs to
  /// the data labeling Dataset.
  core.List<
    GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
  >?
  dataLabelingAnnotatedDatasets;

  /// Full resource name of data labeling Dataset.
  ///
  /// Format: `projects/{project}/datasets/{dataset}`.
  core.String? dataset;

  /// The Dataset's display name in datalabeling.googleapis.com.
  core.String? datasetDisplayName;

  GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDataset({
    this.dataLabelingAnnotatedDatasets,
    this.dataset,
    this.datasetDisplayName,
  });

  GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDataset.fromJson(
    core.Map json_,
  ) : this(
        dataLabelingAnnotatedDatasets:
            (json_['dataLabelingAnnotatedDatasets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        dataset: json_['dataset'] as core.String?,
        datasetDisplayName: json_['datasetDisplayName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataLabelingAnnotatedDatasets != null)
      'dataLabelingAnnotatedDatasets': dataLabelingAnnotatedDatasets!,
    if (dataset != null) 'dataset': dataset!,
    if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName!,
  };
}

/// Represents one AnnotatedDataset in datalabeling.googleapis.com.
typedef GoogleCloudAiplatformV1beta1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset =
    $MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset;

/// Represents one model Version in ml.googleapis.com.
typedef GoogleCloudAiplatformV1beta1MigratableResourceMlEngineModelVersion =
    $MigratableResourceMlEngineModelVersion;

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
class GoogleCloudAiplatformV1beta1MigrateResourceRequest {
  /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
  /// Dataset.
  GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlDatasetConfig?
  migrateAutomlDatasetConfig;

  /// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
  GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlModelConfig?
  migrateAutomlModelConfig;

  /// Config for migrating Dataset in datalabeling.googleapis.com to Vertex AI's
  /// Dataset.
  GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfig?
  migrateDataLabelingDatasetConfig;

  /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
  GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateMlEngineModelVersionConfig?
  migrateMlEngineModelVersionConfig;

  GoogleCloudAiplatformV1beta1MigrateResourceRequest({
    this.migrateAutomlDatasetConfig,
    this.migrateAutomlModelConfig,
    this.migrateDataLabelingDatasetConfig,
    this.migrateMlEngineModelVersionConfig,
  });

  GoogleCloudAiplatformV1beta1MigrateResourceRequest.fromJson(core.Map json_)
    : this(
        migrateAutomlDatasetConfig:
            json_.containsKey('migrateAutomlDatasetConfig')
                ? GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlDatasetConfig.fromJson(
                  json_['migrateAutomlDatasetConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        migrateAutomlModelConfig:
            json_.containsKey('migrateAutomlModelConfig')
                ? GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlModelConfig.fromJson(
                  json_['migrateAutomlModelConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        migrateDataLabelingDatasetConfig:
            json_.containsKey('migrateDataLabelingDatasetConfig')
                ? GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfig.fromJson(
                  json_['migrateDataLabelingDatasetConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        migrateMlEngineModelVersionConfig:
            json_.containsKey('migrateMlEngineModelVersionConfig')
                ? GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateMlEngineModelVersionConfig.fromJson(
                  json_['migrateMlEngineModelVersionConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (migrateAutomlDatasetConfig != null)
      'migrateAutomlDatasetConfig': migrateAutomlDatasetConfig!,
    if (migrateAutomlModelConfig != null)
      'migrateAutomlModelConfig': migrateAutomlModelConfig!,
    if (migrateDataLabelingDatasetConfig != null)
      'migrateDataLabelingDatasetConfig': migrateDataLabelingDatasetConfig!,
    if (migrateMlEngineModelVersionConfig != null)
      'migrateMlEngineModelVersionConfig': migrateMlEngineModelVersionConfig!,
  };
}

/// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
/// Dataset.
typedef GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlDatasetConfig =
    $MigrateResourceRequestMigrateAutomlDatasetConfig;

/// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
typedef GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateAutomlModelConfig =
    $MigrateResourceRequestMigrateAutomlModelConfig;

/// Config for migrating Dataset in datalabeling.googleapis.com to Vertex AI's
/// Dataset.
class GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfig {
  /// Full resource name of data labeling Dataset.
  ///
  /// Format: `projects/{project}/datasets/{dataset}`.
  ///
  /// Required.
  core.String? dataset;

  /// Display name of the Dataset in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Optional.
  core.String? datasetDisplayName;

  /// Configs for migrating AnnotatedDataset in datalabeling.googleapis.com to
  /// Vertex AI's SavedQuery.
  ///
  /// The specified AnnotatedDatasets have to belong to the datalabeling
  /// Dataset.
  ///
  /// Optional.
  core.List<
    GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
  >?
  migrateDataLabelingAnnotatedDatasetConfigs;

  GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
    this.migrateDataLabelingAnnotatedDatasetConfigs,
  });

  GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfig.fromJson(
    core.Map json_,
  ) : this(
        dataset: json_['dataset'] as core.String?,
        datasetDisplayName: json_['datasetDisplayName'] as core.String?,
        migrateDataLabelingAnnotatedDatasetConfigs:
            (json_['migrateDataLabelingAnnotatedDatasetConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataset != null) 'dataset': dataset!,
    if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName!,
    if (migrateDataLabelingAnnotatedDatasetConfigs != null)
      'migrateDataLabelingAnnotatedDatasetConfigs':
          migrateDataLabelingAnnotatedDatasetConfigs!,
  };
}

/// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
/// Vertex AI's SavedQuery.
typedef GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig =
    $MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig;

/// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
typedef GoogleCloudAiplatformV1beta1MigrateResourceRequestMigrateMlEngineModelVersionConfig =
    $MigrateResourceRequestMigrateMlEngineModelVersionConfig;

/// Represents token counting info for a single modality.
typedef GoogleCloudAiplatformV1beta1ModalityTokenCount = $ModalityTokenCount;

/// A trained machine learning Model.
class GoogleCloudAiplatformV1beta1Model {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  ///
  /// Not required for AutoML Models.
  ///
  /// Immutable.
  core.String? artifactUri;

  /// User input field to specify the base model source.
  ///
  /// Currently it only supports specifing the Model Garden models and Genie
  /// models.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ModelBaseModelSource? baseModelSource;

  /// The checkpoints of the model.
  ///
  /// Optional. Output only.
  core.List<GoogleCloudAiplatformV1beta1Checkpoint>? checkpoints;

  /// Input only.
  ///
  /// The specification of the container that is to be used when deploying this
  /// Model. The specification is ingested upon ModelService.UploadModel, and
  /// all binaries it contains are copied and stored internally by Vertex AI.
  /// Not required for AutoML Models.
  GoogleCloudAiplatformV1beta1ModelContainerSpec? containerSpec;

  /// Timestamp when this Model was uploaded into Vertex AI.
  ///
  /// Output only.
  core.String? createTime;

  /// The default checkpoint id of a model version.
  core.String? defaultCheckpointId;

  /// The pointers to DeployedModels created from this Model.
  ///
  /// Note that Model could have been deployed to Endpoints in different
  /// Locations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1DeployedModelRef>? deployedModels;

  /// The description of the Model.
  core.String? description;

  /// The display name of the Model.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Model.
  ///
  /// If set, this Model and all sub-resources of this Model will be secured by
  /// this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The default explanation specification for this Model.
  ///
  /// The Model can be used for requesting explanation after being deployed if
  /// it is populated. The Model can be used for batch explanation if it is
  /// populated. All fields of the explanation_spec can be overridden by
  /// explanation_spec of DeployModelRequest.deployed_model, or explanation_spec
  /// of BatchPredictionJob. If the default explanation specification is not set
  /// for this Model, this Model can still be used for requesting explanation by
  /// setting explanation_spec of DeployModelRequest.deployed_model and for
  /// batch explanation by setting explanation_spec of BatchPredictionJob.
  GoogleCloudAiplatformV1beta1ExplanationSpec? explanationSpec;

  /// The labels with user-defined metadata to organize your Models.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// An additional information about the Model; the schema of the metadata can
  /// be found in metadata_schema.
  ///
  /// Unset if the Model does not have any additional information.
  ///
  /// Immutable.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Artifact that was created in MetadataStore when
  /// creating the Model.
  ///
  /// The Artifact resource name pattern is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  ///
  /// Output only.
  core.String? metadataArtifact;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Model, that is specific to it.
  ///
  /// Unset if the Model does not have any additional information. The schema is
  /// defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// additional metadata is needed, this field is set to an empty string. Note:
  /// The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  ///
  /// Immutable.
  core.String? metadataSchemaUri;

  /// Source of a model.
  ///
  /// It can either be automl training pipeline, custom training pipeline,
  /// BigQuery ML, or saved and tuned from Genie or Model Garden.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ModelSourceInfo? modelSourceInfo;

  /// The resource name of the Model.
  core.String? name;

  /// If this Model is a copy of another Model, this contains info about the
  /// original.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ModelOriginalModelInfo? originalModelInfo;

  /// The schemata that describe formats of the Model's predictions and
  /// explanations as given and returned via PredictionService.Predict and
  /// PredictionService.Explain.
  GoogleCloudAiplatformV1beta1PredictSchemata? predictSchemata;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// When this Model is deployed, its prediction resources are described by the
  /// `prediction_resources` field of the Endpoint.deployed_models object.
  ///
  /// Because not all Models support all resource configuration types, the
  /// configuration types this Model supports are listed here. If no
  /// configuration types are listed, the Model cannot be deployed to an
  /// Endpoint and does not support online predictions
  /// (PredictionService.Predict or PredictionService.Explain). Such a Model can
  /// serve predictions by using a BatchPredictionJob, if it has at least one
  /// entry each in supported_input_storage_formats and
  /// supported_output_storage_formats.
  ///
  /// Output only.
  core.List<core.String>? supportedDeploymentResourcesTypes;

  /// The formats in which this Model may be exported.
  ///
  /// If empty, this Model is not available for export.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ModelExportFormat>?
  supportedExportFormats;

  /// The formats this Model supports in BatchPredictionJob.input_config.
  ///
  /// If PredictSchemata.instance_schema_uri exists, the instances should be
  /// given as per that schema. The possible formats are: * `jsonl` The JSON
  /// Lines format, where each instance is a single line. Uses GcsSource. *
  /// `csv` The CSV format, where each instance is a single comma-separated
  /// line. The first line in the file is the header, containing comma-separated
  /// field names. Uses GcsSource. * `tf-record` The TFRecord format, where each
  /// instance is a single record in tfrecord syntax. Uses GcsSource. *
  /// `tf-record-gzip` Similar to `tf-record`, but the file is gzipped. Uses
  /// GcsSource. * `bigquery` Each instance is a single row in BigQuery. Uses
  /// BigQuerySource. * `file-list` Each line of the file is the location of an
  /// instance to process, uses `gcs_source` field of the InputConfig object. If
  /// this Model doesn't support any of these formats it means it cannot be used
  /// with a BatchPredictionJob. However, if it has
  /// supported_deployment_resources_types, it could serve online predictions by
  /// using PredictionService.Predict or PredictionService.Explain.
  ///
  /// Output only.
  core.List<core.String>? supportedInputStorageFormats;

  /// The formats this Model supports in BatchPredictionJob.output_config.
  ///
  /// If both PredictSchemata.instance_schema_uri and
  /// PredictSchemata.prediction_schema_uri exist, the predictions are returned
  /// together with their instances. In other words, the prediction has the
  /// original instance data first, followed by the actual prediction content
  /// (as per the schema). The possible formats are: * `jsonl` The JSON Lines
  /// format, where each prediction is a single line. Uses GcsDestination. *
  /// `csv` The CSV format, where each prediction is a single comma-separated
  /// line. The first line in the file is the header, containing comma-separated
  /// field names. Uses GcsDestination. * `bigquery` Each prediction is a single
  /// row in a BigQuery table, uses BigQueryDestination . If this Model doesn't
  /// support any of these formats it means it cannot be used with a
  /// BatchPredictionJob. However, if it has
  /// supported_deployment_resources_types, it could serve online predictions by
  /// using PredictionService.Predict or PredictionService.Explain.
  ///
  /// Output only.
  core.List<core.String>? supportedOutputStorageFormats;

  /// The resource name of the TrainingPipeline that uploaded this Model, if
  /// any.
  ///
  /// Output only.
  core.String? trainingPipeline;

  /// Timestamp when this Model was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// User provided version aliases so that a model version can be referenced
  /// via alias (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
  /// instead of auto-generated version id (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
  ///
  /// The format is a-z{0,126}\[a-z0-9\] to distinguish from version_id. A
  /// default version alias will be created for the first version of the model,
  /// and there must be exactly one default version alias for a model.
  core.List<core.String>? versionAliases;

  /// Timestamp when this version was created.
  ///
  /// Output only.
  core.String? versionCreateTime;

  /// The description of this version.
  core.String? versionDescription;

  /// The version ID of the model.
  ///
  /// A new version is committed when a new model version is uploaded or trained
  /// under an existing model id. It is an auto-incrementing decimal number in
  /// string representation.
  ///
  /// Output only. Immutable.
  core.String? versionId;

  /// Timestamp when this version was most recently updated.
  ///
  /// Output only.
  core.String? versionUpdateTime;

  GoogleCloudAiplatformV1beta1Model({
    this.artifactUri,
    this.baseModelSource,
    this.checkpoints,
    this.containerSpec,
    this.createTime,
    this.defaultCheckpointId,
    this.deployedModels,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.explanationSpec,
    this.labels,
    this.metadata,
    this.metadataArtifact,
    this.metadataSchemaUri,
    this.modelSourceInfo,
    this.name,
    this.originalModelInfo,
    this.predictSchemata,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.supportedDeploymentResourcesTypes,
    this.supportedExportFormats,
    this.supportedInputStorageFormats,
    this.supportedOutputStorageFormats,
    this.trainingPipeline,
    this.updateTime,
    this.versionAliases,
    this.versionCreateTime,
    this.versionDescription,
    this.versionId,
    this.versionUpdateTime,
  });

  GoogleCloudAiplatformV1beta1Model.fromJson(core.Map json_)
    : this(
        artifactUri: json_['artifactUri'] as core.String?,
        baseModelSource:
            json_.containsKey('baseModelSource')
                ? GoogleCloudAiplatformV1beta1ModelBaseModelSource.fromJson(
                  json_['baseModelSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        checkpoints:
            (json_['checkpoints'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Checkpoint.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        containerSpec:
            json_.containsKey('containerSpec')
                ? GoogleCloudAiplatformV1beta1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        defaultCheckpointId: json_['defaultCheckpointId'] as core.String?,
        deployedModels:
            (json_['deployedModels'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DeployedModelRef.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        explanationSpec:
            json_.containsKey('explanationSpec')
                ? GoogleCloudAiplatformV1beta1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        metadata: json_['metadata'],
        metadataArtifact: json_['metadataArtifact'] as core.String?,
        metadataSchemaUri: json_['metadataSchemaUri'] as core.String?,
        modelSourceInfo:
            json_.containsKey('modelSourceInfo')
                ? GoogleCloudAiplatformV1beta1ModelSourceInfo.fromJson(
                  json_['modelSourceInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        originalModelInfo:
            json_.containsKey('originalModelInfo')
                ? GoogleCloudAiplatformV1beta1ModelOriginalModelInfo.fromJson(
                  json_['originalModelInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        predictSchemata:
            json_.containsKey('predictSchemata')
                ? GoogleCloudAiplatformV1beta1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        supportedDeploymentResourcesTypes:
            (json_['supportedDeploymentResourcesTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        supportedExportFormats:
            (json_['supportedExportFormats'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelExportFormat.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        supportedInputStorageFormats:
            (json_['supportedInputStorageFormats'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        supportedOutputStorageFormats:
            (json_['supportedOutputStorageFormats'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        trainingPipeline: json_['trainingPipeline'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        versionAliases:
            (json_['versionAliases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        versionCreateTime: json_['versionCreateTime'] as core.String?,
        versionDescription: json_['versionDescription'] as core.String?,
        versionId: json_['versionId'] as core.String?,
        versionUpdateTime: json_['versionUpdateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactUri != null) 'artifactUri': artifactUri!,
    if (baseModelSource != null) 'baseModelSource': baseModelSource!,
    if (checkpoints != null) 'checkpoints': checkpoints!,
    if (containerSpec != null) 'containerSpec': containerSpec!,
    if (createTime != null) 'createTime': createTime!,
    if (defaultCheckpointId != null)
      'defaultCheckpointId': defaultCheckpointId!,
    if (deployedModels != null) 'deployedModels': deployedModels!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (explanationSpec != null) 'explanationSpec': explanationSpec!,
    if (labels != null) 'labels': labels!,
    if (metadata != null) 'metadata': metadata!,
    if (metadataArtifact != null) 'metadataArtifact': metadataArtifact!,
    if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
    if (modelSourceInfo != null) 'modelSourceInfo': modelSourceInfo!,
    if (name != null) 'name': name!,
    if (originalModelInfo != null) 'originalModelInfo': originalModelInfo!,
    if (predictSchemata != null) 'predictSchemata': predictSchemata!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (supportedDeploymentResourcesTypes != null)
      'supportedDeploymentResourcesTypes': supportedDeploymentResourcesTypes!,
    if (supportedExportFormats != null)
      'supportedExportFormats': supportedExportFormats!,
    if (supportedInputStorageFormats != null)
      'supportedInputStorageFormats': supportedInputStorageFormats!,
    if (supportedOutputStorageFormats != null)
      'supportedOutputStorageFormats': supportedOutputStorageFormats!,
    if (trainingPipeline != null) 'trainingPipeline': trainingPipeline!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (versionAliases != null) 'versionAliases': versionAliases!,
    if (versionCreateTime != null) 'versionCreateTime': versionCreateTime!,
    if (versionDescription != null) 'versionDescription': versionDescription!,
    if (versionId != null) 'versionId': versionId!,
    if (versionUpdateTime != null) 'versionUpdateTime': versionUpdateTime!,
  };
}

/// User input field to specify the base model source.
///
/// Currently it only supports specifing the Model Garden models and Genie
/// models.
class GoogleCloudAiplatformV1beta1ModelBaseModelSource {
  /// Information about the base model of Genie models.
  GoogleCloudAiplatformV1beta1GenieSource? genieSource;

  /// Source information of Model Garden models.
  GoogleCloudAiplatformV1beta1ModelGardenSource? modelGardenSource;

  GoogleCloudAiplatformV1beta1ModelBaseModelSource({
    this.genieSource,
    this.modelGardenSource,
  });

  GoogleCloudAiplatformV1beta1ModelBaseModelSource.fromJson(core.Map json_)
    : this(
        genieSource:
            json_.containsKey('genieSource')
                ? GoogleCloudAiplatformV1beta1GenieSource.fromJson(
                  json_['genieSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelGardenSource:
            json_.containsKey('modelGardenSource')
                ? GoogleCloudAiplatformV1beta1ModelGardenSource.fromJson(
                  json_['modelGardenSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (genieSource != null) 'genieSource': genieSource!,
    if (modelGardenSource != null) 'modelGardenSource': modelGardenSource!,
  };
}

/// Specification of a container for serving predictions.
///
/// Some fields in this message correspond to fields in the
/// [Kubernetes Container v1 core specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
class GoogleCloudAiplatformV1beta1ModelContainerSpec {
  /// Specifies arguments for the command that runs when the container starts.
  ///
  /// This overrides the container's
  /// \[`CMD`\](https://docs.docker.com/engine/reference/builder/#cmd). Specify
  /// this field as an array of executable and arguments, similar to a Docker
  /// `CMD`'s "default parameters" form. If you don't specify this field but do
  /// specify the command field, then the command from the `command` field runs
  /// without any additional arguments. See the \[Kubernetes documentation about
  /// how the `command` and `args` fields interact with a container's
  /// `ENTRYPOINT` and
  /// `CMD`\](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  /// If you don't specify this field and don't specify the `command` field,
  /// then the container's
  /// \[`ENTRYPOINT`\](https://docs.docker.com/engine/reference/builder/#cmd)
  /// and `CMD` determine what runs based on their default behavior. See the
  /// Docker documentation about \[how `CMD` and `ENTRYPOINT`
  /// interact\](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  /// In this field, you can reference
  /// [environment variables set by Vertex AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the env field. You cannot reference
  /// environment variables set in the Docker image. In order for environment
  /// variables to be expanded, reference them by using the following syntax: $(
  /// VARIABLE_NAME) Note that this differs from Bash variable expansion, which
  /// does not use parentheses. If a variable cannot be resolved, the reference
  /// in the input string is used unchanged. To avoid variable expansion, you
  /// can escape this syntax with `$$`; for example: $$(VARIABLE_NAME) This
  /// field corresponds to the `args` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<core.String>? args;

  /// Specifies the command that runs when the container starts.
  ///
  /// This overrides the container's
  /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
  /// Specify this field as an array of executable and arguments, similar to a
  /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form. If you do not
  /// specify this field, then the container's `ENTRYPOINT` runs, in conjunction
  /// with the args field or the container's
  /// \[`CMD`\](https://docs.docker.com/engine/reference/builder/#cmd), if
  /// either exists. If this field is not specified and the container does not
  /// have an `ENTRYPOINT`, then refer to the Docker documentation about \[how
  /// `CMD` and `ENTRYPOINT`
  /// interact\](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  /// If you specify this field, then you can also specify the `args` field to
  /// provide additional arguments for this command. However, if you specify
  /// this field, then the container's `CMD` is ignored. See the \[Kubernetes
  /// documentation about how the `command` and `args` fields interact with a
  /// container's `ENTRYPOINT` and
  /// `CMD`\](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  /// In this field, you can reference
  /// [environment variables set by Vertex AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the env field. You cannot reference
  /// environment variables set in the Docker image. In order for environment
  /// variables to be expanded, reference them by using the following syntax: $(
  /// VARIABLE_NAME) Note that this differs from Bash variable expansion, which
  /// does not use parentheses. If a variable cannot be resolved, the reference
  /// in the input string is used unchanged. To avoid variable expansion, you
  /// can escape this syntax with `$$`; for example: $$(VARIABLE_NAME) This
  /// field corresponds to the `command` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<core.String>? command;

  /// Deployment timeout.
  ///
  /// Limit for deployment timeout is 2 hours.
  ///
  /// Immutable.
  core.String? deploymentTimeout;

  /// List of environment variables to set in the container.
  ///
  /// After the container starts running, code running in the container can read
  /// these environment variables. Additionally, the command and args fields can
  /// reference these variables. Later entries in this list can also reference
  /// earlier entries. For example, the following example sets the variable
  /// `VAR_2` to have the value `foo bar`: ```json [ { "name": "VAR_1", "value":
  /// "foo" }, { "name": "VAR_2", "value": "$(VAR_1) bar" } ] ``` If you switch
  /// the order of the variables in the example, then the expansion does not
  /// occur. This field corresponds to the `env` field of the Kubernetes
  /// Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1beta1EnvVar>? env;

  /// List of ports to expose from the container.
  ///
  /// Vertex AI sends gRPC prediction requests that it receives to the first
  /// port on this list. Vertex AI also sends liveness and health checks to this
  /// port. If you do not specify this field, gRPC requests to the container
  /// will be disabled. Vertex AI does not use ports other than the first one
  /// listed. This field corresponds to the `ports` field of the Kubernetes
  /// Containers v1 core API.
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1beta1Port>? grpcPorts;

  /// Specification for Kubernetes readiness probe.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1beta1Probe? healthProbe;

  /// HTTP path on the container to send health checks to.
  ///
  /// Vertex AI intermittently sends GET requests to this path on the
  /// container's IP address and port to check that the container is healthy.
  /// Read more about
  /// [health checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
  /// For example, if you set this field to `/bar`, then Vertex AI
  /// intermittently sends a GET request to the `/bar` path on the port of your
  /// container specified by the first value of this `ModelContainerSpec`'s
  /// ports field. If you don't specify this field, it defaults to the following
  /// value when you deploy this Model to an Endpoint:
  /// /v1/endpoints/ENDPOINT/deployedModels/ DEPLOYED_MODEL:predict The
  /// placeholders in this value are replaced as follows: * ENDPOINT: The last
  /// segment (following `endpoints/`)of the Endpoint.name\]\[\] field of the
  /// Endpoint where this Model has been deployed. (Vertex AI makes this value
  /// available to your container code as the \[`AIP_ENDPOINT_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  /// * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`. (Vertex AI
  /// makes this value available to your container code as the
  /// \[`AIP_DEPLOYED_MODEL_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// Immutable.
  core.String? healthRoute;

  /// URI of the Docker image to be used as the custom container for serving
  /// predictions.
  ///
  /// This URI must identify an image in Artifact Registry or Container
  /// Registry. Learn more about the
  /// [container publishing requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
  /// including permissions requirements for the Vertex AI Service Agent. The
  /// container image is ingested upon ModelService.UploadModel, stored
  /// internally, and this original path is afterwards not used. To learn about
  /// the requirements for the Docker image itself, see
  /// [Custom container requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
  /// You can use the URI to one of Vertex AI's \[pre-built container images for
  /// prediction\](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
  /// in this field.
  ///
  /// Required. Immutable.
  core.String? imageUri;

  /// Invoke route prefix for the custom container.
  ///
  /// " / * " is the only supported value right now. By setting this field, any
  /// non-root route on this model will be accessible with invoke http call eg:
  /// "/invoke/foo/bar", however the \[PredictionService.Invoke\] RPC is not
  /// supported yet. Only one of `predict_route` or `invoke_route_prefix` can be
  /// set, and we default to using `predict_route` if this field is not set. If
  /// this field is set, the Model can only be deployed to dedicated endpoint.
  ///
  /// Immutable.
  core.String? invokeRoutePrefix;

  /// Specification for Kubernetes liveness probe.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1beta1Probe? livenessProbe;

  /// List of ports to expose from the container.
  ///
  /// Vertex AI sends any prediction requests that it receives to the first port
  /// on this list. Vertex AI also sends
  /// [liveness and health checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
  /// to this port. If you do not specify this field, it defaults to following
  /// value: ```json [ { "containerPort": 8080 } ] ``` Vertex AI does not use
  /// ports other than the first one listed. This field corresponds to the
  /// `ports` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1beta1Port>? ports;

  /// HTTP path on the container to send prediction requests to.
  ///
  /// Vertex AI forwards requests sent using
  /// projects.locations.endpoints.predict to this path on the container's IP
  /// address and port. Vertex AI then returns the container's response in the
  /// API response. For example, if you set this field to `/foo`, then when
  /// Vertex AI receives a prediction request, it forwards the request body in a
  /// POST request to the `/foo` path on the port of your container specified by
  /// the first value of this `ModelContainerSpec`'s ports field. If you don't
  /// specify this field, it defaults to the following value when you deploy
  /// this Model to an Endpoint:
  /// /v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict The
  /// placeholders in this value are replaced as follows: * ENDPOINT: The last
  /// segment (following `endpoints/`)of the Endpoint.name\]\[\] field of the
  /// Endpoint where this Model has been deployed. (Vertex AI makes this value
  /// available to your container code as the \[`AIP_ENDPOINT_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  /// * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`. (Vertex AI
  /// makes this value available to your container code as the
  /// \[`AIP_DEPLOYED_MODEL_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// Immutable.
  core.String? predictRoute;

  /// The amount of the VM memory to reserve as the shared memory for the model
  /// in megabytes.
  ///
  /// Immutable.
  core.String? sharedMemorySizeMb;

  /// Specification for Kubernetes startup probe.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1beta1Probe? startupProbe;

  GoogleCloudAiplatformV1beta1ModelContainerSpec({
    this.args,
    this.command,
    this.deploymentTimeout,
    this.env,
    this.grpcPorts,
    this.healthProbe,
    this.healthRoute,
    this.imageUri,
    this.invokeRoutePrefix,
    this.livenessProbe,
    this.ports,
    this.predictRoute,
    this.sharedMemorySizeMb,
    this.startupProbe,
  });

  GoogleCloudAiplatformV1beta1ModelContainerSpec.fromJson(core.Map json_)
    : this(
        args:
            (json_['args'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        command:
            (json_['command'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        deploymentTimeout: json_['deploymentTimeout'] as core.String?,
        env:
            (json_['env'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1EnvVar.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        grpcPorts:
            (json_['grpcPorts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Port.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        healthProbe:
            json_.containsKey('healthProbe')
                ? GoogleCloudAiplatformV1beta1Probe.fromJson(
                  json_['healthProbe'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        healthRoute: json_['healthRoute'] as core.String?,
        imageUri: json_['imageUri'] as core.String?,
        invokeRoutePrefix: json_['invokeRoutePrefix'] as core.String?,
        livenessProbe:
            json_.containsKey('livenessProbe')
                ? GoogleCloudAiplatformV1beta1Probe.fromJson(
                  json_['livenessProbe'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        ports:
            (json_['ports'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Port.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        predictRoute: json_['predictRoute'] as core.String?,
        sharedMemorySizeMb: json_['sharedMemorySizeMb'] as core.String?,
        startupProbe:
            json_.containsKey('startupProbe')
                ? GoogleCloudAiplatformV1beta1Probe.fromJson(
                  json_['startupProbe'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (args != null) 'args': args!,
    if (command != null) 'command': command!,
    if (deploymentTimeout != null) 'deploymentTimeout': deploymentTimeout!,
    if (env != null) 'env': env!,
    if (grpcPorts != null) 'grpcPorts': grpcPorts!,
    if (healthProbe != null) 'healthProbe': healthProbe!,
    if (healthRoute != null) 'healthRoute': healthRoute!,
    if (imageUri != null) 'imageUri': imageUri!,
    if (invokeRoutePrefix != null) 'invokeRoutePrefix': invokeRoutePrefix!,
    if (livenessProbe != null) 'livenessProbe': livenessProbe!,
    if (ports != null) 'ports': ports!,
    if (predictRoute != null) 'predictRoute': predictRoute!,
    if (sharedMemorySizeMb != null) 'sharedMemorySizeMb': sharedMemorySizeMb!,
    if (startupProbe != null) 'startupProbe': startupProbe!,
  };
}

/// ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as
/// well as some information of the logs stored in this table.
typedef GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringBigQueryTable =
    $ModelDeploymentMonitoringBigQueryTable;

/// Represents a job that runs periodically to monitor the deployed models in an
/// endpoint.
///
/// It will analyze the logged training & prediction data to detect any abnormal
/// behaviors.
class GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob {
  /// YAML schema file uri describing the format of a single instance that you
  /// want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If this field is empty, all the feature data types are inferred from
  /// predict_instance_schema_uri, meaning that TFDV will use the data in the
  /// exact format(data type) as prediction request/response. If there are any
  /// data type differences between predict instance and TFDV instance, this
  /// field can be used to override the schema. For models trained with Vertex
  /// AI, this field must be set as all the fields in predict instance formatted
  /// as string.
  core.String? analysisInstanceSchemaUri;

  /// The created bigquery tables for the job under customer project.
  ///
  /// Customer could do their own query & analysis. There could be 4 log tables
  /// in maximum: 1. Training data logging predict request/response 2. Serving
  /// data logging predict request/response
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringBigQueryTable>?
  bigqueryTables;

  /// Timestamp when this ModelDeploymentMonitoringJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the ModelDeploymentMonitoringJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. Display name of a ModelDeploymentMonitoringJob.
  ///
  /// Required.
  core.String? displayName;

  /// If true, the scheduled monitoring pipeline logs are sent to Google Cloud
  /// Logging, including pipeline status and anomalies detected.
  ///
  /// Please note the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
  core.bool? enableMonitoringPipelineLogs;

  /// Customer-managed encryption key spec for a ModelDeploymentMonitoringJob.
  ///
  /// If set, this ModelDeploymentMonitoringJob and all sub-resources of this
  /// ModelDeploymentMonitoringJob will be secured by this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Endpoint resource name.
  ///
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Required.
  core.String? endpoint;

  /// Only populated when the job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize your
  /// ModelDeploymentMonitoringJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Latest triggered monitoring pipeline metadata.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata?
  latestMonitoringPipelineMetadata;

  /// The TTL of BigQuery tables in user projects which stores logs.
  ///
  /// A day is the basic unit of the TTL and we take the ceil of TTL/86400(a
  /// day). e.g. { second: 3600} indicates ttl = 1 day.
  core.String? logTtl;

  /// Sample Strategy for logging.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SamplingStrategy? loggingSamplingStrategy;

  /// The config for monitoring objectives.
  ///
  /// This is a per DeployedModel config. Each DeployedModel needs to be
  /// configured separately.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringObjectiveConfig
  >?
  modelDeploymentMonitoringObjectiveConfigs;

  /// Schedule config for running the monitoring job.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringScheduleConfig?
  modelDeploymentMonitoringScheduleConfig;

  /// Alert config for model monitoring.
  GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfig?
  modelMonitoringAlertConfig;

  /// Resource name of a ModelDeploymentMonitoringJob.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this monitoring pipeline will be scheduled to run for the
  /// next round.
  ///
  /// Output only.
  core.String? nextScheduleTime;

  /// YAML schema file uri describing the format of a single instance, which are
  /// given to format this Endpoint's prediction (and explanation).
  ///
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  core.String? predictInstanceSchemaUri;

  /// Sample Predict instance, same format as PredictRequest.instances, this can
  /// be set as a replacement of
  /// ModelDeploymentMonitoringJob.predict_instance_schema_uri.
  ///
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? samplePredictInstance;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Schedule state when the monitoring job is in Running state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MONITORING_SCHEDULE_STATE_UNSPECIFIED" : Unspecified state.
  /// - "PENDING" : The pipeline is picked up and wait to run.
  /// - "OFFLINE" : The pipeline is offline and will be scheduled for next run.
  /// - "RUNNING" : The pipeline is running.
  core.String? scheduleState;

  /// The detailed state of the monitoring job.
  ///
  /// When the job is still creating, the state will be 'PENDING'. Once the job
  /// is successfully created, the state will be 'RUNNING'. Pause the job, the
  /// state will be 'PAUSED'. Resume the job, the state will return to
  /// 'RUNNING'.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Stats anomalies base folder path.
  GoogleCloudAiplatformV1beta1GcsDestination? statsAnomaliesBaseDirectory;

  /// Timestamp when this ModelDeploymentMonitoringJob was updated most
  /// recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob({
    this.analysisInstanceSchemaUri,
    this.bigqueryTables,
    this.createTime,
    this.displayName,
    this.enableMonitoringPipelineLogs,
    this.encryptionSpec,
    this.endpoint,
    this.error,
    this.labels,
    this.latestMonitoringPipelineMetadata,
    this.logTtl,
    this.loggingSamplingStrategy,
    this.modelDeploymentMonitoringObjectiveConfigs,
    this.modelDeploymentMonitoringScheduleConfig,
    this.modelMonitoringAlertConfig,
    this.name,
    this.nextScheduleTime,
    this.predictInstanceSchemaUri,
    this.samplePredictInstance,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.scheduleState,
    this.state,
    this.statsAnomaliesBaseDirectory,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJob.fromJson(
    core.Map json_,
  ) : this(
        analysisInstanceSchemaUri:
            json_['analysisInstanceSchemaUri'] as core.String?,
        bigqueryTables:
            (json_['bigqueryTables'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringBigQueryTable.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        enableMonitoringPipelineLogs:
            json_['enableMonitoringPipelineLogs'] as core.bool?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endpoint: json_['endpoint'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        latestMonitoringPipelineMetadata:
            json_.containsKey('latestMonitoringPipelineMetadata')
                ? GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata.fromJson(
                  json_['latestMonitoringPipelineMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        logTtl: json_['logTtl'] as core.String?,
        loggingSamplingStrategy:
            json_.containsKey('loggingSamplingStrategy')
                ? GoogleCloudAiplatformV1beta1SamplingStrategy.fromJson(
                  json_['loggingSamplingStrategy']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelDeploymentMonitoringObjectiveConfigs:
            (json_['modelDeploymentMonitoringObjectiveConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringObjectiveConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        modelDeploymentMonitoringScheduleConfig:
            json_.containsKey('modelDeploymentMonitoringScheduleConfig')
                ? GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringScheduleConfig.fromJson(
                  json_['modelDeploymentMonitoringScheduleConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelMonitoringAlertConfig:
            json_.containsKey('modelMonitoringAlertConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfig.fromJson(
                  json_['modelMonitoringAlertConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        nextScheduleTime: json_['nextScheduleTime'] as core.String?,
        predictInstanceSchemaUri:
            json_['predictInstanceSchemaUri'] as core.String?,
        samplePredictInstance: json_['samplePredictInstance'],
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        scheduleState: json_['scheduleState'] as core.String?,
        state: json_['state'] as core.String?,
        statsAnomaliesBaseDirectory:
            json_.containsKey('statsAnomaliesBaseDirectory')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['statsAnomaliesBaseDirectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (analysisInstanceSchemaUri != null)
      'analysisInstanceSchemaUri': analysisInstanceSchemaUri!,
    if (bigqueryTables != null) 'bigqueryTables': bigqueryTables!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (enableMonitoringPipelineLogs != null)
      'enableMonitoringPipelineLogs': enableMonitoringPipelineLogs!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endpoint != null) 'endpoint': endpoint!,
    if (error != null) 'error': error!,
    if (labels != null) 'labels': labels!,
    if (latestMonitoringPipelineMetadata != null)
      'latestMonitoringPipelineMetadata': latestMonitoringPipelineMetadata!,
    if (logTtl != null) 'logTtl': logTtl!,
    if (loggingSamplingStrategy != null)
      'loggingSamplingStrategy': loggingSamplingStrategy!,
    if (modelDeploymentMonitoringObjectiveConfigs != null)
      'modelDeploymentMonitoringObjectiveConfigs':
          modelDeploymentMonitoringObjectiveConfigs!,
    if (modelDeploymentMonitoringScheduleConfig != null)
      'modelDeploymentMonitoringScheduleConfig':
          modelDeploymentMonitoringScheduleConfig!,
    if (modelMonitoringAlertConfig != null)
      'modelMonitoringAlertConfig': modelMonitoringAlertConfig!,
    if (name != null) 'name': name!,
    if (nextScheduleTime != null) 'nextScheduleTime': nextScheduleTime!,
    if (predictInstanceSchemaUri != null)
      'predictInstanceSchemaUri': predictInstanceSchemaUri!,
    if (samplePredictInstance != null)
      'samplePredictInstance': samplePredictInstance!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (scheduleState != null) 'scheduleState': scheduleState!,
    if (state != null) 'state': state!,
    if (statsAnomaliesBaseDirectory != null)
      'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// All metadata of most recent monitoring pipelines.
class GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata {
  /// The time that most recent monitoring pipelines that is related to this
  /// run.
  core.String? runTime;

  /// The status of the most recent monitoring pipeline.
  GoogleRpcStatus? status;

  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata({
    this.runTime,
    this.status,
  });

  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata.fromJson(
    core.Map json_,
  ) : this(
        runTime: json_['runTime'] as core.String?,
        status:
            json_.containsKey('status')
                ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (runTime != null) 'runTime': runTime!,
    if (status != null) 'status': status!,
  };
}

/// ModelDeploymentMonitoringObjectiveConfig contains the pair of
/// deployed_model_id to ModelMonitoringObjectiveConfig.
class GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringObjectiveConfig {
  /// The DeployedModel ID of the objective config.
  core.String? deployedModelId;

  /// The objective config of for the modelmonitoring job of this deployed
  /// model.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfig? objectiveConfig;

  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringObjectiveConfig({
    this.deployedModelId,
    this.objectiveConfig,
  });

  GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringObjectiveConfig.fromJson(
    core.Map json_,
  ) : this(
        deployedModelId: json_['deployedModelId'] as core.String?,
        objectiveConfig:
            json_.containsKey('objectiveConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfig.fromJson(
                  json_['objectiveConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (objectiveConfig != null) 'objectiveConfig': objectiveConfig!,
  };
}

/// The config for scheduling monitoring job.
typedef GoogleCloudAiplatformV1beta1ModelDeploymentMonitoringScheduleConfig =
    $ModelDeploymentMonitoringScheduleConfig;

/// A collection of metrics calculated by comparing Model's predictions on all
/// of the test data against annotations from the test data.
class GoogleCloudAiplatformV1beta1ModelEvaluation {
  /// Specify the configuration for bias detection.
  GoogleCloudAiplatformV1beta1ModelEvaluationBiasConfig? biasConfigs;

  /// Timestamp when this ModelEvaluation was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the ModelEvaluation.
  core.String? displayName;

  /// Describes the values of ExplanationSpec that are used for explaining the
  /// predicted values on the evaluated data.
  core.List<
    GoogleCloudAiplatformV1beta1ModelEvaluationModelEvaluationExplanationSpec
  >?
  explanationSpecs;

  /// The metadata of the ModelEvaluation.
  ///
  /// For the ModelEvaluation uploaded from Managed Pipeline, metadata contains
  /// a structured value with keys of "pipeline_job_id",
  /// "evaluation_dataset_type", "evaluation_dataset_path",
  /// "row_based_metrics_path".
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Evaluation metrics of the Model.
  ///
  /// The schema of the metrics is stored in metrics_schema_uri
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metrics;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// metrics of this ModelEvaluation.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  core.String? metricsSchemaUri;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses.
  ///
  /// This field is populated only if the Model is evaluated with explanations,
  /// and only for AutoML tabular Models.
  GoogleCloudAiplatformV1beta1ModelExplanation? modelExplanation;

  /// The resource name of the ModelEvaluation.
  ///
  /// Output only.
  core.String? name;

  /// All possible dimensions of ModelEvaluationSlices.
  ///
  /// The dimensions can be used as the filter of the
  /// ModelService.ListModelEvaluationSlices request, in the form of
  /// `slice.dimension = `.
  core.List<core.String>? sliceDimensions;

  GoogleCloudAiplatformV1beta1ModelEvaluation({
    this.biasConfigs,
    this.createTime,
    this.displayName,
    this.explanationSpecs,
    this.metadata,
    this.metrics,
    this.metricsSchemaUri,
    this.modelExplanation,
    this.name,
    this.sliceDimensions,
  });

  GoogleCloudAiplatformV1beta1ModelEvaluation.fromJson(core.Map json_)
    : this(
        biasConfigs:
            json_.containsKey('biasConfigs')
                ? GoogleCloudAiplatformV1beta1ModelEvaluationBiasConfig.fromJson(
                  json_['biasConfigs'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        explanationSpecs:
            (json_['explanationSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelEvaluationModelEvaluationExplanationSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metadata: json_['metadata'],
        metrics: json_['metrics'],
        metricsSchemaUri: json_['metricsSchemaUri'] as core.String?,
        modelExplanation:
            json_.containsKey('modelExplanation')
                ? GoogleCloudAiplatformV1beta1ModelExplanation.fromJson(
                  json_['modelExplanation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        sliceDimensions:
            (json_['sliceDimensions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (biasConfigs != null) 'biasConfigs': biasConfigs!,
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (explanationSpecs != null) 'explanationSpecs': explanationSpecs!,
    if (metadata != null) 'metadata': metadata!,
    if (metrics != null) 'metrics': metrics!,
    if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri!,
    if (modelExplanation != null) 'modelExplanation': modelExplanation!,
    if (name != null) 'name': name!,
    if (sliceDimensions != null) 'sliceDimensions': sliceDimensions!,
  };
}

/// Configuration for bias detection.
class GoogleCloudAiplatformV1beta1ModelEvaluationBiasConfig {
  /// Specification for how the data should be sliced for bias.
  ///
  /// It contains a list of slices, with limitation of two slices. The first
  /// slice of data will be the slice_a. The second slice in the list (slice_b)
  /// will be compared against the first slice. If only a single slice is
  /// provided, then slice_a will be compared against "not slice_a". Below are
  /// examples with feature "education" with value "low", "medium", "high" in
  /// the dataset: Example 1: bias_slices = \[{'education': 'low'}\] A single
  /// slice provided. In this case, slice_a is the collection of data with
  /// 'education' equals 'low', and slice_b is the collection of data with
  /// 'education' equals 'medium' or 'high'. Example 2: bias_slices =
  /// \[{'education': 'low'}, {'education': 'high'}\] Two slices provided. In
  /// this case, slice_a is the collection of data with 'education' equals
  /// 'low', and slice_b is the collection of data with 'education' equals
  /// 'high'.
  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpec? biasSlices;

  /// Positive labels selection on the target field.
  core.List<core.String>? labels;

  GoogleCloudAiplatformV1beta1ModelEvaluationBiasConfig({
    this.biasSlices,
    this.labels,
  });

  GoogleCloudAiplatformV1beta1ModelEvaluationBiasConfig.fromJson(core.Map json_)
    : this(
        biasSlices:
            json_.containsKey('biasSlices')
                ? GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpec.fromJson(
                  json_['biasSlices'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels:
            (json_['labels'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (biasSlices != null) 'biasSlices': biasSlices!,
    if (labels != null) 'labels': labels!,
  };
}

class GoogleCloudAiplatformV1beta1ModelEvaluationModelEvaluationExplanationSpec {
  /// Explanation spec details.
  GoogleCloudAiplatformV1beta1ExplanationSpec? explanationSpec;

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are: *
  /// `image-integrated-gradients` * `image-xrai`
  core.String? explanationType;

  GoogleCloudAiplatformV1beta1ModelEvaluationModelEvaluationExplanationSpec({
    this.explanationSpec,
    this.explanationType,
  });

  GoogleCloudAiplatformV1beta1ModelEvaluationModelEvaluationExplanationSpec.fromJson(
    core.Map json_,
  ) : this(
        explanationSpec:
            json_.containsKey('explanationSpec')
                ? GoogleCloudAiplatformV1beta1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        explanationType: json_['explanationType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (explanationSpec != null) 'explanationSpec': explanationSpec!,
    if (explanationType != null) 'explanationType': explanationType!,
  };
}

/// A collection of metrics calculated by comparing Model's predictions on a
/// slice of the test data against ground truth annotations.
class GoogleCloudAiplatformV1beta1ModelEvaluationSlice {
  /// Timestamp when this ModelEvaluationSlice was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Sliced evaluation metrics of the Model.
  ///
  /// The schema of the metrics is stored in metrics_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metrics;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// metrics of this ModelEvaluationSlice.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  ///
  /// Output only.
  core.String? metricsSchemaUri;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses.
  ///
  /// This field is populated only if the Model is evaluated with explanations,
  /// and only for tabular Models.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ModelExplanation? modelExplanation;

  /// The resource name of the ModelEvaluationSlice.
  ///
  /// Output only.
  core.String? name;

  /// The slice of the test data that is used to evaluate the Model.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSlice? slice;

  GoogleCloudAiplatformV1beta1ModelEvaluationSlice({
    this.createTime,
    this.metrics,
    this.metricsSchemaUri,
    this.modelExplanation,
    this.name,
    this.slice,
  });

  GoogleCloudAiplatformV1beta1ModelEvaluationSlice.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        metrics: json_['metrics'],
        metricsSchemaUri: json_['metricsSchemaUri'] as core.String?,
        modelExplanation:
            json_.containsKey('modelExplanation')
                ? GoogleCloudAiplatformV1beta1ModelExplanation.fromJson(
                  json_['modelExplanation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        slice:
            json_.containsKey('slice')
                ? GoogleCloudAiplatformV1beta1ModelEvaluationSliceSlice.fromJson(
                  json_['slice'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (metrics != null) 'metrics': metrics!,
    if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri!,
    if (modelExplanation != null) 'modelExplanation': modelExplanation!,
    if (name != null) 'name': name!,
    if (slice != null) 'slice': slice!,
  };
}

/// Definition of a slice.
class GoogleCloudAiplatformV1beta1ModelEvaluationSliceSlice {
  /// The dimension of the slice.
  ///
  /// Well-known dimensions are: * `annotationSpec`: This slice is on the test
  /// data that has either ground truth or prediction with
  /// AnnotationSpec.display_name equals to value. * `slice`: This slice is a
  /// user customized slice defined by its SliceSpec.
  ///
  /// Output only.
  core.String? dimension;

  /// Specification for how the data was sliced.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpec? sliceSpec;

  /// The value of the dimension in this slice.
  ///
  /// Output only.
  core.String? value;

  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSlice({
    this.dimension,
    this.sliceSpec,
    this.value,
  });

  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSlice.fromJson(core.Map json_)
    : this(
        dimension: json_['dimension'] as core.String?,
        sliceSpec:
            json_.containsKey('sliceSpec')
                ? GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpec.fromJson(
                  json_['sliceSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dimension != null) 'dimension': dimension!,
    if (sliceSpec != null) 'sliceSpec': sliceSpec!,
    if (value != null) 'value': value!,
  };
}

/// Specification for how the data should be sliced.
class GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpec {
  /// Mapping configuration for this SliceSpec.
  ///
  /// The key is the name of the feature. By default, the key will be prefixed
  /// by "instance" as a dictionary prefix for Vertex Batch Predictions output
  /// format.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecSliceConfig
  >?
  configs;

  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpec({
    this.configs,
  });

  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpec.fromJson(
    core.Map json_,
  ) : this(
        configs: (json_['configs'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecSliceConfig.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (configs != null) 'configs': configs!,
  };
}

/// A range of values for slice(s).
///
/// `low` is inclusive, `high` is exclusive.
typedef GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecRange =
    $ModelEvaluationSliceSliceSliceSpecRange;

/// Specification message containing the config for this SliceSpec.
///
/// When `kind` is selected as `value` and/or `range`, only a single slice will
/// be computed. When `all_values` is present, a separate slice will be computed
/// for each possible label/value for the corresponding key in `config`.
/// Examples, with feature zip_code with values 12345, 23334, 88888 and feature
/// country with values "US", "Canada", "Mexico" in the dataset: Example 1: {
/// "zip_code": { "value": { "float_value": 12345.0 } } } A single slice for any
/// data with zip_code 12345 in the dataset. Example 2: { "zip_code": { "range":
/// { "low": 12345, "high": 20000 } } } A single slice containing data where the
/// zip_codes between 12345 and 20000 For this example, data with the zip_code
/// of 12345 will be in this slice. Example 3: { "zip_code": { "range": { "low":
/// 10000, "high": 20000 } }, "country": { "value": { "string_value": "US" } } }
/// A single slice containing data where the zip_codes between 10000 and 20000
/// has the country "US". For this example, data with the zip_code of 12345 and
/// country "US" will be in this slice. Example 4: { "country": {"all_values": {
/// "value": true } } } Three slices are computed, one for each unique country
/// in the dataset. Example 5: { "country": { "all_values": { "value": true } },
/// "zip_code": { "value": { "float_value": 12345.0 } } } Three slices are
/// computed, one for each unique country in the dataset where the zip_code is
/// also 12345. For this example, data with zip_code 12345 and country "US" will
/// be in one slice, zip_code 12345 and country "Canada" in another slice, and
/// zip_code 12345 and country "Mexico" in another slice, totaling 3 slices.
class GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecSliceConfig {
  /// If all_values is set to true, then all possible labels of the keyed
  /// feature will have another slice computed.
  ///
  /// Example: `{"all_values":{"value":true}}`
  core.bool? allValues;

  /// A range of values for a numerical feature.
  ///
  /// Example: `{"range":{"low":10000.0,"high":50000.0}}` will capture 12345 and
  /// 23334 in the slice.
  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecRange? range;

  /// A unique specific value for a given feature.
  ///
  /// Example: `{ "value": { "string_value": "12345" } }`
  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecValue? value;

  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecSliceConfig({
    this.allValues,
    this.range,
    this.value,
  });

  GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecSliceConfig.fromJson(
    core.Map json_,
  ) : this(
        allValues: json_['allValues'] as core.bool?,
        range:
            json_.containsKey('range')
                ? GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecRange.fromJson(
                  json_['range'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        value:
            json_.containsKey('value')
                ? GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allValues != null) 'allValues': allValues!,
    if (range != null) 'range': range!,
    if (value != null) 'value': value!,
  };
}

/// Single value that supports strings and floats.
typedef GoogleCloudAiplatformV1beta1ModelEvaluationSliceSliceSliceSpecValue =
    $ModelEvaluationSliceSliceSliceSpecValue;

/// Aggregated explanation metrics for a Model over a set of instances.
class GoogleCloudAiplatformV1beta1ModelExplanation {
  /// Aggregated attributions explaining the Model's prediction outputs over the
  /// set of instances.
  ///
  /// The attributions are grouped by outputs. For Models that predict only one
  /// output, such as regression Models that predict only one score, there is
  /// only one attibution that explains the predicted output. For Models that
  /// predict multiple outputs, such as multiclass Models that predict multiple
  /// classes, each element explains one specific item. Attribution.output_index
  /// can be used to identify which output this attribution is explaining. The
  /// baselineOutputValue, instanceOutputValue and featureAttributions fields
  /// are averaged over the test data. NOTE: Currently AutoML tabular
  /// classification Models produce only one attribution, which averages
  /// attributions over all the classes it predicts.
  /// Attribution.approximation_error is not populated.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Attribution>? meanAttributions;

  GoogleCloudAiplatformV1beta1ModelExplanation({this.meanAttributions});

  GoogleCloudAiplatformV1beta1ModelExplanation.fromJson(core.Map json_)
    : this(
        meanAttributions:
            (json_['meanAttributions'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Attribution.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (meanAttributions != null) 'meanAttributions': meanAttributions!,
  };
}

/// Represents export format supported by the Model.
///
/// All formats export to Google Cloud Storage.
typedef GoogleCloudAiplatformV1beta1ModelExportFormat = $ModelExportFormat;

/// Contains information about the source of the models generated from Model
/// Garden.
typedef GoogleCloudAiplatformV1beta1ModelGardenSource = $ModelGardenSource;

/// Vertex AI Model Monitoring Service serves as a central hub for the analysis
/// and visualization of data quality and performance related to models.
///
/// ModelMonitor stands as a top level resource for overseeing your model
/// monitoring tasks.
class GoogleCloudAiplatformV1beta1ModelMonitor {
  /// Timestamp when this ModelMonitor was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the ModelMonitor.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8.
  core.String? displayName;

  /// Customer-managed encryption key spec for a ModelMonitor.
  ///
  /// If set, this ModelMonitor and all sub-resources of this ModelMonitor will
  /// be secured by this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Optional model explanation spec.
  ///
  /// It is used for feature attribution monitoring.
  GoogleCloudAiplatformV1beta1ExplanationSpec? explanationSpec;

  /// Monitoring Schema is to specify the model's features, prediction outputs
  /// and ground truth properties.
  ///
  /// It is used to extract pertinent data from the dataset and to process
  /// features based on their properties. Make sure that the schema aligns with
  /// your dataset, if it does not, we will be unable to extract data from the
  /// dataset. It is required for most models, but optional for Vertex AI AutoML
  /// Tables unless the schem information is not available.
  GoogleCloudAiplatformV1beta1ModelMonitoringSchema? modelMonitoringSchema;

  /// The entity that is subject to analysis.
  ///
  /// Currently only models in Vertex AI Model Registry are supported. If you
  /// want to analyze the model which is outside the Vertex AI, you could
  /// register a model in Vertex AI Model Registry using just a display name.
  GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTarget?
  modelMonitoringTarget;

  /// Resource name of the ModelMonitor.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`.
  ///
  /// Immutable.
  core.String? name;

  /// Optional default notification spec, it can be overridden in the
  /// ModelMonitoringJob notification spec.
  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpec? notificationSpec;

  /// Optional default monitoring metrics/logs export spec, it can be overridden
  /// in the ModelMonitoringJob output spec.
  ///
  /// If not specified, a default Google Cloud Storage bucket will be created
  /// under your project.
  GoogleCloudAiplatformV1beta1ModelMonitoringOutputSpec? outputSpec;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Optional default tabular model monitoring objective.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecTabularObjective?
  tabularObjective;

  /// Optional training dataset used to train the model.
  ///
  /// It can serve as a reference dataset to identify changes in production.
  GoogleCloudAiplatformV1beta1ModelMonitoringInput? trainingDataset;

  /// Timestamp when this ModelMonitor was updated most recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1ModelMonitor({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.explanationSpec,
    this.modelMonitoringSchema,
    this.modelMonitoringTarget,
    this.name,
    this.notificationSpec,
    this.outputSpec,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.tabularObjective,
    this.trainingDataset,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1ModelMonitor.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        explanationSpec:
            json_.containsKey('explanationSpec')
                ? GoogleCloudAiplatformV1beta1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelMonitoringSchema:
            json_.containsKey('modelMonitoringSchema')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringSchema.fromJson(
                  json_['modelMonitoringSchema']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelMonitoringTarget:
            json_.containsKey('modelMonitoringTarget')
                ? GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTarget.fromJson(
                  json_['modelMonitoringTarget']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        notificationSpec:
            json_.containsKey('notificationSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpec.fromJson(
                  json_['notificationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        outputSpec:
            json_.containsKey('outputSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringOutputSpec.fromJson(
                  json_['outputSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        tabularObjective:
            json_.containsKey('tabularObjective')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecTabularObjective.fromJson(
                  json_['tabularObjective']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingDataset:
            json_.containsKey('trainingDataset')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInput.fromJson(
                  json_['trainingDataset']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (explanationSpec != null) 'explanationSpec': explanationSpec!,
    if (modelMonitoringSchema != null)
      'modelMonitoringSchema': modelMonitoringSchema!,
    if (modelMonitoringTarget != null)
      'modelMonitoringTarget': modelMonitoringTarget!,
    if (name != null) 'name': name!,
    if (notificationSpec != null) 'notificationSpec': notificationSpec!,
    if (outputSpec != null) 'outputSpec': outputSpec!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (tabularObjective != null) 'tabularObjective': tabularObjective!,
    if (trainingDataset != null) 'trainingDataset': trainingDataset!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// The monitoring target refers to the entity that is subject to analysis.
///
/// e.g. Vertex AI Model version.
class GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTarget {
  /// Model in Vertex AI Model Registry.
  GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTargetVertexModelSource?
  vertexModel;

  GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTarget({
    this.vertexModel,
  });

  GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTarget.fromJson(
    core.Map json_,
  ) : this(
        vertexModel:
            json_.containsKey('vertexModel')
                ? GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTargetVertexModelSource.fromJson(
                  json_['vertexModel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (vertexModel != null) 'vertexModel': vertexModel!,
  };
}

/// Model in Vertex AI Model Registry.
class GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTargetVertexModelSource {
  /// Model resource name.
  ///
  /// Format: projects/{project}/locations/{location}/models/{model}.
  core.String? model;

  /// Model version id.
  core.String? modelVersionId;

  GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTargetVertexModelSource({
    this.model,
    this.modelVersionId,
  });

  GoogleCloudAiplatformV1beta1ModelMonitorModelMonitoringTargetVertexModelSource.fromJson(
    core.Map json_,
  ) : this(
        model: json_['model'] as core.String?,
        modelVersionId: json_['modelVersionId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (modelVersionId != null) 'modelVersionId': modelVersionId!,
  };
}

/// Represents a single monitoring alert.
///
/// This is currently used in the SearchModelMonitoringAlerts api, thus the
/// alert wrapped in this message belongs to the resource asked in the request.
class GoogleCloudAiplatformV1beta1ModelMonitoringAlert {
  /// Alert creation time.
  core.String? alertTime;

  /// Anomaly details.
  GoogleCloudAiplatformV1beta1ModelMonitoringAnomaly? anomaly;

  /// One of the supported monitoring objectives: `raw-feature-drift`
  /// `prediction-output-drift` `feature-attribution`
  core.String? objectiveType;

  /// The stats name.
  core.String? statsName;

  GoogleCloudAiplatformV1beta1ModelMonitoringAlert({
    this.alertTime,
    this.anomaly,
    this.objectiveType,
    this.statsName,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringAlert.fromJson(core.Map json_)
    : this(
        alertTime: json_['alertTime'] as core.String?,
        anomaly:
            json_.containsKey('anomaly')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAnomaly.fromJson(
                  json_['anomaly'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        objectiveType: json_['objectiveType'] as core.String?,
        statsName: json_['statsName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alertTime != null) 'alertTime': alertTime!,
    if (anomaly != null) 'anomaly': anomaly!,
    if (objectiveType != null) 'objectiveType': objectiveType!,
    if (statsName != null) 'statsName': statsName!,
  };
}

/// Monitoring alert triggered condition.
class GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition {
  /// A condition that compares a stats value against a threshold.
  ///
  /// Alert will be triggered if value above the threshold.
  core.double? threshold;

  GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition({this.threshold});

  GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition.fromJson(
    core.Map json_,
  ) : this(threshold: (json_['threshold'] as core.num?)?.toDouble());

  core.Map<core.String, core.dynamic> toJson() => {
    if (threshold != null) 'threshold': threshold!,
  };
}

/// The alert config for model monitoring.
class GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfig {
  /// Email alert config.
  GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfigEmailAlertConfig?
  emailAlertConfig;

  /// Dump the anomalies to Cloud Logging.
  ///
  /// The anomalies will be put to json payload encoded from proto
  /// ModelMonitoringStatsAnomalies. This can be further synced to Pub/Sub or
  /// any other services supported by Cloud Logging.
  core.bool? enableLogging;

  /// Resource names of the NotificationChannels to send alert.
  ///
  /// Must be of the format `projects//notificationChannels/`
  core.List<core.String>? notificationChannels;

  GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfig({
    this.emailAlertConfig,
    this.enableLogging,
    this.notificationChannels,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfig.fromJson(
    core.Map json_,
  ) : this(
        emailAlertConfig:
            json_.containsKey('emailAlertConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfigEmailAlertConfig.fromJson(
                  json_['emailAlertConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        enableLogging: json_['enableLogging'] as core.bool?,
        notificationChannels:
            (json_['notificationChannels'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (emailAlertConfig != null) 'emailAlertConfig': emailAlertConfig!,
    if (enableLogging != null) 'enableLogging': enableLogging!,
    if (notificationChannels != null)
      'notificationChannels': notificationChannels!,
  };
}

/// The config for email alert.
typedef GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfigEmailAlertConfig =
    $ModelMonitoringAlertConfigEmailAlertConfig;

/// Represents a single model monitoring anomaly.
class GoogleCloudAiplatformV1beta1ModelMonitoringAnomaly {
  /// Algorithm used to calculated the metrics, eg: jensen_shannon_divergence,
  /// l_infinity.
  core.String? algorithm;

  /// Model monitoring job resource name.
  core.String? modelMonitoringJob;

  /// Tabular anomaly.
  GoogleCloudAiplatformV1beta1ModelMonitoringAnomalyTabularAnomaly?
  tabularAnomaly;

  GoogleCloudAiplatformV1beta1ModelMonitoringAnomaly({
    this.algorithm,
    this.modelMonitoringJob,
    this.tabularAnomaly,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringAnomaly.fromJson(core.Map json_)
    : this(
        algorithm: json_['algorithm'] as core.String?,
        modelMonitoringJob: json_['modelMonitoringJob'] as core.String?,
        tabularAnomaly:
            json_.containsKey('tabularAnomaly')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAnomalyTabularAnomaly.fromJson(
                  json_['tabularAnomaly']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algorithm != null) 'algorithm': algorithm!,
    if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob!,
    if (tabularAnomaly != null) 'tabularAnomaly': tabularAnomaly!,
  };
}

/// Tabular anomaly details.
class GoogleCloudAiplatformV1beta1ModelMonitoringAnomalyTabularAnomaly {
  /// Anomaly body.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? anomaly;

  /// Additional anomaly information.
  ///
  /// e.g. Google Cloud Storage uri.
  core.String? anomalyUri;

  /// The alert condition associated with this anomaly.
  GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition? condition;

  /// Overview of this anomaly.
  core.String? summary;

  /// The time the anomaly was triggered.
  core.String? triggerTime;

  GoogleCloudAiplatformV1beta1ModelMonitoringAnomalyTabularAnomaly({
    this.anomaly,
    this.anomalyUri,
    this.condition,
    this.summary,
    this.triggerTime,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringAnomalyTabularAnomaly.fromJson(
    core.Map json_,
  ) : this(
        anomaly: json_['anomaly'],
        anomalyUri: json_['anomalyUri'] as core.String?,
        condition:
            json_.containsKey('condition')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition.fromJson(
                  json_['condition'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        summary: json_['summary'] as core.String?,
        triggerTime: json_['triggerTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (anomaly != null) 'anomaly': anomaly!,
    if (anomalyUri != null) 'anomalyUri': anomalyUri!,
    if (condition != null) 'condition': condition!,
    if (summary != null) 'summary': summary!,
    if (triggerTime != null) 'triggerTime': triggerTime!,
  };
}

/// The model monitoring configuration used for Batch Prediction Job.
class GoogleCloudAiplatformV1beta1ModelMonitoringConfig {
  /// Model monitoring alert config.
  GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfig? alertConfig;

  /// YAML schema file uri in Cloud Storage describing the format of a single
  /// instance that you want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If there are any data type differences between predict instance and TFDV
  /// instance, this field can be used to override the schema. For models
  /// trained with Vertex AI, this field must be set as all the fields in
  /// predict instance formatted as string.
  core.String? analysisInstanceSchemaUri;

  /// Model monitoring objective config.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfig>?
  objectiveConfigs;

  /// A Google Cloud Storage location for batch prediction model monitoring to
  /// dump statistics and anomalies.
  ///
  /// If not provided, a folder will be created in customer project to hold
  /// statistics and anomalies.
  GoogleCloudAiplatformV1beta1GcsDestination? statsAnomaliesBaseDirectory;

  GoogleCloudAiplatformV1beta1ModelMonitoringConfig({
    this.alertConfig,
    this.analysisInstanceSchemaUri,
    this.objectiveConfigs,
    this.statsAnomaliesBaseDirectory,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringConfig.fromJson(core.Map json_)
    : this(
        alertConfig:
            json_.containsKey('alertConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAlertConfig.fromJson(
                  json_['alertConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        analysisInstanceSchemaUri:
            json_['analysisInstanceSchemaUri'] as core.String?,
        objectiveConfigs:
            (json_['objectiveConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        statsAnomaliesBaseDirectory:
            json_.containsKey('statsAnomaliesBaseDirectory')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['statsAnomaliesBaseDirectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alertConfig != null) 'alertConfig': alertConfig!,
    if (analysisInstanceSchemaUri != null)
      'analysisInstanceSchemaUri': analysisInstanceSchemaUri!,
    if (objectiveConfigs != null) 'objectiveConfigs': objectiveConfigs!,
    if (statsAnomaliesBaseDirectory != null)
      'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!,
  };
}

/// Model monitoring data input spec.
class GoogleCloudAiplatformV1beta1ModelMonitoringInput {
  /// Vertex AI Batch prediction Job.
  GoogleCloudAiplatformV1beta1ModelMonitoringInputBatchPredictionOutput?
  batchPredictionOutput;

  /// Columnized dataset.
  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDataset?
  columnizedDataset;

  /// The time interval (pair of start_time and end_time) for which results
  /// should be returned.
  GoogleTypeInterval? timeInterval;

  /// The time offset setting for which results should be returned.
  GoogleCloudAiplatformV1beta1ModelMonitoringInputTimeOffset? timeOffset;

  /// Vertex AI Endpoint request & response logging.
  GoogleCloudAiplatformV1beta1ModelMonitoringInputVertexEndpointLogs?
  vertexEndpointLogs;

  GoogleCloudAiplatformV1beta1ModelMonitoringInput({
    this.batchPredictionOutput,
    this.columnizedDataset,
    this.timeInterval,
    this.timeOffset,
    this.vertexEndpointLogs,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringInput.fromJson(core.Map json_)
    : this(
        batchPredictionOutput:
            json_.containsKey('batchPredictionOutput')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInputBatchPredictionOutput.fromJson(
                  json_['batchPredictionOutput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        columnizedDataset:
            json_.containsKey('columnizedDataset')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDataset.fromJson(
                  json_['columnizedDataset']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        timeInterval:
            json_.containsKey('timeInterval')
                ? GoogleTypeInterval.fromJson(
                  json_['timeInterval'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        timeOffset:
            json_.containsKey('timeOffset')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInputTimeOffset.fromJson(
                  json_['timeOffset'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexEndpointLogs:
            json_.containsKey('vertexEndpointLogs')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInputVertexEndpointLogs.fromJson(
                  json_['vertexEndpointLogs']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (batchPredictionOutput != null)
      'batchPredictionOutput': batchPredictionOutput!,
    if (columnizedDataset != null) 'columnizedDataset': columnizedDataset!,
    if (timeInterval != null) 'timeInterval': timeInterval!,
    if (timeOffset != null) 'timeOffset': timeOffset!,
    if (vertexEndpointLogs != null) 'vertexEndpointLogs': vertexEndpointLogs!,
  };
}

/// Data from Vertex AI Batch prediction job output.
class GoogleCloudAiplatformV1beta1ModelMonitoringInputBatchPredictionOutput {
  /// Vertex AI Batch prediction job resource name.
  ///
  /// The job must match the model version specified in
  /// \[ModelMonitor\].\[model_monitoring_target\].
  core.String? batchPredictionJob;

  GoogleCloudAiplatformV1beta1ModelMonitoringInputBatchPredictionOutput({
    this.batchPredictionJob,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringInputBatchPredictionOutput.fromJson(
    core.Map json_,
  ) : this(batchPredictionJob: json_['batchPredictionJob'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (batchPredictionJob != null) 'batchPredictionJob': batchPredictionJob!,
  };
}

/// Input dataset spec.
class GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDataset {
  /// BigQuery data source.
  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringBigQuerySource?
  bigquerySource;

  /// Google Cloud Storage data source.
  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringGcsSource?
  gcsSource;

  /// The timestamp field.
  ///
  /// Usually for serving data.
  core.String? timestampField;

  /// Resource name of the Vertex AI managed dataset.
  core.String? vertexDataset;

  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDataset({
    this.bigquerySource,
    this.gcsSource,
    this.timestampField,
    this.vertexDataset,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDataset.fromJson(
    core.Map json_,
  ) : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringBigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        timestampField: json_['timestampField'] as core.String?,
        vertexDataset: json_['vertexDataset'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (timestampField != null) 'timestampField': timestampField!,
    if (vertexDataset != null) 'vertexDataset': vertexDataset!,
  };
}

/// Dataset spec for data sotred in BigQuery.
class GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringBigQuerySource {
  /// Standard SQL to be used instead of the `table_uri`.
  core.String? query;

  /// BigQuery URI to a table, up to 2000 characters long.
  ///
  /// All the columns in the table will be selected. Accepted forms: * BigQuery
  /// path. For example: `bq://projectId.bqDatasetId.bqTableId`.
  core.String? tableUri;

  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringBigQuerySource({
    this.query,
    this.tableUri,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringBigQuerySource.fromJson(
    core.Map json_,
  ) : this(
        query: json_['query'] as core.String?,
        tableUri: json_['tableUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (query != null) 'query': query!,
    if (tableUri != null) 'tableUri': tableUri!,
  };
}

/// Dataset spec for data stored in Google Cloud Storage.
class GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringGcsSource {
  /// Data format of the dataset.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Data format unspecified, used when this
  /// field is unset.
  /// - "CSV" : CSV files.
  /// - "TF_RECORD" : TfRecord files
  /// - "JSONL" : JsonL files.
  core.String? format;

  /// Google Cloud Storage URI to the input file(s).
  ///
  /// May contain wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/wildcards.
  core.String? gcsUri;

  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringGcsSource({
    this.format,
    this.gcsUri,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringInputModelMonitoringDatasetModelMonitoringGcsSource.fromJson(
    core.Map json_,
  ) : this(
        format: json_['format'] as core.String?,
        gcsUri: json_['gcsUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (format != null) 'format': format!,
    if (gcsUri != null) 'gcsUri': gcsUri!,
  };
}

/// Time offset setting.
class GoogleCloudAiplatformV1beta1ModelMonitoringInputTimeOffset {
  /// \[offset\] is the time difference from the cut-off time.
  ///
  /// For scheduled jobs, the cut-off time is the scheduled time. For
  /// non-scheduled jobs, it's the time when the job was created. Currently we
  /// support the following format: 'w|W': Week, 'd|D': Day, 'h|H': Hour E.g.
  /// '1h' stands for 1 hour, '2d' stands for 2 days.
  core.String? offset;

  /// \[window\] refers to the scope of data selected for analysis.
  ///
  /// It allows you to specify the quantity of data you wish to examine.
  /// Currently we support the following format: 'w|W': Week, 'd|D': Day, 'h|H':
  /// Hour E.g. '1h' stands for 1 hour, '2d' stands for 2 days.
  core.String? window;

  GoogleCloudAiplatformV1beta1ModelMonitoringInputTimeOffset({
    this.offset,
    this.window,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringInputTimeOffset.fromJson(
    core.Map json_,
  ) : this(
        offset: json_['offset'] as core.String?,
        window: json_['window'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (offset != null) 'offset': offset!,
    if (window != null) 'window': window!,
  };
}

/// Data from Vertex AI Endpoint request response logging.
class GoogleCloudAiplatformV1beta1ModelMonitoringInputVertexEndpointLogs {
  /// List of endpoint resource names.
  ///
  /// The endpoints must enable the logging with the
  /// \[Endpoint\].\[request_response_logging_config\], and must contain the
  /// deployed model corresponding to the model version specified in
  /// \[ModelMonitor\].\[model_monitoring_target\].
  core.List<core.String>? endpoints;

  GoogleCloudAiplatformV1beta1ModelMonitoringInputVertexEndpointLogs({
    this.endpoints,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringInputVertexEndpointLogs.fromJson(
    core.Map json_,
  ) : this(
        endpoints:
            (json_['endpoints'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpoints != null) 'endpoints': endpoints!,
  };
}

/// Represents a model monitoring job that analyze dataset using different
/// monitoring algorithm.
class GoogleCloudAiplatformV1beta1ModelMonitoringJob {
  /// Timestamp when this ModelMonitoringJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the ModelMonitoringJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8.
  core.String? displayName;

  /// Execution results for all the monitoring objectives.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetail?
  jobExecutionDetail;

  /// Monitoring monitoring job spec.
  ///
  /// It outlines the specifications for monitoring objectives, notifications,
  /// and result exports. If left blank, the default monitoring specifications
  /// from the top-level resource 'ModelMonitor' will be applied. If provided,
  /// we will use the specification defined here rather than the default one.
  GoogleCloudAiplatformV1beta1ModelMonitoringSpec? modelMonitoringSpec;

  /// Resource name of a ModelMonitoringJob.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
  ///
  /// Output only.
  core.String? name;

  /// Schedule resource name.
  ///
  /// It will only appear when this job is triggered by a schedule.
  ///
  /// Output only.
  core.String? schedule;

  /// Timestamp when this ModelMonitoringJob was scheduled.
  ///
  /// It will only appear when this job is triggered by a schedule.
  ///
  /// Output only.
  core.String? scheduleTime;

  /// The state of the monitoring job.
  ///
  /// * When the job is still creating, the state will be 'JOB_STATE_PENDING'. *
  /// Once the job is successfully created, the state will be
  /// 'JOB_STATE_RUNNING'. * Once the job is finished, the state will be one of
  /// 'JOB_STATE_FAILED', 'JOB_STATE_SUCCEEDED',
  /// 'JOB_STATE_PARTIALLY_SUCCEEDED'.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Timestamp when this ModelMonitoringJob was updated most recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1ModelMonitoringJob({
    this.createTime,
    this.displayName,
    this.jobExecutionDetail,
    this.modelMonitoringSpec,
    this.name,
    this.schedule,
    this.scheduleTime,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringJob.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        jobExecutionDetail:
            json_.containsKey('jobExecutionDetail')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetail.fromJson(
                  json_['jobExecutionDetail']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelMonitoringSpec:
            json_.containsKey('modelMonitoringSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringSpec.fromJson(
                  json_['modelMonitoringSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        schedule: json_['schedule'] as core.String?,
        scheduleTime: json_['scheduleTime'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (jobExecutionDetail != null) 'jobExecutionDetail': jobExecutionDetail!,
    if (modelMonitoringSpec != null)
      'modelMonitoringSpec': modelMonitoringSpec!,
    if (name != null) 'name': name!,
    if (schedule != null) 'schedule': schedule!,
    if (scheduleTime != null) 'scheduleTime': scheduleTime!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Represent the execution details of the job.
class GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetail {
  /// Processed baseline datasets.
  core.List<
    GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetailProcessedDataset
  >?
  baselineDatasets;

  /// Additional job error status.
  GoogleRpcStatus? error;

  /// Status of data processing for each monitoring objective.
  ///
  /// Key is the objective.
  core.Map<core.String, GoogleRpcStatus>? objectiveStatus;

  /// Processed target datasets.
  core.List<
    GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetailProcessedDataset
  >?
  targetDatasets;

  GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetail({
    this.baselineDatasets,
    this.error,
    this.objectiveStatus,
    this.targetDatasets,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetail.fromJson(
    core.Map json_,
  ) : this(
        baselineDatasets:
            (json_['baselineDatasets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetailProcessedDataset.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        objectiveStatus: (json_['objectiveStatus']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleRpcStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        targetDatasets:
            (json_['targetDatasets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetailProcessedDataset.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baselineDatasets != null) 'baselineDatasets': baselineDatasets!,
    if (error != null) 'error': error!,
    if (objectiveStatus != null) 'objectiveStatus': objectiveStatus!,
    if (targetDatasets != null) 'targetDatasets': targetDatasets!,
  };
}

/// Processed dataset information.
class GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetailProcessedDataset {
  /// Actual data location of the processed dataset.
  core.String? location;

  /// Dataset time range information if any.
  GoogleTypeInterval? timeRange;

  GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetailProcessedDataset({
    this.location,
    this.timeRange,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringJobExecutionDetailProcessedDataset.fromJson(
    core.Map json_,
  ) : this(
        location: json_['location'] as core.String?,
        timeRange:
            json_.containsKey('timeRange')
                ? GoogleTypeInterval.fromJson(
                  json_['timeRange'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (location != null) 'location': location!,
    if (timeRange != null) 'timeRange': timeRange!,
  };
}

/// Notification spec(email, notification channel) for model monitoring
/// statistics/alerts.
class GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpec {
  /// Email alert config.
  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecEmailConfig?
  emailConfig;

  /// Dump the anomalies to Cloud Logging.
  ///
  /// The anomalies will be put to json payload encoded from proto
  /// google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can
  /// be further sinked to Pub/Sub or any other services supported by Cloud
  /// Logging.
  core.bool? enableCloudLogging;

  /// Notification channel config.
  core.List<
    GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecNotificationChannelConfig
  >?
  notificationChannelConfigs;

  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpec({
    this.emailConfig,
    this.enableCloudLogging,
    this.notificationChannelConfigs,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpec.fromJson(
    core.Map json_,
  ) : this(
        emailConfig:
            json_.containsKey('emailConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecEmailConfig.fromJson(
                  json_['emailConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        enableCloudLogging: json_['enableCloudLogging'] as core.bool?,
        notificationChannelConfigs:
            (json_['notificationChannelConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecNotificationChannelConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (emailConfig != null) 'emailConfig': emailConfig!,
    if (enableCloudLogging != null) 'enableCloudLogging': enableCloudLogging!,
    if (notificationChannelConfigs != null)
      'notificationChannelConfigs': notificationChannelConfigs!,
  };
}

/// The config for email alerts.
class GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecEmailConfig {
  /// The email addresses to send the alerts.
  core.List<core.String>? userEmails;

  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecEmailConfig({
    this.userEmails,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecEmailConfig.fromJson(
    core.Map json_,
  ) : this(
        userEmails:
            (json_['userEmails'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (userEmails != null) 'userEmails': userEmails!,
  };
}

/// Google Cloud Notification Channel config.
class GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecNotificationChannelConfig {
  /// Resource names of the NotificationChannels.
  ///
  /// Must be of the format `projects//notificationChannels/`
  core.String? notificationChannel;

  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecNotificationChannelConfig({
    this.notificationChannel,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpecNotificationChannelConfig.fromJson(
    core.Map json_,
  ) : this(notificationChannel: json_['notificationChannel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (notificationChannel != null)
      'notificationChannel': notificationChannel!,
  };
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfig {
  /// The config for integrating with Vertex Explainable AI.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfig?
  explanationConfig;

  /// The config for drift of prediction data.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig?
  predictionDriftDetectionConfig;

  /// Training dataset for models.
  ///
  /// This field has to be set only if TrainingPredictionSkewDetectionConfig is
  /// specified.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingDataset?
  trainingDataset;

  /// The config for skew between training data and prediction data.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig?
  trainingPredictionSkewDetectionConfig;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfig({
    this.explanationConfig,
    this.predictionDriftDetectionConfig,
    this.trainingDataset,
    this.trainingPredictionSkewDetectionConfig,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfig.fromJson(
    core.Map json_,
  ) : this(
        explanationConfig:
            json_.containsKey('explanationConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfig.fromJson(
                  json_['explanationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        predictionDriftDetectionConfig:
            json_.containsKey('predictionDriftDetectionConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig.fromJson(
                  json_['predictionDriftDetectionConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingDataset:
            json_.containsKey('trainingDataset')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingDataset.fromJson(
                  json_['trainingDataset']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingPredictionSkewDetectionConfig:
            json_.containsKey('trainingPredictionSkewDetectionConfig')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig.fromJson(
                  json_['trainingPredictionSkewDetectionConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (explanationConfig != null) 'explanationConfig': explanationConfig!,
    if (predictionDriftDetectionConfig != null)
      'predictionDriftDetectionConfig': predictionDriftDetectionConfig!,
    if (trainingDataset != null) 'trainingDataset': trainingDataset!,
    if (trainingPredictionSkewDetectionConfig != null)
      'trainingPredictionSkewDetectionConfig':
          trainingPredictionSkewDetectionConfig!,
  };
}

/// The config for integrating with Vertex Explainable AI.
///
/// Only applicable if the Model has explanation_spec populated.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfig {
  /// If want to analyze the Vertex Explainable AI feature attribute scores or
  /// not.
  ///
  /// If set to true, Vertex AI will log the feature attributions from explain
  /// response and do the skew/drift detection for them.
  core.bool? enableFeatureAttributes;

  /// Predictions generated by the BatchPredictionJob using baseline dataset.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline?
  explanationBaseline;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfig({
    this.enableFeatureAttributes,
    this.explanationBaseline,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfig.fromJson(
    core.Map json_,
  ) : this(
        enableFeatureAttributes: json_['enableFeatureAttributes'] as core.bool?,
        explanationBaseline:
            json_.containsKey('explanationBaseline')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline.fromJson(
                  json_['explanationBaseline']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableFeatureAttributes != null)
      'enableFeatureAttributes': enableFeatureAttributes!,
    if (explanationBaseline != null)
      'explanationBaseline': explanationBaseline!,
  };
}

/// Output from BatchPredictionJob for Model Monitoring baseline dataset, which
/// can be used to generate baseline attribution scores.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline {
  /// BigQuery location for BatchExplain output.
  GoogleCloudAiplatformV1beta1BigQueryDestination? bigquery;

  /// Cloud Storage location for BatchExplain output.
  GoogleCloudAiplatformV1beta1GcsDestination? gcs;

  /// The storage format of the predictions generated BatchPrediction job.
  /// Possible string values are:
  /// - "PREDICTION_FORMAT_UNSPECIFIED" : Should not be set.
  /// - "JSONL" : Predictions are in JSONL files.
  /// - "BIGQUERY" : Predictions are in BigQuery.
  core.String? predictionFormat;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline({
    this.bigquery,
    this.gcs,
    this.predictionFormat,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline.fromJson(
    core.Map json_,
  ) : this(
        bigquery:
            json_.containsKey('bigquery')
                ? GoogleCloudAiplatformV1beta1BigQueryDestination.fromJson(
                  json_['bigquery'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcs:
            json_.containsKey('gcs')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcs'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        predictionFormat: json_['predictionFormat'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquery != null) 'bigquery': bigquery!,
    if (gcs != null) 'gcs': gcs!,
    if (predictionFormat != null) 'predictionFormat': predictionFormat!,
  };
}

/// The config for Prediction data drift detection.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig {
  /// Key is the feature name and value is the threshold.
  ///
  /// The threshold here is against attribution score distance between different
  /// time windows.
  core.Map<core.String, GoogleCloudAiplatformV1beta1ThresholdConfig>?
  attributionScoreDriftThresholds;

  /// Drift anomaly detection threshold used by all features.
  ///
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  GoogleCloudAiplatformV1beta1ThresholdConfig? defaultDriftThreshold;

  /// Key is the feature name and value is the threshold.
  ///
  /// If a feature needs to be monitored for drift, a value threshold must be
  /// configured for that feature. The threshold here is against feature
  /// distribution distance between different time windws.
  core.Map<core.String, GoogleCloudAiplatformV1beta1ThresholdConfig>?
  driftThresholds;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig({
    this.attributionScoreDriftThresholds,
    this.defaultDriftThreshold,
    this.driftThresholds,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig.fromJson(
    core.Map json_,
  ) : this(
        attributionScoreDriftThresholds:
            (json_['attributionScoreDriftThresholds']
                    as core.Map<core.String, core.dynamic>?)
                ?.map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1beta1ThresholdConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>,
                    ),
                  ),
                ),
        defaultDriftThreshold:
            json_.containsKey('defaultDriftThreshold')
                ? GoogleCloudAiplatformV1beta1ThresholdConfig.fromJson(
                  json_['defaultDriftThreshold']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        driftThresholds: (json_['driftThresholds']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1ThresholdConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributionScoreDriftThresholds != null)
      'attributionScoreDriftThresholds': attributionScoreDriftThresholds!,
    if (defaultDriftThreshold != null)
      'defaultDriftThreshold': defaultDriftThreshold!,
    if (driftThresholds != null) 'driftThresholds': driftThresholds!,
  };
}

/// Training Dataset information.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingDataset {
  /// The BigQuery table of the unmanaged Dataset used to train this Model.
  GoogleCloudAiplatformV1beta1BigQuerySource? bigquerySource;

  /// Data format of the dataset, only applicable if the input is from Google
  /// Cloud Storage.
  ///
  /// The possible formats are: "tf-record" The source file is a TFRecord file.
  /// "csv" The source file is a CSV file. "jsonl" The source file is a JSONL
  /// file.
  core.String? dataFormat;

  /// The resource name of the Dataset used to train this Model.
  core.String? dataset;

  /// The Google Cloud Storage uri of the unmanaged Dataset used to train this
  /// Model.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  /// Strategy to sample data from Training Dataset.
  ///
  /// If not set, we process the whole dataset.
  GoogleCloudAiplatformV1beta1SamplingStrategy? loggingSamplingStrategy;

  /// The target field name the model is to predict.
  ///
  /// This field will be excluded when doing Predict and (or) Explain for the
  /// training data.
  core.String? targetField;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingDataset({
    this.bigquerySource,
    this.dataFormat,
    this.dataset,
    this.gcsSource,
    this.loggingSamplingStrategy,
    this.targetField,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingDataset.fromJson(
    core.Map json_,
  ) : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudAiplatformV1beta1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        dataFormat: json_['dataFormat'] as core.String?,
        dataset: json_['dataset'] as core.String?,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        loggingSamplingStrategy:
            json_.containsKey('loggingSamplingStrategy')
                ? GoogleCloudAiplatformV1beta1SamplingStrategy.fromJson(
                  json_['loggingSamplingStrategy']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        targetField: json_['targetField'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (dataset != null) 'dataset': dataset!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (loggingSamplingStrategy != null)
      'loggingSamplingStrategy': loggingSamplingStrategy!,
    if (targetField != null) 'targetField': targetField!,
  };
}

/// The config for Training & Prediction data skew detection.
///
/// It specifies the training dataset sources and the skew detection parameters.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig {
  /// Key is the feature name and value is the threshold.
  ///
  /// The threshold here is against attribution score distance between the
  /// training and prediction feature.
  core.Map<core.String, GoogleCloudAiplatformV1beta1ThresholdConfig>?
  attributionScoreSkewThresholds;

  /// Skew anomaly detection threshold used by all features.
  ///
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  GoogleCloudAiplatformV1beta1ThresholdConfig? defaultSkewThreshold;

  /// Key is the feature name and value is the threshold.
  ///
  /// If a feature needs to be monitored for skew, a value threshold must be
  /// configured for that feature. The threshold here is against feature
  /// distribution distance between the training and prediction feature.
  core.Map<core.String, GoogleCloudAiplatformV1beta1ThresholdConfig>?
  skewThresholds;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig({
    this.attributionScoreSkewThresholds,
    this.defaultSkewThreshold,
    this.skewThresholds,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig.fromJson(
    core.Map json_,
  ) : this(
        attributionScoreSkewThresholds: (json_['attributionScoreSkewThresholds']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1ThresholdConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        defaultSkewThreshold:
            json_.containsKey('defaultSkewThreshold')
                ? GoogleCloudAiplatformV1beta1ThresholdConfig.fromJson(
                  json_['defaultSkewThreshold']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        skewThresholds: (json_['skewThresholds']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1ThresholdConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributionScoreSkewThresholds != null)
      'attributionScoreSkewThresholds': attributionScoreSkewThresholds!,
    if (defaultSkewThreshold != null)
      'defaultSkewThreshold': defaultSkewThreshold!,
    if (skewThresholds != null) 'skewThresholds': skewThresholds!,
  };
}

/// Monitoring objectives spec.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpec {
  /// Baseline dataset.
  ///
  /// It could be the training dataset or production serving dataset from a
  /// previous period.
  GoogleCloudAiplatformV1beta1ModelMonitoringInput? baselineDataset;

  /// The explanation spec.
  ///
  /// This spec is required when the objectives spec includes feature
  /// attribution objectives.
  GoogleCloudAiplatformV1beta1ExplanationSpec? explanationSpec;

  /// Tabular monitoring objective.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecTabularObjective?
  tabularObjective;

  /// Target dataset.
  GoogleCloudAiplatformV1beta1ModelMonitoringInput? targetDataset;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpec({
    this.baselineDataset,
    this.explanationSpec,
    this.tabularObjective,
    this.targetDataset,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpec.fromJson(
    core.Map json_,
  ) : this(
        baselineDataset:
            json_.containsKey('baselineDataset')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInput.fromJson(
                  json_['baselineDataset']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        explanationSpec:
            json_.containsKey('explanationSpec')
                ? GoogleCloudAiplatformV1beta1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tabularObjective:
            json_.containsKey('tabularObjective')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecTabularObjective.fromJson(
                  json_['tabularObjective']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        targetDataset:
            json_.containsKey('targetDataset')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringInput.fromJson(
                  json_['targetDataset'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baselineDataset != null) 'baselineDataset': baselineDataset!,
    if (explanationSpec != null) 'explanationSpec': explanationSpec!,
    if (tabularObjective != null) 'tabularObjective': tabularObjective!,
    if (targetDataset != null) 'targetDataset': targetDataset!,
  };
}

/// Data drift monitoring spec.
///
/// Data drift measures the distribution distance between the current dataset
/// and a baseline dataset. A typical use case is to detect data drift between
/// the recent production serving dataset and the training dataset, or to
/// compare the recent production dataset with a dataset from a previous period.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecDataDriftSpec {
  /// Supported metrics type: * l_infinity * jensen_shannon_divergence
  core.String? categoricalMetricType;

  /// Default alert condition for all the categorical features.
  GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition?
  defaultCategoricalAlertCondition;

  /// Default alert condition for all the numeric features.
  GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition?
  defaultNumericAlertCondition;

  /// Per feature alert condition will override default alert condition.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition
  >?
  featureAlertConditions;

  /// Feature names / Prediction output names interested in monitoring.
  ///
  /// These should be a subset of the input feature names or prediction output
  /// names specified in the monitoring schema. If the field is not specified
  /// all features / prediction outputs outlied in the monitoring schema will be
  /// used.
  core.List<core.String>? features;

  /// Supported metrics type: * jensen_shannon_divergence
  core.String? numericMetricType;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecDataDriftSpec({
    this.categoricalMetricType,
    this.defaultCategoricalAlertCondition,
    this.defaultNumericAlertCondition,
    this.featureAlertConditions,
    this.features,
    this.numericMetricType,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecDataDriftSpec.fromJson(
    core.Map json_,
  ) : this(
        categoricalMetricType: json_['categoricalMetricType'] as core.String?,
        defaultCategoricalAlertCondition:
            json_.containsKey('defaultCategoricalAlertCondition')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition.fromJson(
                  json_['defaultCategoricalAlertCondition']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        defaultNumericAlertCondition:
            json_.containsKey('defaultNumericAlertCondition')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition.fromJson(
                  json_['defaultNumericAlertCondition']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        featureAlertConditions: (json_['featureAlertConditions']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        features:
            (json_['features'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        numericMetricType: json_['numericMetricType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (categoricalMetricType != null)
      'categoricalMetricType': categoricalMetricType!,
    if (defaultCategoricalAlertCondition != null)
      'defaultCategoricalAlertCondition': defaultCategoricalAlertCondition!,
    if (defaultNumericAlertCondition != null)
      'defaultNumericAlertCondition': defaultNumericAlertCondition!,
    if (featureAlertConditions != null)
      'featureAlertConditions': featureAlertConditions!,
    if (features != null) 'features': features!,
    if (numericMetricType != null) 'numericMetricType': numericMetricType!,
  };
}

/// Feature attribution monitoring spec.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecFeatureAttributionSpec {
  /// The config of resources used by the Model Monitoring during the batch
  /// explanation for non-AutoML models.
  ///
  /// If not set, `n1-standard-2` machine type will be used by default.
  GoogleCloudAiplatformV1beta1BatchDedicatedResources?
  batchExplanationDedicatedResources;

  /// Default alert condition for all the features.
  GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition?
  defaultAlertCondition;

  /// Per feature alert condition will override default alert condition.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition
  >?
  featureAlertConditions;

  /// Feature names interested in monitoring.
  ///
  /// These should be a subset of the input feature names specified in the
  /// monitoring schema. If the field is not specified all features outlied in
  /// the monitoring schema will be used.
  core.List<core.String>? features;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecFeatureAttributionSpec({
    this.batchExplanationDedicatedResources,
    this.defaultAlertCondition,
    this.featureAlertConditions,
    this.features,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecFeatureAttributionSpec.fromJson(
    core.Map json_,
  ) : this(
        batchExplanationDedicatedResources:
            json_.containsKey('batchExplanationDedicatedResources')
                ? GoogleCloudAiplatformV1beta1BatchDedicatedResources.fromJson(
                  json_['batchExplanationDedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        defaultAlertCondition:
            json_.containsKey('defaultAlertCondition')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition.fromJson(
                  json_['defaultAlertCondition']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        featureAlertConditions: (json_['featureAlertConditions']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1ModelMonitoringAlertCondition.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        features:
            (json_['features'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (batchExplanationDedicatedResources != null)
      'batchExplanationDedicatedResources': batchExplanationDedicatedResources!,
    if (defaultAlertCondition != null)
      'defaultAlertCondition': defaultAlertCondition!,
    if (featureAlertConditions != null)
      'featureAlertConditions': featureAlertConditions!,
    if (features != null) 'features': features!,
  };
}

/// Tabular monitoring objective.
class GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecTabularObjective {
  /// Feature attribution monitoring spec.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecFeatureAttributionSpec?
  featureAttributionSpec;

  /// Input feature distribution drift monitoring spec.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecDataDriftSpec?
  featureDriftSpec;

  /// Prediction output distribution drift monitoring spec.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecDataDriftSpec?
  predictionOutputDriftSpec;

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecTabularObjective({
    this.featureAttributionSpec,
    this.featureDriftSpec,
    this.predictionOutputDriftSpec,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecTabularObjective.fromJson(
    core.Map json_,
  ) : this(
        featureAttributionSpec:
            json_.containsKey('featureAttributionSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecFeatureAttributionSpec.fromJson(
                  json_['featureAttributionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        featureDriftSpec:
            json_.containsKey('featureDriftSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecDataDriftSpec.fromJson(
                  json_['featureDriftSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        predictionOutputDriftSpec:
            json_.containsKey('predictionOutputDriftSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpecDataDriftSpec.fromJson(
                  json_['predictionOutputDriftSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureAttributionSpec != null)
      'featureAttributionSpec': featureAttributionSpec!,
    if (featureDriftSpec != null) 'featureDriftSpec': featureDriftSpec!,
    if (predictionOutputDriftSpec != null)
      'predictionOutputDriftSpec': predictionOutputDriftSpec!,
  };
}

/// Specification for the export destination of monitoring results, including
/// metrics, logs, etc.
class GoogleCloudAiplatformV1beta1ModelMonitoringOutputSpec {
  /// Google Cloud Storage base folder path for metrics, error logs, etc.
  GoogleCloudAiplatformV1beta1GcsDestination? gcsBaseDirectory;

  GoogleCloudAiplatformV1beta1ModelMonitoringOutputSpec({
    this.gcsBaseDirectory,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringOutputSpec.fromJson(core.Map json_)
    : this(
        gcsBaseDirectory:
            json_.containsKey('gcsBaseDirectory')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcsBaseDirectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsBaseDirectory != null) 'gcsBaseDirectory': gcsBaseDirectory!,
  };
}

/// The Model Monitoring Schema definition.
class GoogleCloudAiplatformV1beta1ModelMonitoringSchema {
  /// Feature names of the model.
  ///
  /// Vertex AI will try to match the features from your dataset as follows: *
  /// For 'csv' files, the header names are required, and we will extract the
  /// corresponding feature values when the header names align with the feature
  /// names. * For 'jsonl' files, we will extract the corresponding feature
  /// values if the key names match the feature names. Note: Nested features are
  /// not supported, so please ensure your features are flattened. Ensure the
  /// feature values are scalar or an array of scalars. * For 'bigquery'
  /// dataset, we will extract the corresponding feature values if the column
  /// names match the feature names. Note: The column type can be a scalar or an
  /// array of scalars. STRUCT or JSON types are not supported. You may use SQL
  /// queries to select or aggregate the relevant features from your original
  /// table. However, ensure that the 'schema' of the query results meets our
  /// requirements. * For the Vertex AI Endpoint Request Response Logging table
  /// or Vertex AI Batch Prediction Job results. If the instance_type is an
  /// array, ensure that the sequence in feature_fields matches the order of
  /// features in the prediction instance. We will match the feature with the
  /// array in the order specified in \[feature_fields\].
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema>?
  featureFields;

  /// Target /ground truth names of the model.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema>?
  groundTruthFields;

  /// Prediction output names of the model.
  ///
  /// The requirements are the same as the feature_fields. For AutoML Tables,
  /// the prediction output name presented in schema will be:
  /// `predicted_{target_column}`, the `target_column` is the one you specified
  /// when you train the model. For Prediction output drift analysis: * AutoML
  /// Classification, the distribution of the argmax label will be analyzed. *
  /// AutoML Regression, the distribution of the value will be analyzed.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema>?
  predictionFields;

  GoogleCloudAiplatformV1beta1ModelMonitoringSchema({
    this.featureFields,
    this.groundTruthFields,
    this.predictionFields,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringSchema.fromJson(core.Map json_)
    : this(
        featureFields:
            (json_['featureFields'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        groundTruthFields:
            (json_['groundTruthFields'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        predictionFields:
            (json_['predictionFields'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureFields != null) 'featureFields': featureFields!,
    if (groundTruthFields != null) 'groundTruthFields': groundTruthFields!,
    if (predictionFields != null) 'predictionFields': predictionFields!,
  };
}

/// Schema field definition.
class GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema {
  /// Supported data types are: `float` `integer` `boolean` `string`
  /// `categorical`
  core.String? dataType;

  /// Field name.
  core.String? name;

  /// Describes if the schema field is an array of given data type.
  core.bool? repeated;

  GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema({
    this.dataType,
    this.name,
    this.repeated,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringSchemaFieldSchema.fromJson(
    core.Map json_,
  ) : this(
        dataType: json_['dataType'] as core.String?,
        name: json_['name'] as core.String?,
        repeated: json_['repeated'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataType != null) 'dataType': dataType!,
    if (name != null) 'name': name!,
    if (repeated != null) 'repeated': repeated!,
  };
}

/// Monitoring monitoring job spec.
///
/// It outlines the specifications for monitoring objectives, notifications, and
/// result exports.
class GoogleCloudAiplatformV1beta1ModelMonitoringSpec {
  /// The model monitoring notification spec.
  GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpec? notificationSpec;

  /// The monitoring objective spec.
  GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpec? objectiveSpec;

  /// The Output destination spec for metrics, error logs, etc.
  GoogleCloudAiplatformV1beta1ModelMonitoringOutputSpec? outputSpec;

  GoogleCloudAiplatformV1beta1ModelMonitoringSpec({
    this.notificationSpec,
    this.objectiveSpec,
    this.outputSpec,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringSpec.fromJson(core.Map json_)
    : this(
        notificationSpec:
            json_.containsKey('notificationSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringNotificationSpec.fromJson(
                  json_['notificationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        objectiveSpec:
            json_.containsKey('objectiveSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringObjectiveSpec.fromJson(
                  json_['objectiveSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        outputSpec:
            json_.containsKey('outputSpec')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringOutputSpec.fromJson(
                  json_['outputSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (notificationSpec != null) 'notificationSpec': notificationSpec!,
    if (objectiveSpec != null) 'objectiveSpec': objectiveSpec!,
    if (outputSpec != null) 'outputSpec': outputSpec!,
  };
}

/// Represents the collection of statistics for a metric.
class GoogleCloudAiplatformV1beta1ModelMonitoringStats {
  /// Generated tabular statistics.
  GoogleCloudAiplatformV1beta1ModelMonitoringTabularStats? tabularStats;

  GoogleCloudAiplatformV1beta1ModelMonitoringStats({this.tabularStats});

  GoogleCloudAiplatformV1beta1ModelMonitoringStats.fromJson(core.Map json_)
    : this(
        tabularStats:
            json_.containsKey('tabularStats')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringTabularStats.fromJson(
                  json_['tabularStats'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tabularStats != null) 'tabularStats': tabularStats!,
  };
}

/// Statistics and anomalies generated by Model Monitoring.
class GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomalies {
  /// Number of anomalies within all stats.
  core.int? anomalyCount;

  /// Deployed Model ID.
  core.String? deployedModelId;

  /// A list of historical Stats and Anomalies generated for all Features.
  core.List<
    GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies
  >?
  featureStats;

  /// Model Monitoring Objective those stats and anomalies belonging to.
  /// Possible string values are:
  /// - "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" : Default
  /// value, should not be set.
  /// - "RAW_FEATURE_SKEW" : Raw feature values' stats to detect skew between
  /// Training-Prediction datasets.
  /// - "RAW_FEATURE_DRIFT" : Raw feature values' stats to detect drift between
  /// Serving-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_SKEW" : Feature attribution scores to detect skew
  /// between Training-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_DRIFT" : Feature attribution scores to detect skew
  /// between Prediction datasets collected within different time windows.
  core.String? objective;

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomalies({
    this.anomalyCount,
    this.deployedModelId,
    this.featureStats,
    this.objective,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomalies.fromJson(
    core.Map json_,
  ) : this(
        anomalyCount: json_['anomalyCount'] as core.int?,
        deployedModelId: json_['deployedModelId'] as core.String?,
        featureStats:
            (json_['featureStats'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        objective: json_['objective'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (anomalyCount != null) 'anomalyCount': anomalyCount!,
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (featureStats != null) 'featureStats': featureStats!,
    if (objective != null) 'objective': objective!,
  };
}

/// Historical Stats (and Anomalies) for a specific Feature.
class GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies {
  /// Display Name of the Feature.
  core.String? featureDisplayName;

  /// A list of historical stats generated by different time window's Prediction
  /// Dataset.
  core.List<GoogleCloudAiplatformV1beta1FeatureStatsAnomaly>? predictionStats;

  /// Threshold for anomaly detection.
  GoogleCloudAiplatformV1beta1ThresholdConfig? threshold;

  /// Stats calculated for the Training Dataset.
  GoogleCloudAiplatformV1beta1FeatureStatsAnomaly? trainingStats;

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies({
    this.featureDisplayName,
    this.predictionStats,
    this.threshold,
    this.trainingStats,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies.fromJson(
    core.Map json_,
  ) : this(
        featureDisplayName: json_['featureDisplayName'] as core.String?,
        predictionStats:
            (json_['predictionStats'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureStatsAnomaly.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        threshold:
            json_.containsKey('threshold')
                ? GoogleCloudAiplatformV1beta1ThresholdConfig.fromJson(
                  json_['threshold'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingStats:
            json_.containsKey('trainingStats')
                ? GoogleCloudAiplatformV1beta1FeatureStatsAnomaly.fromJson(
                  json_['trainingStats'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureDisplayName != null) 'featureDisplayName': featureDisplayName!,
    if (predictionStats != null) 'predictionStats': predictionStats!,
    if (threshold != null) 'threshold': threshold!,
    if (trainingStats != null) 'trainingStats': trainingStats!,
  };
}

/// Represents a single statistics data point.
class GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPoint {
  /// Algorithm used to calculated the metrics, eg: jensen_shannon_divergence,
  /// l_infinity.
  core.String? algorithm;

  /// Statistics from baseline dataset.
  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValue?
  baselineStats;

  /// Statistics create time.
  core.String? createTime;

  /// Statistics from current dataset.
  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValue?
  currentStats;

  /// Indicate if the statistics has anomaly.
  core.bool? hasAnomaly;

  /// Model monitoring job resource name.
  core.String? modelMonitoringJob;

  /// Schedule resource name.
  core.String? schedule;

  /// Threshold value.
  core.double? thresholdValue;

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPoint({
    this.algorithm,
    this.baselineStats,
    this.createTime,
    this.currentStats,
    this.hasAnomaly,
    this.modelMonitoringJob,
    this.schedule,
    this.thresholdValue,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPoint.fromJson(
    core.Map json_,
  ) : this(
        algorithm: json_['algorithm'] as core.String?,
        baselineStats:
            json_.containsKey('baselineStats')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValue.fromJson(
                  json_['baselineStats'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        currentStats:
            json_.containsKey('currentStats')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValue.fromJson(
                  json_['currentStats'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        hasAnomaly: json_['hasAnomaly'] as core.bool?,
        modelMonitoringJob: json_['modelMonitoringJob'] as core.String?,
        schedule: json_['schedule'] as core.String?,
        thresholdValue: (json_['thresholdValue'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algorithm != null) 'algorithm': algorithm!,
    if (baselineStats != null) 'baselineStats': baselineStats!,
    if (createTime != null) 'createTime': createTime!,
    if (currentStats != null) 'currentStats': currentStats!,
    if (hasAnomaly != null) 'hasAnomaly': hasAnomaly!,
    if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob!,
    if (schedule != null) 'schedule': schedule!,
    if (thresholdValue != null) 'thresholdValue': thresholdValue!,
  };
}

/// Typed value of the statistics.
class GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValue {
  /// Distribution.
  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValueDistributionDataValue?
  distributionValue;

  /// Double.
  core.double? doubleValue;

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValue({
    this.distributionValue,
    this.doubleValue,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValue.fromJson(
    core.Map json_,
  ) : this(
        distributionValue:
            json_.containsKey('distributionValue')
                ? GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValueDistributionDataValue.fromJson(
                  json_['distributionValue']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (distributionValue != null) 'distributionValue': distributionValue!,
    if (doubleValue != null) 'doubleValue': doubleValue!,
  };
}

/// Summary statistics for a population of values.
class GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValueDistributionDataValue {
  /// Predictive monitoring drift distribution in
  /// `tensorflow.metadata.v0.DatasetFeatureStatistics` format.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? distribution;

  /// Distribution distance deviation from the current dataset's statistics to
  /// baseline dataset's statistics.
  ///
  /// * For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm or JensenShannon divergence. * For numerical feature,
  /// the distribution distance is calculated by JensenShannon divergence.
  core.double? distributionDeviation;

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValueDistributionDataValue({
    this.distribution,
    this.distributionDeviation,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPointTypedValueDistributionDataValue.fromJson(
    core.Map json_,
  ) : this(
        distribution: json_['distribution'],
        distributionDeviation:
            (json_['distributionDeviation'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (distribution != null) 'distribution': distribution!,
    if (distributionDeviation != null)
      'distributionDeviation': distributionDeviation!,
  };
}

/// A collection of data points that describes the time-varying values of a
/// tabular metric.
class GoogleCloudAiplatformV1beta1ModelMonitoringTabularStats {
  /// The data points of this time series.
  ///
  /// When listing time series, points are returned in reverse time order.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPoint>?
  dataPoints;

  /// One of the supported monitoring objectives: `raw-feature-drift`
  /// `prediction-output-drift` `feature-attribution`
  core.String? objectiveType;

  /// The stats name.
  core.String? statsName;

  GoogleCloudAiplatformV1beta1ModelMonitoringTabularStats({
    this.dataPoints,
    this.objectiveType,
    this.statsName,
  });

  GoogleCloudAiplatformV1beta1ModelMonitoringTabularStats.fromJson(
    core.Map json_,
  ) : this(
        dataPoints:
            (json_['dataPoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringStatsDataPoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        objectiveType: json_['objectiveType'] as core.String?,
        statsName: json_['statsName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataPoints != null) 'dataPoints': dataPoints!,
    if (objectiveType != null) 'objectiveType': objectiveType!,
    if (statsName != null) 'statsName': statsName!,
  };
}

/// Contains information about the original Model if this Model is a copy.
typedef GoogleCloudAiplatformV1beta1ModelOriginalModelInfo =
    $ModelOriginalModelInfo;

/// Detail description of the source information of the model.
typedef GoogleCloudAiplatformV1beta1ModelSourceInfo = $ModelSourceInfo;

/// Describes the machine learning model version checkpoint.
typedef GoogleCloudAiplatformV1beta1ModelVersionCheckpoint =
    $ModelVersionCheckpoint;

/// Request message for EndpointService.MutateDeployedModel.
class GoogleCloudAiplatformV1beta1MutateDeployedModelRequest {
  /// The DeployedModel to be mutated within the Endpoint.
  ///
  /// Only the following fields can be mutated: * `min_replica_count` in either
  /// DedicatedResources or AutomaticResources * `max_replica_count` in either
  /// DedicatedResources or AutomaticResources * `required_replica_count` in
  /// DedicatedResources * autoscaling_metric_specs *
  /// `disable_container_logging` (v1 only) * `enable_container_logging`
  /// (v1beta1 only)
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1DeployedModel? deployedModel;

  /// The update mask applies to the resource.
  ///
  /// See google.protobuf.FieldMask.
  ///
  /// Required.
  core.String? updateMask;

  GoogleCloudAiplatformV1beta1MutateDeployedModelRequest({
    this.deployedModel,
    this.updateMask,
  });

  GoogleCloudAiplatformV1beta1MutateDeployedModelRequest.fromJson(
    core.Map json_,
  ) : this(
        deployedModel:
            json_.containsKey('deployedModel')
                ? GoogleCloudAiplatformV1beta1DeployedModel.fromJson(
                  json_['deployedModel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateMask: json_['updateMask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedModel != null) 'deployedModel': deployedModel!,
    if (updateMask != null) 'updateMask': updateMask!,
  };
}

/// Represents a Neural Architecture Search (NAS) job.
class GoogleCloudAiplatformV1beta1NasJob {
  /// Time when the NasJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the NasJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Enable a separation of Custom model training and restricted image training
  /// for tenant project.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableRestrictedImageTraining;

  /// Customer-managed encryption key options for a NasJob.
  ///
  /// If this is set, then all resources created by the NasJob will be encrypted
  /// with the provided encryption key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Time when the NasJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize NasJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the NasJob.
  ///
  /// Output only.
  core.String? name;

  /// Output of the NasJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NasJobOutput? nasJobOutput;

  /// The specification of a NasJob.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1NasJobSpec? nasJobSpec;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the NasJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Time when the NasJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1NasJob({
    this.createTime,
    this.displayName,
    this.enableRestrictedImageTraining,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.labels,
    this.name,
    this.nasJobOutput,
    this.nasJobSpec,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1NasJob.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        enableRestrictedImageTraining:
            json_['enableRestrictedImageTraining'] as core.bool?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        nasJobOutput:
            json_.containsKey('nasJobOutput')
                ? GoogleCloudAiplatformV1beta1NasJobOutput.fromJson(
                  json_['nasJobOutput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        nasJobSpec:
            json_.containsKey('nasJobSpec')
                ? GoogleCloudAiplatformV1beta1NasJobSpec.fromJson(
                  json_['nasJobSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (enableRestrictedImageTraining != null)
      'enableRestrictedImageTraining': enableRestrictedImageTraining!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (nasJobOutput != null) 'nasJobOutput': nasJobOutput!,
    if (nasJobSpec != null) 'nasJobSpec': nasJobSpec!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Represents a uCAIP NasJob output.
class GoogleCloudAiplatformV1beta1NasJobOutput {
  /// The output of this multi-trial Neural Architecture Search (NAS) job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NasJobOutputMultiTrialJobOutput?
  multiTrialJobOutput;

  GoogleCloudAiplatformV1beta1NasJobOutput({this.multiTrialJobOutput});

  GoogleCloudAiplatformV1beta1NasJobOutput.fromJson(core.Map json_)
    : this(
        multiTrialJobOutput:
            json_.containsKey('multiTrialJobOutput')
                ? GoogleCloudAiplatformV1beta1NasJobOutputMultiTrialJobOutput.fromJson(
                  json_['multiTrialJobOutput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (multiTrialJobOutput != null)
      'multiTrialJobOutput': multiTrialJobOutput!,
  };
}

/// The output of a multi-trial Neural Architecture Search (NAS) jobs.
class GoogleCloudAiplatformV1beta1NasJobOutputMultiTrialJobOutput {
  /// List of NasTrials that were started as part of search stage.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1NasTrial>? searchTrials;

  /// List of NasTrials that were started as part of train stage.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1NasTrial>? trainTrials;

  GoogleCloudAiplatformV1beta1NasJobOutputMultiTrialJobOutput({
    this.searchTrials,
    this.trainTrials,
  });

  GoogleCloudAiplatformV1beta1NasJobOutputMultiTrialJobOutput.fromJson(
    core.Map json_,
  ) : this(
        searchTrials:
            (json_['searchTrials'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1NasTrial.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        trainTrials:
            (json_['trainTrials'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1NasTrial.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (searchTrials != null) 'searchTrials': searchTrials!,
    if (trainTrials != null) 'trainTrials': trainTrials!,
  };
}

/// Represents the spec of a NasJob.
class GoogleCloudAiplatformV1beta1NasJobSpec {
  /// The spec of multi-trial algorithms.
  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpec?
  multiTrialAlgorithmSpec;

  /// The ID of the existing NasJob in the same Project and Location which will
  /// be used to resume search.
  ///
  /// search_space_spec and nas_algorithm_spec are obtained from previous NasJob
  /// hence should not provide them again for this NasJob.
  core.String? resumeNasJobId;

  /// It defines the search space for Neural Architecture Search (NAS).
  core.String? searchSpaceSpec;

  GoogleCloudAiplatformV1beta1NasJobSpec({
    this.multiTrialAlgorithmSpec,
    this.resumeNasJobId,
    this.searchSpaceSpec,
  });

  GoogleCloudAiplatformV1beta1NasJobSpec.fromJson(core.Map json_)
    : this(
        multiTrialAlgorithmSpec:
            json_.containsKey('multiTrialAlgorithmSpec')
                ? GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpec.fromJson(
                  json_['multiTrialAlgorithmSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        resumeNasJobId: json_['resumeNasJobId'] as core.String?,
        searchSpaceSpec: json_['searchSpaceSpec'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (multiTrialAlgorithmSpec != null)
      'multiTrialAlgorithmSpec': multiTrialAlgorithmSpec!,
    if (resumeNasJobId != null) 'resumeNasJobId': resumeNasJobId!,
    if (searchSpaceSpec != null) 'searchSpaceSpec': searchSpaceSpec!,
  };
}

/// The spec of multi-trial Neural Architecture Search (NAS).
class GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpec {
  /// Metric specs for the NAS job.
  ///
  /// Validation for this field is done at `multi_trial_algorithm_spec` field.
  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecMetricSpec?
  metric;

  /// The multi-trial Neural Architecture Search (NAS) algorithm type.
  ///
  /// Defaults to `REINFORCEMENT_LEARNING`.
  /// Possible string values are:
  /// - "MULTI_TRIAL_ALGORITHM_UNSPECIFIED" : Defaults to
  /// `REINFORCEMENT_LEARNING`.
  /// - "REINFORCEMENT_LEARNING" : The Reinforcement Learning Algorithm for
  /// Multi-trial Neural Architecture Search (NAS).
  /// - "GRID_SEARCH" : The Grid Search Algorithm for Multi-trial Neural
  /// Architecture Search (NAS).
  core.String? multiTrialAlgorithm;

  /// Spec for search trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec?
  searchTrialSpec;

  /// Spec for train trials.
  ///
  /// Top N \[TrainTrialSpec.max_parallel_trial_count\] search trials will be
  /// trained for every M \[TrainTrialSpec.frequency\] trials searched.
  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec?
  trainTrialSpec;

  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpec({
    this.metric,
    this.multiTrialAlgorithm,
    this.searchTrialSpec,
    this.trainTrialSpec,
  });

  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpec.fromJson(
    core.Map json_,
  ) : this(
        metric:
            json_.containsKey('metric')
                ? GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecMetricSpec.fromJson(
                  json_['metric'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        multiTrialAlgorithm: json_['multiTrialAlgorithm'] as core.String?,
        searchTrialSpec:
            json_.containsKey('searchTrialSpec')
                ? GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec.fromJson(
                  json_['searchTrialSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainTrialSpec:
            json_.containsKey('trainTrialSpec')
                ? GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec.fromJson(
                  json_['trainTrialSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metric != null) 'metric': metric!,
    if (multiTrialAlgorithm != null)
      'multiTrialAlgorithm': multiTrialAlgorithm!,
    if (searchTrialSpec != null) 'searchTrialSpec': searchTrialSpec!,
    if (trainTrialSpec != null) 'trainTrialSpec': trainTrialSpec!,
  };
}

/// Represents a metric to optimize.
typedef GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecMetricSpec =
    $NasJobSpecMultiTrialAlgorithmSpecMetricSpec;

/// Represent spec for search trials.
class GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec {
  /// The number of failed trials that need to be seen before failing the
  /// NasJob.
  ///
  /// If set to 0, Vertex AI decides how many trials must fail before the whole
  /// job fails.
  core.int? maxFailedTrialCount;

  /// The maximum number of trials to run in parallel.
  ///
  /// Required.
  core.int? maxParallelTrialCount;

  /// The maximum number of Neural Architecture Search (NAS) trials to run.
  ///
  /// Required.
  core.int? maxTrialCount;

  /// The spec of a search trial job.
  ///
  /// The same spec applies to all search trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CustomJobSpec? searchTrialJobSpec;

  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec({
    this.maxFailedTrialCount,
    this.maxParallelTrialCount,
    this.maxTrialCount,
    this.searchTrialJobSpec,
  });

  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec.fromJson(
    core.Map json_,
  ) : this(
        maxFailedTrialCount: json_['maxFailedTrialCount'] as core.int?,
        maxParallelTrialCount: json_['maxParallelTrialCount'] as core.int?,
        maxTrialCount: json_['maxTrialCount'] as core.int?,
        searchTrialJobSpec:
            json_.containsKey('searchTrialJobSpec')
                ? GoogleCloudAiplatformV1beta1CustomJobSpec.fromJson(
                  json_['searchTrialJobSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxFailedTrialCount != null)
      'maxFailedTrialCount': maxFailedTrialCount!,
    if (maxParallelTrialCount != null)
      'maxParallelTrialCount': maxParallelTrialCount!,
    if (maxTrialCount != null) 'maxTrialCount': maxTrialCount!,
    if (searchTrialJobSpec != null) 'searchTrialJobSpec': searchTrialJobSpec!,
  };
}

/// Represent spec for train trials.
class GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec {
  /// Frequency of search trials to start train stage.
  ///
  /// Top N \[TrainTrialSpec.max_parallel_trial_count\] search trials will be
  /// trained for every M \[TrainTrialSpec.frequency\] trials searched.
  ///
  /// Required.
  core.int? frequency;

  /// The maximum number of trials to run in parallel.
  ///
  /// Required.
  core.int? maxParallelTrialCount;

  /// The spec of a train trial job.
  ///
  /// The same spec applies to all train trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1CustomJobSpec? trainTrialJobSpec;

  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec({
    this.frequency,
    this.maxParallelTrialCount,
    this.trainTrialJobSpec,
  });

  GoogleCloudAiplatformV1beta1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec.fromJson(
    core.Map json_,
  ) : this(
        frequency: json_['frequency'] as core.int?,
        maxParallelTrialCount: json_['maxParallelTrialCount'] as core.int?,
        trainTrialJobSpec:
            json_.containsKey('trainTrialJobSpec')
                ? GoogleCloudAiplatformV1beta1CustomJobSpec.fromJson(
                  json_['trainTrialJobSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (frequency != null) 'frequency': frequency!,
    if (maxParallelTrialCount != null)
      'maxParallelTrialCount': maxParallelTrialCount!,
    if (trainTrialJobSpec != null) 'trainTrialJobSpec': trainTrialJobSpec!,
  };
}

/// Represents a uCAIP NasJob trial.
class GoogleCloudAiplatformV1beta1NasTrial {
  /// Time when the NasTrial's status changed to `SUCCEEDED` or `INFEASIBLE`.
  ///
  /// Output only.
  core.String? endTime;

  /// The final measurement containing the objective value.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1Measurement? finalMeasurement;

  /// The identifier of the NasTrial assigned by the service.
  ///
  /// Output only.
  core.String? id;

  /// Time when the NasTrial was started.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the NasTrial.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The NasTrial state is unspecified.
  /// - "REQUESTED" : Indicates that a specific NasTrial has been requested, but
  /// it has not yet been suggested by the service.
  /// - "ACTIVE" : Indicates that the NasTrial has been suggested.
  /// - "STOPPING" : Indicates that the NasTrial should stop according to the
  /// service.
  /// - "SUCCEEDED" : Indicates that the NasTrial is completed successfully.
  /// - "INFEASIBLE" : Indicates that the NasTrial should not be attempted
  /// again. The service will set a NasTrial to INFEASIBLE when it's done but
  /// missing the final_measurement.
  core.String? state;

  GoogleCloudAiplatformV1beta1NasTrial({
    this.endTime,
    this.finalMeasurement,
    this.id,
    this.startTime,
    this.state,
  });

  GoogleCloudAiplatformV1beta1NasTrial.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        finalMeasurement:
            json_.containsKey('finalMeasurement')
                ? GoogleCloudAiplatformV1beta1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        id: json_['id'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
    if (id != null) 'id': id!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
  };
}

/// Represents a NasTrial details along with its parameters.
///
/// If there is a corresponding train NasTrial, the train NasTrial is also
/// returned.
class GoogleCloudAiplatformV1beta1NasTrialDetail {
  /// Resource name of the NasTrialDetail.
  ///
  /// Output only.
  core.String? name;

  /// The parameters for the NasJob NasTrial.
  core.String? parameters;

  /// The requested search NasTrial.
  GoogleCloudAiplatformV1beta1NasTrial? searchTrial;

  /// The train NasTrial corresponding to search_trial.
  ///
  /// Only populated if search_trial is used for training.
  GoogleCloudAiplatformV1beta1NasTrial? trainTrial;

  GoogleCloudAiplatformV1beta1NasTrialDetail({
    this.name,
    this.parameters,
    this.searchTrial,
    this.trainTrial,
  });

  GoogleCloudAiplatformV1beta1NasTrialDetail.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        parameters: json_['parameters'] as core.String?,
        searchTrial:
            json_.containsKey('searchTrial')
                ? GoogleCloudAiplatformV1beta1NasTrial.fromJson(
                  json_['searchTrial'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainTrial:
            json_.containsKey('trainTrial')
                ? GoogleCloudAiplatformV1beta1NasTrial.fromJson(
                  json_['trainTrial'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (parameters != null) 'parameters': parameters!,
    if (searchTrial != null) 'searchTrial': searchTrial!,
    if (trainTrial != null) 'trainTrial': trainTrial!,
  };
}

/// A query to find a number of similar entities.
class GoogleCloudAiplatformV1beta1NearestNeighborQuery {
  /// The embedding vector that be used for similar search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1NearestNeighborQueryEmbedding? embedding;

  /// The entity id whose similar entities should be searched for.
  ///
  /// If embedding is set, search will use embedding instead of entity_id.
  ///
  /// Optional.
  core.String? entityId;

  /// The number of similar entities to be retrieved from feature view for each
  /// query.
  ///
  /// Optional.
  core.int? neighborCount;

  /// The list of numeric filters.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1NearestNeighborQueryNumericFilter>?
  numericFilters;

  /// Parameters that can be set to tune query on the fly.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1NearestNeighborQueryParameters? parameters;

  /// Crowding is a constraint on a neighbor list produced by nearest neighbor
  /// search requiring that no more than sper_crowding_attribute_neighbor_count
  /// of the k neighbors returned have the same value of crowding_attribute.
  ///
  /// It's used for improving result diversity.
  ///
  /// Optional.
  core.int? perCrowdingAttributeNeighborCount;

  /// The list of string filters.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1NearestNeighborQueryStringFilter>?
  stringFilters;

  GoogleCloudAiplatformV1beta1NearestNeighborQuery({
    this.embedding,
    this.entityId,
    this.neighborCount,
    this.numericFilters,
    this.parameters,
    this.perCrowdingAttributeNeighborCount,
    this.stringFilters,
  });

  GoogleCloudAiplatformV1beta1NearestNeighborQuery.fromJson(core.Map json_)
    : this(
        embedding:
            json_.containsKey('embedding')
                ? GoogleCloudAiplatformV1beta1NearestNeighborQueryEmbedding.fromJson(
                  json_['embedding'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        entityId: json_['entityId'] as core.String?,
        neighborCount: json_['neighborCount'] as core.int?,
        numericFilters:
            (json_['numericFilters'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1NearestNeighborQueryNumericFilter.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1NearestNeighborQueryParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        perCrowdingAttributeNeighborCount:
            json_['perCrowdingAttributeNeighborCount'] as core.int?,
        stringFilters:
            (json_['stringFilters'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1NearestNeighborQueryStringFilter.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (embedding != null) 'embedding': embedding!,
    if (entityId != null) 'entityId': entityId!,
    if (neighborCount != null) 'neighborCount': neighborCount!,
    if (numericFilters != null) 'numericFilters': numericFilters!,
    if (parameters != null) 'parameters': parameters!,
    if (perCrowdingAttributeNeighborCount != null)
      'perCrowdingAttributeNeighborCount': perCrowdingAttributeNeighborCount!,
    if (stringFilters != null) 'stringFilters': stringFilters!,
  };
}

/// The embedding vector.
typedef GoogleCloudAiplatformV1beta1NearestNeighborQueryEmbedding =
    $NearestNeighborQueryEmbedding;

/// Numeric filter is used to search a subset of the entities by using boolean
/// rules on numeric columns.
///
/// For example: Database Point 0: {name: "a" value_int: 42} {name: "b"
/// value_float: 1.0} Database Point 1: {name: "a" value_int: 10} {name: "b"
/// value_float: 2.0} Database Point 2: {name: "a" value_int: -1} {name: "b"
/// value_float: 3.0} Query: {name: "a" value_int: 12 operator: LESS} // Matches
/// Point 1, 2 {name: "b" value_float: 2.0 operator: EQUAL} // Matches Point 1
typedef GoogleCloudAiplatformV1beta1NearestNeighborQueryNumericFilter =
    $NearestNeighborQueryNumericFilter;

/// Parameters that can be overrided in each query to tune query latency and
/// recall.
typedef GoogleCloudAiplatformV1beta1NearestNeighborQueryParameters =
    $NearestNeighborQueryParameters;

/// String filter is used to search a subset of the entities by using boolean
/// rules on string columns.
///
/// For example: if a query specifies string filter with 'name = color,
/// allow_tokens = {red, blue}, deny_tokens = {purple}',' then that query will
/// match entities that are red or blue, but if those points are also purple,
/// then they will be excluded even if they are red/blue. Only string filter is
/// supported for now, numeric filter will be supported in the near future.
typedef GoogleCloudAiplatformV1beta1NearestNeighborQueryStringFilter =
    $NearestNeighborQueryStringFilter;

/// Nearest neighbors for one query.
class GoogleCloudAiplatformV1beta1NearestNeighbors {
  /// All its neighbors.
  core.List<GoogleCloudAiplatformV1beta1NearestNeighborsNeighbor>? neighbors;

  GoogleCloudAiplatformV1beta1NearestNeighbors({this.neighbors});

  GoogleCloudAiplatformV1beta1NearestNeighbors.fromJson(core.Map json_)
    : this(
        neighbors:
            (json_['neighbors'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1NearestNeighborsNeighbor.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (neighbors != null) 'neighbors': neighbors!,
  };
}

/// A neighbor of the query vector.
class GoogleCloudAiplatformV1beta1NearestNeighborsNeighbor {
  /// The distance between the neighbor and the query vector.
  core.double? distance;

  /// The id of the similar entity.
  core.String? entityId;

  /// The attributes of the neighbor, e.g. filters, crowding and metadata Note
  /// that full entities are returned only when "return_full_entity" is set to
  /// true.
  ///
  /// Otherwise, only the "entity_id" and "distance" fields are populated.
  GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse? entityKeyValues;

  GoogleCloudAiplatformV1beta1NearestNeighborsNeighbor({
    this.distance,
    this.entityId,
    this.entityKeyValues,
  });

  GoogleCloudAiplatformV1beta1NearestNeighborsNeighbor.fromJson(core.Map json_)
    : this(
        distance: (json_['distance'] as core.num?)?.toDouble(),
        entityId: json_['entityId'] as core.String?,
        entityKeyValues:
            json_.containsKey('entityKeyValues')
                ? GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse.fromJson(
                  json_['entityKeyValues']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (distance != null) 'distance': distance!,
    if (entityId != null) 'entityId': entityId!,
    if (entityKeyValues != null) 'entityKeyValues': entityKeyValues!,
  };
}

/// Neighbors for example-based explanations.
typedef GoogleCloudAiplatformV1beta1Neighbor = $Neighbor;

/// Network spec.
typedef GoogleCloudAiplatformV1beta1NetworkSpec = $NetworkSpec;

/// Represents a mount configuration for Network File System (NFS) to mount.
typedef GoogleCloudAiplatformV1beta1NfsMount = $NfsMount;

/// The euc configuration of NotebookRuntimeTemplate.
typedef GoogleCloudAiplatformV1beta1NotebookEucConfig = $NotebookEucConfig;

/// NotebookExecutionJob represents an instance of a notebook execution.
class GoogleCloudAiplatformV1beta1NotebookExecutionJob {
  /// Timestamp when this NotebookExecutionJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The custom compute configuration for an execution job.
  GoogleCloudAiplatformV1beta1NotebookExecutionJobCustomEnvironmentSpec?
  customEnvironmentSpec;

  /// The Dataform Repository pointing to a single file notebook repository.
  GoogleCloudAiplatformV1beta1NotebookExecutionJobDataformRepositorySource?
  dataformRepositorySource;

  /// The contents of an input notebook file.
  GoogleCloudAiplatformV1beta1NotebookExecutionJobDirectNotebookSource?
  directNotebookSource;

  /// The display name of the NotebookExecutionJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  core.String? displayName;

  /// Customer-managed encryption key spec for the notebook execution job.
  ///
  /// This field is auto-populated if the NotebookRuntimeTemplate has an
  /// encryption spec.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Max running time of the execution job in seconds (default 86400s / 24
  /// hrs).
  core.String? executionTimeout;

  /// The user email to run the execution as.
  ///
  /// Only supported by Colab runtimes.
  core.String? executionUser;

  /// The Cloud Storage url pointing to the ipynb file.
  ///
  /// Format: `gs://bucket/notebook_file.ipynb`
  GoogleCloudAiplatformV1beta1NotebookExecutionJobGcsNotebookSource?
  gcsNotebookSource;

  /// The Cloud Storage location to upload the result to.
  ///
  /// Format: `gs://bucket-name`
  core.String? gcsOutputUri;

  /// The state of the NotebookExecutionJob.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? jobState;

  /// The name of the kernel to use during notebook execution.
  ///
  /// If unset, the default kernel is used.
  core.String? kernelName;

  /// The labels with user-defined metadata to organize NotebookExecutionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? labels;

  /// The resource name of this NotebookExecutionJob.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
  ///
  /// Output only.
  core.String? name;

  /// The NotebookRuntimeTemplate to source compute configuration from.
  core.String? notebookRuntimeTemplateResourceName;

  /// The Schedule resource name if this job is triggered by one.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
  core.String? scheduleResourceName;

  /// The service account to run the execution as.
  core.String? serviceAccount;

  /// Populated when the NotebookExecutionJob is completed.
  ///
  /// When there is an error during notebook execution, the error details are
  /// populated.
  ///
  /// Output only.
  GoogleRpcStatus? status;

  /// Timestamp when this NotebookExecutionJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The Workbench runtime configuration to use for the notebook execution.
  GoogleCloudAiplatformV1beta1NotebookExecutionJobWorkbenchRuntime?
  workbenchRuntime;

  GoogleCloudAiplatformV1beta1NotebookExecutionJob({
    this.createTime,
    this.customEnvironmentSpec,
    this.dataformRepositorySource,
    this.directNotebookSource,
    this.displayName,
    this.encryptionSpec,
    this.executionTimeout,
    this.executionUser,
    this.gcsNotebookSource,
    this.gcsOutputUri,
    this.jobState,
    this.kernelName,
    this.labels,
    this.name,
    this.notebookRuntimeTemplateResourceName,
    this.scheduleResourceName,
    this.serviceAccount,
    this.status,
    this.updateTime,
    this.workbenchRuntime,
  });

  GoogleCloudAiplatformV1beta1NotebookExecutionJob.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        customEnvironmentSpec:
            json_.containsKey('customEnvironmentSpec')
                ? GoogleCloudAiplatformV1beta1NotebookExecutionJobCustomEnvironmentSpec.fromJson(
                  json_['customEnvironmentSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        dataformRepositorySource:
            json_.containsKey('dataformRepositorySource')
                ? GoogleCloudAiplatformV1beta1NotebookExecutionJobDataformRepositorySource.fromJson(
                  json_['dataformRepositorySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        directNotebookSource:
            json_.containsKey('directNotebookSource')
                ? GoogleCloudAiplatformV1beta1NotebookExecutionJobDirectNotebookSource.fromJson(
                  json_['directNotebookSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        executionTimeout: json_['executionTimeout'] as core.String?,
        executionUser: json_['executionUser'] as core.String?,
        gcsNotebookSource:
            json_.containsKey('gcsNotebookSource')
                ? GoogleCloudAiplatformV1beta1NotebookExecutionJobGcsNotebookSource.fromJson(
                  json_['gcsNotebookSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsOutputUri: json_['gcsOutputUri'] as core.String?,
        jobState: json_['jobState'] as core.String?,
        kernelName: json_['kernelName'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        notebookRuntimeTemplateResourceName:
            json_['notebookRuntimeTemplateResourceName'] as core.String?,
        scheduleResourceName: json_['scheduleResourceName'] as core.String?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        status:
            json_.containsKey('status')
                ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
        workbenchRuntime:
            json_.containsKey('workbenchRuntime')
                ? GoogleCloudAiplatformV1beta1NotebookExecutionJobWorkbenchRuntime.fromJson(
                  json_['workbenchRuntime']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (customEnvironmentSpec != null)
      'customEnvironmentSpec': customEnvironmentSpec!,
    if (dataformRepositorySource != null)
      'dataformRepositorySource': dataformRepositorySource!,
    if (directNotebookSource != null)
      'directNotebookSource': directNotebookSource!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (executionTimeout != null) 'executionTimeout': executionTimeout!,
    if (executionUser != null) 'executionUser': executionUser!,
    if (gcsNotebookSource != null) 'gcsNotebookSource': gcsNotebookSource!,
    if (gcsOutputUri != null) 'gcsOutputUri': gcsOutputUri!,
    if (jobState != null) 'jobState': jobState!,
    if (kernelName != null) 'kernelName': kernelName!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (notebookRuntimeTemplateResourceName != null)
      'notebookRuntimeTemplateResourceName':
          notebookRuntimeTemplateResourceName!,
    if (scheduleResourceName != null)
      'scheduleResourceName': scheduleResourceName!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (status != null) 'status': status!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (workbenchRuntime != null) 'workbenchRuntime': workbenchRuntime!,
  };
}

/// Compute configuration to use for an execution job.
class GoogleCloudAiplatformV1beta1NotebookExecutionJobCustomEnvironmentSpec {
  /// The specification of a single machine for the execution job.
  GoogleCloudAiplatformV1beta1MachineSpec? machineSpec;

  /// The network configuration to use for the execution job.
  GoogleCloudAiplatformV1beta1NetworkSpec? networkSpec;

  /// The specification of a persistent disk to attach for the execution job.
  GoogleCloudAiplatformV1beta1PersistentDiskSpec? persistentDiskSpec;

  GoogleCloudAiplatformV1beta1NotebookExecutionJobCustomEnvironmentSpec({
    this.machineSpec,
    this.networkSpec,
    this.persistentDiskSpec,
  });

  GoogleCloudAiplatformV1beta1NotebookExecutionJobCustomEnvironmentSpec.fromJson(
    core.Map json_,
  ) : this(
        machineSpec:
            json_.containsKey('machineSpec')
                ? GoogleCloudAiplatformV1beta1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        networkSpec:
            json_.containsKey('networkSpec')
                ? GoogleCloudAiplatformV1beta1NetworkSpec.fromJson(
                  json_['networkSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        persistentDiskSpec:
            json_.containsKey('persistentDiskSpec')
                ? GoogleCloudAiplatformV1beta1PersistentDiskSpec.fromJson(
                  json_['persistentDiskSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (machineSpec != null) 'machineSpec': machineSpec!,
    if (networkSpec != null) 'networkSpec': networkSpec!,
    if (persistentDiskSpec != null) 'persistentDiskSpec': persistentDiskSpec!,
  };
}

/// The Dataform Repository containing the input notebook.
typedef GoogleCloudAiplatformV1beta1NotebookExecutionJobDataformRepositorySource =
    $NotebookExecutionJobDataformRepositorySource;

/// The content of the input notebook in ipynb format.
typedef GoogleCloudAiplatformV1beta1NotebookExecutionJobDirectNotebookSource =
    $NotebookExecutionJobDirectNotebookSource;

/// The Cloud Storage uri for the input notebook.
typedef GoogleCloudAiplatformV1beta1NotebookExecutionJobGcsNotebookSource =
    $NotebookExecutionJobGcsNotebookSource;

/// Configuration for a Workbench Instances-based environment.
typedef GoogleCloudAiplatformV1beta1NotebookExecutionJobWorkbenchRuntime =
    $Empty;

/// The idle shutdown configuration of NotebookRuntimeTemplate, which contains
/// the idle_timeout as required field.
typedef GoogleCloudAiplatformV1beta1NotebookIdleShutdownConfig =
    $NotebookIdleShutdownConfig;

/// Notebook Reservation Affinity for consuming Zonal reservation.
typedef GoogleCloudAiplatformV1beta1NotebookReservationAffinity =
    $NotebookReservationAffinity;

/// A runtime is a virtual machine allocated to a particular user for a
/// particular Notebook file on temporary basis with lifetime.
///
/// Default runtimes have a lifetime of 18 hours, while custom runtimes last for
/// 6 months from their creation or last upgrade.
class GoogleCloudAiplatformV1beta1NotebookRuntime {
  /// Timestamp when this NotebookRuntime was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The specification of persistent disk attached to the notebook runtime as
  /// data disk storage.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PersistentDiskSpec? dataPersistentDiskSpec;

  /// The description of the NotebookRuntime.
  core.String? description;

  /// The display name of the NotebookRuntime.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// EUC configuration of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NotebookEucConfig? eucConfig;

  /// Timestamp when this NotebookRuntime will be expired: 1.
  ///
  /// System Predefined NotebookRuntime: 24 hours after creation. After
  /// expiration, system predifined runtime will be deleted. 2. User created
  /// NotebookRuntime: 6 months after last upgrade. After expiration, user
  /// created runtime will be stopped and allowed for upgrade.
  ///
  /// Output only.
  core.String? expirationTime;

  /// The health state of the NotebookRuntime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HEALTH_STATE_UNSPECIFIED" : Unspecified health state.
  /// - "HEALTHY" : NotebookRuntime is in healthy state. Applies to ACTIVE
  /// state.
  /// - "UNHEALTHY" : NotebookRuntime is in unhealthy state. Applies to ACTIVE
  /// state.
  core.String? healthState;

  /// The idle shutdown configuration of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NotebookIdleShutdownConfig? idleShutdownConfig;

  /// Whether NotebookRuntime is upgradable.
  ///
  /// Output only.
  core.bool? isUpgradable;

  /// The labels with user-defined metadata to organize your NotebookRuntime.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one NotebookRuntime (System labels
  /// are excluded). See https://goo.gl/xmQnxf for more information and examples
  /// of labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for NotebookRuntime: *
  /// "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output only,
  /// its value is the Compute Engine instance id. *
  /// "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
  /// either "bigquery" or "vertex"; if absent, it should be "vertex". This is
  /// to describe the entry service, either BigQuery or Vertex.
  core.Map<core.String, core.String>? labels;

  /// The specification of a single machine used by the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1MachineSpec? machineSpec;

  /// The resource name of the NotebookRuntime.
  ///
  /// Output only.
  core.String? name;

  /// Network spec of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NetworkSpec? networkSpec;

  /// The Compute Engine tags to add to runtime (see
  /// [Tagging instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  ///
  /// Optional.
  core.List<core.String>? networkTags;

  /// The pointer to NotebookRuntimeTemplate this NotebookRuntime is created
  /// from.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NotebookRuntimeTemplateRef?
  notebookRuntimeTemplateRef;

  /// The type of the notebook runtime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" : Unspecified notebook runtime type,
  /// NotebookRuntimeType will default to USER_DEFINED.
  /// - "USER_DEFINED" : runtime or template with coustomized configurations
  /// from user.
  /// - "ONE_CLICK" : runtime or template with system defined configurations.
  core.String? notebookRuntimeType;

  /// The proxy endpoint used to access the NotebookRuntime.
  ///
  /// Output only.
  core.String? proxyUri;

  /// Reservation Affinity of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NotebookReservationAffinity? reservationAffinity;

  /// The runtime (instance) state of the NotebookRuntime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "RUNTIME_STATE_UNSPECIFIED" : Unspecified runtime state.
  /// - "RUNNING" : NotebookRuntime is in running state.
  /// - "BEING_STARTED" : NotebookRuntime is in starting state. This is when the
  /// runtime is being started from a stopped state.
  /// - "BEING_STOPPED" : NotebookRuntime is in stopping state.
  /// - "STOPPED" : NotebookRuntime is in stopped state.
  /// - "BEING_UPGRADED" : NotebookRuntime is in upgrading state. It is in the
  /// middle of upgrading process.
  /// - "ERROR" : NotebookRuntime was unable to start/stop properly.
  /// - "INVALID" : NotebookRuntime is in invalid state. Cannot be recovered.
  core.String? runtimeState;

  /// The user email of the NotebookRuntime.
  ///
  /// Required.
  core.String? runtimeUser;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Deprecated: This field is no longer used and the "Vertex AI Notebook
  /// Service Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  ///
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details. The service account that the NotebookRuntime workload
  /// runs as.
  ///
  /// Output only.
  core.String? serviceAccount;

  /// Runtime Shielded VM spec.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ShieldedVmConfig? shieldedVmConfig;

  /// Software config of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1NotebookSoftwareConfig? softwareConfig;

  /// Timestamp when this NotebookRuntime was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The VM os image version of NotebookRuntime.
  ///
  /// Output only.
  core.String? version;

  GoogleCloudAiplatformV1beta1NotebookRuntime({
    this.createTime,
    this.dataPersistentDiskSpec,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.eucConfig,
    this.expirationTime,
    this.healthState,
    this.idleShutdownConfig,
    this.isUpgradable,
    this.labels,
    this.machineSpec,
    this.name,
    this.networkSpec,
    this.networkTags,
    this.notebookRuntimeTemplateRef,
    this.notebookRuntimeType,
    this.proxyUri,
    this.reservationAffinity,
    this.runtimeState,
    this.runtimeUser,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccount,
    this.shieldedVmConfig,
    this.softwareConfig,
    this.updateTime,
    this.version,
  });

  GoogleCloudAiplatformV1beta1NotebookRuntime.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        dataPersistentDiskSpec:
            json_.containsKey('dataPersistentDiskSpec')
                ? GoogleCloudAiplatformV1beta1PersistentDiskSpec.fromJson(
                  json_['dataPersistentDiskSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        eucConfig:
            json_.containsKey('eucConfig')
                ? GoogleCloudAiplatformV1beta1NotebookEucConfig.fromJson(
                  json_['eucConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        expirationTime: json_['expirationTime'] as core.String?,
        healthState: json_['healthState'] as core.String?,
        idleShutdownConfig:
            json_.containsKey('idleShutdownConfig')
                ? GoogleCloudAiplatformV1beta1NotebookIdleShutdownConfig.fromJson(
                  json_['idleShutdownConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        isUpgradable: json_['isUpgradable'] as core.bool?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        machineSpec:
            json_.containsKey('machineSpec')
                ? GoogleCloudAiplatformV1beta1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        networkSpec:
            json_.containsKey('networkSpec')
                ? GoogleCloudAiplatformV1beta1NetworkSpec.fromJson(
                  json_['networkSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        networkTags:
            (json_['networkTags'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        notebookRuntimeTemplateRef:
            json_.containsKey('notebookRuntimeTemplateRef')
                ? GoogleCloudAiplatformV1beta1NotebookRuntimeTemplateRef.fromJson(
                  json_['notebookRuntimeTemplateRef']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        notebookRuntimeType: json_['notebookRuntimeType'] as core.String?,
        proxyUri: json_['proxyUri'] as core.String?,
        reservationAffinity:
            json_.containsKey('reservationAffinity')
                ? GoogleCloudAiplatformV1beta1NotebookReservationAffinity.fromJson(
                  json_['reservationAffinity']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        runtimeState: json_['runtimeState'] as core.String?,
        runtimeUser: json_['runtimeUser'] as core.String?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        shieldedVmConfig:
            json_.containsKey('shieldedVmConfig')
                ? GoogleCloudAiplatformV1beta1ShieldedVmConfig.fromJson(
                  json_['shieldedVmConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        softwareConfig:
            json_.containsKey('softwareConfig')
                ? GoogleCloudAiplatformV1beta1NotebookSoftwareConfig.fromJson(
                  json_['softwareConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (dataPersistentDiskSpec != null)
      'dataPersistentDiskSpec': dataPersistentDiskSpec!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (eucConfig != null) 'eucConfig': eucConfig!,
    if (expirationTime != null) 'expirationTime': expirationTime!,
    if (healthState != null) 'healthState': healthState!,
    if (idleShutdownConfig != null) 'idleShutdownConfig': idleShutdownConfig!,
    if (isUpgradable != null) 'isUpgradable': isUpgradable!,
    if (labels != null) 'labels': labels!,
    if (machineSpec != null) 'machineSpec': machineSpec!,
    if (name != null) 'name': name!,
    if (networkSpec != null) 'networkSpec': networkSpec!,
    if (networkTags != null) 'networkTags': networkTags!,
    if (notebookRuntimeTemplateRef != null)
      'notebookRuntimeTemplateRef': notebookRuntimeTemplateRef!,
    if (notebookRuntimeType != null)
      'notebookRuntimeType': notebookRuntimeType!,
    if (proxyUri != null) 'proxyUri': proxyUri!,
    if (reservationAffinity != null)
      'reservationAffinity': reservationAffinity!,
    if (runtimeState != null) 'runtimeState': runtimeState!,
    if (runtimeUser != null) 'runtimeUser': runtimeUser!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (shieldedVmConfig != null) 'shieldedVmConfig': shieldedVmConfig!,
    if (softwareConfig != null) 'softwareConfig': softwareConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (version != null) 'version': version!,
  };
}

/// A template that specifies runtime configurations such as machine type,
/// runtime version, network configurations, etc.
///
/// Multiple runtimes can be created from a runtime template.
class GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate {
  /// Timestamp when this NotebookRuntimeTemplate was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The specification of persistent disk attached to the runtime as data disk
  /// storage.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PersistentDiskSpec? dataPersistentDiskSpec;

  /// The description of the NotebookRuntimeTemplate.
  core.String? description;

  /// The display name of the NotebookRuntimeTemplate.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for the notebook runtime.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// EUC configuration of the NotebookRuntimeTemplate.
  GoogleCloudAiplatformV1beta1NotebookEucConfig? eucConfig;

  /// The idle shutdown configuration of NotebookRuntimeTemplate.
  ///
  /// This config will only be set when idle shutdown is enabled.
  GoogleCloudAiplatformV1beta1NotebookIdleShutdownConfig? idleShutdownConfig;

  /// Deprecated: This field has no behavior.
  ///
  /// Use notebook_runtime_type = 'ONE_CLICK' instead. The default template to
  /// use if not specified.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? isDefault;

  /// The labels with user-defined metadata to organize the
  /// NotebookRuntimeTemplates.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The specification of a single machine for the template.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1MachineSpec? machineSpec;

  /// The resource name of the NotebookRuntimeTemplate.
  core.String? name;

  /// Network spec.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1NetworkSpec? networkSpec;

  /// The Compute Engine tags to add to runtime (see
  /// [Tagging instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  ///
  /// Optional.
  core.List<core.String>? networkTags;

  /// The type of the notebook runtime template.
  ///
  /// Optional. Immutable.
  /// Possible string values are:
  /// - "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" : Unspecified notebook runtime type,
  /// NotebookRuntimeType will default to USER_DEFINED.
  /// - "USER_DEFINED" : runtime or template with coustomized configurations
  /// from user.
  /// - "ONE_CLICK" : runtime or template with system defined configurations.
  core.String? notebookRuntimeType;

  /// Reservation Affinity of the notebook runtime template.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1NotebookReservationAffinity? reservationAffinity;

  /// Deprecated: This field is ignored and the "Vertex AI Notebook Service
  /// Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  ///
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details. For NotebookExecutionJob, use
  /// NotebookExecutionJob.service_account instead. The service account that the
  /// runtime workload runs as. You can use any service account within the same
  /// project, but you must have the service account user permission to use the
  /// instance. If not specified, the
  /// [Compute Engine default service account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
  /// is used.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? serviceAccount;

  /// Runtime Shielded VM spec.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1ShieldedVmConfig? shieldedVmConfig;

  /// The notebook software configuration of the notebook runtime.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1NotebookSoftwareConfig? softwareConfig;

  /// Timestamp when this NotebookRuntimeTemplate was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate({
    this.createTime,
    this.dataPersistentDiskSpec,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.eucConfig,
    this.idleShutdownConfig,
    this.isDefault,
    this.labels,
    this.machineSpec,
    this.name,
    this.networkSpec,
    this.networkTags,
    this.notebookRuntimeType,
    this.reservationAffinity,
    this.serviceAccount,
    this.shieldedVmConfig,
    this.softwareConfig,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1NotebookRuntimeTemplate.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        dataPersistentDiskSpec:
            json_.containsKey('dataPersistentDiskSpec')
                ? GoogleCloudAiplatformV1beta1PersistentDiskSpec.fromJson(
                  json_['dataPersistentDiskSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        eucConfig:
            json_.containsKey('eucConfig')
                ? GoogleCloudAiplatformV1beta1NotebookEucConfig.fromJson(
                  json_['eucConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        idleShutdownConfig:
            json_.containsKey('idleShutdownConfig')
                ? GoogleCloudAiplatformV1beta1NotebookIdleShutdownConfig.fromJson(
                  json_['idleShutdownConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        isDefault: json_['isDefault'] as core.bool?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        machineSpec:
            json_.containsKey('machineSpec')
                ? GoogleCloudAiplatformV1beta1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        networkSpec:
            json_.containsKey('networkSpec')
                ? GoogleCloudAiplatformV1beta1NetworkSpec.fromJson(
                  json_['networkSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        networkTags:
            (json_['networkTags'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        notebookRuntimeType: json_['notebookRuntimeType'] as core.String?,
        reservationAffinity:
            json_.containsKey('reservationAffinity')
                ? GoogleCloudAiplatformV1beta1NotebookReservationAffinity.fromJson(
                  json_['reservationAffinity']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        serviceAccount: json_['serviceAccount'] as core.String?,
        shieldedVmConfig:
            json_.containsKey('shieldedVmConfig')
                ? GoogleCloudAiplatformV1beta1ShieldedVmConfig.fromJson(
                  json_['shieldedVmConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        softwareConfig:
            json_.containsKey('softwareConfig')
                ? GoogleCloudAiplatformV1beta1NotebookSoftwareConfig.fromJson(
                  json_['softwareConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (dataPersistentDiskSpec != null)
      'dataPersistentDiskSpec': dataPersistentDiskSpec!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (eucConfig != null) 'eucConfig': eucConfig!,
    if (idleShutdownConfig != null) 'idleShutdownConfig': idleShutdownConfig!,
    if (isDefault != null) 'isDefault': isDefault!,
    if (labels != null) 'labels': labels!,
    if (machineSpec != null) 'machineSpec': machineSpec!,
    if (name != null) 'name': name!,
    if (networkSpec != null) 'networkSpec': networkSpec!,
    if (networkTags != null) 'networkTags': networkTags!,
    if (notebookRuntimeType != null)
      'notebookRuntimeType': notebookRuntimeType!,
    if (reservationAffinity != null)
      'reservationAffinity': reservationAffinity!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (shieldedVmConfig != null) 'shieldedVmConfig': shieldedVmConfig!,
    if (softwareConfig != null) 'softwareConfig': softwareConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Points to a NotebookRuntimeTemplateRef.
typedef GoogleCloudAiplatformV1beta1NotebookRuntimeTemplateRef =
    $NotebookRuntimeTemplateRef;

/// Notebook Software Config.
///
/// This is passed to the backend when user makes software configurations in UI.
class GoogleCloudAiplatformV1beta1NotebookSoftwareConfig {
  /// Google-managed NotebookRuntime colab image.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ColabImage? colabImage;

  /// Environment variables to be passed to the container.
  ///
  /// Maximum limit is 100.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1EnvVar>? env;

  /// Post startup script config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PostStartupScriptConfig? postStartupScriptConfig;

  GoogleCloudAiplatformV1beta1NotebookSoftwareConfig({
    this.colabImage,
    this.env,
    this.postStartupScriptConfig,
  });

  GoogleCloudAiplatformV1beta1NotebookSoftwareConfig.fromJson(core.Map json_)
    : this(
        colabImage:
            json_.containsKey('colabImage')
                ? GoogleCloudAiplatformV1beta1ColabImage.fromJson(
                  json_['colabImage'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        env:
            (json_['env'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1EnvVar.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        postStartupScriptConfig:
            json_.containsKey('postStartupScriptConfig')
                ? GoogleCloudAiplatformV1beta1PostStartupScriptConfig.fromJson(
                  json_['postStartupScriptConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (colabImage != null) 'colabImage': colabImage!,
    if (env != null) 'env': env!,
    if (postStartupScriptConfig != null)
      'postStartupScriptConfig': postStartupScriptConfig!,
  };
}

/// Request message for GenAiTuningService.OptimizePrompt.
class GoogleCloudAiplatformV1beta1OptimizePromptRequest {
  /// The content to optimize.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Content? content;

  GoogleCloudAiplatformV1beta1OptimizePromptRequest({this.content});

  GoogleCloudAiplatformV1beta1OptimizePromptRequest.fromJson(core.Map json_)
    : this(
        content:
            json_.containsKey('content')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Response message for GenAiTuningService.OptimizePrompt
class GoogleCloudAiplatformV1beta1OptimizePromptResponse {
  /// The optimized prompt content.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1Content? content;

  GoogleCloudAiplatformV1beta1OptimizePromptResponse({this.content});

  GoogleCloudAiplatformV1beta1OptimizePromptResponse.fromJson(core.Map json_)
    : this(
        content:
            json_.containsKey('content')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
  };
}

/// Config for evaluation output.
class GoogleCloudAiplatformV1beta1OutputConfig {
  /// Cloud storage destination for evaluation output.
  GoogleCloudAiplatformV1beta1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1beta1OutputConfig({this.gcsDestination});

  GoogleCloudAiplatformV1beta1OutputConfig.fromJson(core.Map json_)
    : this(
        gcsDestination:
            json_.containsKey('gcsDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!,
  };
}

/// PSC config that is used to automatically create PSC endpoints in the user
/// projects.
typedef GoogleCloudAiplatformV1beta1PSCAutomationConfig = $PSCAutomationConfig;

/// Input for pairwise metric.
class GoogleCloudAiplatformV1beta1PairwiseMetricInput {
  /// Pairwise metric instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PairwiseMetricInstance? instance;

  /// Spec for pairwise metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PairwiseMetricSpec? metricSpec;

  GoogleCloudAiplatformV1beta1PairwiseMetricInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1PairwiseMetricInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1PairwiseMetricInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1PairwiseMetricSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Pairwise metric instance.
///
/// Usually one instance corresponds to one row in an evaluation dataset.
class GoogleCloudAiplatformV1beta1PairwiseMetricInstance {
  /// Key-value contents for the mutlimodality input, including text, image,
  /// video, audio, and pdf, etc.
  ///
  /// The key is placeholder in metric prompt template, and the value is the
  /// multimodal content.
  GoogleCloudAiplatformV1beta1ContentMap? contentMapInstance;

  /// Instance specified as a json string.
  ///
  /// String key-value pairs are expected in the json_instance to render
  /// PairwiseMetricSpec.instance_prompt_template.
  core.String? jsonInstance;

  GoogleCloudAiplatformV1beta1PairwiseMetricInstance({
    this.contentMapInstance,
    this.jsonInstance,
  });

  GoogleCloudAiplatformV1beta1PairwiseMetricInstance.fromJson(core.Map json_)
    : this(
        contentMapInstance:
            json_.containsKey('contentMapInstance')
                ? GoogleCloudAiplatformV1beta1ContentMap.fromJson(
                  json_['contentMapInstance']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        jsonInstance: json_['jsonInstance'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentMapInstance != null) 'contentMapInstance': contentMapInstance!,
    if (jsonInstance != null) 'jsonInstance': jsonInstance!,
  };
}

/// Spec for pairwise metric result.
class GoogleCloudAiplatformV1beta1PairwiseMetricResult {
  /// Spec for custom output.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1CustomOutput? customOutput;

  /// Explanation for pairwise metric score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pairwise metric choice.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PAIRWISE_CHOICE_UNSPECIFIED" : Unspecified prediction choice.
  /// - "BASELINE" : Baseline prediction wins
  /// - "CANDIDATE" : Candidate prediction wins
  /// - "TIE" : Winner cannot be determined
  core.String? pairwiseChoice;

  GoogleCloudAiplatformV1beta1PairwiseMetricResult({
    this.customOutput,
    this.explanation,
    this.pairwiseChoice,
  });

  GoogleCloudAiplatformV1beta1PairwiseMetricResult.fromJson(core.Map json_)
    : this(
        customOutput:
            json_.containsKey('customOutput')
                ? GoogleCloudAiplatformV1beta1CustomOutput.fromJson(
                  json_['customOutput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        explanation: json_['explanation'] as core.String?,
        pairwiseChoice: json_['pairwiseChoice'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customOutput != null) 'customOutput': customOutput!,
    if (explanation != null) 'explanation': explanation!,
    if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!,
  };
}

/// Spec for pairwise metric.
class GoogleCloudAiplatformV1beta1PairwiseMetricSpec {
  /// The field name of the baseline response.
  ///
  /// Optional.
  core.String? baselineResponseFieldName;

  /// The field name of the candidate response.
  ///
  /// Optional.
  core.String? candidateResponseFieldName;

  /// CustomOutputFormatConfig allows customization of metric output.
  ///
  /// When this config is set, the default output is replaced with the raw
  /// output string. If a custom format is chosen, the `pairwise_choice` and
  /// `explanation` fields in the corresponding metric result will be empty.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1CustomOutputFormatConfig?
  customOutputFormatConfig;

  /// Metric prompt template for pairwise metric.
  ///
  /// Required.
  core.String? metricPromptTemplate;

  /// System instructions for pairwise metric.
  ///
  /// Optional.
  core.String? systemInstruction;

  GoogleCloudAiplatformV1beta1PairwiseMetricSpec({
    this.baselineResponseFieldName,
    this.candidateResponseFieldName,
    this.customOutputFormatConfig,
    this.metricPromptTemplate,
    this.systemInstruction,
  });

  GoogleCloudAiplatformV1beta1PairwiseMetricSpec.fromJson(core.Map json_)
    : this(
        baselineResponseFieldName:
            json_['baselineResponseFieldName'] as core.String?,
        candidateResponseFieldName:
            json_['candidateResponseFieldName'] as core.String?,
        customOutputFormatConfig:
            json_.containsKey('customOutputFormatConfig')
                ? GoogleCloudAiplatformV1beta1CustomOutputFormatConfig.fromJson(
                  json_['customOutputFormatConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricPromptTemplate: json_['metricPromptTemplate'] as core.String?,
        systemInstruction: json_['systemInstruction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baselineResponseFieldName != null)
      'baselineResponseFieldName': baselineResponseFieldName!,
    if (candidateResponseFieldName != null)
      'candidateResponseFieldName': candidateResponseFieldName!,
    if (customOutputFormatConfig != null)
      'customOutputFormatConfig': customOutputFormatConfig!,
    if (metricPromptTemplate != null)
      'metricPromptTemplate': metricPromptTemplate!,
    if (systemInstruction != null) 'systemInstruction': systemInstruction!,
  };
}

/// Input for pairwise question answering quality metric.
class GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInput {
  /// Pairwise question answering quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInstance?
  instance;

  /// Spec for pairwise question answering quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualitySpec? metricSpec;

  GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualitySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for pairwise question answering quality instance.
typedef GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityInstance =
    $PairwiseQuestionAnsweringQualityInstance;

/// Spec for pairwise question answering quality result.
typedef GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualityResult =
    $PairwiseQuestionAnsweringQualityResult;

/// Spec for pairwise question answering quality score metric.
typedef GoogleCloudAiplatformV1beta1PairwiseQuestionAnsweringQualitySpec =
    $QuestionAnsweringQualitySpec;

/// Input for pairwise summarization quality metric.
class GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInput {
  /// Pairwise summarization quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInstance? instance;

  /// Spec for pairwise summarization quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PairwiseSummarizationQualitySpec? metricSpec;

  GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1PairwiseSummarizationQualitySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for pairwise summarization quality instance.
typedef GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityInstance =
    $PairwiseSummarizationQualityInstance;

/// Spec for pairwise summarization quality result.
typedef GoogleCloudAiplatformV1beta1PairwiseSummarizationQualityResult =
    $PairwiseSummarizationQualityResult;

/// Spec for pairwise summarization quality score metric.
typedef GoogleCloudAiplatformV1beta1PairwiseSummarizationQualitySpec =
    $PairwiseSummarizationQualitySpec;

/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can
/// only contain one of the accepted types in `Part.data`. A `Part` must have a
/// fixed IANA MIME type identifying the type and subtype of the media if
/// `inline_data` or `file_data` field is filled with raw bytes.
class GoogleCloudAiplatformV1beta1Part {
  /// Result of executing the \[ExecutableCode\].
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1CodeExecutionResult? codeExecutionResult;

  /// Code generated by the model that is meant to be executed.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ExecutableCode? executableCode;

  /// URI based data.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FileData? fileData;

  /// A predicted \[FunctionCall\] returned from the model that contains a
  /// string representing the \[FunctionDeclaration.name\] with the parameters
  /// and their values.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FunctionCall? functionCall;

  /// The result output of a \[FunctionCall\] that contains a string
  /// representing the \[FunctionDeclaration.name\] and a structured JSON object
  /// containing any output from the function call.
  ///
  /// It is used as context to the model.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FunctionResponse? functionResponse;

  /// Inlined bytes data.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Blob? inlineData;

  /// Text part (can be code).
  ///
  /// Optional.
  core.String? text;

  /// Indicates if the part is thought from the model.
  ///
  /// Optional.
  core.bool? thought;

  /// An opaque signature for the thought so it can be reused in subsequent
  /// requests.
  ///
  /// Optional.
  core.String? thoughtSignature;
  core.List<core.int> get thoughtSignatureAsBytes =>
      convert.base64.decode(thoughtSignature!);

  set thoughtSignatureAsBytes(core.List<core.int> bytes_) {
    thoughtSignature = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Video metadata.
  ///
  /// The metadata should only be specified while the video data is presented in
  /// inline_data or file_data.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1VideoMetadata? videoMetadata;

  GoogleCloudAiplatformV1beta1Part({
    this.codeExecutionResult,
    this.executableCode,
    this.fileData,
    this.functionCall,
    this.functionResponse,
    this.inlineData,
    this.text,
    this.thought,
    this.thoughtSignature,
    this.videoMetadata,
  });

  GoogleCloudAiplatformV1beta1Part.fromJson(core.Map json_)
    : this(
        codeExecutionResult:
            json_.containsKey('codeExecutionResult')
                ? GoogleCloudAiplatformV1beta1CodeExecutionResult.fromJson(
                  json_['codeExecutionResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        executableCode:
            json_.containsKey('executableCode')
                ? GoogleCloudAiplatformV1beta1ExecutableCode.fromJson(
                  json_['executableCode']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        fileData:
            json_.containsKey('fileData')
                ? GoogleCloudAiplatformV1beta1FileData.fromJson(
                  json_['fileData'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        functionCall:
            json_.containsKey('functionCall')
                ? GoogleCloudAiplatformV1beta1FunctionCall.fromJson(
                  json_['functionCall'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        functionResponse:
            json_.containsKey('functionResponse')
                ? GoogleCloudAiplatformV1beta1FunctionResponse.fromJson(
                  json_['functionResponse']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineData:
            json_.containsKey('inlineData')
                ? GoogleCloudAiplatformV1beta1Blob.fromJson(
                  json_['inlineData'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        text: json_['text'] as core.String?,
        thought: json_['thought'] as core.bool?,
        thoughtSignature: json_['thoughtSignature'] as core.String?,
        videoMetadata:
            json_.containsKey('videoMetadata')
                ? GoogleCloudAiplatformV1beta1VideoMetadata.fromJson(
                  json_['videoMetadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (codeExecutionResult != null)
      'codeExecutionResult': codeExecutionResult!,
    if (executableCode != null) 'executableCode': executableCode!,
    if (fileData != null) 'fileData': fileData!,
    if (functionCall != null) 'functionCall': functionCall!,
    if (functionResponse != null) 'functionResponse': functionResponse!,
    if (inlineData != null) 'inlineData': inlineData!,
    if (text != null) 'text': text!,
    if (thought != null) 'thought': thought!,
    if (thoughtSignature != null) 'thoughtSignature': thoughtSignature!,
    if (videoMetadata != null) 'videoMetadata': videoMetadata!,
  };
}

/// Tuning spec for Partner models.
class GoogleCloudAiplatformV1beta1PartnerModelTuningSpec {
  /// Hyperparameters for tuning.
  ///
  /// The accepted hyper_parameters and their valid range of values will differ
  /// depending on the base model.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? hyperParameters;

  /// Cloud Storage path to file containing training dataset for tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Required.
  core.String? trainingDatasetUri;

  /// Cloud Storage path to file containing validation dataset for tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Optional.
  core.String? validationDatasetUri;

  GoogleCloudAiplatformV1beta1PartnerModelTuningSpec({
    this.hyperParameters,
    this.trainingDatasetUri,
    this.validationDatasetUri,
  });

  GoogleCloudAiplatformV1beta1PartnerModelTuningSpec.fromJson(core.Map json_)
    : this(
        hyperParameters:
            json_.containsKey('hyperParameters')
                ? json_['hyperParameters']
                    as core.Map<core.String, core.dynamic>
                : null,
        trainingDatasetUri: json_['trainingDatasetUri'] as core.String?,
        validationDatasetUri: json_['validationDatasetUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperParameters != null) 'hyperParameters': hyperParameters!,
    if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri!,
    if (validationDatasetUri != null)
      'validationDatasetUri': validationDatasetUri!,
  };
}

/// Request message for JobService.PauseModelDeploymentMonitoringJob.
typedef GoogleCloudAiplatformV1beta1PauseModelDeploymentMonitoringJobRequest =
    $Empty;

/// Request message for ScheduleService.PauseSchedule.
typedef GoogleCloudAiplatformV1beta1PauseScheduleRequest = $Empty;

/// Represents the spec of persistent disk options.
typedef GoogleCloudAiplatformV1beta1PersistentDiskSpec = $PersistentDiskSpec;

/// Represents long-lasting resources that are dedicated to users to runs custom
/// workloads.
///
/// A PersistentResource can have multiple node pools and each node pool can
/// have its own machine spec.
class GoogleCloudAiplatformV1beta1PersistentResource {
  /// Time when the PersistentResource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the PersistentResource.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Optional.
  core.String? displayName;

  /// Customer-managed encryption key spec for a PersistentResource.
  ///
  /// If set, this PersistentResource and all sub-resources of this
  /// PersistentResource will be secured by this key.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Only populated when persistent resource's state is `STOPPING` or `ERROR`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize PersistentResource.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Resource name of a PersistentResource.
  ///
  /// Immutable.
  core.String? name;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to peered with
  /// Vertex AI to host the persistent resources.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. To specify
  /// this field, you must have already
  /// [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  /// If this field is left unspecified, the resources aren't peered with any
  /// network.
  ///
  /// Optional.
  core.String? network;

  /// Configuration for PSC-I for PersistentResource.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PscInterfaceConfig? pscInterfaceConfig;

  /// A list of names for the reserved IP ranges under the VPC network that can
  /// be used for this persistent resource.
  ///
  /// If set, we will deploy the persistent resource within the provided IP
  /// ranges. Otherwise, the persistent resource is deployed to any IP ranges
  /// under the provided VPC network. Example: \['vertex-ai-ip-range'\].
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  /// The spec of the pools of different resources.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ResourcePool>? resourcePools;

  /// Runtime information of the Persistent Resource.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ResourceRuntime? resourceRuntime;

  /// Persistent Resource runtime spec.
  ///
  /// For example, used for Ray cluster configuration.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ResourceRuntimeSpec? resourceRuntimeSpec;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the PersistentResource for the first time entered the `RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of a Study.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "PROVISIONING" : The PROVISIONING state indicates the persistent
  /// resources is being created.
  /// - "RUNNING" : The RUNNING state indicates the persistent resource is
  /// healthy and fully usable.
  /// - "STOPPING" : The STOPPING state indicates the persistent resource is
  /// being deleted.
  /// - "ERROR" : The ERROR state indicates the persistent resource may be
  /// unusable. Details can be found in the `error` field.
  /// - "REBOOTING" : The REBOOTING state indicates the persistent resource is
  /// being rebooted (PR is not available right now but is expected to be ready
  /// again later).
  /// - "UPDATING" : The UPDATING state indicates the persistent resource is
  /// being updated.
  core.String? state;

  /// Time when the PersistentResource was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1PersistentResource({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.error,
    this.labels,
    this.name,
    this.network,
    this.pscInterfaceConfig,
    this.reservedIpRanges,
    this.resourcePools,
    this.resourceRuntime,
    this.resourceRuntimeSpec,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1PersistentResource.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        pscInterfaceConfig:
            json_.containsKey('pscInterfaceConfig')
                ? GoogleCloudAiplatformV1beta1PscInterfaceConfig.fromJson(
                  json_['pscInterfaceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        reservedIpRanges:
            (json_['reservedIpRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        resourcePools:
            (json_['resourcePools'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1ResourcePool.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        resourceRuntime:
            json_.containsKey('resourceRuntime')
                ? GoogleCloudAiplatformV1beta1ResourceRuntime.fromJson(
                  json_['resourceRuntime']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        resourceRuntimeSpec:
            json_.containsKey('resourceRuntimeSpec')
                ? GoogleCloudAiplatformV1beta1ResourceRuntimeSpec.fromJson(
                  json_['resourceRuntimeSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (error != null) 'error': error!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (pscInterfaceConfig != null) 'pscInterfaceConfig': pscInterfaceConfig!,
    if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
    if (resourcePools != null) 'resourcePools': resourcePools!,
    if (resourceRuntime != null) 'resourceRuntime': resourceRuntime!,
    if (resourceRuntimeSpec != null)
      'resourceRuntimeSpec': resourceRuntimeSpec!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// An instance of a machine learning PipelineJob.
class GoogleCloudAiplatformV1beta1PipelineJob {
  /// Pipeline creation time.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the Pipeline.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  core.String? displayName;

  /// Customer-managed encryption key spec for a pipelineJob.
  ///
  /// If set, this PipelineJob and all of its sub-resources will be secured by
  /// this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Pipeline end time.
  ///
  /// Output only.
  core.String? endTime;

  /// The error that occurred during pipeline execution.
  ///
  /// Only populated when the pipeline's state is FAILED or CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The details of pipeline run.
  ///
  /// Not available in the list view.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PipelineJobDetail? jobDetail;

  /// The labels with user-defined metadata to organize PipelineJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. Note
  /// there is some reserved label key for Vertex AI Pipelines. -
  /// `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the PipelineJob.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to which the
  /// Pipeline Job's workload should be peered.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. Private
  /// services access must already be configured for the network. Pipeline job
  /// will apply the network configuration to the Google Cloud resources being
  /// launched, if applied, such as Vertex AI Training or Dataflow job. If left
  /// unspecified, the workload is not peered with any network.
  core.String? network;

  /// The original pipeline job id if this pipeline job is a rerun of a previous
  /// pipeline job.
  ///
  /// Optional.
  core.String? originalPipelineJobId;

  /// The spec of the pipeline.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? pipelineSpec;

  /// The rerun configs for each task in the pipeline job.
  ///
  /// By default, the rerun will: 1. Use the same input artifacts as the
  /// original run. 2. Use the same input parameters as the original run. 3.
  /// Skip all the tasks that are already succeeded in the original run. 4.
  /// Rerun all the tasks that are not succeeded in the original run. By
  /// providing this field, users can override the default behavior and specify
  /// the rerun config for each task.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1PipelineTaskRerunConfig>?
  pipelineTaskRerunConfigs;

  /// Whether to do component level validations before job creation.
  ///
  /// Optional.
  core.bool? preflightValidations;

  /// Configuration for PSC-I for PipelineJob.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PscInterfaceConfig? pscInterfaceConfig;

  /// A list of names for the reserved ip ranges under the VPC network that can
  /// be used for this Pipeline Job's workload.
  ///
  /// If set, we will deploy the Pipeline Job's workload within the provided ip
  /// ranges. Otherwise, the job will be deployed to any ip ranges under the
  /// provided VPC network. Example: \['vertex-ai-ip-range'\].
  core.List<core.String>? reservedIpRanges;

  /// Runtime config of the pipeline.
  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfig? runtimeConfig;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// The schedule resource name.
  ///
  /// Only returned if the Pipeline is created by Schedule API.
  ///
  /// Output only.
  core.String? scheduleName;

  /// The service account that the pipeline workload runs as.
  ///
  /// If not specified, the Compute Engine default service account in the
  /// project will be used. See
  /// https://cloud.google.com/compute/docs/access/service-accounts#default_service_account
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  core.String? serviceAccount;

  /// Pipeline start time.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PIPELINE_STATE_UNSPECIFIED" : The pipeline state is unspecified.
  /// - "PIPELINE_STATE_QUEUED" : The pipeline has been created or resumed, and
  /// processing has not yet begun.
  /// - "PIPELINE_STATE_PENDING" : The service is preparing to run the pipeline.
  /// - "PIPELINE_STATE_RUNNING" : The pipeline is in progress.
  /// - "PIPELINE_STATE_SUCCEEDED" : The pipeline completed successfully.
  /// - "PIPELINE_STATE_FAILED" : The pipeline failed.
  /// - "PIPELINE_STATE_CANCELLING" : The pipeline is being cancelled. From this
  /// state, the pipeline may only go to either PIPELINE_STATE_SUCCEEDED,
  /// PIPELINE_STATE_FAILED or PIPELINE_STATE_CANCELLED.
  /// - "PIPELINE_STATE_CANCELLED" : The pipeline has been cancelled.
  /// - "PIPELINE_STATE_PAUSED" : The pipeline has been stopped, and can be
  /// resumed.
  core.String? state;

  /// Pipeline template metadata.
  ///
  /// Will fill up fields if PipelineJob.template_uri is from supported template
  /// registry.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PipelineTemplateMetadata? templateMetadata;

  /// A template uri from where the PipelineJob.pipeline_spec, if empty, will be
  /// downloaded.
  ///
  /// Currently, only uri from Vertex Template Registry & Gallery is supported.
  /// Reference to
  /// https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
  core.String? templateUri;

  /// Timestamp when this PipelineJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1PipelineJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.jobDetail,
    this.labels,
    this.name,
    this.network,
    this.originalPipelineJobId,
    this.pipelineSpec,
    this.pipelineTaskRerunConfigs,
    this.preflightValidations,
    this.pscInterfaceConfig,
    this.reservedIpRanges,
    this.runtimeConfig,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.scheduleName,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.templateMetadata,
    this.templateUri,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1PipelineJob.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        jobDetail:
            json_.containsKey('jobDetail')
                ? GoogleCloudAiplatformV1beta1PipelineJobDetail.fromJson(
                  json_['jobDetail'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        network: json_['network'] as core.String?,
        originalPipelineJobId: json_['originalPipelineJobId'] as core.String?,
        pipelineSpec:
            json_.containsKey('pipelineSpec')
                ? json_['pipelineSpec'] as core.Map<core.String, core.dynamic>
                : null,
        pipelineTaskRerunConfigs:
            (json_['pipelineTaskRerunConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PipelineTaskRerunConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        preflightValidations: json_['preflightValidations'] as core.bool?,
        pscInterfaceConfig:
            json_.containsKey('pscInterfaceConfig')
                ? GoogleCloudAiplatformV1beta1PscInterfaceConfig.fromJson(
                  json_['pscInterfaceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        reservedIpRanges:
            (json_['reservedIpRanges'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        runtimeConfig:
            json_.containsKey('runtimeConfig')
                ? GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfig.fromJson(
                  json_['runtimeConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        scheduleName: json_['scheduleName'] as core.String?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        templateMetadata:
            json_.containsKey('templateMetadata')
                ? GoogleCloudAiplatformV1beta1PipelineTemplateMetadata.fromJson(
                  json_['templateMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        templateUri: json_['templateUri'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (jobDetail != null) 'jobDetail': jobDetail!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (network != null) 'network': network!,
    if (originalPipelineJobId != null)
      'originalPipelineJobId': originalPipelineJobId!,
    if (pipelineSpec != null) 'pipelineSpec': pipelineSpec!,
    if (pipelineTaskRerunConfigs != null)
      'pipelineTaskRerunConfigs': pipelineTaskRerunConfigs!,
    if (preflightValidations != null)
      'preflightValidations': preflightValidations!,
    if (pscInterfaceConfig != null) 'pscInterfaceConfig': pscInterfaceConfig!,
    if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
    if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (scheduleName != null) 'scheduleName': scheduleName!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (templateMetadata != null) 'templateMetadata': templateMetadata!,
    if (templateUri != null) 'templateUri': templateUri!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// The runtime detail of PipelineJob.
class GoogleCloudAiplatformV1beta1PipelineJobDetail {
  /// The context of the pipeline.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1Context? pipelineContext;

  /// The context of the current pipeline run.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1Context? pipelineRunContext;

  /// The runtime details of the tasks under the pipeline.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1PipelineTaskDetail>? taskDetails;

  GoogleCloudAiplatformV1beta1PipelineJobDetail({
    this.pipelineContext,
    this.pipelineRunContext,
    this.taskDetails,
  });

  GoogleCloudAiplatformV1beta1PipelineJobDetail.fromJson(core.Map json_)
    : this(
        pipelineContext:
            json_.containsKey('pipelineContext')
                ? GoogleCloudAiplatformV1beta1Context.fromJson(
                  json_['pipelineContext']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pipelineRunContext:
            json_.containsKey('pipelineRunContext')
                ? GoogleCloudAiplatformV1beta1Context.fromJson(
                  json_['pipelineRunContext']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        taskDetails:
            (json_['taskDetails'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PipelineTaskDetail.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pipelineContext != null) 'pipelineContext': pipelineContext!,
    if (pipelineRunContext != null) 'pipelineRunContext': pipelineRunContext!,
    if (taskDetails != null) 'taskDetails': taskDetails!,
  };
}

/// The runtime config of a PipelineJob.
class GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfig {
  /// The default runtime for the PipelineJob.
  ///
  /// If not set, Standard Vertex Custom
  /// Job(https://cloud.google.com/vertex-ai/docs/training/overview) is used as
  /// the runtime. If set, all pipeline tasks will run on the default runtime
  /// unless a task is a GCPC custom job component
  /// (https://cloud.google.com/vertex-ai/docs/pipelines/customjob-component)
  /// based task. If the task is based on a GCPC custom job component, it runs
  /// solely according to the component's configuration.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigDefaultRuntime?
  defaultRuntime;

  /// Represents the failure policy of a pipeline.
  ///
  /// Currently, the default of a pipeline is that the pipeline will continue to
  /// run until no more tasks can be executed, also known as
  /// PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to
  /// PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks
  /// when a task has failed. Any scheduled tasks will continue to completion.
  /// Possible string values are:
  /// - "PIPELINE_FAILURE_POLICY_UNSPECIFIED" : Default value, and follows fail
  /// slow behavior.
  /// - "PIPELINE_FAILURE_POLICY_FAIL_SLOW" : Indicates that the pipeline should
  /// continue to run until all possible tasks have been scheduled and
  /// completed.
  /// - "PIPELINE_FAILURE_POLICY_FAIL_FAST" : Indicates that the pipeline should
  /// stop scheduling new tasks after a task has failed.
  core.String? failurePolicy;

  /// A path in a Cloud Storage bucket, which will be treated as the root output
  /// directory of the pipeline.
  ///
  /// It is used by the system to generate the paths of output artifacts. The
  /// artifact paths are generated with a sub-path pattern
  /// `{job_id}/{task_id}/{output_key}` under the specified output directory.
  /// The service account specified in this pipeline must have the
  /// `storage.objects.get` and `storage.objects.create` permissions for this
  /// bucket.
  ///
  /// Required.
  core.String? gcsOutputDirectory;

  /// The runtime artifacts of the PipelineJob.
  ///
  /// The key will be the input artifact name and the value would be one of the
  /// InputArtifact.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigInputArtifact
  >?
  inputArtifacts;

  /// The runtime parameters of the PipelineJob.
  ///
  /// The parameters will be passed into PipelineJob.pipeline_spec to replace
  /// the placeholders at runtime. This field is used by pipelines built using
  /// `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built
  /// using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? parameterValues;

  /// Use RuntimeConfig.parameter_values instead.
  ///
  /// The runtime parameters of the PipelineJob. The parameters will be passed
  /// into PipelineJob.pipeline_spec to replace the placeholders at runtime.
  /// This field is used by pipelines built using
  /// `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as
  /// pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.Map<core.String, GoogleCloudAiplatformV1beta1Value>? parameters;

  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfig({
    this.defaultRuntime,
    this.failurePolicy,
    this.gcsOutputDirectory,
    this.inputArtifacts,
    this.parameterValues,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfig.fromJson(core.Map json_)
    : this(
        defaultRuntime:
            json_.containsKey('defaultRuntime')
                ? GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigDefaultRuntime.fromJson(
                  json_['defaultRuntime']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        failurePolicy: json_['failurePolicy'] as core.String?,
        gcsOutputDirectory: json_['gcsOutputDirectory'] as core.String?,
        inputArtifacts: (json_['inputArtifacts']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigInputArtifact.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        parameterValues:
            json_.containsKey('parameterValues')
                ? json_['parameterValues']
                    as core.Map<core.String, core.dynamic>
                : null,
        parameters:
            (json_['parameters'] as core.Map<core.String, core.dynamic>?)?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1Value.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (defaultRuntime != null) 'defaultRuntime': defaultRuntime!,
    if (failurePolicy != null) 'failurePolicy': failurePolicy!,
    if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory!,
    if (inputArtifacts != null) 'inputArtifacts': inputArtifacts!,
    if (parameterValues != null) 'parameterValues': parameterValues!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// The default runtime for the PipelineJob.
class GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigDefaultRuntime {
  /// Persistent resource based runtime detail.
  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigPersistentResourceRuntimeDetail?
  persistentResourceRuntimeDetail;

  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigDefaultRuntime({
    this.persistentResourceRuntimeDetail,
  });

  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigDefaultRuntime.fromJson(
    core.Map json_,
  ) : this(
        persistentResourceRuntimeDetail:
            json_.containsKey('persistentResourceRuntimeDetail')
                ? GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigPersistentResourceRuntimeDetail.fromJson(
                  json_['persistentResourceRuntimeDetail']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (persistentResourceRuntimeDetail != null)
      'persistentResourceRuntimeDetail': persistentResourceRuntimeDetail!,
  };
}

/// The type of an input artifact.
typedef GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigInputArtifact =
    $PipelineJobRuntimeConfigInputArtifact;

/// Persistent resource based runtime detail.
///
/// For more information about persistent resource, refer to
/// https://cloud.google.com/vertex-ai/docs/training/persistent-resource-overview
class GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigPersistentResourceRuntimeDetail {
  /// Persistent resource name.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  core.String? persistentResourceName;

  /// Specifies the behavior to take if the timeout is reached.
  /// Possible string values are:
  /// - "TASK_RESOURCE_UNAVAILABLE_TIMEOUT_BEHAVIOR_UNSPECIFIED" : Unspecified.
  /// Behavior is same as `FAIL`.
  /// - "FAIL" : Fail the task if the timeout is reached.
  /// - "FALL_BACK_TO_ON_DEMAND" : Fall back to on-demand execution if the
  /// timeout is reached.
  core.String? taskResourceUnavailableTimeoutBehavior;

  /// The max time a pipeline task waits for the required CPU, memory, or
  /// accelerator resource to become available from the specified persistent
  /// resource.
  ///
  /// Default wait time is 0.
  core.String? taskResourceUnavailableWaitTimeMs;

  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigPersistentResourceRuntimeDetail({
    this.persistentResourceName,
    this.taskResourceUnavailableTimeoutBehavior,
    this.taskResourceUnavailableWaitTimeMs,
  });

  GoogleCloudAiplatformV1beta1PipelineJobRuntimeConfigPersistentResourceRuntimeDetail.fromJson(
    core.Map json_,
  ) : this(
        persistentResourceName: json_['persistentResourceName'] as core.String?,
        taskResourceUnavailableTimeoutBehavior:
            json_['taskResourceUnavailableTimeoutBehavior'] as core.String?,
        taskResourceUnavailableWaitTimeMs:
            json_['taskResourceUnavailableWaitTimeMs'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (persistentResourceName != null)
      'persistentResourceName': persistentResourceName!,
    if (taskResourceUnavailableTimeoutBehavior != null)
      'taskResourceUnavailableTimeoutBehavior':
          taskResourceUnavailableTimeoutBehavior!,
    if (taskResourceUnavailableWaitTimeMs != null)
      'taskResourceUnavailableWaitTimeMs': taskResourceUnavailableWaitTimeMs!,
  };
}

/// The runtime detail of a task execution.
class GoogleCloudAiplatformV1beta1PipelineTaskDetail {
  /// Task create time.
  ///
  /// Output only.
  core.String? createTime;

  /// Task end time.
  ///
  /// Output only.
  core.String? endTime;

  /// The error that occurred during task execution.
  ///
  /// Only populated when the task's state is FAILED or CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The execution metadata of the task.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1Execution? execution;

  /// The detailed execution info.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetail? executorDetail;

  /// The runtime input artifacts of the task.
  ///
  /// Output only.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1PipelineTaskDetailArtifactList
  >?
  inputs;

  /// The runtime output artifacts of the task.
  ///
  /// Output only.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1PipelineTaskDetailArtifactList
  >?
  outputs;

  /// The id of the parent task if the task is within a component scope.
  ///
  /// Empty if the task is at the root level.
  ///
  /// Output only.
  core.String? parentTaskId;

  /// A list of task status.
  ///
  /// This field keeps a record of task status evolving over time.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1PipelineTaskDetailPipelineTaskStatus>?
  pipelineTaskStatus;

  /// Task start time.
  ///
  /// Output only.
  core.String? startTime;

  /// State of the task.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "PENDING" : Specifies pending state for the task.
  /// - "RUNNING" : Specifies task is being executed.
  /// - "SUCCEEDED" : Specifies task completed successfully.
  /// - "CANCEL_PENDING" : Specifies Task cancel is in pending state.
  /// - "CANCELLING" : Specifies task is being cancelled.
  /// - "CANCELLED" : Specifies task was cancelled.
  /// - "FAILED" : Specifies task failed.
  /// - "SKIPPED" : Specifies task was skipped due to cache hit.
  /// - "NOT_TRIGGERED" : Specifies that the task was not triggered because the
  /// task's trigger policy is not satisfied. The trigger policy is specified in
  /// the `condition` field of PipelineJob.pipeline_spec.
  core.String? state;

  /// The system generated ID of the task.
  ///
  /// Output only.
  core.String? taskId;

  /// The user specified name of the task that is defined in pipeline_spec.
  ///
  /// Output only.
  core.String? taskName;

  /// The unique name of a task.
  ///
  /// This field is used by rerun pipeline job. Console UI and Vertex AI SDK
  /// will support triggering pipeline job reruns. The name is constructed by
  /// concatenating all the parent tasks name with the task name. For example,
  /// if a task named "child_task" has a parent task named "parent_task_1" and
  /// parent task 1 has a parent task named "parent_task_2", the task unique
  /// name will be "parent_task_2.parent_task_1.child_task".
  ///
  /// Output only.
  core.String? taskUniqueName;

  GoogleCloudAiplatformV1beta1PipelineTaskDetail({
    this.createTime,
    this.endTime,
    this.error,
    this.execution,
    this.executorDetail,
    this.inputs,
    this.outputs,
    this.parentTaskId,
    this.pipelineTaskStatus,
    this.startTime,
    this.state,
    this.taskId,
    this.taskName,
    this.taskUniqueName,
  });

  GoogleCloudAiplatformV1beta1PipelineTaskDetail.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        execution:
            json_.containsKey('execution')
                ? GoogleCloudAiplatformV1beta1Execution.fromJson(
                  json_['execution'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        executorDetail:
            json_.containsKey('executorDetail')
                ? GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetail.fromJson(
                  json_['executorDetail']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        inputs: (json_['inputs'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1PipelineTaskDetailArtifactList.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
        outputs: (json_['outputs'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1PipelineTaskDetailArtifactList.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
        parentTaskId: json_['parentTaskId'] as core.String?,
        pipelineTaskStatus:
            (json_['pipelineTaskStatus'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PipelineTaskDetailPipelineTaskStatus.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        taskId: json_['taskId'] as core.String?,
        taskName: json_['taskName'] as core.String?,
        taskUniqueName: json_['taskUniqueName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (execution != null) 'execution': execution!,
    if (executorDetail != null) 'executorDetail': executorDetail!,
    if (inputs != null) 'inputs': inputs!,
    if (outputs != null) 'outputs': outputs!,
    if (parentTaskId != null) 'parentTaskId': parentTaskId!,
    if (pipelineTaskStatus != null) 'pipelineTaskStatus': pipelineTaskStatus!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (taskId != null) 'taskId': taskId!,
    if (taskName != null) 'taskName': taskName!,
    if (taskUniqueName != null) 'taskUniqueName': taskUniqueName!,
  };
}

/// A list of artifact metadata.
class GoogleCloudAiplatformV1beta1PipelineTaskDetailArtifactList {
  /// A list of artifact metadata.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Artifact>? artifacts;

  GoogleCloudAiplatformV1beta1PipelineTaskDetailArtifactList({this.artifacts});

  GoogleCloudAiplatformV1beta1PipelineTaskDetailArtifactList.fromJson(
    core.Map json_,
  ) : this(
        artifacts:
            (json_['artifacts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Artifact.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifacts != null) 'artifacts': artifacts!,
  };
}

/// A single record of the task status.
class GoogleCloudAiplatformV1beta1PipelineTaskDetailPipelineTaskStatus {
  /// The error that occurred during the state.
  ///
  /// May be set when the state is any of the non-final state
  /// (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the
  /// error here is final and not going to be retried. If the state is a
  /// non-final state, the error indicates a system-error being retried.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The state of the task.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "PENDING" : Specifies pending state for the task.
  /// - "RUNNING" : Specifies task is being executed.
  /// - "SUCCEEDED" : Specifies task completed successfully.
  /// - "CANCEL_PENDING" : Specifies Task cancel is in pending state.
  /// - "CANCELLING" : Specifies task is being cancelled.
  /// - "CANCELLED" : Specifies task was cancelled.
  /// - "FAILED" : Specifies task failed.
  /// - "SKIPPED" : Specifies task was skipped due to cache hit.
  /// - "NOT_TRIGGERED" : Specifies that the task was not triggered because the
  /// task's trigger policy is not satisfied. The trigger policy is specified in
  /// the `condition` field of PipelineJob.pipeline_spec.
  core.String? state;

  /// Update time of this status.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1PipelineTaskDetailPipelineTaskStatus({
    this.error,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1PipelineTaskDetailPipelineTaskStatus.fromJson(
    core.Map json_,
  ) : this(
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// The runtime detail of a pipeline executor.
class GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetail {
  /// The detailed info for a container executor.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailContainerDetail?
  containerDetail;

  /// The detailed info for a custom job executor.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailCustomJobDetail?
  customJobDetail;

  GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetail({
    this.containerDetail,
    this.customJobDetail,
  });

  GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetail.fromJson(
    core.Map json_,
  ) : this(
        containerDetail:
            json_.containsKey('containerDetail')
                ? GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailContainerDetail.fromJson(
                  json_['containerDetail']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        customJobDetail:
            json_.containsKey('customJobDetail')
                ? GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailCustomJobDetail.fromJson(
                  json_['customJobDetail']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (containerDetail != null) 'containerDetail': containerDetail!,
    if (customJobDetail != null) 'customJobDetail': customJobDetail!,
  };
}

/// The detail of a container execution.
///
/// It contains the job names of the lifecycle of a container execution.
typedef GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailContainerDetail =
    $PipelineTaskExecutorDetailContainerDetail;

/// The detailed info for a custom job executor.
typedef GoogleCloudAiplatformV1beta1PipelineTaskExecutorDetailCustomJobDetail =
    $PipelineTaskExecutorDetailCustomJobDetail;

/// User provided rerun config to submit a rerun pipelinejob.
///
/// This includes 1. Which task to rerun 2. User override input parameters and
/// artifacts.
class GoogleCloudAiplatformV1beta1PipelineTaskRerunConfig {
  /// The runtime input of the task overridden by the user.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigInputs? inputs;

  /// Whether to skip downstream tasks.
  ///
  /// Default value is False.
  ///
  /// Optional.
  core.bool? skipDownstreamTasks;

  /// Whether to skip this task.
  ///
  /// Default value is False.
  ///
  /// Optional.
  core.bool? skipTask;

  /// The system generated ID of the task.
  ///
  /// Retrieved from original run.
  ///
  /// Optional.
  core.String? taskId;

  /// The name of the task.
  ///
  /// Optional.
  core.String? taskName;

  GoogleCloudAiplatformV1beta1PipelineTaskRerunConfig({
    this.inputs,
    this.skipDownstreamTasks,
    this.skipTask,
    this.taskId,
    this.taskName,
  });

  GoogleCloudAiplatformV1beta1PipelineTaskRerunConfig.fromJson(core.Map json_)
    : this(
        inputs:
            json_.containsKey('inputs')
                ? GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigInputs.fromJson(
                  json_['inputs'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        skipDownstreamTasks: json_['skipDownstreamTasks'] as core.bool?,
        skipTask: json_['skipTask'] as core.bool?,
        taskId: json_['taskId'] as core.String?,
        taskName: json_['taskName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputs != null) 'inputs': inputs!,
    if (skipDownstreamTasks != null)
      'skipDownstreamTasks': skipDownstreamTasks!,
    if (skipTask != null) 'skipTask': skipTask!,
    if (taskId != null) 'taskId': taskId!,
    if (taskName != null) 'taskName': taskName!,
  };
}

/// A list of artifact metadata.
class GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigArtifactList {
  /// A list of artifact metadata.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1RuntimeArtifact>? artifacts;

  GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigArtifactList({
    this.artifacts,
  });

  GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigArtifactList.fromJson(
    core.Map json_,
  ) : this(
        artifacts:
            (json_['artifacts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1RuntimeArtifact.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifacts != null) 'artifacts': artifacts!,
  };
}

/// Runtime inputs data of the task.
class GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigInputs {
  /// Input artifacts.
  ///
  /// Optional.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigArtifactList
  >?
  artifacts;

  /// Input parameters.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? parameterValues;

  GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigInputs({
    this.artifacts,
    this.parameterValues,
  });

  GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigInputs.fromJson(
    core.Map json_,
  ) : this(
        artifacts: (json_['artifacts'] as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1PipelineTaskRerunConfigArtifactList.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        parameterValues:
            json_.containsKey('parameterValues')
                ? json_['parameterValues']
                    as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifacts != null) 'artifacts': artifacts!,
    if (parameterValues != null) 'parameterValues': parameterValues!,
  };
}

/// Pipeline template metadata if PipelineJob.template_uri is from supported
/// template registry.
///
/// Currently, the only supported registry is Artifact Registry.
typedef GoogleCloudAiplatformV1beta1PipelineTemplateMetadata =
    $PipelineTemplateMetadata;

/// Input for pointwise metric.
class GoogleCloudAiplatformV1beta1PointwiseMetricInput {
  /// Pointwise metric instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PointwiseMetricInstance? instance;

  /// Spec for pointwise metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PointwiseMetricSpec? metricSpec;

  GoogleCloudAiplatformV1beta1PointwiseMetricInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1PointwiseMetricInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1PointwiseMetricInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1PointwiseMetricSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Pointwise metric instance.
///
/// Usually one instance corresponds to one row in an evaluation dataset.
class GoogleCloudAiplatformV1beta1PointwiseMetricInstance {
  /// Key-value contents for the mutlimodality input, including text, image,
  /// video, audio, and pdf, etc.
  ///
  /// The key is placeholder in metric prompt template, and the value is the
  /// multimodal content.
  GoogleCloudAiplatformV1beta1ContentMap? contentMapInstance;

  /// Instance specified as a json string.
  ///
  /// String key-value pairs are expected in the json_instance to render
  /// PointwiseMetricSpec.instance_prompt_template.
  core.String? jsonInstance;

  GoogleCloudAiplatformV1beta1PointwiseMetricInstance({
    this.contentMapInstance,
    this.jsonInstance,
  });

  GoogleCloudAiplatformV1beta1PointwiseMetricInstance.fromJson(core.Map json_)
    : this(
        contentMapInstance:
            json_.containsKey('contentMapInstance')
                ? GoogleCloudAiplatformV1beta1ContentMap.fromJson(
                  json_['contentMapInstance']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        jsonInstance: json_['jsonInstance'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentMapInstance != null) 'contentMapInstance': contentMapInstance!,
    if (jsonInstance != null) 'jsonInstance': jsonInstance!,
  };
}

/// Spec for pointwise metric result.
class GoogleCloudAiplatformV1beta1PointwiseMetricResult {
  /// Spec for custom output.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1CustomOutput? customOutput;

  /// Explanation for pointwise metric score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pointwise metric score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1beta1PointwiseMetricResult({
    this.customOutput,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1beta1PointwiseMetricResult.fromJson(core.Map json_)
    : this(
        customOutput:
            json_.containsKey('customOutput')
                ? GoogleCloudAiplatformV1beta1CustomOutput.fromJson(
                  json_['customOutput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        explanation: json_['explanation'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customOutput != null) 'customOutput': customOutput!,
    if (explanation != null) 'explanation': explanation!,
    if (score != null) 'score': score!,
  };
}

/// Spec for pointwise metric.
class GoogleCloudAiplatformV1beta1PointwiseMetricSpec {
  /// CustomOutputFormatConfig allows customization of metric output.
  ///
  /// By default, metrics return a score and explanation. When this config is
  /// set, the default output is replaced with either: - The raw output string.
  /// - A parsed output based on a user-defined schema. If a custom format is
  /// chosen, the `score` and `explanation` fields in the corresponding metric
  /// result will be empty.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1CustomOutputFormatConfig?
  customOutputFormatConfig;

  /// Metric prompt template for pointwise metric.
  ///
  /// Required.
  core.String? metricPromptTemplate;

  /// System instructions for pointwise metric.
  ///
  /// Optional.
  core.String? systemInstruction;

  GoogleCloudAiplatformV1beta1PointwiseMetricSpec({
    this.customOutputFormatConfig,
    this.metricPromptTemplate,
    this.systemInstruction,
  });

  GoogleCloudAiplatformV1beta1PointwiseMetricSpec.fromJson(core.Map json_)
    : this(
        customOutputFormatConfig:
            json_.containsKey('customOutputFormatConfig')
                ? GoogleCloudAiplatformV1beta1CustomOutputFormatConfig.fromJson(
                  json_['customOutputFormatConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricPromptTemplate: json_['metricPromptTemplate'] as core.String?,
        systemInstruction: json_['systemInstruction'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customOutputFormatConfig != null)
      'customOutputFormatConfig': customOutputFormatConfig!,
    if (metricPromptTemplate != null)
      'metricPromptTemplate': metricPromptTemplate!,
    if (systemInstruction != null) 'systemInstruction': systemInstruction!,
  };
}

/// Represents a network port in a container.
typedef GoogleCloudAiplatformV1beta1Port = $Port;

/// Post startup script config.
typedef GoogleCloudAiplatformV1beta1PostStartupScriptConfig =
    $PostStartupScriptConfig;

/// A pre-tuned model for continuous tuning.
class GoogleCloudAiplatformV1beta1PreTunedModel {
  /// The name of the base model this PreTunedModel was tuned from.
  ///
  /// Output only.
  core.String? baseModel;

  /// The source checkpoint id.
  ///
  /// If not specified, the default checkpoint will be used.
  ///
  /// Optional.
  core.String? checkpointId;

  /// The resource name of the Model.
  ///
  /// E.g., a model resource name with a specified version id or alias:
  /// `projects/{project}/locations/{location}/models/{model}@{version_id}`
  /// `projects/{project}/locations/{location}/models/{model}@{alias}` Or, omit
  /// the version id to use the default version:
  /// `projects/{project}/locations/{location}/models/{model}`
  core.String? tunedModelName;

  GoogleCloudAiplatformV1beta1PreTunedModel({
    this.baseModel,
    this.checkpointId,
    this.tunedModelName,
  });

  GoogleCloudAiplatformV1beta1PreTunedModel.fromJson(core.Map json_)
    : this(
        baseModel: json_['baseModel'] as core.String?,
        checkpointId: json_['checkpointId'] as core.String?,
        tunedModelName: json_['tunedModelName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseModel != null) 'baseModel': baseModel!,
    if (checkpointId != null) 'checkpointId': checkpointId!,
    if (tunedModelName != null) 'tunedModelName': tunedModelName!,
  };
}

/// The configuration for the prebuilt speaker to use.
typedef GoogleCloudAiplatformV1beta1PrebuiltVoiceConfig = $PrebuiltVoiceConfig;

/// Assigns input data to training, validation, and test sets based on the value
/// of a provided key.
///
/// Supported only for tabular Datasets.
typedef GoogleCloudAiplatformV1beta1PredefinedSplit = $PredefinedSplit;

/// Request message for PredictionService.PredictLongRunning.
typedef GoogleCloudAiplatformV1beta1PredictLongRunningRequest =
    $PredictLongRunningRequest;

/// Request message for PredictionService.Predict.
typedef GoogleCloudAiplatformV1beta1PredictRequest = $PredictRequest;

/// Configuration for logging request-response to a BigQuery table.
class GoogleCloudAiplatformV1beta1PredictRequestResponseLoggingConfig {
  /// BigQuery table for logging.
  ///
  /// If only given a project, a new dataset will be created with name
  /// `logging__` where will be made BigQuery-dataset-name compatible (e.g. most
  /// special characters will become underscores). If no table name is given, a
  /// new table will be created with name `request_response_logging`
  GoogleCloudAiplatformV1beta1BigQueryDestination? bigqueryDestination;

  /// This field is used for large models.
  ///
  /// If true, in addition to the original large model logs, logs will be
  /// converted in OTel schema format, and saved in otel_log column. Default
  /// value is false.
  core.bool? enableOtelLogging;

  /// If logging is enabled or not.
  core.bool? enabled;

  /// The schema version used in creating the BigQuery table for the request
  /// response logging.
  ///
  /// The versions are "v1" and "v2". The current default version is "v1".
  ///
  /// Output only.
  core.String? requestResponseLoggingSchemaVersion;

  /// Percentage of requests to be logged, expressed as a fraction in
  /// range(0,1\].
  core.double? samplingRate;

  GoogleCloudAiplatformV1beta1PredictRequestResponseLoggingConfig({
    this.bigqueryDestination,
    this.enableOtelLogging,
    this.enabled,
    this.requestResponseLoggingSchemaVersion,
    this.samplingRate,
  });

  GoogleCloudAiplatformV1beta1PredictRequestResponseLoggingConfig.fromJson(
    core.Map json_,
  ) : this(
        bigqueryDestination:
            json_.containsKey('bigqueryDestination')
                ? GoogleCloudAiplatformV1beta1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        enableOtelLogging: json_['enableOtelLogging'] as core.bool?,
        enabled: json_['enabled'] as core.bool?,
        requestResponseLoggingSchemaVersion:
            json_['requestResponseLoggingSchemaVersion'] as core.String?,
        samplingRate: (json_['samplingRate'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!,
    if (enableOtelLogging != null) 'enableOtelLogging': enableOtelLogging!,
    if (enabled != null) 'enabled': enabled!,
    if (requestResponseLoggingSchemaVersion != null)
      'requestResponseLoggingSchemaVersion':
          requestResponseLoggingSchemaVersion!,
    if (samplingRate != null) 'samplingRate': samplingRate!,
  };
}

/// Response message for PredictionService.Predict.
typedef GoogleCloudAiplatformV1beta1PredictResponse = $PredictResponse;

/// Contains the schemata used in Model's predictions and explanations via
/// PredictionService.Predict, PredictionService.Explain and BatchPredictionJob.
typedef GoogleCloudAiplatformV1beta1PredictSchemata = $PredictSchemata;

/// Statistics computed for datasets used for preference optimization.
class GoogleCloudAiplatformV1beta1PreferenceOptimizationDataStats {
  /// Dataset distributions for scores variance per example.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetDistribution?
  scoreVariancePerExampleDistribution;

  /// Dataset distributions for scores.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetDistribution? scoresDistribution;

  /// Number of billable tokens in the tuning dataset.
  ///
  /// Output only.
  core.String? totalBillableTokenCount;

  /// Number of examples in the tuning dataset.
  ///
  /// Output only.
  core.String? tuningDatasetExampleCount;

  /// Number of tuning steps for this Tuning Job.
  ///
  /// Output only.
  core.String? tuningStepCount;

  /// Sample user examples in the training dataset.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1GeminiPreferenceExample>?
  userDatasetExamples;

  /// Dataset distributions for the user input tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetDistribution? userInputTokenDistribution;

  /// Dataset distributions for the user output tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DatasetDistribution? userOutputTokenDistribution;

  GoogleCloudAiplatformV1beta1PreferenceOptimizationDataStats({
    this.scoreVariancePerExampleDistribution,
    this.scoresDistribution,
    this.totalBillableTokenCount,
    this.tuningDatasetExampleCount,
    this.tuningStepCount,
    this.userDatasetExamples,
    this.userInputTokenDistribution,
    this.userOutputTokenDistribution,
  });

  GoogleCloudAiplatformV1beta1PreferenceOptimizationDataStats.fromJson(
    core.Map json_,
  ) : this(
        scoreVariancePerExampleDistribution:
            json_.containsKey('scoreVariancePerExampleDistribution')
                ? GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(
                  json_['scoreVariancePerExampleDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        scoresDistribution:
            json_.containsKey('scoresDistribution')
                ? GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(
                  json_['scoresDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        totalBillableTokenCount:
            json_['totalBillableTokenCount'] as core.String?,
        tuningDatasetExampleCount:
            json_['tuningDatasetExampleCount'] as core.String?,
        tuningStepCount: json_['tuningStepCount'] as core.String?,
        userDatasetExamples:
            (json_['userDatasetExamples'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1GeminiPreferenceExample.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        userInputTokenDistribution:
            json_.containsKey('userInputTokenDistribution')
                ? GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(
                  json_['userInputTokenDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userOutputTokenDistribution:
            json_.containsKey('userOutputTokenDistribution')
                ? GoogleCloudAiplatformV1beta1DatasetDistribution.fromJson(
                  json_['userOutputTokenDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (scoreVariancePerExampleDistribution != null)
      'scoreVariancePerExampleDistribution':
          scoreVariancePerExampleDistribution!,
    if (scoresDistribution != null) 'scoresDistribution': scoresDistribution!,
    if (totalBillableTokenCount != null)
      'totalBillableTokenCount': totalBillableTokenCount!,
    if (tuningDatasetExampleCount != null)
      'tuningDatasetExampleCount': tuningDatasetExampleCount!,
    if (tuningStepCount != null) 'tuningStepCount': tuningStepCount!,
    if (userDatasetExamples != null)
      'userDatasetExamples': userDatasetExamples!,
    if (userInputTokenDistribution != null)
      'userInputTokenDistribution': userInputTokenDistribution!,
    if (userOutputTokenDistribution != null)
      'userOutputTokenDistribution': userOutputTokenDistribution!,
  };
}

/// Hyperparameters for Preference Optimization.
class GoogleCloudAiplatformV1beta1PreferenceOptimizationHyperParameters {
  /// Adapter size for preference optimization.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ADAPTER_SIZE_UNSPECIFIED" : Adapter size is unspecified.
  /// - "ADAPTER_SIZE_ONE" : Adapter size 1.
  /// - "ADAPTER_SIZE_TWO" : Adapter size 2.
  /// - "ADAPTER_SIZE_FOUR" : Adapter size 4.
  /// - "ADAPTER_SIZE_EIGHT" : Adapter size 8.
  /// - "ADAPTER_SIZE_SIXTEEN" : Adapter size 16.
  /// - "ADAPTER_SIZE_THIRTY_TWO" : Adapter size 32.
  core.String? adapterSize;

  /// Weight for KL Divergence regularization.
  ///
  /// Optional.
  core.double? beta;

  /// Number of complete passes the model makes over the entire training dataset
  /// during training.
  ///
  /// Optional.
  core.String? epochCount;

  /// Multiplier for adjusting the default learning rate.
  ///
  /// Optional.
  core.double? learningRateMultiplier;

  GoogleCloudAiplatformV1beta1PreferenceOptimizationHyperParameters({
    this.adapterSize,
    this.beta,
    this.epochCount,
    this.learningRateMultiplier,
  });

  GoogleCloudAiplatformV1beta1PreferenceOptimizationHyperParameters.fromJson(
    core.Map json_,
  ) : this(
        adapterSize: json_['adapterSize'] as core.String?,
        beta: (json_['beta'] as core.num?)?.toDouble(),
        epochCount: json_['epochCount'] as core.String?,
        learningRateMultiplier:
            (json_['learningRateMultiplier'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adapterSize != null) 'adapterSize': adapterSize!,
    if (beta != null) 'beta': beta!,
    if (epochCount != null) 'epochCount': epochCount!,
    if (learningRateMultiplier != null)
      'learningRateMultiplier': learningRateMultiplier!,
  };
}

/// Tuning Spec for Preference Optimization.
class GoogleCloudAiplatformV1beta1PreferenceOptimizationSpec {
  /// Hyperparameters for Preference Optimization.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PreferenceOptimizationHyperParameters?
  hyperParameters;

  /// Cloud Storage path to file containing training dataset for preference
  /// optimization tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Required.
  core.String? trainingDatasetUri;

  /// Cloud Storage path to file containing validation dataset for preference
  /// optimization tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Optional.
  core.String? validationDatasetUri;

  GoogleCloudAiplatformV1beta1PreferenceOptimizationSpec({
    this.hyperParameters,
    this.trainingDatasetUri,
    this.validationDatasetUri,
  });

  GoogleCloudAiplatformV1beta1PreferenceOptimizationSpec.fromJson(
    core.Map json_,
  ) : this(
        hyperParameters:
            json_.containsKey('hyperParameters')
                ? GoogleCloudAiplatformV1beta1PreferenceOptimizationHyperParameters.fromJson(
                  json_['hyperParameters']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingDatasetUri: json_['trainingDatasetUri'] as core.String?,
        validationDatasetUri: json_['validationDatasetUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperParameters != null) 'hyperParameters': hyperParameters!,
    if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri!,
    if (validationDatasetUri != null)
      'validationDatasetUri': validationDatasetUri!,
  };
}

/// Preset configuration for example-based explanations
typedef GoogleCloudAiplatformV1beta1Presets = $Presets;

/// PrivateEndpoints proto is used to provide paths for users to send requests
/// privately.
///
/// To send request via private service access, use predict_http_uri,
/// explain_http_uri or health_http_uri. To send request via private service
/// connect, use service_attachment.
typedef GoogleCloudAiplatformV1beta1PrivateEndpoints = $PrivateEndpoints;

/// Represents configuration for private service connect.
class GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig {
  /// If true, expose the IndexEndpoint via private service connect.
  ///
  /// Required.
  core.bool? enablePrivateServiceConnect;

  /// If set to true, enable secure private service connect with IAM
  /// authorization.
  ///
  /// Otherwise, private service connect will be done without authorization.
  /// Note latency will be slightly increased if authorization is enabled.
  ///
  /// Optional.
  core.bool? enableSecurePrivateServiceConnect;

  /// A list of Projects from which the forwarding rule will target the service
  /// attachment.
  core.List<core.String>? projectAllowlist;

  /// List of projects and networks where the PSC endpoints will be created.
  ///
  /// This field is used by Online Inference(Prediction) only.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1PSCAutomationConfig>?
  pscAutomationConfigs;

  /// The name of the generated service attachment resource.
  ///
  /// This is only populated if the endpoint is deployed with
  /// PrivateServiceConnect.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig({
    this.enablePrivateServiceConnect,
    this.enableSecurePrivateServiceConnect,
    this.projectAllowlist,
    this.pscAutomationConfigs,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1beta1PrivateServiceConnectConfig.fromJson(
    core.Map json_,
  ) : this(
        enablePrivateServiceConnect:
            json_['enablePrivateServiceConnect'] as core.bool?,
        enableSecurePrivateServiceConnect:
            json_['enableSecurePrivateServiceConnect'] as core.bool?,
        projectAllowlist:
            (json_['projectAllowlist'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        pscAutomationConfigs:
            (json_['pscAutomationConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PSCAutomationConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        serviceAttachment: json_['serviceAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enablePrivateServiceConnect != null)
      'enablePrivateServiceConnect': enablePrivateServiceConnect!,
    if (enableSecurePrivateServiceConnect != null)
      'enableSecurePrivateServiceConnect': enableSecurePrivateServiceConnect!,
    if (projectAllowlist != null) 'projectAllowlist': projectAllowlist!,
    if (pscAutomationConfigs != null)
      'pscAutomationConfigs': pscAutomationConfigs!,
    if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
  };
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
class GoogleCloudAiplatformV1beta1Probe {
  /// ExecAction probes the health of a container by executing a command.
  GoogleCloudAiplatformV1beta1ProbeExecAction? exec;

  /// Number of consecutive failures before the probe is considered failed.
  ///
  /// Defaults to 3. Minimum value is 1. Maps to Kubernetes probe argument
  /// 'failureThreshold'.
  core.int? failureThreshold;

  /// GrpcAction probes the health of a container by sending a gRPC request.
  GoogleCloudAiplatformV1beta1ProbeGrpcAction? grpc;

  /// HttpGetAction probes the health of a container by sending an HTTP GET
  /// request.
  GoogleCloudAiplatformV1beta1ProbeHttpGetAction? httpGet;

  /// Number of seconds to wait before starting the probe.
  ///
  /// Defaults to 0. Minimum value is 0. Maps to Kubernetes probe argument
  /// 'initialDelaySeconds'.
  core.int? initialDelaySeconds;

  /// How often (in seconds) to perform the probe.
  ///
  /// Default to 10 seconds. Minimum value is 1. Must be less than
  /// timeout_seconds. Maps to Kubernetes probe argument 'periodSeconds'.
  core.int? periodSeconds;

  /// Number of consecutive successes before the probe is considered successful.
  ///
  /// Defaults to 1. Minimum value is 1. Maps to Kubernetes probe argument
  /// 'successThreshold'.
  core.int? successThreshold;

  /// TcpSocketAction probes the health of a container by opening a TCP socket
  /// connection.
  GoogleCloudAiplatformV1beta1ProbeTcpSocketAction? tcpSocket;

  /// Number of seconds after which the probe times out.
  ///
  /// Defaults to 1 second. Minimum value is 1. Must be greater or equal to
  /// period_seconds. Maps to Kubernetes probe argument 'timeoutSeconds'.
  core.int? timeoutSeconds;

  GoogleCloudAiplatformV1beta1Probe({
    this.exec,
    this.failureThreshold,
    this.grpc,
    this.httpGet,
    this.initialDelaySeconds,
    this.periodSeconds,
    this.successThreshold,
    this.tcpSocket,
    this.timeoutSeconds,
  });

  GoogleCloudAiplatformV1beta1Probe.fromJson(core.Map json_)
    : this(
        exec:
            json_.containsKey('exec')
                ? GoogleCloudAiplatformV1beta1ProbeExecAction.fromJson(
                  json_['exec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        failureThreshold: json_['failureThreshold'] as core.int?,
        grpc:
            json_.containsKey('grpc')
                ? GoogleCloudAiplatformV1beta1ProbeGrpcAction.fromJson(
                  json_['grpc'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        httpGet:
            json_.containsKey('httpGet')
                ? GoogleCloudAiplatformV1beta1ProbeHttpGetAction.fromJson(
                  json_['httpGet'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        initialDelaySeconds: json_['initialDelaySeconds'] as core.int?,
        periodSeconds: json_['periodSeconds'] as core.int?,
        successThreshold: json_['successThreshold'] as core.int?,
        tcpSocket:
            json_.containsKey('tcpSocket')
                ? GoogleCloudAiplatformV1beta1ProbeTcpSocketAction.fromJson(
                  json_['tcpSocket'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        timeoutSeconds: json_['timeoutSeconds'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exec != null) 'exec': exec!,
    if (failureThreshold != null) 'failureThreshold': failureThreshold!,
    if (grpc != null) 'grpc': grpc!,
    if (httpGet != null) 'httpGet': httpGet!,
    if (initialDelaySeconds != null)
      'initialDelaySeconds': initialDelaySeconds!,
    if (periodSeconds != null) 'periodSeconds': periodSeconds!,
    if (successThreshold != null) 'successThreshold': successThreshold!,
    if (tcpSocket != null) 'tcpSocket': tcpSocket!,
    if (timeoutSeconds != null) 'timeoutSeconds': timeoutSeconds!,
  };
}

/// ExecAction specifies a command to execute.
typedef GoogleCloudAiplatformV1beta1ProbeExecAction = $ExecAction;

/// GrpcAction checks the health of a container using a gRPC service.
typedef GoogleCloudAiplatformV1beta1ProbeGrpcAction = $ProbeGrpcAction;

/// HttpGetAction describes an action based on HTTP Get requests.
class GoogleCloudAiplatformV1beta1ProbeHttpGetAction {
  /// Host name to connect to, defaults to the model serving container's IP.
  ///
  /// You probably want to set "Host" in httpHeaders instead.
  core.String? host;

  /// Custom headers to set in the request.
  ///
  /// HTTP allows repeated headers.
  core.List<GoogleCloudAiplatformV1beta1ProbeHttpHeader>? httpHeaders;

  /// Path to access on the HTTP server.
  core.String? path;

  /// Number of the port to access on the container.
  ///
  /// Number must be in the range 1 to 65535.
  core.int? port;

  /// Scheme to use for connecting to the host.
  ///
  /// Defaults to HTTP. Acceptable values are "HTTP" or "HTTPS".
  core.String? scheme;

  GoogleCloudAiplatformV1beta1ProbeHttpGetAction({
    this.host,
    this.httpHeaders,
    this.path,
    this.port,
    this.scheme,
  });

  GoogleCloudAiplatformV1beta1ProbeHttpGetAction.fromJson(core.Map json_)
    : this(
        host: json_['host'] as core.String?,
        httpHeaders:
            (json_['httpHeaders'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ProbeHttpHeader.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        path: json_['path'] as core.String?,
        port: json_['port'] as core.int?,
        scheme: json_['scheme'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (httpHeaders != null) 'httpHeaders': httpHeaders!,
    if (path != null) 'path': path!,
    if (port != null) 'port': port!,
    if (scheme != null) 'scheme': scheme!,
  };
}

/// HttpHeader describes a custom header to be used in HTTP probes
typedef GoogleCloudAiplatformV1beta1ProbeHttpHeader = $ProbeHttpHeader;

/// TcpSocketAction probes the health of a container by opening a TCP socket
/// connection.
typedef GoogleCloudAiplatformV1beta1ProbeTcpSocketAction =
    $ProbeTcpSocketAction;

/// PscAutomatedEndpoints defines the output of the forwarding rule
/// automatically created by each PscAutomationConfig.
typedef GoogleCloudAiplatformV1beta1PscAutomatedEndpoints =
    $PscAutomatedEndpoints;

/// Configuration for PSC-I.
class GoogleCloudAiplatformV1beta1PscInterfaceConfig {
  /// DNS peering configurations.
  ///
  /// When specified, Vertex AI will attempt to configure DNS peering zones in
  /// the tenant project VPC to resolve the specified domains using the target
  /// network's Cloud DNS. The user must grant the dns.peer role to the Vertex
  /// AI Service Agent on the target project.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1DnsPeeringConfig>? dnsPeeringConfigs;

  /// The name of the Compute Engine
  /// [network attachment](https://cloud.google.com/vpc/docs/about-network-attachments)
  /// to attach to the resource within the region and user project.
  ///
  /// To specify this field, you must have already
  /// [created a network attachment](https://cloud.google.com/vpc/docs/create-manage-network-attachments#create-network-attachments).
  /// This field is only used for resources using PSC-I.
  ///
  /// Optional.
  core.String? networkAttachment;

  GoogleCloudAiplatformV1beta1PscInterfaceConfig({
    this.dnsPeeringConfigs,
    this.networkAttachment,
  });

  GoogleCloudAiplatformV1beta1PscInterfaceConfig.fromJson(core.Map json_)
    : this(
        dnsPeeringConfigs:
            (json_['dnsPeeringConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DnsPeeringConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        networkAttachment: json_['networkAttachment'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dnsPeeringConfigs != null) 'dnsPeeringConfigs': dnsPeeringConfigs!,
    if (networkAttachment != null) 'networkAttachment': networkAttachment!,
  };
}

/// A Model Garden Publisher Model.
class GoogleCloudAiplatformV1beta1PublisherModel {
  /// Additional information about the model's Frameworks.
  ///
  /// Optional.
  core.List<core.String>? frameworks;

  /// Indicates the launch stage of the model.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "LAUNCH_STAGE_UNSPECIFIED" : The model launch stage is unspecified.
  /// - "EXPERIMENTAL" : Used to indicate the PublisherModel is at Experimental
  /// launch stage, available to a small set of customers.
  /// - "PRIVATE_PREVIEW" : Used to indicate the PublisherModel is at Private
  /// Preview launch stage, only available to a small set of customers, although
  /// a larger set of customers than an Experimental launch. Previews are the
  /// first launch stage used to get feedback from customers.
  /// - "PUBLIC_PREVIEW" : Used to indicate the PublisherModel is at Public
  /// Preview launch stage, available to all customers, although not supported
  /// for production workloads.
  /// - "GA" : Used to indicate the PublisherModel is at GA launch stage,
  /// available to all customers and ready for production workload.
  core.String? launchStage;

  /// The resource name of the PublisherModel.
  ///
  /// Output only.
  core.String? name;

  /// Indicates the open source category of the publisher model.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OPEN_SOURCE_CATEGORY_UNSPECIFIED" : The open source category is
  /// unspecified, which should not be used.
  /// - "PROPRIETARY" : Used to indicate the PublisherModel is not open sourced.
  /// - "GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" : Used to indicate the
  /// PublisherModel is a Google-owned open source model w/ Google checkpoint.
  /// - "THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" : Used to indicate the
  /// PublisherModel is a 3p-owned open source model w/ Google checkpoint.
  /// - "GOOGLE_OWNED_OSS" : Used to indicate the PublisherModel is a
  /// Google-owned pure open source model.
  /// - "THIRD_PARTY_OWNED_OSS" : Used to indicate the PublisherModel is a
  /// 3p-owned pure open source model.
  core.String? openSourceCategory;

  /// The parent that this model was customized from.
  ///
  /// E.g., Vision API, Natural Language API, LaMDA, T5, etc. Foundation models
  /// don't have parents.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelParent? parent;

  /// The schemata that describes formats of the PublisherModel's predictions
  /// and explanations as given and returned via PredictionService.Predict.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PredictSchemata? predictSchemata;

  /// Used to indicate this model has a publisher model and provide the template
  /// of the publisher model resource name.
  ///
  /// Optional. Output only. Immutable.
  core.String? publisherModelTemplate;

  /// Supported call-to-action options.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToAction? supportedActions;

  /// The version ID of the PublisherModel.
  ///
  /// A new version is committed when a new model version is uploaded under an
  /// existing model id. It is an auto-incrementing decimal number in string
  /// representation.
  ///
  /// Output only. Immutable.
  core.String? versionId;

  /// Indicates the state of the model version.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "VERSION_STATE_UNSPECIFIED" : The version state is unspecified.
  /// - "VERSION_STATE_STABLE" : Used to indicate the version is stable.
  /// - "VERSION_STATE_UNSTABLE" : Used to indicate the version is unstable.
  core.String? versionState;

  GoogleCloudAiplatformV1beta1PublisherModel({
    this.frameworks,
    this.launchStage,
    this.name,
    this.openSourceCategory,
    this.parent,
    this.predictSchemata,
    this.publisherModelTemplate,
    this.supportedActions,
    this.versionId,
    this.versionState,
  });

  GoogleCloudAiplatformV1beta1PublisherModel.fromJson(core.Map json_)
    : this(
        frameworks:
            (json_['frameworks'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        launchStage: json_['launchStage'] as core.String?,
        name: json_['name'] as core.String?,
        openSourceCategory: json_['openSourceCategory'] as core.String?,
        parent:
            json_.containsKey('parent')
                ? GoogleCloudAiplatformV1beta1PublisherModelParent.fromJson(
                  json_['parent'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        predictSchemata:
            json_.containsKey('predictSchemata')
                ? GoogleCloudAiplatformV1beta1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        publisherModelTemplate: json_['publisherModelTemplate'] as core.String?,
        supportedActions:
            json_.containsKey('supportedActions')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToAction.fromJson(
                  json_['supportedActions']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        versionId: json_['versionId'] as core.String?,
        versionState: json_['versionState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (frameworks != null) 'frameworks': frameworks!,
    if (launchStage != null) 'launchStage': launchStage!,
    if (name != null) 'name': name!,
    if (openSourceCategory != null) 'openSourceCategory': openSourceCategory!,
    if (parent != null) 'parent': parent!,
    if (predictSchemata != null) 'predictSchemata': predictSchemata!,
    if (publisherModelTemplate != null)
      'publisherModelTemplate': publisherModelTemplate!,
    if (supportedActions != null) 'supportedActions': supportedActions!,
    if (versionId != null) 'versionId': versionId!,
    if (versionState != null) 'versionState': versionState!,
  };
}

/// Actions could take on this Publisher Model.
class GoogleCloudAiplatformV1beta1PublisherModelCallToAction {
  /// Create application using the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  createApplication;

  /// Deploy the PublisherModel to Vertex Endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeploy? deploy;

  /// Deploy PublisherModel to Google Kubernetes Engine.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployGke? deployGke;

  /// Multiple setups to deploy the PublisherModel to Vertex Endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployVertex?
  multiDeployVertex;

  /// Open evaluation pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  openEvaluationPipeline;

  /// Open fine-tuning pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  openFineTuningPipeline;

  /// Open fine-tuning pipelines of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenFineTuningPipelines?
  openFineTuningPipelines;

  /// Open in Generation AI Studio.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  openGenerationAiStudio;

  /// Open Genie / Playground.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  openGenie;

  /// Open notebook of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  openNotebook;

  /// Open notebooks of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenNotebooks?
  openNotebooks;

  /// Open prompt-tuning pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  openPromptTuningPipeline;

  /// Request for access.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences?
  requestAccess;

  /// To view Rest API docs.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionViewRestApi?
  viewRestApi;

  GoogleCloudAiplatformV1beta1PublisherModelCallToAction({
    this.createApplication,
    this.deploy,
    this.deployGke,
    this.multiDeployVertex,
    this.openEvaluationPipeline,
    this.openFineTuningPipeline,
    this.openFineTuningPipelines,
    this.openGenerationAiStudio,
    this.openGenie,
    this.openNotebook,
    this.openNotebooks,
    this.openPromptTuningPipeline,
    this.requestAccess,
    this.viewRestApi,
  });

  GoogleCloudAiplatformV1beta1PublisherModelCallToAction.fromJson(
    core.Map json_,
  ) : this(
        createApplication:
            json_.containsKey('createApplication')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['createApplication']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        deploy:
            json_.containsKey('deploy')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeploy.fromJson(
                  json_['deploy'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        deployGke:
            json_.containsKey('deployGke')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployGke.fromJson(
                  json_['deployGke'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        multiDeployVertex:
            json_.containsKey('multiDeployVertex')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployVertex.fromJson(
                  json_['multiDeployVertex']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        openEvaluationPipeline:
            json_.containsKey('openEvaluationPipeline')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['openEvaluationPipeline']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        openFineTuningPipeline:
            json_.containsKey('openFineTuningPipeline')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['openFineTuningPipeline']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        openFineTuningPipelines:
            json_.containsKey('openFineTuningPipelines')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenFineTuningPipelines.fromJson(
                  json_['openFineTuningPipelines']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        openGenerationAiStudio:
            json_.containsKey('openGenerationAiStudio')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['openGenerationAiStudio']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        openGenie:
            json_.containsKey('openGenie')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['openGenie'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        openNotebook:
            json_.containsKey('openNotebook')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['openNotebook'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        openNotebooks:
            json_.containsKey('openNotebooks')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenNotebooks.fromJson(
                  json_['openNotebooks'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        openPromptTuningPipeline:
            json_.containsKey('openPromptTuningPipeline')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['openPromptTuningPipeline']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        requestAccess:
            json_.containsKey('requestAccess')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                  json_['requestAccess'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        viewRestApi:
            json_.containsKey('viewRestApi')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionViewRestApi.fromJson(
                  json_['viewRestApi'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createApplication != null) 'createApplication': createApplication!,
    if (deploy != null) 'deploy': deploy!,
    if (deployGke != null) 'deployGke': deployGke!,
    if (multiDeployVertex != null) 'multiDeployVertex': multiDeployVertex!,
    if (openEvaluationPipeline != null)
      'openEvaluationPipeline': openEvaluationPipeline!,
    if (openFineTuningPipeline != null)
      'openFineTuningPipeline': openFineTuningPipeline!,
    if (openFineTuningPipelines != null)
      'openFineTuningPipelines': openFineTuningPipelines!,
    if (openGenerationAiStudio != null)
      'openGenerationAiStudio': openGenerationAiStudio!,
    if (openGenie != null) 'openGenie': openGenie!,
    if (openNotebook != null) 'openNotebook': openNotebook!,
    if (openNotebooks != null) 'openNotebooks': openNotebooks!,
    if (openPromptTuningPipeline != null)
      'openPromptTuningPipeline': openPromptTuningPipeline!,
    if (requestAccess != null) 'requestAccess': requestAccess!,
    if (viewRestApi != null) 'viewRestApi': viewRestApi!,
  };
}

/// Model metadata that is needed for UploadModel or DeployModel/CreateEndpoint
/// requests.
class GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeploy {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  ///
  /// Optional.
  core.String? artifactUri;

  /// A description of resources that to large degree are decided by Vertex AI,
  /// and require only a modest additional configuration.
  GoogleCloudAiplatformV1beta1AutomaticResources? automaticResources;

  /// The specification of the container that is to be used when deploying this
  /// Model in Vertex AI.
  ///
  /// Not present for Large Models.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ModelContainerSpec? containerSpec;

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  GoogleCloudAiplatformV1beta1DedicatedResources? dedicatedResources;

  /// Metadata information about this deployment config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployDeployMetadata?
  deployMetadata;

  /// The name of the deploy task (e.g., "text to image generation").
  ///
  /// Optional.
  core.String? deployTaskName;

  /// Large model reference.
  ///
  /// When this is set, model_artifact_spec is not needed.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1LargeModelReference? largeModelReference;

  /// Default model display name.
  ///
  /// Optional.
  core.String? modelDisplayName;

  /// The signed URI for ephemeral Cloud Storage access to model artifact.
  ///
  /// Optional.
  core.String? publicArtifactUri;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  core.String? sharedResources;

  /// The title of the regional resource reference.
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeploy({
    this.artifactUri,
    this.automaticResources,
    this.containerSpec,
    this.dedicatedResources,
    this.deployMetadata,
    this.deployTaskName,
    this.largeModelReference,
    this.modelDisplayName,
    this.publicArtifactUri,
    this.sharedResources,
    this.title,
  });

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeploy.fromJson(
    core.Map json_,
  ) : this(
        artifactUri: json_['artifactUri'] as core.String?,
        automaticResources:
            json_.containsKey('automaticResources')
                ? GoogleCloudAiplatformV1beta1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        containerSpec:
            json_.containsKey('containerSpec')
                ? GoogleCloudAiplatformV1beta1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        dedicatedResources:
            json_.containsKey('dedicatedResources')
                ? GoogleCloudAiplatformV1beta1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        deployMetadata:
            json_.containsKey('deployMetadata')
                ? GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployDeployMetadata.fromJson(
                  json_['deployMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        deployTaskName: json_['deployTaskName'] as core.String?,
        largeModelReference:
            json_.containsKey('largeModelReference')
                ? GoogleCloudAiplatformV1beta1LargeModelReference.fromJson(
                  json_['largeModelReference']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelDisplayName: json_['modelDisplayName'] as core.String?,
        publicArtifactUri: json_['publicArtifactUri'] as core.String?,
        sharedResources: json_['sharedResources'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactUri != null) 'artifactUri': artifactUri!,
    if (automaticResources != null) 'automaticResources': automaticResources!,
    if (containerSpec != null) 'containerSpec': containerSpec!,
    if (dedicatedResources != null) 'dedicatedResources': dedicatedResources!,
    if (deployMetadata != null) 'deployMetadata': deployMetadata!,
    if (deployTaskName != null) 'deployTaskName': deployTaskName!,
    if (largeModelReference != null)
      'largeModelReference': largeModelReference!,
    if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
    if (publicArtifactUri != null) 'publicArtifactUri': publicArtifactUri!,
    if (sharedResources != null) 'sharedResources': sharedResources!,
    if (title != null) 'title': title!,
  };
}

/// Metadata information about the deployment for managing deployment config.
typedef GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployDeployMetadata =
    $PublisherModelCallToActionDeployDeployMetadata;

/// Configurations for PublisherModel GKE deployment
typedef GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployGke =
    $PublisherModelCallToActionDeployGke;

/// Multiple setups to deploy the PublisherModel.
class GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployVertex {
  /// One click deployment configurations.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeploy>?
  multiDeployVertex;

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployVertex({
    this.multiDeployVertex,
  });

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeployVertex.fromJson(
    core.Map json_,
  ) : this(
        multiDeployVertex:
            (json_['multiDeployVertex'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PublisherModelCallToActionDeploy.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (multiDeployVertex != null) 'multiDeployVertex': multiDeployVertex!,
  };
}

/// Open fine tuning pipelines.
class GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenFineTuningPipelines {
  /// Regional resource references to fine tuning pipelines.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences
  >?
  fineTuningPipelines;

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenFineTuningPipelines({
    this.fineTuningPipelines,
  });

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenFineTuningPipelines.fromJson(
    core.Map json_,
  ) : this(
        fineTuningPipelines:
            (json_['fineTuningPipelines'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fineTuningPipelines != null)
      'fineTuningPipelines': fineTuningPipelines!,
  };
}

/// Open notebooks.
class GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenNotebooks {
  /// Regional resource references to notebooks.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences
  >?
  notebooks;

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenNotebooks({
    this.notebooks,
  });

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionOpenNotebooks.fromJson(
    core.Map json_,
  ) : this(
        notebooks:
            (json_['notebooks'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (notebooks != null) 'notebooks': notebooks!,
  };
}

/// The regional resource name or the URI.
///
/// Key is region, e.g., us-central1, europe-west2, global, etc..
class GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences {
  /// For notebook resource.
  ///
  /// When set to true, the Colab Enterprise link will be disabled in the "open
  /// notebook" dialog in UI.
  ///
  /// Optional.
  core.bool? colabNotebookDisabled;

  /// Required.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1PublisherModelResourceReference
  >?
  references;

  /// Description of the resource.
  ///
  /// Optional.
  core.String? resourceDescription;

  /// Title of the resource.
  ///
  /// Optional.
  core.String? resourceTitle;

  /// Use case (CUJ) of the resource.
  ///
  /// Optional.
  core.String? resourceUseCase;

  /// For notebook resource, whether the notebook supports Workbench.
  ///
  /// Optional.
  core.bool? supportsWorkbench;

  ///
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences({
    this.colabNotebookDisabled,
    this.references,
    this.resourceDescription,
    this.resourceTitle,
    this.resourceUseCase,
    this.supportsWorkbench,
    this.title,
  });

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionRegionalResourceReferences.fromJson(
    core.Map json_,
  ) : this(
        colabNotebookDisabled: json_['colabNotebookDisabled'] as core.bool?,
        references:
            (json_['references'] as core.Map<core.String, core.dynamic>?)?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1PublisherModelResourceReference.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        resourceDescription: json_['resourceDescription'] as core.String?,
        resourceTitle: json_['resourceTitle'] as core.String?,
        resourceUseCase: json_['resourceUseCase'] as core.String?,
        supportsWorkbench: json_['supportsWorkbench'] as core.bool?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (colabNotebookDisabled != null)
      'colabNotebookDisabled': colabNotebookDisabled!,
    if (references != null) 'references': references!,
    if (resourceDescription != null)
      'resourceDescription': resourceDescription!,
    if (resourceTitle != null) 'resourceTitle': resourceTitle!,
    if (resourceUseCase != null) 'resourceUseCase': resourceUseCase!,
    if (supportsWorkbench != null) 'supportsWorkbench': supportsWorkbench!,
    if (title != null) 'title': title!,
  };
}

/// Rest API docs.
class GoogleCloudAiplatformV1beta1PublisherModelCallToActionViewRestApi {
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1PublisherModelDocumentation>?
  documentations;

  /// The title of the view rest API.
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionViewRestApi({
    this.documentations,
    this.title,
  });

  GoogleCloudAiplatformV1beta1PublisherModelCallToActionViewRestApi.fromJson(
    core.Map json_,
  ) : this(
        documentations:
            (json_['documentations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1PublisherModelDocumentation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentations != null) 'documentations': documentations!,
    if (title != null) 'title': title!,
  };
}

/// This message contains configs of a publisher model.
class GoogleCloudAiplatformV1beta1PublisherModelConfig {
  /// The prediction request/response logging config.
  GoogleCloudAiplatformV1beta1PredictRequestResponseLoggingConfig?
  loggingConfig;

  GoogleCloudAiplatformV1beta1PublisherModelConfig({this.loggingConfig});

  GoogleCloudAiplatformV1beta1PublisherModelConfig.fromJson(core.Map json_)
    : this(
        loggingConfig:
            json_.containsKey('loggingConfig')
                ? GoogleCloudAiplatformV1beta1PredictRequestResponseLoggingConfig.fromJson(
                  json_['loggingConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (loggingConfig != null) 'loggingConfig': loggingConfig!,
  };
}

/// A named piece of documentation.
typedef GoogleCloudAiplatformV1beta1PublisherModelDocumentation =
    $PublisherModelDocumentation;

/// Response message for ModelGardenService.UpdatePublisherModelEula.
class GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance {
  /// The project number requesting access for named model.
  core.String? projectNumber;

  /// The publisher model resource name.
  core.String? publisherModel;

  /// The EULA content acceptance status.
  core.bool? publisherModelEulaAcked;

  GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance({
    this.projectNumber,
    this.publisherModel,
    this.publisherModelEulaAcked,
  });

  GoogleCloudAiplatformV1beta1PublisherModelEulaAcceptance.fromJson(
    core.Map json_,
  ) : this(
        projectNumber: json_['projectNumber'] as core.String?,
        publisherModel: json_['publisherModel'] as core.String?,
        publisherModelEulaAcked: json_['publisherModelEulaAcked'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (projectNumber != null) 'projectNumber': projectNumber!,
    if (publisherModel != null) 'publisherModel': publisherModel!,
    if (publisherModelEulaAcked != null)
      'publisherModelEulaAcked': publisherModelEulaAcked!,
  };
}

/// The information about the parent of a model.
class GoogleCloudAiplatformV1beta1PublisherModelParent {
  /// The display name of the parent.
  ///
  /// E.g., LaMDA, T5, Vision API, Natural Language API.
  ///
  /// Required.
  core.String? displayName;

  /// The Google Cloud resource name or the URI reference.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1PublisherModelResourceReference? reference;

  GoogleCloudAiplatformV1beta1PublisherModelParent({
    this.displayName,
    this.reference,
  });

  GoogleCloudAiplatformV1beta1PublisherModelParent.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        reference:
            json_.containsKey('reference')
                ? GoogleCloudAiplatformV1beta1PublisherModelResourceReference.fromJson(
                  json_['reference'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (reference != null) 'reference': reference!,
  };
}

/// Reference to a resource.
typedef GoogleCloudAiplatformV1beta1PublisherModelResourceReference =
    $PublisherModelResourceReference;

/// Request message for MetadataService.PurgeArtifacts.
typedef GoogleCloudAiplatformV1beta1PurgeArtifactsRequest =
    $PurgeArtifactsRequest;

/// Request message for MetadataService.PurgeContexts.
typedef GoogleCloudAiplatformV1beta1PurgeContextsRequest =
    $PurgeContextsRequest;

/// Request message for MetadataService.PurgeExecutions.
typedef GoogleCloudAiplatformV1beta1PurgeExecutionsRequest =
    $PurgeExecutionsRequest;

/// The spec of a Python packaged code.
class GoogleCloudAiplatformV1beta1PythonPackageSpec {
  /// Command line arguments to be passed to the Python task.
  core.List<core.String>? args;

  /// Environment variables to be passed to the python module.
  ///
  /// Maximum limit is 100.
  core.List<GoogleCloudAiplatformV1beta1EnvVar>? env;

  /// The URI of a container image in Artifact Registry that will run the
  /// provided Python package.
  ///
  /// Vertex AI provides a wide range of executor images with pre-installed
  /// packages to meet users' various use cases. See the list of \[pre-built
  /// containers for
  /// training\](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// You must use an image from this list.
  ///
  /// Required.
  core.String? executorImageUri;

  /// The Google Cloud Storage location of the Python package files which are
  /// the training program and its dependent packages.
  ///
  /// The maximum number of package URIs is 100.
  ///
  /// Required.
  core.List<core.String>? packageUris;

  /// The Python module name to run after installing the packages.
  ///
  /// Required.
  core.String? pythonModule;

  GoogleCloudAiplatformV1beta1PythonPackageSpec({
    this.args,
    this.env,
    this.executorImageUri,
    this.packageUris,
    this.pythonModule,
  });

  GoogleCloudAiplatformV1beta1PythonPackageSpec.fromJson(core.Map json_)
    : this(
        args:
            (json_['args'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        env:
            (json_['env'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1EnvVar.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        executorImageUri: json_['executorImageUri'] as core.String?,
        packageUris:
            (json_['packageUris'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        pythonModule: json_['pythonModule'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (args != null) 'args': args!,
    if (env != null) 'env': env!,
    if (executorImageUri != null) 'executorImageUri': executorImageUri!,
    if (packageUris != null) 'packageUris': packageUris!,
    if (pythonModule != null) 'pythonModule': pythonModule!,
  };
}

/// Response message for QueryDeployedModels method.
class GoogleCloudAiplatformV1beta1QueryDeployedModelsResponse {
  /// References to the DeployedModels that share the specified
  /// deploymentResourcePool.
  core.List<GoogleCloudAiplatformV1beta1DeployedModelRef>? deployedModelRefs;

  /// DEPRECATED Use deployed_model_refs instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<GoogleCloudAiplatformV1beta1DeployedModel>? deployedModels;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The total number of DeployedModels on this DeploymentResourcePool.
  core.int? totalDeployedModelCount;

  /// The total number of Endpoints that have DeployedModels on this
  /// DeploymentResourcePool.
  core.int? totalEndpointCount;

  GoogleCloudAiplatformV1beta1QueryDeployedModelsResponse({
    this.deployedModelRefs,
    this.deployedModels,
    this.nextPageToken,
    this.totalDeployedModelCount,
    this.totalEndpointCount,
  });

  GoogleCloudAiplatformV1beta1QueryDeployedModelsResponse.fromJson(
    core.Map json_,
  ) : this(
        deployedModelRefs:
            (json_['deployedModelRefs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1DeployedModelRef.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        deployedModels:
            (json_['deployedModels'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1DeployedModel.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
        totalDeployedModelCount: json_['totalDeployedModelCount'] as core.int?,
        totalEndpointCount: json_['totalEndpointCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedModelRefs != null) 'deployedModelRefs': deployedModelRefs!,
    if (deployedModels != null) 'deployedModels': deployedModels!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (totalDeployedModelCount != null)
      'totalDeployedModelCount': totalDeployedModelCount!,
    if (totalEndpointCount != null) 'totalEndpointCount': totalEndpointCount!,
  };
}

/// Request message for ExtensionExecutionService.QueryExtension.
class GoogleCloudAiplatformV1beta1QueryExtensionRequest {
  /// The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn
  /// queries, this is a repeated field that contains conversation history +
  /// latest request.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  GoogleCloudAiplatformV1beta1QueryExtensionRequest({this.contents});

  GoogleCloudAiplatformV1beta1QueryExtensionRequest.fromJson(core.Map json_)
    : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
  };
}

/// Response message for ExtensionExecutionService.QueryExtension.
class GoogleCloudAiplatformV1beta1QueryExtensionResponse {
  /// Failure message if any.
  core.String? failureMessage;

  /// Steps of extension or LLM interaction, can contain function call, function
  /// response, or text response.
  ///
  /// The last step contains the final response to the query.
  core.List<GoogleCloudAiplatformV1beta1Content>? steps;

  GoogleCloudAiplatformV1beta1QueryExtensionResponse({
    this.failureMessage,
    this.steps,
  });

  GoogleCloudAiplatformV1beta1QueryExtensionResponse.fromJson(core.Map json_)
    : this(
        failureMessage: json_['failureMessage'] as core.String?,
        steps:
            (json_['steps'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (failureMessage != null) 'failureMessage': failureMessage!,
    if (steps != null) 'steps': steps!,
  };
}

/// Request message for ReasoningEngineExecutionService.Query.
typedef GoogleCloudAiplatformV1beta1QueryReasoningEngineRequest =
    $QueryReasoningEngineRequest;

/// Response message for ReasoningEngineExecutionService.Query
typedef GoogleCloudAiplatformV1beta1QueryReasoningEngineResponse =
    $QueryReasoningEngineResponse;

/// Input for question answering correctness metric.
class GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInput {
  /// Question answering correctness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInstance? instance;

  /// Spec for question answering correctness score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessSpec? metricSpec;

  GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for question answering correctness instance.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessInstance =
    $Instance02;

/// Spec for question answering correctness result.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessResult =
    $QuestionAnsweringCorrectnessResult;

/// Spec for question answering correctness metric.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringCorrectnessSpec =
    $QuestionAnsweringCorrectnessSpec;

/// Input for question answering helpfulness metric.
class GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInput {
  /// Question answering helpfulness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInstance? instance;

  /// Spec for question answering helpfulness score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessSpec? metricSpec;

  GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for question answering helpfulness instance.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessInstance =
    $Instance02;

/// Spec for question answering helpfulness result.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessResult =
    $QuestionAnsweringHelpfulnessResult;

/// Spec for question answering helpfulness metric.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringHelpfulnessSpec =
    $QuestionAnsweringHelpfulnessSpec;

/// Input for question answering quality metric.
class GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInput {
  /// Question answering quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInstance? instance;

  /// Spec for question answering quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringQualitySpec? metricSpec;

  GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringQualitySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for question answering quality instance.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringQualityInstance =
    $QuestionAnsweringQualityInstance;

/// Spec for question answering quality result.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringQualityResult =
    $QuestionAnsweringQualityResult;

/// Spec for question answering quality score metric.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringQualitySpec =
    $QuestionAnsweringQualitySpec;

/// Input for question answering relevance metric.
class GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInput {
  /// Question answering relevance instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInstance? instance;

  /// Spec for question answering relevance score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceSpec? metricSpec;

  GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for question answering relevance instance.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceInstance =
    $Instance02;

/// Spec for question answering relevance result.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceResult =
    $QuestionAnsweringRelevanceResult;

/// Spec for question answering relevance metric.
typedef GoogleCloudAiplatformV1beta1QuestionAnsweringRelevanceSpec =
    $QuestionAnsweringRelevanceSpec;

/// A RagChunk includes the content of a chunk of a RagFile, and associated
/// metadata.
class GoogleCloudAiplatformV1beta1RagChunk {
  /// If populated, represents where the chunk starts and ends in the document.
  GoogleCloudAiplatformV1beta1RagChunkPageSpan? pageSpan;

  /// The content of the chunk.
  core.String? text;

  GoogleCloudAiplatformV1beta1RagChunk({this.pageSpan, this.text});

  GoogleCloudAiplatformV1beta1RagChunk.fromJson(core.Map json_)
    : this(
        pageSpan:
            json_.containsKey('pageSpan')
                ? GoogleCloudAiplatformV1beta1RagChunkPageSpan.fromJson(
                  json_['pageSpan'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageSpan != null) 'pageSpan': pageSpan!,
    if (text != null) 'text': text!,
  };
}

/// Represents where the chunk starts and ends in the document.
typedef GoogleCloudAiplatformV1beta1RagChunkPageSpan = $RagChunkPageSpan;

/// Relevant contexts for one query.
class GoogleCloudAiplatformV1beta1RagContexts {
  /// All its contexts.
  core.List<GoogleCloudAiplatformV1beta1RagContextsContext>? contexts;

  GoogleCloudAiplatformV1beta1RagContexts({this.contexts});

  GoogleCloudAiplatformV1beta1RagContexts.fromJson(core.Map json_)
    : this(
        contexts:
            (json_['contexts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1RagContextsContext.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contexts != null) 'contexts': contexts!,
  };
}

/// A context of the query.
class GoogleCloudAiplatformV1beta1RagContextsContext {
  /// Context of the retrieved chunk.
  GoogleCloudAiplatformV1beta1RagChunk? chunk;

  /// The distance between the query dense embedding vector and the context text
  /// vector.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? distance;

  /// According to the underlying Vector DB and the selected metric type, the
  /// score can be either the distance or the similarity between the query and
  /// the context and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the context. The larger the distance, the
  /// less relevant the context is to the query. The range is \[0, 2\], while 0
  /// means the most relevant and 2 means the least relevant.
  core.double? score;

  /// The file display name.
  core.String? sourceDisplayName;

  /// If the file is imported from Cloud Storage or Google Drive, source_uri
  /// will be original file URI in Cloud Storage or Google Drive; if file is
  /// uploaded, source_uri will be file display name.
  core.String? sourceUri;

  /// The distance between the query sparse embedding vector and the context
  /// text vector.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? sparseDistance;

  /// The text chunk.
  core.String? text;

  GoogleCloudAiplatformV1beta1RagContextsContext({
    this.chunk,
    this.distance,
    this.score,
    this.sourceDisplayName,
    this.sourceUri,
    this.sparseDistance,
    this.text,
  });

  GoogleCloudAiplatformV1beta1RagContextsContext.fromJson(core.Map json_)
    : this(
        chunk:
            json_.containsKey('chunk')
                ? GoogleCloudAiplatformV1beta1RagChunk.fromJson(
                  json_['chunk'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        distance: (json_['distance'] as core.num?)?.toDouble(),
        score: (json_['score'] as core.num?)?.toDouble(),
        sourceDisplayName: json_['sourceDisplayName'] as core.String?,
        sourceUri: json_['sourceUri'] as core.String?,
        sparseDistance: (json_['sparseDistance'] as core.num?)?.toDouble(),
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunk != null) 'chunk': chunk!,
    if (distance != null) 'distance': distance!,
    if (score != null) 'score': score!,
    if (sourceDisplayName != null) 'sourceDisplayName': sourceDisplayName!,
    if (sourceUri != null) 'sourceUri': sourceUri!,
    if (sparseDistance != null) 'sparseDistance': sparseDistance!,
    if (text != null) 'text': text!,
  };
}

/// A RagCorpus is a RagFile container and a project can have multiple
/// RagCorpora.
class GoogleCloudAiplatformV1beta1RagCorpus {
  /// RagCorpus state.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1CorpusStatus? corpusStatus;

  /// The corpus type config of the RagCorpus.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfig? corpusTypeConfig;

  /// Timestamp when this RagCorpus was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the RagCorpus.
  ///
  /// Optional.
  core.String? description;

  /// The display name of the RagCorpus.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// The CMEK key name used to encrypt at-rest data related to this Corpus.
  ///
  /// Only applicable to RagManagedDb option for Vector DB. This field can only
  /// be set at corpus creation time, and cannot be updated or deleted.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// The resource name of the RagCorpus.
  ///
  /// Output only.
  core.String? name;

  /// The embedding model config of the RagCorpus.
  ///
  /// Optional. Immutable.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfig? ragEmbeddingModelConfig;

  /// Number of RagFiles in the RagCorpus.
  ///
  /// Output only.
  core.int? ragFilesCount;

  /// The Vector DB config of the RagCorpus.
  ///
  /// Optional. Immutable.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1RagVectorDbConfig? ragVectorDbConfig;

  /// Timestamp when this RagCorpus was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The config for the Vector DBs.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1RagVectorDbConfig? vectorDbConfig;

  /// The config for the Vertex AI Search.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1VertexAiSearchConfig? vertexAiSearchConfig;

  GoogleCloudAiplatformV1beta1RagCorpus({
    this.corpusStatus,
    this.corpusTypeConfig,
    this.createTime,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.name,
    this.ragEmbeddingModelConfig,
    this.ragFilesCount,
    this.ragVectorDbConfig,
    this.updateTime,
    this.vectorDbConfig,
    this.vertexAiSearchConfig,
  });

  GoogleCloudAiplatformV1beta1RagCorpus.fromJson(core.Map json_)
    : this(
        corpusStatus:
            json_.containsKey('corpusStatus')
                ? GoogleCloudAiplatformV1beta1CorpusStatus.fromJson(
                  json_['corpusStatus'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        corpusTypeConfig:
            json_.containsKey('corpusTypeConfig')
                ? GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfig.fromJson(
                  json_['corpusTypeConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        ragEmbeddingModelConfig:
            json_.containsKey('ragEmbeddingModelConfig')
                ? GoogleCloudAiplatformV1beta1RagEmbeddingModelConfig.fromJson(
                  json_['ragEmbeddingModelConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFilesCount: json_['ragFilesCount'] as core.int?,
        ragVectorDbConfig:
            json_.containsKey('ragVectorDbConfig')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfig.fromJson(
                  json_['ragVectorDbConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
        vectorDbConfig:
            json_.containsKey('vectorDbConfig')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfig.fromJson(
                  json_['vectorDbConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexAiSearchConfig:
            json_.containsKey('vertexAiSearchConfig')
                ? GoogleCloudAiplatformV1beta1VertexAiSearchConfig.fromJson(
                  json_['vertexAiSearchConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (corpusStatus != null) 'corpusStatus': corpusStatus!,
    if (corpusTypeConfig != null) 'corpusTypeConfig': corpusTypeConfig!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (name != null) 'name': name!,
    if (ragEmbeddingModelConfig != null)
      'ragEmbeddingModelConfig': ragEmbeddingModelConfig!,
    if (ragFilesCount != null) 'ragFilesCount': ragFilesCount!,
    if (ragVectorDbConfig != null) 'ragVectorDbConfig': ragVectorDbConfig!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (vectorDbConfig != null) 'vectorDbConfig': vectorDbConfig!,
    if (vertexAiSearchConfig != null)
      'vertexAiSearchConfig': vertexAiSearchConfig!,
  };
}

/// The config for the corpus type of the RagCorpus.
class GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfig {
  /// Config for the document corpus.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigDocumentCorpus?
  documentCorpus;

  /// Config for the memory corpus.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigMemoryCorpus?
  memoryCorpus;

  GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfig({
    this.documentCorpus,
    this.memoryCorpus,
  });

  GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfig.fromJson(core.Map json_)
    : this(
        documentCorpus:
            json_.containsKey('documentCorpus')
                ? GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigDocumentCorpus.fromJson(
                  json_['documentCorpus']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        memoryCorpus:
            json_.containsKey('memoryCorpus')
                ? GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigMemoryCorpus.fromJson(
                  json_['memoryCorpus'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentCorpus != null) 'documentCorpus': documentCorpus!,
    if (memoryCorpus != null) 'memoryCorpus': memoryCorpus!,
  };
}

/// Config for the document corpus.
typedef GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigDocumentCorpus =
    $Empty;

/// Config for the memory corpus.
class GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigMemoryCorpus {
  /// The LLM parser to use for the memory corpus.
  GoogleCloudAiplatformV1beta1RagFileParsingConfigLlmParser? llmParser;

  GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigMemoryCorpus({
    this.llmParser,
  });

  GoogleCloudAiplatformV1beta1RagCorpusCorpusTypeConfigMemoryCorpus.fromJson(
    core.Map json_,
  ) : this(
        llmParser:
            json_.containsKey('llmParser')
                ? GoogleCloudAiplatformV1beta1RagFileParsingConfigLlmParser.fromJson(
                  json_['llmParser'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (llmParser != null) 'llmParser': llmParser!,
  };
}

/// Config for the embedding model to use for RAG.
class GoogleCloudAiplatformV1beta1RagEmbeddingModelConfig {
  /// Configuration for hybrid search.
  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigHybridSearchConfig?
  hybridSearchConfig;

  /// The Vertex AI Prediction Endpoint that either refers to a publisher model
  /// or an endpoint that is hosting a 1P fine-tuned text embedding model.
  ///
  /// Endpoints hosting non-1P fine-tuned text embedding models are currently
  /// not supported. This is used for dense vector search.
  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigVertexPredictionEndpoint?
  vertexPredictionEndpoint;

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfig({
    this.hybridSearchConfig,
    this.vertexPredictionEndpoint,
  });

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfig.fromJson(core.Map json_)
    : this(
        hybridSearchConfig:
            json_.containsKey('hybridSearchConfig')
                ? GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigHybridSearchConfig.fromJson(
                  json_['hybridSearchConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexPredictionEndpoint:
            json_.containsKey('vertexPredictionEndpoint')
                ? GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigVertexPredictionEndpoint.fromJson(
                  json_['vertexPredictionEndpoint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hybridSearchConfig != null) 'hybridSearchConfig': hybridSearchConfig!,
    if (vertexPredictionEndpoint != null)
      'vertexPredictionEndpoint': vertexPredictionEndpoint!,
  };
}

/// Config for hybrid search.
class GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigHybridSearchConfig {
  /// The Vertex AI Prediction Endpoint that hosts the embedding model for dense
  /// embedding generations.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigVertexPredictionEndpoint?
  denseEmbeddingModelPredictionEndpoint;

  /// The configuration for sparse embedding generation.
  ///
  /// This field is optional the default behavior depends on the vector database
  /// choice on the RagCorpus.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfig?
  sparseEmbeddingConfig;

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigHybridSearchConfig({
    this.denseEmbeddingModelPredictionEndpoint,
    this.sparseEmbeddingConfig,
  });

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigHybridSearchConfig.fromJson(
    core.Map json_,
  ) : this(
        denseEmbeddingModelPredictionEndpoint:
            json_.containsKey('denseEmbeddingModelPredictionEndpoint')
                ? GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigVertexPredictionEndpoint.fromJson(
                  json_['denseEmbeddingModelPredictionEndpoint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        sparseEmbeddingConfig:
            json_.containsKey('sparseEmbeddingConfig')
                ? GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfig.fromJson(
                  json_['sparseEmbeddingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (denseEmbeddingModelPredictionEndpoint != null)
      'denseEmbeddingModelPredictionEndpoint':
          denseEmbeddingModelPredictionEndpoint!,
    if (sparseEmbeddingConfig != null)
      'sparseEmbeddingConfig': sparseEmbeddingConfig!,
  };
}

/// Configuration for sparse emebdding generation.
class GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfig {
  /// Use BM25 scoring algorithm.
  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfigBm25?
  bm25;

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfig({
    this.bm25,
  });

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfig.fromJson(
    core.Map json_,
  ) : this(
        bm25:
            json_.containsKey('bm25')
                ? GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfigBm25.fromJson(
                  json_['bm25'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bm25 != null) 'bm25': bm25!,
  };
}

/// Message for BM25 parameters.
class GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfigBm25 {
  /// The parameter to control document length normalization.
  ///
  /// It determines how much the document length affects the final score. b is
  /// in the range of \[0, 1\]. The default value is 0.75.
  ///
  /// Optional.
  core.double? b;

  /// The parameter to control term frequency saturation.
  ///
  /// It determines the scaling between the matching term frequency and final
  /// score. k1 is in the range of \[1.2, 3\]. The default value is 1.2.
  ///
  /// Optional.
  core.double? k1;

  /// Use multilingual tokenizer if set to true.
  ///
  /// Optional.
  core.bool? multilingual;

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfigBm25({
    this.b,
    this.k1,
    this.multilingual,
  });

  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigSparseEmbeddingConfigBm25.fromJson(
    core.Map json_,
  ) : this(
        b: (json_['b'] as core.num?)?.toDouble(),
        k1: (json_['k1'] as core.num?)?.toDouble(),
        multilingual: json_['multilingual'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (b != null) 'b': b!,
    if (k1 != null) 'k1': k1!,
    if (multilingual != null) 'multilingual': multilingual!,
  };
}

/// Config representing a model hosted on Vertex Prediction Endpoint.
typedef GoogleCloudAiplatformV1beta1RagEmbeddingModelConfigVertexPredictionEndpoint =
    $RagEmbeddingModelConfigVertexPredictionEndpoint;

/// Config for RagEngine.
class GoogleCloudAiplatformV1beta1RagEngineConfig {
  /// Identifier.
  ///
  /// The name of the RagEngineConfig. Format:
  /// `projects/{project}/locations/{location}/ragEngineConfig`
  core.String? name;

  /// The config of the RagManagedDb used by RagEngine.
  GoogleCloudAiplatformV1beta1RagManagedDbConfig? ragManagedDbConfig;

  GoogleCloudAiplatformV1beta1RagEngineConfig({
    this.name,
    this.ragManagedDbConfig,
  });

  GoogleCloudAiplatformV1beta1RagEngineConfig.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        ragManagedDbConfig:
            json_.containsKey('ragManagedDbConfig')
                ? GoogleCloudAiplatformV1beta1RagManagedDbConfig.fromJson(
                  json_['ragManagedDbConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (ragManagedDbConfig != null) 'ragManagedDbConfig': ragManagedDbConfig!,
  };
}

/// A RagFile contains user data for chunking, embedding and indexing.
class GoogleCloudAiplatformV1beta1RagFile {
  /// Timestamp when this RagFile was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the RagFile.
  ///
  /// Optional.
  core.String? description;

  /// The RagFile is encapsulated and uploaded in the UploadRagFile request.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DirectUploadSource? directUploadSource;

  /// The display name of the RagFile.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// State of the RagFile.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1FileStatus? fileStatus;

  /// Google Cloud Storage location of the RagFile.
  ///
  /// It does not support wildcards in the Cloud Storage uri for now.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1GcsSource? gcsSource;

  /// Google Drive location.
  ///
  /// Supports importing individual files as well as Google Drive folders.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1GoogleDriveSource? googleDriveSource;

  /// The RagFile is imported from a Jira query.
  GoogleCloudAiplatformV1beta1JiraSource? jiraSource;

  /// The resource name of the RagFile.
  ///
  /// Output only.
  core.String? name;

  /// The type of the RagFile.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "RAG_FILE_TYPE_UNSPECIFIED" : RagFile type is unspecified.
  /// - "RAG_FILE_TYPE_TXT" : RagFile type is TXT.
  /// - "RAG_FILE_TYPE_PDF" : RagFile type is PDF.
  core.String? ragFileType;

  /// The RagFile is imported from a SharePoint source.
  GoogleCloudAiplatformV1beta1SharePointSources? sharePointSources;

  /// The size of the RagFile in bytes.
  ///
  /// Output only.
  core.String? sizeBytes;

  /// The RagFile is imported from a Slack channel.
  GoogleCloudAiplatformV1beta1SlackSource? slackSource;

  /// Timestamp when this RagFile was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The metadata for metadata search.
  ///
  /// The user_metadata Needs to be in JSON format.
  ///
  /// Output only.
  core.String? userMetadata;

  GoogleCloudAiplatformV1beta1RagFile({
    this.createTime,
    this.description,
    this.directUploadSource,
    this.displayName,
    this.fileStatus,
    this.gcsSource,
    this.googleDriveSource,
    this.jiraSource,
    this.name,
    this.ragFileType,
    this.sharePointSources,
    this.sizeBytes,
    this.slackSource,
    this.updateTime,
    this.userMetadata,
  });

  GoogleCloudAiplatformV1beta1RagFile.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        directUploadSource:
            json_.containsKey('directUploadSource')
                ? GoogleCloudAiplatformV1beta1DirectUploadSource.fromJson(
                  json_['directUploadSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        displayName: json_['displayName'] as core.String?,
        fileStatus:
            json_.containsKey('fileStatus')
                ? GoogleCloudAiplatformV1beta1FileStatus.fromJson(
                  json_['fileStatus'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        googleDriveSource:
            json_.containsKey('googleDriveSource')
                ? GoogleCloudAiplatformV1beta1GoogleDriveSource.fromJson(
                  json_['googleDriveSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        jiraSource:
            json_.containsKey('jiraSource')
                ? GoogleCloudAiplatformV1beta1JiraSource.fromJson(
                  json_['jiraSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        ragFileType: json_['ragFileType'] as core.String?,
        sharePointSources:
            json_.containsKey('sharePointSources')
                ? GoogleCloudAiplatformV1beta1SharePointSources.fromJson(
                  json_['sharePointSources']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        sizeBytes: json_['sizeBytes'] as core.String?,
        slackSource:
            json_.containsKey('slackSource')
                ? GoogleCloudAiplatformV1beta1SlackSource.fromJson(
                  json_['slackSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
        userMetadata: json_['userMetadata'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (directUploadSource != null) 'directUploadSource': directUploadSource!,
    if (displayName != null) 'displayName': displayName!,
    if (fileStatus != null) 'fileStatus': fileStatus!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (googleDriveSource != null) 'googleDriveSource': googleDriveSource!,
    if (jiraSource != null) 'jiraSource': jiraSource!,
    if (name != null) 'name': name!,
    if (ragFileType != null) 'ragFileType': ragFileType!,
    if (sharePointSources != null) 'sharePointSources': sharePointSources!,
    if (sizeBytes != null) 'sizeBytes': sizeBytes!,
    if (slackSource != null) 'slackSource': slackSource!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (userMetadata != null) 'userMetadata': userMetadata!,
  };
}

/// Specifies the size and overlap of chunks for RagFiles.
class GoogleCloudAiplatformV1beta1RagFileChunkingConfig {
  /// The overlap between chunks.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? chunkOverlap;

  /// The size of the chunks.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? chunkSize;

  /// Specifies the fixed length chunking config.
  GoogleCloudAiplatformV1beta1RagFileChunkingConfigFixedLengthChunking?
  fixedLengthChunking;

  GoogleCloudAiplatformV1beta1RagFileChunkingConfig({
    this.chunkOverlap,
    this.chunkSize,
    this.fixedLengthChunking,
  });

  GoogleCloudAiplatformV1beta1RagFileChunkingConfig.fromJson(core.Map json_)
    : this(
        chunkOverlap: json_['chunkOverlap'] as core.int?,
        chunkSize: json_['chunkSize'] as core.int?,
        fixedLengthChunking:
            json_.containsKey('fixedLengthChunking')
                ? GoogleCloudAiplatformV1beta1RagFileChunkingConfigFixedLengthChunking.fromJson(
                  json_['fixedLengthChunking']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkOverlap != null) 'chunkOverlap': chunkOverlap!,
    if (chunkSize != null) 'chunkSize': chunkSize!,
    if (fixedLengthChunking != null)
      'fixedLengthChunking': fixedLengthChunking!,
  };
}

/// Specifies the fixed length chunking config.
typedef GoogleCloudAiplatformV1beta1RagFileChunkingConfigFixedLengthChunking =
    $RagFileChunkingConfigFixedLengthChunking;

/// Metadata config for RagFile.
class GoogleCloudAiplatformV1beta1RagFileMetadataConfig {
  /// Google Cloud Storage location.
  ///
  /// Supports importing individual files as well as entire Google Cloud Storage
  /// directories. Sample formats: -
  /// `gs://bucket_name/my_directory/object_name/metadata_schema.json` -
  /// `gs://bucket_name/my_directory` If the user provides a directory, the
  /// metadata schema will be read from the files that ends with
  /// "metadata_schema.json" in the directory.
  GoogleCloudAiplatformV1beta1GcsSource? gcsMetadataSchemaSource;

  /// Google Cloud Storage location.
  ///
  /// Supports importing individual files as well as entire Google Cloud Storage
  /// directories. Sample formats: -
  /// `gs://bucket_name/my_directory/object_name/metadata.json` -
  /// `gs://bucket_name/my_directory` If the user provides a directory, the
  /// metadata will be read from the files that ends with "metadata.json" in the
  /// directory.
  GoogleCloudAiplatformV1beta1GcsSource? gcsMetadataSource;

  /// Google Drive location.
  ///
  /// Supports importing individual files as well as Google Drive folders. If
  /// the user provides a folder, the metadata schema will be read from the
  /// files that ends with "metadata_schema.json" in the directory.
  GoogleCloudAiplatformV1beta1GoogleDriveSource?
  googleDriveMetadataSchemaSource;

  /// Google Drive location.
  ///
  /// Supports importing individual files as well as Google Drive folders. If
  /// the user provides a directory, the metadata will be read from the files
  /// that ends with "metadata.json" in the directory.
  GoogleCloudAiplatformV1beta1GoogleDriveSource? googleDriveMetadataSource;

  /// Inline metadata schema source.
  ///
  /// Must be a JSON string.
  core.String? inlineMetadataSchemaSource;

  /// Inline metadata source.
  ///
  /// Must be a JSON string.
  core.String? inlineMetadataSource;

  GoogleCloudAiplatformV1beta1RagFileMetadataConfig({
    this.gcsMetadataSchemaSource,
    this.gcsMetadataSource,
    this.googleDriveMetadataSchemaSource,
    this.googleDriveMetadataSource,
    this.inlineMetadataSchemaSource,
    this.inlineMetadataSource,
  });

  GoogleCloudAiplatformV1beta1RagFileMetadataConfig.fromJson(core.Map json_)
    : this(
        gcsMetadataSchemaSource:
            json_.containsKey('gcsMetadataSchemaSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsMetadataSchemaSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsMetadataSource:
            json_.containsKey('gcsMetadataSource')
                ? GoogleCloudAiplatformV1beta1GcsSource.fromJson(
                  json_['gcsMetadataSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        googleDriveMetadataSchemaSource:
            json_.containsKey('googleDriveMetadataSchemaSource')
                ? GoogleCloudAiplatformV1beta1GoogleDriveSource.fromJson(
                  json_['googleDriveMetadataSchemaSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        googleDriveMetadataSource:
            json_.containsKey('googleDriveMetadataSource')
                ? GoogleCloudAiplatformV1beta1GoogleDriveSource.fromJson(
                  json_['googleDriveMetadataSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineMetadataSchemaSource:
            json_['inlineMetadataSchemaSource'] as core.String?,
        inlineMetadataSource: json_['inlineMetadataSource'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsMetadataSchemaSource != null)
      'gcsMetadataSchemaSource': gcsMetadataSchemaSource!,
    if (gcsMetadataSource != null) 'gcsMetadataSource': gcsMetadataSource!,
    if (googleDriveMetadataSchemaSource != null)
      'googleDriveMetadataSchemaSource': googleDriveMetadataSchemaSource!,
    if (googleDriveMetadataSource != null)
      'googleDriveMetadataSource': googleDriveMetadataSource!,
    if (inlineMetadataSchemaSource != null)
      'inlineMetadataSchemaSource': inlineMetadataSchemaSource!,
    if (inlineMetadataSource != null)
      'inlineMetadataSource': inlineMetadataSource!,
  };
}

/// Specifies the parsing config for RagFiles.
class GoogleCloudAiplatformV1beta1RagFileParsingConfig {
  /// The Advanced Parser to use for RagFiles.
  GoogleCloudAiplatformV1beta1RagFileParsingConfigAdvancedParser?
  advancedParser;

  /// The Layout Parser to use for RagFiles.
  GoogleCloudAiplatformV1beta1RagFileParsingConfigLayoutParser? layoutParser;

  /// The LLM Parser to use for RagFiles.
  GoogleCloudAiplatformV1beta1RagFileParsingConfigLlmParser? llmParser;

  /// Whether to use advanced PDF parsing.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? useAdvancedPdfParsing;

  GoogleCloudAiplatformV1beta1RagFileParsingConfig({
    this.advancedParser,
    this.layoutParser,
    this.llmParser,
    this.useAdvancedPdfParsing,
  });

  GoogleCloudAiplatformV1beta1RagFileParsingConfig.fromJson(core.Map json_)
    : this(
        advancedParser:
            json_.containsKey('advancedParser')
                ? GoogleCloudAiplatformV1beta1RagFileParsingConfigAdvancedParser.fromJson(
                  json_['advancedParser']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        layoutParser:
            json_.containsKey('layoutParser')
                ? GoogleCloudAiplatformV1beta1RagFileParsingConfigLayoutParser.fromJson(
                  json_['layoutParser'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        llmParser:
            json_.containsKey('llmParser')
                ? GoogleCloudAiplatformV1beta1RagFileParsingConfigLlmParser.fromJson(
                  json_['llmParser'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        useAdvancedPdfParsing: json_['useAdvancedPdfParsing'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advancedParser != null) 'advancedParser': advancedParser!,
    if (layoutParser != null) 'layoutParser': layoutParser!,
    if (llmParser != null) 'llmParser': llmParser!,
    if (useAdvancedPdfParsing != null)
      'useAdvancedPdfParsing': useAdvancedPdfParsing!,
  };
}

/// Specifies the advanced parsing for RagFiles.
class GoogleCloudAiplatformV1beta1RagFileParsingConfigAdvancedParser {
  /// Whether to use advanced PDF parsing.
  core.bool? useAdvancedPdfParsing;

  GoogleCloudAiplatformV1beta1RagFileParsingConfigAdvancedParser({
    this.useAdvancedPdfParsing,
  });

  GoogleCloudAiplatformV1beta1RagFileParsingConfigAdvancedParser.fromJson(
    core.Map json_,
  ) : this(useAdvancedPdfParsing: json_['useAdvancedPdfParsing'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (useAdvancedPdfParsing != null)
      'useAdvancedPdfParsing': useAdvancedPdfParsing!,
  };
}

/// Document AI Layout Parser config.
class GoogleCloudAiplatformV1beta1RagFileParsingConfigLayoutParser {
  /// The maximum number of requests the job is allowed to make to the Document
  /// AI processor per minute in this project.
  ///
  /// Consult https://cloud.google.com/document-ai/quotas and the Quota page for
  /// your project to set an appropriate value here. If this value is not
  /// specified, max_parsing_requests_per_min will be used by indexing pipeline
  /// as the global limit.
  core.int? globalMaxParsingRequestsPerMin;

  /// The maximum number of requests the job is allowed to make to the Document
  /// AI processor per minute.
  ///
  /// Consult https://cloud.google.com/document-ai/quotas and the Quota page for
  /// your project to set an appropriate value here. If unspecified, a default
  /// value of 120 QPM would be used.
  core.int? maxParsingRequestsPerMin;

  /// The full resource name of a Document AI processor or processor version.
  ///
  /// The processor must have type `LAYOUT_PARSER_PROCESSOR`. If specified, the
  /// `additional_config.parse_as_scanned_pdf` field must be false. Format: *
  /// `projects/{project_id}/locations/{location}/processors/{processor_id}` *
  /// `projects/{project_id}/locations/{location}/processors/{processor_id}/processorVersions/{processor_version_id}`
  core.String? processorName;

  GoogleCloudAiplatformV1beta1RagFileParsingConfigLayoutParser({
    this.globalMaxParsingRequestsPerMin,
    this.maxParsingRequestsPerMin,
    this.processorName,
  });

  GoogleCloudAiplatformV1beta1RagFileParsingConfigLayoutParser.fromJson(
    core.Map json_,
  ) : this(
        globalMaxParsingRequestsPerMin:
            json_['globalMaxParsingRequestsPerMin'] as core.int?,
        maxParsingRequestsPerMin:
            json_['maxParsingRequestsPerMin'] as core.int?,
        processorName: json_['processorName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (globalMaxParsingRequestsPerMin != null)
      'globalMaxParsingRequestsPerMin': globalMaxParsingRequestsPerMin!,
    if (maxParsingRequestsPerMin != null)
      'maxParsingRequestsPerMin': maxParsingRequestsPerMin!,
    if (processorName != null) 'processorName': processorName!,
  };
}

/// Specifies the LLM parsing for RagFiles.
class GoogleCloudAiplatformV1beta1RagFileParsingConfigLlmParser {
  /// The prompt to use for parsing.
  ///
  /// If not specified, a default prompt will be used.
  core.String? customParsingPrompt;

  /// The maximum number of requests the job is allowed to make to the LLM model
  /// per minute in this project.
  ///
  /// Consult https://cloud.google.com/vertex-ai/generative-ai/docs/quotas and
  /// your document size to set an appropriate value here. If this value is not
  /// specified, max_parsing_requests_per_min will be used by indexing pipeline
  /// job as the global limit.
  core.int? globalMaxParsingRequestsPerMin;

  /// The maximum number of requests the job is allowed to make to the LLM model
  /// per minute.
  ///
  /// Consult https://cloud.google.com/vertex-ai/generative-ai/docs/quotas and
  /// your document size to set an appropriate value here. If unspecified, a
  /// default value of 5000 QPM would be used.
  core.int? maxParsingRequestsPerMin;

  /// The name of a LLM model used for parsing.
  ///
  /// Format: *
  /// `projects/{project_id}/locations/{location}/publishers/{publisher}/models/{model}`
  core.String? modelName;

  GoogleCloudAiplatformV1beta1RagFileParsingConfigLlmParser({
    this.customParsingPrompt,
    this.globalMaxParsingRequestsPerMin,
    this.maxParsingRequestsPerMin,
    this.modelName,
  });

  GoogleCloudAiplatformV1beta1RagFileParsingConfigLlmParser.fromJson(
    core.Map json_,
  ) : this(
        customParsingPrompt: json_['customParsingPrompt'] as core.String?,
        globalMaxParsingRequestsPerMin:
            json_['globalMaxParsingRequestsPerMin'] as core.int?,
        maxParsingRequestsPerMin:
            json_['maxParsingRequestsPerMin'] as core.int?,
        modelName: json_['modelName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customParsingPrompt != null)
      'customParsingPrompt': customParsingPrompt!,
    if (globalMaxParsingRequestsPerMin != null)
      'globalMaxParsingRequestsPerMin': globalMaxParsingRequestsPerMin!,
    if (maxParsingRequestsPerMin != null)
      'maxParsingRequestsPerMin': maxParsingRequestsPerMin!,
    if (modelName != null) 'modelName': modelName!,
  };
}

/// Specifies the transformation config for RagFiles.
class GoogleCloudAiplatformV1beta1RagFileTransformationConfig {
  /// Specifies the chunking config for RagFiles.
  GoogleCloudAiplatformV1beta1RagFileChunkingConfig? ragFileChunkingConfig;

  GoogleCloudAiplatformV1beta1RagFileTransformationConfig({
    this.ragFileChunkingConfig,
  });

  GoogleCloudAiplatformV1beta1RagFileTransformationConfig.fromJson(
    core.Map json_,
  ) : this(
        ragFileChunkingConfig:
            json_.containsKey('ragFileChunkingConfig')
                ? GoogleCloudAiplatformV1beta1RagFileChunkingConfig.fromJson(
                  json_['ragFileChunkingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragFileChunkingConfig != null)
      'ragFileChunkingConfig': ragFileChunkingConfig!,
  };
}

/// Configuration message for RagManagedDb used by RagEngine.
class GoogleCloudAiplatformV1beta1RagManagedDbConfig {
  /// Sets the RagManagedDb to the Basic tier.
  GoogleCloudAiplatformV1beta1RagManagedDbConfigBasic? basic;

  /// Sets the RagManagedDb to the Enterprise tier.
  ///
  /// This is the default tier if not explicitly chosen.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1RagManagedDbConfigEnterprise? enterprise;

  /// Sets the RagManagedDb to the Scaled tier.
  GoogleCloudAiplatformV1beta1RagManagedDbConfigScaled? scaled;

  /// Sets the RagManagedDb to the Unprovisioned tier.
  GoogleCloudAiplatformV1beta1RagManagedDbConfigUnprovisioned? unprovisioned;

  GoogleCloudAiplatformV1beta1RagManagedDbConfig({
    this.basic,
    this.enterprise,
    this.scaled,
    this.unprovisioned,
  });

  GoogleCloudAiplatformV1beta1RagManagedDbConfig.fromJson(core.Map json_)
    : this(
        basic:
            json_.containsKey('basic')
                ? GoogleCloudAiplatformV1beta1RagManagedDbConfigBasic.fromJson(
                  json_['basic'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        enterprise:
            json_.containsKey('enterprise')
                ? GoogleCloudAiplatformV1beta1RagManagedDbConfigEnterprise.fromJson(
                  json_['enterprise'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        scaled:
            json_.containsKey('scaled')
                ? GoogleCloudAiplatformV1beta1RagManagedDbConfigScaled.fromJson(
                  json_['scaled'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        unprovisioned:
            json_.containsKey('unprovisioned')
                ? GoogleCloudAiplatformV1beta1RagManagedDbConfigUnprovisioned.fromJson(
                  json_['unprovisioned'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (basic != null) 'basic': basic!,
    if (enterprise != null) 'enterprise': enterprise!,
    if (scaled != null) 'scaled': scaled!,
    if (unprovisioned != null) 'unprovisioned': unprovisioned!,
  };
}

/// Basic tier is a cost-effective and low compute tier suitable for the
/// following cases: * Experimenting with RagManagedDb.
///
/// * Small data size. * Latency insensitive workload. * Only using RAG Engine
/// with external vector DBs. NOTE: This is the default tier if not explicitly
/// chosen.
typedef GoogleCloudAiplatformV1beta1RagManagedDbConfigBasic = $Empty;

/// Enterprise tier offers production grade performance along with autoscaling
/// functionality.
///
/// It is suitable for customers with large amounts of data or performance
/// sensitive workloads.
typedef GoogleCloudAiplatformV1beta1RagManagedDbConfigEnterprise = $Shared03;

/// Scaled tier offers production grade performance along with autoscaling
/// functionality.
///
/// It is suitable for customers with large amounts of data or performance
/// sensitive workloads.
typedef GoogleCloudAiplatformV1beta1RagManagedDbConfigScaled = $Empty;

/// Disables the RAG Engine service and deletes all your data held within this
/// service.
///
/// This will halt the billing of the service. NOTE: Once deleted the data
/// cannot be recovered. To start using RAG Engine again, you will need to
/// update the tier by calling the UpdateRagEngineConfig API.
typedef GoogleCloudAiplatformV1beta1RagManagedDbConfigUnprovisioned = $Empty;

/// A query to retrieve relevant contexts.
class GoogleCloudAiplatformV1beta1RagQuery {
  /// The retrieval config for the query.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagRetrievalConfig? ragRetrievalConfig;

  /// Configurations for hybrid search results ranking.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1RagQueryRanking? ranking;

  /// The number of contexts to retrieve.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? similarityTopK;

  /// The query in text format to get relevant contexts.
  ///
  /// Optional.
  core.String? text;

  GoogleCloudAiplatformV1beta1RagQuery({
    this.ragRetrievalConfig,
    this.ranking,
    this.similarityTopK,
    this.text,
  });

  GoogleCloudAiplatformV1beta1RagQuery.fromJson(core.Map json_)
    : this(
        ragRetrievalConfig:
            json_.containsKey('ragRetrievalConfig')
                ? GoogleCloudAiplatformV1beta1RagRetrievalConfig.fromJson(
                  json_['ragRetrievalConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ranking:
            json_.containsKey('ranking')
                ? GoogleCloudAiplatformV1beta1RagQueryRanking.fromJson(
                  json_['ranking'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        similarityTopK: json_['similarityTopK'] as core.int?,
        text: json_['text'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragRetrievalConfig != null) 'ragRetrievalConfig': ragRetrievalConfig!,
    if (ranking != null) 'ranking': ranking!,
    if (similarityTopK != null) 'similarityTopK': similarityTopK!,
    if (text != null) 'text': text!,
  };
}

/// Configurations for hybrid search results ranking.
typedef GoogleCloudAiplatformV1beta1RagQueryRanking = $Shared09;

/// Specifies the context retrieval config.
class GoogleCloudAiplatformV1beta1RagRetrievalConfig {
  /// Config for filters.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagRetrievalConfigFilter? filter;

  /// Config for Hybrid Search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagRetrievalConfigHybridSearch? hybridSearch;

  /// Config for ranking and reranking.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagRetrievalConfigRanking? ranking;

  /// The number of contexts to retrieve.
  ///
  /// Optional.
  core.int? topK;

  GoogleCloudAiplatformV1beta1RagRetrievalConfig({
    this.filter,
    this.hybridSearch,
    this.ranking,
    this.topK,
  });

  GoogleCloudAiplatformV1beta1RagRetrievalConfig.fromJson(core.Map json_)
    : this(
        filter:
            json_.containsKey('filter')
                ? GoogleCloudAiplatformV1beta1RagRetrievalConfigFilter.fromJson(
                  json_['filter'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        hybridSearch:
            json_.containsKey('hybridSearch')
                ? GoogleCloudAiplatformV1beta1RagRetrievalConfigHybridSearch.fromJson(
                  json_['hybridSearch'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        ranking:
            json_.containsKey('ranking')
                ? GoogleCloudAiplatformV1beta1RagRetrievalConfigRanking.fromJson(
                  json_['ranking'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        topK: json_['topK'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (hybridSearch != null) 'hybridSearch': hybridSearch!,
    if (ranking != null) 'ranking': ranking!,
    if (topK != null) 'topK': topK!,
  };
}

/// Config for filters.
typedef GoogleCloudAiplatformV1beta1RagRetrievalConfigFilter =
    $RagRetrievalConfigFilter;

/// Config for Hybrid Search.
typedef GoogleCloudAiplatformV1beta1RagRetrievalConfigHybridSearch = $Shared09;

/// Config for ranking and reranking.
class GoogleCloudAiplatformV1beta1RagRetrievalConfigRanking {
  /// Config for LlmRanker.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingLlmRanker? llmRanker;

  /// Config for Rank Service.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingRankService? rankService;

  GoogleCloudAiplatformV1beta1RagRetrievalConfigRanking({
    this.llmRanker,
    this.rankService,
  });

  GoogleCloudAiplatformV1beta1RagRetrievalConfigRanking.fromJson(core.Map json_)
    : this(
        llmRanker:
            json_.containsKey('llmRanker')
                ? GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingLlmRanker.fromJson(
                  json_['llmRanker'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        rankService:
            json_.containsKey('rankService')
                ? GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingRankService.fromJson(
                  json_['rankService'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (llmRanker != null) 'llmRanker': llmRanker!,
    if (rankService != null) 'rankService': rankService!,
  };
}

/// Config for LlmRanker.
typedef GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingLlmRanker =
    $RagRetrievalConfigRankingLlmRanker;

/// Config for Rank Service.
typedef GoogleCloudAiplatformV1beta1RagRetrievalConfigRankingRankService =
    $RagRetrievalConfigRankingRankService;

/// Config for the Vector DB to use for RAG.
class GoogleCloudAiplatformV1beta1RagVectorDbConfig {
  /// Authentication config for the chosen Vector DB.
  GoogleCloudAiplatformV1beta1ApiAuth? apiAuth;

  /// The config for the Pinecone.
  GoogleCloudAiplatformV1beta1RagVectorDbConfigPinecone? pinecone;

  /// The embedding model config of the Vector DB.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1RagEmbeddingModelConfig? ragEmbeddingModelConfig;

  /// The config for the RAG-managed Vector DB.
  GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDb? ragManagedDb;

  /// The config for the Vertex Feature Store.
  GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexFeatureStore?
  vertexFeatureStore;

  /// The config for the Vertex Vector Search.
  GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexVectorSearch?
  vertexVectorSearch;

  /// The config for the Weaviate.
  GoogleCloudAiplatformV1beta1RagVectorDbConfigWeaviate? weaviate;

  GoogleCloudAiplatformV1beta1RagVectorDbConfig({
    this.apiAuth,
    this.pinecone,
    this.ragEmbeddingModelConfig,
    this.ragManagedDb,
    this.vertexFeatureStore,
    this.vertexVectorSearch,
    this.weaviate,
  });

  GoogleCloudAiplatformV1beta1RagVectorDbConfig.fromJson(core.Map json_)
    : this(
        apiAuth:
            json_.containsKey('apiAuth')
                ? GoogleCloudAiplatformV1beta1ApiAuth.fromJson(
                  json_['apiAuth'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        pinecone:
            json_.containsKey('pinecone')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfigPinecone.fromJson(
                  json_['pinecone'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragEmbeddingModelConfig:
            json_.containsKey('ragEmbeddingModelConfig')
                ? GoogleCloudAiplatformV1beta1RagEmbeddingModelConfig.fromJson(
                  json_['ragEmbeddingModelConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragManagedDb:
            json_.containsKey('ragManagedDb')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDb.fromJson(
                  json_['ragManagedDb'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexFeatureStore:
            json_.containsKey('vertexFeatureStore')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexFeatureStore.fromJson(
                  json_['vertexFeatureStore']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexVectorSearch:
            json_.containsKey('vertexVectorSearch')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexVectorSearch.fromJson(
                  json_['vertexVectorSearch']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        weaviate:
            json_.containsKey('weaviate')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfigWeaviate.fromJson(
                  json_['weaviate'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiAuth != null) 'apiAuth': apiAuth!,
    if (pinecone != null) 'pinecone': pinecone!,
    if (ragEmbeddingModelConfig != null)
      'ragEmbeddingModelConfig': ragEmbeddingModelConfig!,
    if (ragManagedDb != null) 'ragManagedDb': ragManagedDb!,
    if (vertexFeatureStore != null) 'vertexFeatureStore': vertexFeatureStore!,
    if (vertexVectorSearch != null) 'vertexVectorSearch': vertexVectorSearch!,
    if (weaviate != null) 'weaviate': weaviate!,
  };
}

/// The config for the Pinecone.
typedef GoogleCloudAiplatformV1beta1RagVectorDbConfigPinecone =
    $RagVectorDbConfigPinecone;

/// The config for the default RAG-managed Vector DB.
class GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDb {
  /// Performs an ANN search on RagCorpus.
  ///
  /// Use this if you have a lot of files (\> 10K) in your RagCorpus and want to
  /// reduce the search latency.
  GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbANN? ann;

  /// Performs a KNN search on RagCorpus.
  ///
  /// Default choice if not specified.
  GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbKNN? knn;

  GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDb({
    this.ann,
    this.knn,
  });

  GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDb.fromJson(
    core.Map json_,
  ) : this(
        ann:
            json_.containsKey('ann')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbANN.fromJson(
                  json_['ann'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        knn:
            json_.containsKey('knn')
                ? GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbKNN.fromJson(
                  json_['knn'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ann != null) 'ann': ann!,
    if (knn != null) 'knn': knn!,
  };
}

/// Config for ANN search.
///
/// RagManagedDb uses a tree-based structure to partition data and facilitate
/// faster searches. As a tradeoff, it requires longer indexing time and manual
/// triggering of index rebuild via the ImportRagFiles and UpdateRagCorpus API.
typedef GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbANN =
    $RagVectorDbConfigRagManagedDbANN;

/// Config for KNN search.
typedef GoogleCloudAiplatformV1beta1RagVectorDbConfigRagManagedDbKNN = $Empty;

/// The config for the Vertex Feature Store.
class GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexFeatureStore {
  /// The resource name of the FeatureView.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  core.String? featureViewResourceName;

  GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexFeatureStore({
    this.featureViewResourceName,
  });

  GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexFeatureStore.fromJson(
    core.Map json_,
  ) : this(
        featureViewResourceName:
            json_['featureViewResourceName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureViewResourceName != null)
      'featureViewResourceName': featureViewResourceName!,
  };
}

/// The config for the Vertex Vector Search.
typedef GoogleCloudAiplatformV1beta1RagVectorDbConfigVertexVectorSearch =
    $RagVectorDbConfigVertexVectorSearch;

/// The config for the Weaviate.
class GoogleCloudAiplatformV1beta1RagVectorDbConfigWeaviate {
  /// The corresponding collection this corpus maps to.
  ///
  /// This value cannot be changed after it's set.
  core.String? collectionName;

  /// Weaviate DB instance HTTP endpoint.
  ///
  /// e.g. 34.56.78.90:8080 Vertex RAG only supports HTTP connection to
  /// Weaviate. This value cannot be changed after it's set.
  core.String? httpEndpoint;

  GoogleCloudAiplatformV1beta1RagVectorDbConfigWeaviate({
    this.collectionName,
    this.httpEndpoint,
  });

  GoogleCloudAiplatformV1beta1RagVectorDbConfigWeaviate.fromJson(core.Map json_)
    : this(
        collectionName: json_['collectionName'] as core.String?,
        httpEndpoint: json_['httpEndpoint'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (collectionName != null) 'collectionName': collectionName!,
    if (httpEndpoint != null) 'httpEndpoint': httpEndpoint!,
  };
}

/// Raw output.
typedef GoogleCloudAiplatformV1beta1RawOutput = $RawOutput;

/// Request message for PredictionService.RawPredict.
class GoogleCloudAiplatformV1beta1RawPredictRequest {
  /// The prediction input.
  ///
  /// Supports HTTP headers and arbitrary data payload. A DeployedModel may have
  /// an upper limit on the number of instances it supports per request. When
  /// this limit it is exceeded for an AutoML model, the RawPredict method
  /// returns an error. When this limit is exceeded for a custom-trained model,
  /// the behavior varies depending on the model. You can specify the schema for
  /// each instance in the predict_schemata.instance_schema_uri field when you
  /// create a Model. This schema applies when you deploy the `Model` as a
  /// `DeployedModel` to an Endpoint and use the `RawPredict` method.
  GoogleApiHttpBody? httpBody;

  GoogleCloudAiplatformV1beta1RawPredictRequest({this.httpBody});

  GoogleCloudAiplatformV1beta1RawPredictRequest.fromJson(core.Map json_)
    : this(
        httpBody:
            json_.containsKey('httpBody')
                ? GoogleApiHttpBody.fromJson(
                  json_['httpBody'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (httpBody != null) 'httpBody': httpBody!,
  };
}

/// Configuration for the Ray OSS Logs.
typedef GoogleCloudAiplatformV1beta1RayLogsSpec = $RayLogsSpec;

/// Configuration for the Ray metrics.
typedef GoogleCloudAiplatformV1beta1RayMetricSpec = $RayMetricSpec;

/// Configuration information for the Ray cluster.
///
/// For experimental launch, Ray cluster creation and Persistent cluster
/// creation are 1:1 mapping: We will provision all the nodes within the
/// Persistent cluster as Ray nodes.
class GoogleCloudAiplatformV1beta1RaySpec {
  /// This will be used to indicate which resource pool will serve as the Ray
  /// head node(the first node within that pool).
  ///
  /// Will use the machine from the first workerpool as the head node by default
  /// if this field isn't set.
  ///
  /// Optional.
  core.String? headNodeResourcePoolId;

  /// Default image for user to choose a preferred ML framework (for example,
  /// TensorFlow or Pytorch) by choosing from
  /// [Vertex prebuilt images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  ///
  /// Either this or the resource_pool_images is required. Use this field if you
  /// need all the resource pools to have the same Ray image. Otherwise, use the
  /// {@code resource_pool_images} field.
  ///
  /// Optional.
  core.String? imageUri;

  /// Use if you want to mount to any NFS storages.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1NfsMount>? nfsMounts;

  /// OSS Ray logging configurations.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RayLogsSpec? rayLogsSpec;

  /// Ray metrics configurations.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RayMetricSpec? rayMetricSpec;

  /// Required if image_uri isn't set.
  ///
  /// A map of resource_pool_id to prebuild Ray image if user need to use
  /// different images for different head/worker pools. This map needs to cover
  /// all the resource pool ids. Example: { "ray_head_node_pool": "head image"
  /// "ray_worker_node_pool1": "worker image" "ray_worker_node_pool2": "another
  /// worker image" }
  ///
  /// Optional.
  core.Map<core.String, core.String>? resourcePoolImages;

  GoogleCloudAiplatformV1beta1RaySpec({
    this.headNodeResourcePoolId,
    this.imageUri,
    this.nfsMounts,
    this.rayLogsSpec,
    this.rayMetricSpec,
    this.resourcePoolImages,
  });

  GoogleCloudAiplatformV1beta1RaySpec.fromJson(core.Map json_)
    : this(
        headNodeResourcePoolId: json_['headNodeResourcePoolId'] as core.String?,
        imageUri: json_['imageUri'] as core.String?,
        nfsMounts:
            (json_['nfsMounts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1NfsMount.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        rayLogsSpec:
            json_.containsKey('rayLogsSpec')
                ? GoogleCloudAiplatformV1beta1RayLogsSpec.fromJson(
                  json_['rayLogsSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        rayMetricSpec:
            json_.containsKey('rayMetricSpec')
                ? GoogleCloudAiplatformV1beta1RayMetricSpec.fromJson(
                  json_['rayMetricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        resourcePoolImages: (json_['resourcePoolImages']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (headNodeResourcePoolId != null)
      'headNodeResourcePoolId': headNodeResourcePoolId!,
    if (imageUri != null) 'imageUri': imageUri!,
    if (nfsMounts != null) 'nfsMounts': nfsMounts!,
    if (rayLogsSpec != null) 'rayLogsSpec': rayLogsSpec!,
    if (rayMetricSpec != null) 'rayMetricSpec': rayMetricSpec!,
    if (resourcePoolImages != null) 'resourcePoolImages': resourcePoolImages!,
  };
}

/// Request message for FeaturestoreOnlineServingService.ReadFeatureValues.
class GoogleCloudAiplatformV1beta1ReadFeatureValuesRequest {
  /// ID for a specific entity.
  ///
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an entity ID could be `user_123`.
  ///
  /// Required.
  core.String? entityId;

  /// Selector choosing Features of the target EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureSelector? featureSelector;

  GoogleCloudAiplatformV1beta1ReadFeatureValuesRequest({
    this.entityId,
    this.featureSelector,
  });

  GoogleCloudAiplatformV1beta1ReadFeatureValuesRequest.fromJson(core.Map json_)
    : this(
        entityId: json_['entityId'] as core.String?,
        featureSelector:
            json_.containsKey('featureSelector')
                ? GoogleCloudAiplatformV1beta1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityId != null) 'entityId': entityId!,
    if (featureSelector != null) 'featureSelector': featureSelector!,
  };
}

/// Response message for FeaturestoreOnlineServingService.ReadFeatureValues.
class GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse {
  /// Entity view with Feature values.
  ///
  /// This may be the entity in the Featurestore if values for all Features were
  /// requested, or a projection of the entity in the Featurestore if values for
  /// only some Features were requested.
  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityView? entityView;

  /// Response header.
  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseHeader? header;

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse({
    this.entityView,
    this.header,
  });

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponse.fromJson(core.Map json_)
    : this(
        entityView:
            json_.containsKey('entityView')
                ? GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityView.fromJson(
                  json_['entityView'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        header:
            json_.containsKey('header')
                ? GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseHeader.fromJson(
                  json_['header'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityView != null) 'entityView': entityView!,
    if (header != null) 'header': header!,
  };
}

/// Entity view with Feature values.
class GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityView {
  /// Each piece of data holds the k requested values for one requested Feature.
  ///
  /// If no values for the requested Feature exist, the corresponding cell will
  /// be empty. This has the same size and is in the same order as the features
  /// from the header ReadFeatureValuesResponse.header.
  core.List<
    GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityViewData
  >?
  data;

  /// ID of the requested entity.
  core.String? entityId;

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityView({
    this.data,
    this.entityId,
  });

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityView.fromJson(
    core.Map json_,
  ) : this(
        data:
            (json_['data'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityViewData.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        entityId: json_['entityId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (entityId != null) 'entityId': entityId!,
  };
}

/// Container to hold value(s), successive in time, for one Feature from the
/// request.
class GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityViewData {
  /// Feature value if a single value is requested.
  GoogleCloudAiplatformV1beta1FeatureValue? value;

  /// Feature values list if values, successive in time, are requested.
  ///
  /// If the requested number of values is greater than the number of existing
  /// Feature values, nonexistent values are omitted instead of being returned
  /// as empty.
  GoogleCloudAiplatformV1beta1FeatureValueList? values;

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityViewData({
    this.value,
    this.values,
  });

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseEntityViewData.fromJson(
    core.Map json_,
  ) : this(
        value:
            json_.containsKey('value')
                ? GoogleCloudAiplatformV1beta1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        values:
            json_.containsKey('values')
                ? GoogleCloudAiplatformV1beta1FeatureValueList.fromJson(
                  json_['values'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (value != null) 'value': value!,
    if (values != null) 'values': values!,
  };
}

/// Metadata for requested Features.
typedef GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseFeatureDescriptor =
    $ReadFeatureValuesResponseFeatureDescriptor;

/// Response header with metadata for the requested
/// ReadFeatureValuesRequest.entity_type and Features.
class GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseHeader {
  /// The resource name of the EntityType from the ReadFeatureValuesRequest.
  ///
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  core.String? entityType;

  /// List of Feature metadata corresponding to each piece of
  /// ReadFeatureValuesResponse.EntityView.data.
  core.List<
    GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseFeatureDescriptor
  >?
  featureDescriptors;

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseHeader({
    this.entityType,
    this.featureDescriptors,
  });

  GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseHeader.fromJson(
    core.Map json_,
  ) : this(
        entityType: json_['entityType'] as core.String?,
        featureDescriptors:
            (json_['featureDescriptors'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ReadFeatureValuesResponseFeatureDescriptor.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityType != null) 'entityType': entityType!,
    if (featureDescriptors != null) 'featureDescriptors': featureDescriptors!,
  };
}

/// The request message for MatchService.ReadIndexDatapoints.
typedef GoogleCloudAiplatformV1beta1ReadIndexDatapointsRequest =
    $ReadIndexDatapointsRequest;

/// The response message for MatchService.ReadIndexDatapoints.
class GoogleCloudAiplatformV1beta1ReadIndexDatapointsResponse {
  /// The result list of datapoints.
  core.List<GoogleCloudAiplatformV1beta1IndexDatapoint>? datapoints;

  GoogleCloudAiplatformV1beta1ReadIndexDatapointsResponse({this.datapoints});

  GoogleCloudAiplatformV1beta1ReadIndexDatapointsResponse.fromJson(
    core.Map json_,
  ) : this(
        datapoints:
            (json_['datapoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1IndexDatapoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datapoints != null) 'datapoints': datapoints!,
  };
}

/// Response message for TensorboardService.ReadTensorboardBlobData.
class GoogleCloudAiplatformV1beta1ReadTensorboardBlobDataResponse {
  /// Blob messages containing blob bytes.
  core.List<GoogleCloudAiplatformV1beta1TensorboardBlob>? blobs;

  GoogleCloudAiplatformV1beta1ReadTensorboardBlobDataResponse({this.blobs});

  GoogleCloudAiplatformV1beta1ReadTensorboardBlobDataResponse.fromJson(
    core.Map json_,
  ) : this(
        blobs:
            (json_['blobs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TensorboardBlob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobs != null) 'blobs': blobs!,
  };
}

/// Response message for TensorboardService.ReadTensorboardSize.
typedef GoogleCloudAiplatformV1beta1ReadTensorboardSizeResponse =
    $ReadTensorboardSizeResponse;

/// Response message for TensorboardService.ReadTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1beta1ReadTensorboardTimeSeriesDataResponse {
  /// The returned time series data.
  GoogleCloudAiplatformV1beta1TimeSeriesData? timeSeriesData;

  GoogleCloudAiplatformV1beta1ReadTensorboardTimeSeriesDataResponse({
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1beta1ReadTensorboardTimeSeriesDataResponse.fromJson(
    core.Map json_,
  ) : this(
        timeSeriesData:
            json_.containsKey('timeSeriesData')
                ? GoogleCloudAiplatformV1beta1TimeSeriesData.fromJson(
                  json_['timeSeriesData']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
  };
}

/// Response message for TensorboardService.ReadTensorboardUsage.
class GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponse {
  /// Maps year-month (YYYYMM) string to per month usage data.
  core.Map<
    core.String,
    GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerMonthUsageData
  >?
  monthlyUsageData;

  GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponse({
    this.monthlyUsageData,
  });

  GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponse.fromJson(
    core.Map json_,
  ) : this(
        monthlyUsageData: (json_['monthlyUsageData']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerMonthUsageData.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (monthlyUsageData != null) 'monthlyUsageData': monthlyUsageData!,
  };
}

/// Per month usage data
class GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerMonthUsageData {
  /// Usage data for each user in the given month.
  core.List<
    GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerUserUsageData
  >?
  userUsageData;

  GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerMonthUsageData({
    this.userUsageData,
  });

  GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerMonthUsageData.fromJson(
    core.Map json_,
  ) : this(
        userUsageData:
            (json_['userUsageData'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerUserUsageData.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (userUsageData != null) 'userUsageData': userUsageData!,
  };
}

/// Per user usage data.
typedef GoogleCloudAiplatformV1beta1ReadTensorboardUsageResponsePerUserUsageData =
    $ReadTensorboardUsageResponsePerUserUsageData;

/// ReasoningEngine provides a customizable runtime for models to determine
/// which actions to take and in which order.
class GoogleCloudAiplatformV1beta1ReasoningEngine {
  /// Configuration for how Agent Engine sub-resources should manage context.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpec? contextSpec;

  /// Timestamp when this ReasoningEngine was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the ReasoningEngine.
  ///
  /// Optional.
  core.String? description;

  /// The display name of the ReasoningEngine.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a ReasoningEngine.
  ///
  /// If set, this ReasoningEngine and all sub-resources of this ReasoningEngine
  /// will be secured by this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Identifier.
  ///
  /// The resource name of the ReasoningEngine. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  core.String? name;

  /// Configurations of the ReasoningEngine
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ReasoningEngineSpec? spec;

  /// Timestamp when this ReasoningEngine was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1ReasoningEngine({
    this.contextSpec,
    this.createTime,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.name,
    this.spec,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1ReasoningEngine.fromJson(core.Map json_)
    : this(
        contextSpec:
            json_.containsKey('contextSpec')
                ? GoogleCloudAiplatformV1beta1ReasoningEngineContextSpec.fromJson(
                  json_['contextSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        name: json_['name'] as core.String?,
        spec:
            json_.containsKey('spec')
                ? GoogleCloudAiplatformV1beta1ReasoningEngineSpec.fromJson(
                  json_['spec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contextSpec != null) 'contextSpec': contextSpec!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (name != null) 'name': name!,
    if (spec != null) 'spec': spec!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Configuration for how Agent Engine sub-resources should manage context.
class GoogleCloudAiplatformV1beta1ReasoningEngineContextSpec {
  /// Specification for a Memory Bank, which manages memories for the Agent
  /// Engine.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfig?
  memoryBankConfig;

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpec({
    this.memoryBankConfig,
  });

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpec.fromJson(
    core.Map json_,
  ) : this(
        memoryBankConfig:
            json_.containsKey('memoryBankConfig')
                ? GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfig.fromJson(
                  json_['memoryBankConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (memoryBankConfig != null) 'memoryBankConfig': memoryBankConfig!,
  };
}

/// Specification for a Memory Bank.
class GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfig {
  /// Configuration for how to generate memories for the Memory Bank.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigGenerationConfig?
  generationConfig;

  /// Configuration for how to perform similarity search on memories.
  ///
  /// If not set, the Memory Bank will use the default embedding model
  /// `text-embedding-005`.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig?
  similaritySearchConfig;

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfig({
    this.generationConfig,
    this.similaritySearchConfig,
  });

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfig.fromJson(
    core.Map json_,
  ) : this(
        generationConfig:
            json_.containsKey('generationConfig')
                ? GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigGenerationConfig.fromJson(
                  json_['generationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        similaritySearchConfig:
            json_.containsKey('similaritySearchConfig')
                ? GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig.fromJson(
                  json_['similaritySearchConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (generationConfig != null) 'generationConfig': generationConfig!,
    if (similaritySearchConfig != null)
      'similaritySearchConfig': similaritySearchConfig!,
  };
}

/// Configuration for how to generate memories.
class GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigGenerationConfig {
  /// The model used to generate memories.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/google/models/{model}`.
  ///
  /// Required.
  core.String? model;

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigGenerationConfig({
    this.model,
  });

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigGenerationConfig.fromJson(
    core.Map json_,
  ) : this(model: json_['model'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
  };
}

/// Configuration for how to perform similarity search on memories.
class GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig {
  /// The model used to generate embeddings to lookup similar memories.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/google/models/{model}`.
  ///
  /// Required.
  core.String? embeddingModel;

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig({
    this.embeddingModel,
  });

  GoogleCloudAiplatformV1beta1ReasoningEngineContextSpecMemoryBankConfigSimilaritySearchConfig.fromJson(
    core.Map json_,
  ) : this(embeddingModel: json_['embeddingModel'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (embeddingModel != null) 'embeddingModel': embeddingModel!,
  };
}

/// ReasoningEngine configurations
class GoogleCloudAiplatformV1beta1ReasoningEngineSpec {
  /// The OSS agent framework used to develop the agent.
  ///
  /// Currently supported values: "google-adk", "langchain", "langgraph", "ag2",
  /// "llama-index", "custom".
  ///
  /// Optional.
  core.String? agentFramework;

  /// Declarations for object class methods in OpenAPI specification format.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? classMethods;

  /// The specification of a Reasoning Engine deployment.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ReasoningEngineSpecDeploymentSpec? deploymentSpec;

  /// User provided package spec of the ReasoningEngine.
  ///
  /// Ignored when users directly specify a deployment image through
  /// `deployment_spec.first_party_image_override`, but keeping the
  /// field_behavior to avoid introducing breaking changes.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ReasoningEngineSpecPackageSpec? packageSpec;

  /// The service account that the Reasoning Engine artifact runs as.
  ///
  /// It should have "roles/storage.objectViewer" for reading the user project's
  /// Cloud Storage and "roles/aiplatform.user" for using Vertex extensions. If
  /// not specified, the Vertex AI Reasoning Engine Service Agent in the project
  /// will be used.
  ///
  /// Optional.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1beta1ReasoningEngineSpec({
    this.agentFramework,
    this.classMethods,
    this.deploymentSpec,
    this.packageSpec,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1beta1ReasoningEngineSpec.fromJson(core.Map json_)
    : this(
        agentFramework: json_['agentFramework'] as core.String?,
        classMethods:
            (json_['classMethods'] as core.List?)
                ?.map((value) => value as core.Map<core.String, core.dynamic>)
                .toList(),
        deploymentSpec:
            json_.containsKey('deploymentSpec')
                ? GoogleCloudAiplatformV1beta1ReasoningEngineSpecDeploymentSpec.fromJson(
                  json_['deploymentSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        packageSpec:
            json_.containsKey('packageSpec')
                ? GoogleCloudAiplatformV1beta1ReasoningEngineSpecPackageSpec.fromJson(
                  json_['packageSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        serviceAccount: json_['serviceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agentFramework != null) 'agentFramework': agentFramework!,
    if (classMethods != null) 'classMethods': classMethods!,
    if (deploymentSpec != null) 'deploymentSpec': deploymentSpec!,
    if (packageSpec != null) 'packageSpec': packageSpec!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
  };
}

/// The specification of a Reasoning Engine deployment.
class GoogleCloudAiplatformV1beta1ReasoningEngineSpecDeploymentSpec {
  /// Environment variables to be set with the Reasoning Engine deployment.
  ///
  /// The environment variables can be updated through the UpdateReasoningEngine
  /// API.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1EnvVar>? env;

  /// Environment variables where the value is a secret in Cloud Secret Manager.
  ///
  /// To use this feature, add 'Secret Manager Secret Accessor' role
  /// (roles/secretmanager.secretAccessor) to AI Platform Reasoning Engine
  /// Service Agent.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1SecretEnvVar>? secretEnv;

  GoogleCloudAiplatformV1beta1ReasoningEngineSpecDeploymentSpec({
    this.env,
    this.secretEnv,
  });

  GoogleCloudAiplatformV1beta1ReasoningEngineSpecDeploymentSpec.fromJson(
    core.Map json_,
  ) : this(
        env:
            (json_['env'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1EnvVar.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        secretEnv:
            (json_['secretEnv'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1SecretEnvVar.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (env != null) 'env': env!,
    if (secretEnv != null) 'secretEnv': secretEnv!,
  };
}

/// User provided package spec like pickled object and package requirements.
typedef GoogleCloudAiplatformV1beta1ReasoningEngineSpecPackageSpec =
    $ReasoningEngineSpecPackageSpec;

/// Request message for GenAiTuningService.RebaseTunedModel.
class GoogleCloudAiplatformV1beta1RebaseTunedModelRequest {
  /// The Google Cloud Storage location to write the artifacts.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GcsDestination? artifactDestination;

  /// By default, bison to gemini migration will always create new
  /// model/endpoint, but for gemini-1.0 to gemini-1.5 migration, we default
  /// deploy to the same endpoint.
  ///
  /// See details in this Section.
  ///
  /// Optional.
  core.bool? deployToSameEndpoint;

  /// TunedModel reference to retrieve the legacy model information.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TunedModelRef? tunedModelRef;

  /// The TuningJob to be updated.
  ///
  /// Users can use this TuningJob field to overwrite tuning configs.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1TuningJob? tuningJob;

  GoogleCloudAiplatformV1beta1RebaseTunedModelRequest({
    this.artifactDestination,
    this.deployToSameEndpoint,
    this.tunedModelRef,
    this.tuningJob,
  });

  GoogleCloudAiplatformV1beta1RebaseTunedModelRequest.fromJson(core.Map json_)
    : this(
        artifactDestination:
            json_.containsKey('artifactDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['artifactDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        deployToSameEndpoint: json_['deployToSameEndpoint'] as core.bool?,
        tunedModelRef:
            json_.containsKey('tunedModelRef')
                ? GoogleCloudAiplatformV1beta1TunedModelRef.fromJson(
                  json_['tunedModelRef'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        tuningJob:
            json_.containsKey('tuningJob')
                ? GoogleCloudAiplatformV1beta1TuningJob.fromJson(
                  json_['tuningJob'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactDestination != null)
      'artifactDestination': artifactDestination!,
    if (deployToSameEndpoint != null)
      'deployToSameEndpoint': deployToSameEndpoint!,
    if (tunedModelRef != null) 'tunedModelRef': tunedModelRef!,
    if (tuningJob != null) 'tuningJob': tuningJob!,
  };
}

/// Request message for PersistentResourceService.RebootPersistentResource.
typedef GoogleCloudAiplatformV1beta1RebootPersistentResourceRequest = $Empty;

/// Request message for MetadataService.DeleteContextChildrenRequest.
typedef GoogleCloudAiplatformV1beta1RemoveContextChildrenRequest =
    $ContextChildrenRequest;

/// Response message for MetadataService.RemoveContextChildren.
typedef GoogleCloudAiplatformV1beta1RemoveContextChildrenResponse = $Empty;

/// Request message for IndexService.RemoveDatapoints
typedef GoogleCloudAiplatformV1beta1RemoveDatapointsRequest =
    $RemoveDatapointsRequest;

/// Response message for IndexService.RemoveDatapoints
typedef GoogleCloudAiplatformV1beta1RemoveDatapointsResponse = $Empty;

/// Request message for ExampleStoreService.RemoveExamples.
class GoogleCloudAiplatformV1beta1RemoveExamplesRequest {
  /// Example IDs to remove.
  ///
  /// If both metadata filters and Example IDs are specified, the metadata
  /// filters will be applied to the specified examples in order to identify
  /// which should be removed.
  ///
  /// Optional.
  core.List<core.String>? exampleIds;

  /// The metadata filters for StoredContentsExamples.
  GoogleCloudAiplatformV1beta1StoredContentsExampleFilter?
  storedContentsExampleFilter;

  GoogleCloudAiplatformV1beta1RemoveExamplesRequest({
    this.exampleIds,
    this.storedContentsExampleFilter,
  });

  GoogleCloudAiplatformV1beta1RemoveExamplesRequest.fromJson(core.Map json_)
    : this(
        exampleIds:
            (json_['exampleIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        storedContentsExampleFilter:
            json_.containsKey('storedContentsExampleFilter')
                ? GoogleCloudAiplatformV1beta1StoredContentsExampleFilter.fromJson(
                  json_['storedContentsExampleFilter']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exampleIds != null) 'exampleIds': exampleIds!,
    if (storedContentsExampleFilter != null)
      'storedContentsExampleFilter': storedContentsExampleFilter!,
  };
}

/// Response message for ExampleStoreService.RemoveExamples.
class GoogleCloudAiplatformV1beta1RemoveExamplesResponse {
  /// The IDs for the removed examples.
  core.List<core.String>? exampleIds;

  GoogleCloudAiplatformV1beta1RemoveExamplesResponse({this.exampleIds});

  GoogleCloudAiplatformV1beta1RemoveExamplesResponse.fromJson(core.Map json_)
    : this(
        exampleIds:
            (json_['exampleIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exampleIds != null) 'exampleIds': exampleIds!,
  };
}

/// Request message for NotebookInternalService.ReportExecutionEvent.
class GoogleCloudAiplatformV1beta1ReportExecutionEventRequest {
  /// The type of the event.
  ///
  /// Required.
  /// Possible string values are:
  /// - "EVENT_TYPE_UNSPECIFIED" : Unspecified.
  /// - "ACTIVE" : Notebook execution process has started. Expect this message
  /// within expected time to provision compute.
  /// - "DONE" : Notebook execution process is completed. Expect this message
  /// within timeout.
  /// - "FAILED" : Notebook execution process has failed. Expect this message
  /// within timeout.
  core.String? eventType;

  /// The error details of the event.
  ///
  /// Optional.
  GoogleRpcStatus? status;

  /// The VM identity token (a JWT) for authenticating the VM.
  ///
  /// https://cloud.google.com/compute/docs/instances/verifying-instance-identity
  ///
  /// Required.
  core.String? vmToken;

  GoogleCloudAiplatformV1beta1ReportExecutionEventRequest({
    this.eventType,
    this.status,
    this.vmToken,
  });

  GoogleCloudAiplatformV1beta1ReportExecutionEventRequest.fromJson(
    core.Map json_,
  ) : this(
        eventType: json_['eventType'] as core.String?,
        status:
            json_.containsKey('status')
                ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        vmToken: json_['vmToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (eventType != null) 'eventType': eventType!,
    if (status != null) 'status': status!,
    if (vmToken != null) 'vmToken': vmToken!,
  };
}

/// Response message for NotebookInternalService.ReportExecutionEvent.
typedef GoogleCloudAiplatformV1beta1ReportExecutionEventResponse = $Empty;

/// Request message for NotebookInternalService.ReportRuntimeEvent.
class GoogleCloudAiplatformV1beta1ReportRuntimeEventRequest {
  /// The details of the request for debug.
  ///
  /// Optional.
  core.Map<core.String, core.String>? eventDetails;

  /// The type of the event.
  ///
  /// Required.
  /// Possible string values are:
  /// - "EVENT_TYPE_UNSPECIFIED" : Unspecified.
  /// - "HEARTBEAT" : Used for readiness reporting.
  /// - "IDLE" : Used for idle reporting.
  core.String? eventType;

  /// The details of the internal os service states.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<GoogleCloudAiplatformV1beta1InternalOsServiceStateInstance>?
  internalOsServiceStateInstance;

  /// The details of the internal os service states.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1InternalOsServiceStateInstance>?
  internalOsServiceStateInstances;

  /// The VM identity token (a JWT) for authenticating the VM.
  ///
  /// https://cloud.google.com/compute/docs/instances/verifying-instance-identity
  ///
  /// Required.
  core.String? vmToken;

  GoogleCloudAiplatformV1beta1ReportRuntimeEventRequest({
    this.eventDetails,
    this.eventType,
    this.internalOsServiceStateInstance,
    this.internalOsServiceStateInstances,
    this.vmToken,
  });

  GoogleCloudAiplatformV1beta1ReportRuntimeEventRequest.fromJson(core.Map json_)
    : this(
        eventDetails: (json_['eventDetails']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        eventType: json_['eventType'] as core.String?,
        internalOsServiceStateInstance:
            (json_['internalOsServiceStateInstance'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1InternalOsServiceStateInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        internalOsServiceStateInstances:
            (json_['internalOsServiceStateInstances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1InternalOsServiceStateInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        vmToken: json_['vmToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (eventDetails != null) 'eventDetails': eventDetails!,
    if (eventType != null) 'eventType': eventType!,
    if (internalOsServiceStateInstance != null)
      'internalOsServiceStateInstance': internalOsServiceStateInstance!,
    if (internalOsServiceStateInstances != null)
      'internalOsServiceStateInstances': internalOsServiceStateInstances!,
    if (vmToken != null) 'vmToken': vmToken!,
  };
}

/// Response message for NotebookInternalService.ReportRuntimeEvent.
class GoogleCloudAiplatformV1beta1ReportRuntimeEventResponse {
  /// If the idle shutdown is blocked by CP, CP will send the block message.
  ///
  /// Otherwise, this field is not set.
  core.String? idleShutdownMessage;

  GoogleCloudAiplatformV1beta1ReportRuntimeEventResponse({
    this.idleShutdownMessage,
  });

  GoogleCloudAiplatformV1beta1ReportRuntimeEventResponse.fromJson(
    core.Map json_,
  ) : this(idleShutdownMessage: json_['idleShutdownMessage'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (idleShutdownMessage != null)
      'idleShutdownMessage': idleShutdownMessage!,
  };
}

/// A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a
/// DeployedModel) to draw its Compute Engine resources from a Shared
/// Reservation, or exclusively from on-demand capacity.
typedef GoogleCloudAiplatformV1beta1ReservationAffinity =
    $ReservationAffinity00;

/// Represents the spec of a group of resources of the same type, for example
/// machine type, disk, and accelerators, in a PersistentResource.
class GoogleCloudAiplatformV1beta1ResourcePool {
  /// Optional spec to configure GKE or Ray-on-Vertex autoscaling
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ResourcePoolAutoscalingSpec? autoscalingSpec;

  /// Disk spec for the machine in this node pool.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1DiskSpec? diskSpec;

  /// The unique ID in a PersistentResource for referring to this resource pool.
  ///
  /// User can specify it if necessary. Otherwise, it's generated automatically.
  ///
  /// Immutable.
  core.String? id;

  /// The specification of a single machine.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1beta1MachineSpec? machineSpec;

  /// The total number of machines to use for this resource pool.
  ///
  /// Optional.
  core.String? replicaCount;

  /// The number of machines currently in use by training jobs for this resource
  /// pool.
  ///
  /// Will replace idle_replica_count.
  ///
  /// Output only.
  core.String? usedReplicaCount;

  GoogleCloudAiplatformV1beta1ResourcePool({
    this.autoscalingSpec,
    this.diskSpec,
    this.id,
    this.machineSpec,
    this.replicaCount,
    this.usedReplicaCount,
  });

  GoogleCloudAiplatformV1beta1ResourcePool.fromJson(core.Map json_)
    : this(
        autoscalingSpec:
            json_.containsKey('autoscalingSpec')
                ? GoogleCloudAiplatformV1beta1ResourcePoolAutoscalingSpec.fromJson(
                  json_['autoscalingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        diskSpec:
            json_.containsKey('diskSpec')
                ? GoogleCloudAiplatformV1beta1DiskSpec.fromJson(
                  json_['diskSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        id: json_['id'] as core.String?,
        machineSpec:
            json_.containsKey('machineSpec')
                ? GoogleCloudAiplatformV1beta1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        replicaCount: json_['replicaCount'] as core.String?,
        usedReplicaCount: json_['usedReplicaCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoscalingSpec != null) 'autoscalingSpec': autoscalingSpec!,
    if (diskSpec != null) 'diskSpec': diskSpec!,
    if (id != null) 'id': id!,
    if (machineSpec != null) 'machineSpec': machineSpec!,
    if (replicaCount != null) 'replicaCount': replicaCount!,
    if (usedReplicaCount != null) 'usedReplicaCount': usedReplicaCount!,
  };
}

/// The min/max number of replicas allowed if enabling autoscaling
typedef GoogleCloudAiplatformV1beta1ResourcePoolAutoscalingSpec =
    $ResourcePoolAutoscalingSpec;

/// Persistent Cluster runtime information as output
class GoogleCloudAiplatformV1beta1ResourceRuntime {
  /// URIs for user to connect to the Cluster.
  ///
  /// Example: { "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
  /// "RAY_DASHBOARD_URI": "ray-dashboard-address:8888" }
  ///
  /// Output only.
  core.Map<core.String, core.String>? accessUris;

  /// The resource name of NotebookRuntimeTemplate for the RoV Persistent
  /// Cluster The NotebokRuntimeTemplate is created in the same VPC (if set),
  /// and with the same Ray and Python version as the Persistent Cluster.
  ///
  /// Example:
  /// "projects/1000/locations/us-central1/notebookRuntimeTemplates/abc123"
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? notebookRuntimeTemplate;

  GoogleCloudAiplatformV1beta1ResourceRuntime({
    this.accessUris,
    this.notebookRuntimeTemplate,
  });

  GoogleCloudAiplatformV1beta1ResourceRuntime.fromJson(core.Map json_)
    : this(
        accessUris: (json_['accessUris']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        notebookRuntimeTemplate:
            json_['notebookRuntimeTemplate'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessUris != null) 'accessUris': accessUris!,
    if (notebookRuntimeTemplate != null)
      'notebookRuntimeTemplate': notebookRuntimeTemplate!,
  };
}

/// Configuration for the runtime on a PersistentResource instance, including
/// but not limited to: * Service accounts used to run the workloads.
///
/// * Whether to make it a dedicated Ray Cluster.
class GoogleCloudAiplatformV1beta1ResourceRuntimeSpec {
  /// Ray cluster configuration.
  ///
  /// Required when creating a dedicated RayCluster on the PersistentResource.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RaySpec? raySpec;

  /// Configure the use of workload identity on the PersistentResource
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ServiceAccountSpec? serviceAccountSpec;

  GoogleCloudAiplatformV1beta1ResourceRuntimeSpec({
    this.raySpec,
    this.serviceAccountSpec,
  });

  GoogleCloudAiplatformV1beta1ResourceRuntimeSpec.fromJson(core.Map json_)
    : this(
        raySpec:
            json_.containsKey('raySpec')
                ? GoogleCloudAiplatformV1beta1RaySpec.fromJson(
                  json_['raySpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        serviceAccountSpec:
            json_.containsKey('serviceAccountSpec')
                ? GoogleCloudAiplatformV1beta1ServiceAccountSpec.fromJson(
                  json_['serviceAccountSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (raySpec != null) 'raySpec': raySpec!,
    if (serviceAccountSpec != null) 'serviceAccountSpec': serviceAccountSpec!,
  };
}

/// Statistics information about resource consumption.
typedef GoogleCloudAiplatformV1beta1ResourcesConsumed = $ResourcesConsumed;

/// Request message for JobService.ResumeModelDeploymentMonitoringJob.
typedef GoogleCloudAiplatformV1beta1ResumeModelDeploymentMonitoringJobRequest =
    $Empty;

/// Request message for ScheduleService.ResumeSchedule.
typedef GoogleCloudAiplatformV1beta1ResumeScheduleRequest =
    $ResumeScheduleRequest;

/// Defines a retrieval tool that model can call to access external knowledge.
class GoogleCloudAiplatformV1beta1Retrieval {
  /// This option is no longer supported.
  ///
  /// Optional. Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? disableAttribution;

  /// Use data source powered by external API for grounding.
  GoogleCloudAiplatformV1beta1ExternalApi? externalApi;

  /// Set to use data source powered by Vertex AI Search.
  GoogleCloudAiplatformV1beta1VertexAISearch? vertexAiSearch;

  /// Set to use data source powered by Vertex RAG store.
  ///
  /// User data is uploaded via the VertexRagDataService.
  GoogleCloudAiplatformV1beta1VertexRagStore? vertexRagStore;

  GoogleCloudAiplatformV1beta1Retrieval({
    this.disableAttribution,
    this.externalApi,
    this.vertexAiSearch,
    this.vertexRagStore,
  });

  GoogleCloudAiplatformV1beta1Retrieval.fromJson(core.Map json_)
    : this(
        disableAttribution: json_['disableAttribution'] as core.bool?,
        externalApi:
            json_.containsKey('externalApi')
                ? GoogleCloudAiplatformV1beta1ExternalApi.fromJson(
                  json_['externalApi'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexAiSearch:
            json_.containsKey('vertexAiSearch')
                ? GoogleCloudAiplatformV1beta1VertexAISearch.fromJson(
                  json_['vertexAiSearch']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexRagStore:
            json_.containsKey('vertexRagStore')
                ? GoogleCloudAiplatformV1beta1VertexRagStore.fromJson(
                  json_['vertexRagStore']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableAttribution != null) 'disableAttribution': disableAttribution!,
    if (externalApi != null) 'externalApi': externalApi!,
    if (vertexAiSearch != null) 'vertexAiSearch': vertexAiSearch!,
    if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!,
  };
}

/// Retrieval config.
class GoogleCloudAiplatformV1beta1RetrievalConfig {
  /// The language code of the user.
  core.String? languageCode;

  /// The location of the user.
  GoogleTypeLatLng? latLng;

  GoogleCloudAiplatformV1beta1RetrievalConfig({this.languageCode, this.latLng});

  GoogleCloudAiplatformV1beta1RetrievalConfig.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        latLng:
            json_.containsKey('latLng')
                ? GoogleTypeLatLng.fromJson(
                  json_['latLng'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (latLng != null) 'latLng': latLng!,
  };
}

/// Metadata related to retrieval in the grounding flow.
typedef GoogleCloudAiplatformV1beta1RetrievalMetadata = $RetrievalMetadata;

/// Request message for VertexRagService.RetrieveContexts.
class GoogleCloudAiplatformV1beta1RetrieveContextsRequest {
  /// Single RAG retrieve query.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1RagQuery? query;

  /// The data source for Vertex RagStore.
  GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStore?
  vertexRagStore;

  GoogleCloudAiplatformV1beta1RetrieveContextsRequest({
    this.query,
    this.vertexRagStore,
  });

  GoogleCloudAiplatformV1beta1RetrieveContextsRequest.fromJson(core.Map json_)
    : this(
        query:
            json_.containsKey('query')
                ? GoogleCloudAiplatformV1beta1RagQuery.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexRagStore:
            json_.containsKey('vertexRagStore')
                ? GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStore.fromJson(
                  json_['vertexRagStore']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (query != null) 'query': query!,
    if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!,
  };
}

/// The data source for Vertex RagStore.
class GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStore {
  /// Please use rag_resources to specify the data source.
  ///
  /// Optional. Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<core.String>? ragCorpora;

  /// The representation of the rag source.
  ///
  /// It can be used to specify corpus only or ragfiles. Currently only support
  /// one corpus or multiple files from one corpus. In the future we may open up
  /// multiple corpora support.
  ///
  /// Optional.
  core.List<
    GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStoreRagResource
  >?
  ragResources;

  /// Only return contexts with vector distance smaller than the threshold.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? vectorDistanceThreshold;

  GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStore({
    this.ragCorpora,
    this.ragResources,
    this.vectorDistanceThreshold,
  });

  GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStore.fromJson(
    core.Map json_,
  ) : this(
        ragCorpora:
            (json_['ragCorpora'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        ragResources:
            (json_['ragResources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStoreRagResource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        vectorDistanceThreshold:
            (json_['vectorDistanceThreshold'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragCorpora != null) 'ragCorpora': ragCorpora!,
    if (ragResources != null) 'ragResources': ragResources!,
    if (vectorDistanceThreshold != null)
      'vectorDistanceThreshold': vectorDistanceThreshold!,
  };
}

/// The definition of the Rag resource.
typedef GoogleCloudAiplatformV1beta1RetrieveContextsRequestVertexRagStoreRagResource =
    $VertexRagStoreRagResource;

/// Response message for VertexRagService.RetrieveContexts.
class GoogleCloudAiplatformV1beta1RetrieveContextsResponse {
  /// The contexts of the query.
  GoogleCloudAiplatformV1beta1RagContexts? contexts;

  GoogleCloudAiplatformV1beta1RetrieveContextsResponse({this.contexts});

  GoogleCloudAiplatformV1beta1RetrieveContextsResponse.fromJson(core.Map json_)
    : this(
        contexts:
            json_.containsKey('contexts')
                ? GoogleCloudAiplatformV1beta1RagContexts.fromJson(
                  json_['contexts'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contexts != null) 'contexts': contexts!,
  };
}

/// Request message for MemoryBankService.RetrieveMemories.
class GoogleCloudAiplatformV1beta1RetrieveMemoriesRequest {
  /// The scope of the memories to retrieve.
  ///
  /// A memory must have exactly the same scope (`Memory.scope`) as the scope
  /// provided here to be retrieved (same keys and values). Order does not
  /// matter, but it is case-sensitive.
  ///
  /// Required.
  core.Map<core.String, core.String>? scope;

  /// Parameters for semantic similarity search based retrieval.
  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimilaritySearchParams?
  similaritySearchParams;

  /// Parameters for simple (non-similarity search) retrieval.
  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimpleRetrievalParams?
  simpleRetrievalParams;

  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequest({
    this.scope,
    this.similaritySearchParams,
    this.simpleRetrievalParams,
  });

  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequest.fromJson(core.Map json_)
    : this(
        scope: (json_['scope'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        similaritySearchParams:
            json_.containsKey('similaritySearchParams')
                ? GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimilaritySearchParams.fromJson(
                  json_['similaritySearchParams']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        simpleRetrievalParams:
            json_.containsKey('simpleRetrievalParams')
                ? GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimpleRetrievalParams.fromJson(
                  json_['simpleRetrievalParams']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (scope != null) 'scope': scope!,
    if (similaritySearchParams != null)
      'similaritySearchParams': similaritySearchParams!,
    if (simpleRetrievalParams != null)
      'simpleRetrievalParams': simpleRetrievalParams!,
  };
}

/// Parameters for semantic similarity search based retrieval.
class GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimilaritySearchParams {
  /// Query to use for similarity search retrieval.
  ///
  /// If provided, then the parent ReasoningEngine must have
  /// ReasoningEngineContextSpec.MemoryBankConfig.SimilaritySearchConfig set.
  ///
  /// Required.
  core.String? searchQuery;

  /// The maximum number of memories to return.
  ///
  /// The service may return fewer than this value. If unspecified, at most 3
  /// memories will be returned. The maximum value is 100; values above 100 will
  /// be coerced to 100.
  ///
  /// Optional.
  core.int? topK;

  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimilaritySearchParams({
    this.searchQuery,
    this.topK,
  });

  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimilaritySearchParams.fromJson(
    core.Map json_,
  ) : this(
        searchQuery: json_['searchQuery'] as core.String?,
        topK: json_['topK'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (searchQuery != null) 'searchQuery': searchQuery!,
    if (topK != null) 'topK': topK!,
  };
}

/// Parameters for simple (non-similarity search) retrieval.
class GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimpleRetrievalParams {
  /// The maximum number of memories to return.
  ///
  /// The service may return fewer than this value. If unspecified, at most 3
  /// memories will be returned. The maximum value is 100; values above 100 will
  /// be coerced to 100.
  ///
  /// Optional.
  core.int? pageSize;

  /// A page token, received from a previous `RetrieveMemories` call.
  ///
  /// Provide this to retrieve the subsequent page.
  ///
  /// Optional.
  core.String? pageToken;

  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimpleRetrievalParams({
    this.pageSize,
    this.pageToken,
  });

  GoogleCloudAiplatformV1beta1RetrieveMemoriesRequestSimpleRetrievalParams.fromJson(
    core.Map json_,
  ) : this(
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
  };
}

/// Response message for MemoryBankService.RetrieveMemories.
class GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse {
  /// A token that can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages. This token is not
  /// set if similarity search was used for retrieval.
  core.String? nextPageToken;

  /// The retrieved memories.
  core.List<
    GoogleCloudAiplatformV1beta1RetrieveMemoriesResponseRetrievedMemory
  >?
  retrievedMemories;

  GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse({
    this.nextPageToken,
    this.retrievedMemories,
  });

  GoogleCloudAiplatformV1beta1RetrieveMemoriesResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        retrievedMemories:
            (json_['retrievedMemories'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1RetrieveMemoriesResponseRetrievedMemory.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (retrievedMemories != null) 'retrievedMemories': retrievedMemories!,
  };
}

/// A retrieved memory.
class GoogleCloudAiplatformV1beta1RetrieveMemoriesResponseRetrievedMemory {
  /// The distance between the query and the retrieved Memory.
  ///
  /// Smaller values indicate more similar memories. This is only set if
  /// similarity search was used for retrieval.
  core.double? distance;

  /// The retrieved Memory.
  GoogleCloudAiplatformV1beta1Memory? memory;

  GoogleCloudAiplatformV1beta1RetrieveMemoriesResponseRetrievedMemory({
    this.distance,
    this.memory,
  });

  GoogleCloudAiplatformV1beta1RetrieveMemoriesResponseRetrievedMemory.fromJson(
    core.Map json_,
  ) : this(
        distance: (json_['distance'] as core.num?)?.toDouble(),
        memory:
            json_.containsKey('memory')
                ? GoogleCloudAiplatformV1beta1Memory.fromJson(
                  json_['memory'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (distance != null) 'distance': distance!,
    if (memory != null) 'memory': memory!,
  };
}

/// Configuration for rolling deployments.
class GoogleCloudAiplatformV1beta1RolloutOptions {
  /// Percentage of allowed additional replicas.
  ///
  /// For autoscaling deployments, this refers to the target replica count.
  core.int? maxSurgePercentage;

  /// Absolute count of allowed additional replicas.
  core.int? maxSurgeReplicas;

  /// Percentage of replicas allowed to be unavailable.
  ///
  /// For autoscaling deployments, this refers to the target replica count.
  core.int? maxUnavailablePercentage;

  /// Absolute count of replicas allowed to be unavailable.
  core.int? maxUnavailableReplicas;

  /// ID of the DeployedModel that this deployment should replace.
  core.String? previousDeployedModel;

  /// Read-only.
  ///
  /// Revision number determines the relative priority of DeployedModels in the
  /// same rollout. The DeployedModel with the largest revision number specifies
  /// the intended state of the deployment.
  ///
  /// Output only.
  core.int? revisionNumber;

  GoogleCloudAiplatformV1beta1RolloutOptions({
    this.maxSurgePercentage,
    this.maxSurgeReplicas,
    this.maxUnavailablePercentage,
    this.maxUnavailableReplicas,
    this.previousDeployedModel,
    this.revisionNumber,
  });

  GoogleCloudAiplatformV1beta1RolloutOptions.fromJson(core.Map json_)
    : this(
        maxSurgePercentage: json_['maxSurgePercentage'] as core.int?,
        maxSurgeReplicas: json_['maxSurgeReplicas'] as core.int?,
        maxUnavailablePercentage:
            json_['maxUnavailablePercentage'] as core.int?,
        maxUnavailableReplicas: json_['maxUnavailableReplicas'] as core.int?,
        previousDeployedModel: json_['previousDeployedModel'] as core.String?,
        revisionNumber: json_['revisionNumber'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxSurgePercentage != null) 'maxSurgePercentage': maxSurgePercentage!,
    if (maxSurgeReplicas != null) 'maxSurgeReplicas': maxSurgeReplicas!,
    if (maxUnavailablePercentage != null)
      'maxUnavailablePercentage': maxUnavailablePercentage!,
    if (maxUnavailableReplicas != null)
      'maxUnavailableReplicas': maxUnavailableReplicas!,
    if (previousDeployedModel != null)
      'previousDeployedModel': previousDeployedModel!,
    if (revisionNumber != null) 'revisionNumber': revisionNumber!,
  };
}

/// Input for rouge metric.
class GoogleCloudAiplatformV1beta1RougeInput {
  /// Repeated rouge instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1RougeInstance>? instances;

  /// Spec for rouge score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1RougeSpec? metricSpec;

  GoogleCloudAiplatformV1beta1RougeInput({this.instances, this.metricSpec});

  GoogleCloudAiplatformV1beta1RougeInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1RougeInstance.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1RougeSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for rouge instance.
typedef GoogleCloudAiplatformV1beta1RougeInstance = $Instance00;

/// Rouge metric value for an instance.
typedef GoogleCloudAiplatformV1beta1RougeMetricValue = $RougeMetricValue;

/// Results for rouge metric.
class GoogleCloudAiplatformV1beta1RougeResults {
  /// Rouge metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1RougeMetricValue>? rougeMetricValues;

  GoogleCloudAiplatformV1beta1RougeResults({this.rougeMetricValues});

  GoogleCloudAiplatformV1beta1RougeResults.fromJson(core.Map json_)
    : this(
        rougeMetricValues:
            (json_['rougeMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1RougeMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rougeMetricValues != null) 'rougeMetricValues': rougeMetricValues!,
  };
}

/// Spec for rouge score metric - calculates the recall of n-grams in prediction
/// as compared to reference - returns a score ranging between 0 and 1.
typedef GoogleCloudAiplatformV1beta1RougeSpec = $RougeSpec;

/// Instance and metric spec for RubricBasedInstructionFollowing metric.
class GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInput {
  /// Instance for RubricBasedInstructionFollowing metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInstance? instance;

  /// Spec for RubricBasedInstructionFollowing metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingSpec? metricSpec;

  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Instance for RubricBasedInstructionFollowing metric - one instance
/// corresponds to one row in an evaluation dataset.
typedef GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingInstance =
    $RubricBasedInstructionFollowingInstance;

/// Result for RubricBasedInstructionFollowing metric.
class GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingResult {
  /// List of per rubric critique results.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1RubricCritiqueResult>?
  rubricCritiqueResults;

  /// Overall score for the instruction following.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingResult({
    this.rubricCritiqueResults,
    this.score,
  });

  GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingResult.fromJson(
    core.Map json_,
  ) : this(
        rubricCritiqueResults:
            (json_['rubricCritiqueResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1RubricCritiqueResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        score: (json_['score'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (rubricCritiqueResults != null)
      'rubricCritiqueResults': rubricCritiqueResults!,
    if (score != null) 'score': score!,
  };
}

/// Spec for RubricBasedInstructionFollowing metric - returns rubrics and
/// verdicts corresponding to rubrics along with overall score.
typedef GoogleCloudAiplatformV1beta1RubricBasedInstructionFollowingSpec =
    $Empty;

/// Rubric critique result.
typedef GoogleCloudAiplatformV1beta1RubricCritiqueResult =
    $RubricCritiqueResult;

/// The definition of a runtime artifact.
class GoogleCloudAiplatformV1beta1RuntimeArtifact {
  /// The custom properties of the artifact.
  ///
  /// Deprecated. Use RuntimeArtifact.metadata instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.Map<core.String, GoogleCloudAiplatformV1beta1Value>? customProperties;

  /// Properties of the Artifact.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The name of an artifact.
  core.String? name;

  /// The properties of the artifact.
  ///
  /// Deprecated. Use RuntimeArtifact.metadata instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.Map<core.String, GoogleCloudAiplatformV1beta1Value>? properties;

  /// The type of the artifact.
  GoogleCloudAiplatformV1beta1ArtifactTypeSchema? type;

  /// The URI of the artifact.
  core.String? uri;

  GoogleCloudAiplatformV1beta1RuntimeArtifact({
    this.customProperties,
    this.metadata,
    this.name,
    this.properties,
    this.type,
    this.uri,
  });

  GoogleCloudAiplatformV1beta1RuntimeArtifact.fromJson(core.Map json_)
    : this(
        customProperties: (json_['customProperties']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1Value.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
        properties:
            (json_['properties'] as core.Map<core.String, core.dynamic>?)?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1Value.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        type:
            json_.containsKey('type')
                ? GoogleCloudAiplatformV1beta1ArtifactTypeSchema.fromJson(
                  json_['type'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customProperties != null) 'customProperties': customProperties!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (properties != null) 'properties': properties!,
    if (type != null) 'type': type!,
    if (uri != null) 'uri': uri!,
  };
}

/// Runtime configuration to run the extension.
class GoogleCloudAiplatformV1beta1RuntimeConfig {
  /// Code execution runtime configurations for code interpreter extension.
  GoogleCloudAiplatformV1beta1RuntimeConfigCodeInterpreterRuntimeConfig?
  codeInterpreterRuntimeConfig;

  /// Default parameters that will be set for all the execution of this
  /// extension.
  ///
  /// If specified, the parameter values can be overridden by values in
  /// \[\[ExecuteExtensionRequest.operation_params\]\] at request time. The
  /// struct should be in a form of map with param name as the key and actual
  /// param value as the value. E.g. If this operation requires a param "name"
  /// to be set to "abc". you can set this to something like {"name": "abc"}.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? defaultParams;

  /// Runtime configuration for Vertex AI Search extension.
  GoogleCloudAiplatformV1beta1RuntimeConfigVertexAISearchRuntimeConfig?
  vertexAiSearchRuntimeConfig;

  GoogleCloudAiplatformV1beta1RuntimeConfig({
    this.codeInterpreterRuntimeConfig,
    this.defaultParams,
    this.vertexAiSearchRuntimeConfig,
  });

  GoogleCloudAiplatformV1beta1RuntimeConfig.fromJson(core.Map json_)
    : this(
        codeInterpreterRuntimeConfig:
            json_.containsKey('codeInterpreterRuntimeConfig')
                ? GoogleCloudAiplatformV1beta1RuntimeConfigCodeInterpreterRuntimeConfig.fromJson(
                  json_['codeInterpreterRuntimeConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        defaultParams:
            json_.containsKey('defaultParams')
                ? json_['defaultParams'] as core.Map<core.String, core.dynamic>
                : null,
        vertexAiSearchRuntimeConfig:
            json_.containsKey('vertexAiSearchRuntimeConfig')
                ? GoogleCloudAiplatformV1beta1RuntimeConfigVertexAISearchRuntimeConfig.fromJson(
                  json_['vertexAiSearchRuntimeConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (codeInterpreterRuntimeConfig != null)
      'codeInterpreterRuntimeConfig': codeInterpreterRuntimeConfig!,
    if (defaultParams != null) 'defaultParams': defaultParams!,
    if (vertexAiSearchRuntimeConfig != null)
      'vertexAiSearchRuntimeConfig': vertexAiSearchRuntimeConfig!,
  };
}

class GoogleCloudAiplatformV1beta1RuntimeConfigCodeInterpreterRuntimeConfig {
  /// The Cloud Storage bucket for file input of this Extension.
  ///
  /// If specified, support input from the Cloud Storage bucket. Vertex
  /// Extension Custom Code Service Agent should be granted file reader to this
  /// bucket. If not specified, the extension will only accept file contents
  /// from request body and reject Cloud Storage file inputs.
  ///
  /// Optional.
  core.String? fileInputGcsBucket;

  /// The Cloud Storage bucket for file output of this Extension.
  ///
  /// If specified, write all output files to the Cloud Storage bucket. Vertex
  /// Extension Custom Code Service Agent should be granted file writer to this
  /// bucket. If not specified, the file content will be output in response
  /// body.
  ///
  /// Optional.
  core.String? fileOutputGcsBucket;

  GoogleCloudAiplatformV1beta1RuntimeConfigCodeInterpreterRuntimeConfig({
    this.fileInputGcsBucket,
    this.fileOutputGcsBucket,
  });

  GoogleCloudAiplatformV1beta1RuntimeConfigCodeInterpreterRuntimeConfig.fromJson(
    core.Map json_,
  ) : this(
        fileInputGcsBucket: json_['fileInputGcsBucket'] as core.String?,
        fileOutputGcsBucket: json_['fileOutputGcsBucket'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fileInputGcsBucket != null) 'fileInputGcsBucket': fileInputGcsBucket!,
    if (fileOutputGcsBucket != null)
      'fileOutputGcsBucket': fileOutputGcsBucket!,
  };
}

class GoogleCloudAiplatformV1beta1RuntimeConfigVertexAISearchRuntimeConfig {
  /// Vertex AI Search engine ID.
  ///
  /// This is used to construct the search request. By setting this engine_id,
  /// API will construct the serving config using the default value to call
  /// search API for the user. The engine_id and serving_config_name cannot both
  /// be empty at the same time.
  ///
  /// Optional.
  core.String? engineId;

  /// Vertex AI Search serving config name.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config}`
  ///
  /// Optional.
  core.String? servingConfigName;

  GoogleCloudAiplatformV1beta1RuntimeConfigVertexAISearchRuntimeConfig({
    this.engineId,
    this.servingConfigName,
  });

  GoogleCloudAiplatformV1beta1RuntimeConfigVertexAISearchRuntimeConfig.fromJson(
    core.Map json_,
  ) : this(
        engineId: json_['engineId'] as core.String?,
        servingConfigName: json_['servingConfigName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (engineId != null) 'engineId': engineId!,
    if (servingConfigName != null) 'servingConfigName': servingConfigName!,
  };
}

/// Input for safety metric.
class GoogleCloudAiplatformV1beta1SafetyInput {
  /// Safety instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SafetyInstance? instance;

  /// Spec for safety metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SafetySpec? metricSpec;

  GoogleCloudAiplatformV1beta1SafetyInput({this.instance, this.metricSpec});

  GoogleCloudAiplatformV1beta1SafetyInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1SafetyInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1SafetySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for safety instance.
typedef GoogleCloudAiplatformV1beta1SafetyInstance = $Instance01;

/// Safety rating corresponding to the generated content.
typedef GoogleCloudAiplatformV1beta1SafetyRating = $SafetyRating00;

/// Spec for safety result.
typedef GoogleCloudAiplatformV1beta1SafetyResult = $SafetyResult;

/// Safety settings.
typedef GoogleCloudAiplatformV1beta1SafetySetting = $SafetySetting;

/// Spec for safety metric.
typedef GoogleCloudAiplatformV1beta1SafetySpec = $Spec00;

/// Active learning data sampling config.
///
/// For every active learning labeling iteration, it will select a batch of data
/// based on the sampling strategy.
typedef GoogleCloudAiplatformV1beta1SampleConfig = $SampleConfig;

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted.
///
/// A sampling strategy is used to approximate the value rather than considering
/// all subsets of features.
typedef GoogleCloudAiplatformV1beta1SampledShapleyAttribution =
    $SampledShapleyAttribution;

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
class GoogleCloudAiplatformV1beta1SamplingStrategy {
  /// Random sample config.
  ///
  /// Will support more sampling strategies later.
  GoogleCloudAiplatformV1beta1SamplingStrategyRandomSampleConfig?
  randomSampleConfig;

  GoogleCloudAiplatformV1beta1SamplingStrategy({this.randomSampleConfig});

  GoogleCloudAiplatformV1beta1SamplingStrategy.fromJson(core.Map json_)
    : this(
        randomSampleConfig:
            json_.containsKey('randomSampleConfig')
                ? GoogleCloudAiplatformV1beta1SamplingStrategyRandomSampleConfig.fromJson(
                  json_['randomSampleConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (randomSampleConfig != null) 'randomSampleConfig': randomSampleConfig!,
  };
}

/// Requests are randomly selected.
typedef GoogleCloudAiplatformV1beta1SamplingStrategyRandomSampleConfig =
    $SamplingStrategyRandomSampleConfig;

/// A SavedQuery is a view of the dataset.
///
/// It references a subset of annotations by problem type and filters.
typedef GoogleCloudAiplatformV1beta1SavedQuery = $SavedQuery;

/// One point viewable on a scalar metric plot.
typedef GoogleCloudAiplatformV1beta1Scalar = $Scalar;

/// An instance of a Schedule periodically schedules runs to make API calls
/// based on user specified time specification and API request type.
class GoogleCloudAiplatformV1beta1Schedule {
  /// Whether new scheduled runs can be queued when max_concurrent_runs limit is
  /// reached.
  ///
  /// If set to true, new runs will be queued instead of skipped. Default to
  /// false.
  ///
  /// Optional.
  core.bool? allowQueueing;

  /// Whether to backfill missed runs when the schedule is resumed from PAUSED
  /// state.
  ///
  /// If set to true, all missed runs will be scheduled. New runs will be
  /// scheduled after the backfill is complete. Default to false.
  ///
  /// Output only.
  core.bool? catchUp;

  /// Request for ModelMonitoringService.CreateModelMonitoringJob.
  GoogleCloudAiplatformV1beta1CreateModelMonitoringJobRequest?
  createModelMonitoringJobRequest;

  /// Request for NotebookService.CreateNotebookExecutionJob.
  GoogleCloudAiplatformV1beta1CreateNotebookExecutionJobRequest?
  createNotebookExecutionJobRequest;

  /// Request for PipelineService.CreatePipelineJob.
  ///
  /// CreatePipelineJobRequest.parent field is required (format:
  /// projects/{project}/locations/{location}).
  GoogleCloudAiplatformV1beta1CreatePipelineJobRequest?
  createPipelineJobRequest;

  /// Timestamp when this Schedule was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs.
  ///
  /// To explicitly set a timezone to the cron tab, apply a prefix in the cron
  /// tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The
  /// ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database.
  /// For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York
  /// 1 * * * *".
  core.String? cron;

  /// User provided name of the Schedule.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Timestamp after which no new runs can be scheduled.
  ///
  /// If specified, The schedule will be completed when either end_time is
  /// reached or when scheduled_run_count \>= max_run_count. If not specified,
  /// new runs will keep getting scheduled until this Schedule is paused or
  /// deleted. Already scheduled runs will be allowed to complete. Unset if not
  /// specified.
  ///
  /// Optional.
  core.String? endTime;

  /// Timestamp when this Schedule was last paused.
  ///
  /// Unset if never paused.
  ///
  /// Output only.
  core.String? lastPauseTime;

  /// Timestamp when this Schedule was last resumed.
  ///
  /// Unset if never resumed from pause.
  ///
  /// Output only.
  core.String? lastResumeTime;

  /// Response of the last scheduled run.
  ///
  /// This is the response for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  /// Unset if no run has been scheduled yet.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1ScheduleRunResponse? lastScheduledRunResponse;

  /// Maximum number of runs that can be started concurrently for this Schedule.
  ///
  /// This is the limit for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  ///
  /// Required.
  core.String? maxConcurrentRunCount;

  /// Maximum run count of the schedule.
  ///
  /// If specified, The schedule will be completed when either started_run_count
  /// \>= max_run_count or when end_time is reached. If not specified, new runs
  /// will keep getting scheduled until this Schedule is paused or deleted.
  /// Already scheduled runs will be allowed to complete. Unset if not
  /// specified.
  ///
  /// Optional.
  core.String? maxRunCount;

  /// The resource name of the Schedule.
  ///
  /// Immutable.
  core.String? name;

  /// Timestamp when this Schedule should schedule the next run.
  ///
  /// Having a next_run_time in the past means the runs are being started behind
  /// schedule.
  ///
  /// Output only.
  core.String? nextRunTime;

  /// Timestamp after which the first run can be scheduled.
  ///
  /// Default to Schedule create time if not specified.
  ///
  /// Optional.
  core.String? startTime;

  /// The number of runs started by this schedule.
  ///
  /// Output only.
  core.String? startedRunCount;

  /// The state of this Schedule.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "ACTIVE" : The Schedule is active. Runs are being scheduled on the
  /// user-specified timespec.
  /// - "PAUSED" : The schedule is paused. No new runs will be created until the
  /// schedule is resumed. Already started runs will be allowed to complete.
  /// - "COMPLETED" : The Schedule is completed. No new runs will be scheduled.
  /// Already started runs will be allowed to complete. Schedules in completed
  /// state cannot be paused or resumed.
  core.String? state;

  /// Timestamp when this Schedule was updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Schedule({
    this.allowQueueing,
    this.catchUp,
    this.createModelMonitoringJobRequest,
    this.createNotebookExecutionJobRequest,
    this.createPipelineJobRequest,
    this.createTime,
    this.cron,
    this.displayName,
    this.endTime,
    this.lastPauseTime,
    this.lastResumeTime,
    this.lastScheduledRunResponse,
    this.maxConcurrentRunCount,
    this.maxRunCount,
    this.name,
    this.nextRunTime,
    this.startTime,
    this.startedRunCount,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Schedule.fromJson(core.Map json_)
    : this(
        allowQueueing: json_['allowQueueing'] as core.bool?,
        catchUp: json_['catchUp'] as core.bool?,
        createModelMonitoringJobRequest:
            json_.containsKey('createModelMonitoringJobRequest')
                ? GoogleCloudAiplatformV1beta1CreateModelMonitoringJobRequest.fromJson(
                  json_['createModelMonitoringJobRequest']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createNotebookExecutionJobRequest:
            json_.containsKey('createNotebookExecutionJobRequest')
                ? GoogleCloudAiplatformV1beta1CreateNotebookExecutionJobRequest.fromJson(
                  json_['createNotebookExecutionJobRequest']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createPipelineJobRequest:
            json_.containsKey('createPipelineJobRequest')
                ? GoogleCloudAiplatformV1beta1CreatePipelineJobRequest.fromJson(
                  json_['createPipelineJobRequest']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        cron: json_['cron'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        lastPauseTime: json_['lastPauseTime'] as core.String?,
        lastResumeTime: json_['lastResumeTime'] as core.String?,
        lastScheduledRunResponse:
            json_.containsKey('lastScheduledRunResponse')
                ? GoogleCloudAiplatformV1beta1ScheduleRunResponse.fromJson(
                  json_['lastScheduledRunResponse']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        maxConcurrentRunCount: json_['maxConcurrentRunCount'] as core.String?,
        maxRunCount: json_['maxRunCount'] as core.String?,
        name: json_['name'] as core.String?,
        nextRunTime: json_['nextRunTime'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        startedRunCount: json_['startedRunCount'] as core.String?,
        state: json_['state'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowQueueing != null) 'allowQueueing': allowQueueing!,
    if (catchUp != null) 'catchUp': catchUp!,
    if (createModelMonitoringJobRequest != null)
      'createModelMonitoringJobRequest': createModelMonitoringJobRequest!,
    if (createNotebookExecutionJobRequest != null)
      'createNotebookExecutionJobRequest': createNotebookExecutionJobRequest!,
    if (createPipelineJobRequest != null)
      'createPipelineJobRequest': createPipelineJobRequest!,
    if (createTime != null) 'createTime': createTime!,
    if (cron != null) 'cron': cron!,
    if (displayName != null) 'displayName': displayName!,
    if (endTime != null) 'endTime': endTime!,
    if (lastPauseTime != null) 'lastPauseTime': lastPauseTime!,
    if (lastResumeTime != null) 'lastResumeTime': lastResumeTime!,
    if (lastScheduledRunResponse != null)
      'lastScheduledRunResponse': lastScheduledRunResponse!,
    if (maxConcurrentRunCount != null)
      'maxConcurrentRunCount': maxConcurrentRunCount!,
    if (maxRunCount != null) 'maxRunCount': maxRunCount!,
    if (name != null) 'name': name!,
    if (nextRunTime != null) 'nextRunTime': nextRunTime!,
    if (startTime != null) 'startTime': startTime!,
    if (startedRunCount != null) 'startedRunCount': startedRunCount!,
    if (state != null) 'state': state!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Schedule configuration for the FeatureMonitor.
class GoogleCloudAiplatformV1beta1ScheduleConfig {
  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs.
  ///
  /// To explicitly set a timezone to the cron tab, apply a prefix in the cron
  /// tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The
  /// ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database.
  /// For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York
  /// 1 * * * *".
  core.String? cron;

  GoogleCloudAiplatformV1beta1ScheduleConfig({this.cron});

  GoogleCloudAiplatformV1beta1ScheduleConfig.fromJson(core.Map json_)
    : this(cron: json_['cron'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (cron != null) 'cron': cron!,
  };
}

/// Status of a scheduled run.
typedef GoogleCloudAiplatformV1beta1ScheduleRunResponse = $ScheduleRunResponse;

/// All parameters related to queuing and scheduling of custom jobs.
typedef GoogleCloudAiplatformV1beta1Scheduling = $Scheduling;

/// Schema is used to define the format of input/output data.
///
/// Represents a select subset of an
/// [OpenAPI 3.0 schema object](https://spec.openapis.org/oas/v3.0.3#schema-object).
/// More fields may be added in the future as needed.
class GoogleCloudAiplatformV1beta1Schema {
  /// Can either be a boolean or an object; controls the presence of additional
  /// properties.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? additionalProperties;

  /// The value should be validated against any (one or more) of the subschemas
  /// in the list.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1Schema>? anyOf;

  /// Default value of the data.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? default_;

  /// A map of definitions for use by `ref` Only allowed at the root of the
  /// schema.
  ///
  /// Optional.
  core.Map<core.String, GoogleCloudAiplatformV1beta1Schema>? defs;

  /// The description of the data.
  ///
  /// Optional.
  core.String? description;

  /// Possible values of the element of primitive type with enum format.
  ///
  /// Examples: 1. We can define direction as : {type:STRING, format:enum,
  /// enum:\["EAST", NORTH", "SOUTH", "WEST"\]} 2. We can define apartment
  /// number as : {type:INTEGER, format:enum, enum:\["101", "201", "301"\]}
  ///
  /// Optional.
  core.List<core.String>? enum_;

  /// Example of the object.
  ///
  /// Will only populated when the object is the root.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? example;

  /// The format of the data.
  ///
  /// Supported formats: for NUMBER type: "float", "double" for INTEGER type:
  /// "int32", "int64" for STRING type: "email", "byte", etc
  ///
  /// Optional.
  core.String? format;

  /// SCHEMA FIELDS FOR TYPE ARRAY Schema of the elements of Type.ARRAY.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Schema? items;

  /// Maximum number of the elements for Type.ARRAY.
  ///
  /// Optional.
  core.String? maxItems;

  /// Maximum length of the Type.STRING
  ///
  /// Optional.
  core.String? maxLength;

  /// Maximum number of the properties for Type.OBJECT.
  ///
  /// Optional.
  core.String? maxProperties;

  /// Maximum value of the Type.INTEGER and Type.NUMBER
  ///
  /// Optional.
  core.double? maximum;

  /// Minimum number of the elements for Type.ARRAY.
  ///
  /// Optional.
  core.String? minItems;

  /// SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRING
  ///
  /// Optional.
  core.String? minLength;

  /// Minimum number of the properties for Type.OBJECT.
  ///
  /// Optional.
  core.String? minProperties;

  /// SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the
  /// Type.INTEGER and Type.NUMBER
  ///
  /// Optional.
  core.double? minimum;

  /// Indicates if the value may be null.
  ///
  /// Optional.
  core.bool? nullable;

  /// Pattern of the Type.STRING to restrict a string to a regular expression.
  ///
  /// Optional.
  core.String? pattern;

  /// SCHEMA FIELDS FOR TYPE OBJECT Properties of Type.OBJECT.
  ///
  /// Optional.
  core.Map<core.String, GoogleCloudAiplatformV1beta1Schema>? properties;

  /// The order of the properties.
  ///
  /// Not a standard field in open api spec. Only used to support the order of
  /// the properties.
  ///
  /// Optional.
  core.List<core.String>? propertyOrdering;

  /// Allows indirect references between schema nodes.
  ///
  /// The value should be a valid reference to a child of the root `defs`. For
  /// example, the following schema defines a reference to a schema node named
  /// "Pet": type: object properties: pet: ref: #/defs/Pet defs: Pet: type:
  /// object properties: name: type: string The value of the "pet" property is a
  /// reference to the schema node named "Pet". See details in
  /// https://json-schema.org/understanding-json-schema/structuring
  ///
  /// Optional.
  core.String? ref;

  /// Required properties of Type.OBJECT.
  ///
  /// Optional.
  core.List<core.String>? required;

  /// The title of the Schema.
  ///
  /// Optional.
  core.String? title;

  /// The type of the data.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Not specified, should not be used.
  /// - "STRING" : OpenAPI string type
  /// - "NUMBER" : OpenAPI number type
  /// - "INTEGER" : OpenAPI integer type
  /// - "BOOLEAN" : OpenAPI boolean type
  /// - "ARRAY" : OpenAPI array type
  /// - "OBJECT" : OpenAPI object type
  /// - "NULL" : Null type
  core.String? type;

  GoogleCloudAiplatformV1beta1Schema({
    this.additionalProperties,
    this.anyOf,
    this.default_,
    this.defs,
    this.description,
    this.enum_,
    this.example,
    this.format,
    this.items,
    this.maxItems,
    this.maxLength,
    this.maxProperties,
    this.maximum,
    this.minItems,
    this.minLength,
    this.minProperties,
    this.minimum,
    this.nullable,
    this.pattern,
    this.properties,
    this.propertyOrdering,
    this.ref,
    this.required,
    this.title,
    this.type,
  });

  GoogleCloudAiplatformV1beta1Schema.fromJson(core.Map json_)
    : this(
        additionalProperties: json_['additionalProperties'],
        anyOf:
            (json_['anyOf'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Schema.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        default_: json_['default'],
        defs: (json_['defs'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudAiplatformV1beta1Schema.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
        description: json_['description'] as core.String?,
        enum_:
            (json_['enum'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        example: json_['example'],
        format: json_['format'] as core.String?,
        items:
            json_.containsKey('items')
                ? GoogleCloudAiplatformV1beta1Schema.fromJson(
                  json_['items'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        maxItems: json_['maxItems'] as core.String?,
        maxLength: json_['maxLength'] as core.String?,
        maxProperties: json_['maxProperties'] as core.String?,
        maximum: (json_['maximum'] as core.num?)?.toDouble(),
        minItems: json_['minItems'] as core.String?,
        minLength: json_['minLength'] as core.String?,
        minProperties: json_['minProperties'] as core.String?,
        minimum: (json_['minimum'] as core.num?)?.toDouble(),
        nullable: json_['nullable'] as core.bool?,
        pattern: json_['pattern'] as core.String?,
        properties:
            (json_['properties'] as core.Map<core.String, core.dynamic>?)?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1Schema.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        propertyOrdering:
            (json_['propertyOrdering'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        ref: json_['ref'] as core.String?,
        required:
            (json_['required'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        title: json_['title'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (additionalProperties != null)
      'additionalProperties': additionalProperties!,
    if (anyOf != null) 'anyOf': anyOf!,
    if (default_ != null) 'default': default_!,
    if (defs != null) 'defs': defs!,
    if (description != null) 'description': description!,
    if (enum_ != null) 'enum': enum_!,
    if (example != null) 'example': example!,
    if (format != null) 'format': format!,
    if (items != null) 'items': items!,
    if (maxItems != null) 'maxItems': maxItems!,
    if (maxLength != null) 'maxLength': maxLength!,
    if (maxProperties != null) 'maxProperties': maxProperties!,
    if (maximum != null) 'maximum': maximum!,
    if (minItems != null) 'minItems': minItems!,
    if (minLength != null) 'minLength': minLength!,
    if (minProperties != null) 'minProperties': minProperties!,
    if (minimum != null) 'minimum': minimum!,
    if (nullable != null) 'nullable': nullable!,
    if (pattern != null) 'pattern': pattern!,
    if (properties != null) 'properties': properties!,
    if (propertyOrdering != null) 'propertyOrdering': propertyOrdering!,
    if (ref != null) 'ref': ref!,
    if (required != null) 'required': required!,
    if (title != null) 'title': title!,
    if (type != null) 'type': type!,
  };
}

/// Response message for DatasetService.SearchDataItems.
class GoogleCloudAiplatformV1beta1SearchDataItemsResponse {
  /// The DataItemViews read.
  core.List<GoogleCloudAiplatformV1beta1DataItemView>? dataItemViews;

  /// A token to retrieve next page of results.
  ///
  /// Pass to SearchDataItemsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1SearchDataItemsResponse({
    this.dataItemViews,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1SearchDataItemsResponse.fromJson(core.Map json_)
    : this(
        dataItemViews:
            (json_['dataItemViews'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1DataItemView.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataItemViews != null) 'dataItemViews': dataItemViews!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Google search entry point.
typedef GoogleCloudAiplatformV1beta1SearchEntryPoint = $SearchEntryPoint;

/// Request message for ExampleStoreService.SearchExamples.
class GoogleCloudAiplatformV1beta1SearchExamplesRequest {
  /// The parameters of StoredContentsExamples to be searched.
  GoogleCloudAiplatformV1beta1StoredContentsExampleParameters?
  storedContentsExampleParameters;

  /// The number of similar examples to return.
  ///
  /// Optional.
  core.String? topK;

  GoogleCloudAiplatformV1beta1SearchExamplesRequest({
    this.storedContentsExampleParameters,
    this.topK,
  });

  GoogleCloudAiplatformV1beta1SearchExamplesRequest.fromJson(core.Map json_)
    : this(
        storedContentsExampleParameters:
            json_.containsKey('storedContentsExampleParameters')
                ? GoogleCloudAiplatformV1beta1StoredContentsExampleParameters.fromJson(
                  json_['storedContentsExampleParameters']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        topK: json_['topK'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (storedContentsExampleParameters != null)
      'storedContentsExampleParameters': storedContentsExampleParameters!,
    if (topK != null) 'topK': topK!,
  };
}

/// Response message for ExampleStoreService.SearchExamples.
class GoogleCloudAiplatformV1beta1SearchExamplesResponse {
  /// The results of searching for similar examples.
  core.List<GoogleCloudAiplatformV1beta1SearchExamplesResponseSimilarExample>?
  results;

  GoogleCloudAiplatformV1beta1SearchExamplesResponse({this.results});

  GoogleCloudAiplatformV1beta1SearchExamplesResponse.fromJson(core.Map json_)
    : this(
        results:
            (json_['results'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1SearchExamplesResponseSimilarExample.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (results != null) 'results': results!,
  };
}

/// The result of the similar example.
class GoogleCloudAiplatformV1beta1SearchExamplesResponseSimilarExample {
  /// The example that is similar to the searched query.
  GoogleCloudAiplatformV1beta1Example? example;

  /// The similarity score of this example.
  core.double? similarityScore;

  GoogleCloudAiplatformV1beta1SearchExamplesResponseSimilarExample({
    this.example,
    this.similarityScore,
  });

  GoogleCloudAiplatformV1beta1SearchExamplesResponseSimilarExample.fromJson(
    core.Map json_,
  ) : this(
        example:
            json_.containsKey('example')
                ? GoogleCloudAiplatformV1beta1Example.fromJson(
                  json_['example'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        similarityScore: (json_['similarityScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (example != null) 'example': example!,
    if (similarityScore != null) 'similarityScore': similarityScore!,
  };
}

/// Response message for FeaturestoreService.SearchFeatures.
class GoogleCloudAiplatformV1beta1SearchFeaturesResponse {
  /// The Features matching the request.
  ///
  /// Fields returned: * `name` * `description` * `labels` * `create_time` *
  /// `update_time`
  core.List<GoogleCloudAiplatformV1beta1Feature>? features;

  /// A token, which can be sent as SearchFeaturesRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1SearchFeaturesResponse({
    this.features,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1SearchFeaturesResponse.fromJson(core.Map json_)
    : this(
        features:
            (json_['features'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Feature.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (features != null) 'features': features!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Request message for MigrationService.SearchMigratableResources.
typedef GoogleCloudAiplatformV1beta1SearchMigratableResourcesRequest =
    $SearchMigratableResourcesRequest;

/// Response message for MigrationService.SearchMigratableResources.
class GoogleCloudAiplatformV1beta1SearchMigratableResourcesResponse {
  /// All migratable resources that can be migrated to the location specified in
  /// the request.
  core.List<GoogleCloudAiplatformV1beta1MigratableResource>?
  migratableResources;

  /// The standard next-page token.
  ///
  /// The migratable_resources may not fill page_size in
  /// SearchMigratableResourcesRequest even when there are subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1SearchMigratableResourcesResponse({
    this.migratableResources,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1SearchMigratableResourcesResponse.fromJson(
    core.Map json_,
  ) : this(
        migratableResources:
            (json_['migratableResources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1MigratableResource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (migratableResources != null)
      'migratableResources': migratableResources!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Request message for
/// JobService.SearchModelDeploymentMonitoringStatsAnomalies.
class GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequest {
  /// The DeployedModel ID of the
  /// \[ModelDeploymentMonitoringObjectiveConfig.deployed_model_id\].
  ///
  /// Required.
  core.String? deployedModelId;

  /// The latest timestamp of stats being generated.
  ///
  /// If not set, indicates feching stats till the latest possible one.
  core.String? endTime;

  /// The feature display name.
  ///
  /// If specified, only return the stats belonging to this feature. Format:
  /// ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name,
  /// example: "user_destination".
  core.String? featureDisplayName;

  /// Objectives of the stats to retrieve.
  ///
  /// Required.
  core.List<
    GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
  >?
  objectives;

  /// The standard list page size.
  core.int? pageSize;

  /// A page token received from a previous
  /// JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
  core.String? pageToken;

  /// The earliest timestamp of stats being generated.
  ///
  /// If not set, indicates fetching stats till the earliest possible one.
  core.String? startTime;

  GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequest({
    this.deployedModelId,
    this.endTime,
    this.featureDisplayName,
    this.objectives,
    this.pageSize,
    this.pageToken,
    this.startTime,
  });

  GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequest.fromJson(
    core.Map json_,
  ) : this(
        deployedModelId: json_['deployedModelId'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        featureDisplayName: json_['featureDisplayName'] as core.String?,
        objectives:
            (json_['objectives'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
        startTime: json_['startTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deployedModelId != null) 'deployedModelId': deployedModelId!,
    if (endTime != null) 'endTime': endTime!,
    if (featureDisplayName != null) 'featureDisplayName': featureDisplayName!,
    if (objectives != null) 'objectives': objectives!,
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
    if (startTime != null) 'startTime': startTime!,
  };
}

/// Stats requested for specific objective.
typedef GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective =
    $SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective;

/// Response message for
/// JobService.SearchModelDeploymentMonitoringStatsAnomalies.
class GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesResponse {
  /// Stats retrieved for requested objectives.
  ///
  /// There are at most 1000
  /// ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats
  /// in the response.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomalies>?
  monitoringStats;

  /// The page token that can be used by the next
  /// JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesResponse({
    this.monitoringStats,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
    core.Map json_,
  ) : this(
        monitoringStats:
            (json_['monitoringStats'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringStatsAnomalies.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (monitoringStats != null) 'monitoringStats': monitoringStats!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Request message for ModelMonitoringService.SearchModelMonitoringAlerts.
class GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsRequest {
  /// If non-empty, returns the alerts in this time interval.
  GoogleTypeInterval? alertTimeInterval;

  /// If non-empty, returns the alerts of this model monitoring job.
  core.String? modelMonitoringJob;

  /// If non-empty, returns the alerts of this objective type.
  ///
  /// Supported monitoring objectives: `raw-feature-drift`
  /// `prediction-output-drift` `feature-attribution`
  core.String? objectiveType;

  /// The standard list page size.
  core.int? pageSize;

  /// A page token received from a previous
  /// ModelMonitoringService.SearchModelMonitoringAlerts call.
  core.String? pageToken;

  /// If non-empty, returns the alerts of this stats_name.
  core.String? statsName;

  GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsRequest({
    this.alertTimeInterval,
    this.modelMonitoringJob,
    this.objectiveType,
    this.pageSize,
    this.pageToken,
    this.statsName,
  });

  GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsRequest.fromJson(
    core.Map json_,
  ) : this(
        alertTimeInterval:
            json_.containsKey('alertTimeInterval')
                ? GoogleTypeInterval.fromJson(
                  json_['alertTimeInterval']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelMonitoringJob: json_['modelMonitoringJob'] as core.String?,
        objectiveType: json_['objectiveType'] as core.String?,
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
        statsName: json_['statsName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alertTimeInterval != null) 'alertTimeInterval': alertTimeInterval!,
    if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob!,
    if (objectiveType != null) 'objectiveType': objectiveType!,
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
    if (statsName != null) 'statsName': statsName!,
  };
}

/// Response message for ModelMonitoringService.SearchModelMonitoringAlerts.
class GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsResponse {
  /// Alerts retrieved for the requested objectives.
  ///
  /// Sorted by alert time descendingly.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringAlert>?
  modelMonitoringAlerts;

  /// The page token that can be used by the next
  /// ModelMonitoringService.SearchModelMonitoringAlerts call.
  core.String? nextPageToken;

  /// The total number of alerts retrieved by the requested objectives.
  core.String? totalNumberAlerts;

  GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsResponse({
    this.modelMonitoringAlerts,
    this.nextPageToken,
    this.totalNumberAlerts,
  });

  GoogleCloudAiplatformV1beta1SearchModelMonitoringAlertsResponse.fromJson(
    core.Map json_,
  ) : this(
        modelMonitoringAlerts:
            (json_['modelMonitoringAlerts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringAlert.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
        totalNumberAlerts: json_['totalNumberAlerts'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (modelMonitoringAlerts != null)
      'modelMonitoringAlerts': modelMonitoringAlerts!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (totalNumberAlerts != null) 'totalNumberAlerts': totalNumberAlerts!,
  };
}

/// Filter for searching ModelMonitoringStats.
class GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilter {
  /// Tabular statistics filter.
  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilterTabularStatsFilter?
  tabularStatsFilter;

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilter({
    this.tabularStatsFilter,
  });

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilter.fromJson(
    core.Map json_,
  ) : this(
        tabularStatsFilter:
            json_.containsKey('tabularStatsFilter')
                ? GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilterTabularStatsFilter.fromJson(
                  json_['tabularStatsFilter']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tabularStatsFilter != null) 'tabularStatsFilter': tabularStatsFilter!,
  };
}

/// Tabular statistics filter.
class GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilterTabularStatsFilter {
  /// Specify the algorithm type used for distance calculation, eg:
  /// jensen_shannon_divergence, l_infinity.
  core.String? algorithm;

  /// From a particular monitoring job.
  core.String? modelMonitoringJob;

  /// From a particular monitoring schedule.
  core.String? modelMonitoringSchedule;

  /// One of the supported monitoring objectives: `raw-feature-drift`
  /// `prediction-output-drift` `feature-attribution`
  core.String? objectiveType;

  /// If not specified, will return all the stats_names.
  core.String? statsName;

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilterTabularStatsFilter({
    this.algorithm,
    this.modelMonitoringJob,
    this.modelMonitoringSchedule,
    this.objectiveType,
    this.statsName,
  });

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilterTabularStatsFilter.fromJson(
    core.Map json_,
  ) : this(
        algorithm: json_['algorithm'] as core.String?,
        modelMonitoringJob: json_['modelMonitoringJob'] as core.String?,
        modelMonitoringSchedule:
            json_['modelMonitoringSchedule'] as core.String?,
        objectiveType: json_['objectiveType'] as core.String?,
        statsName: json_['statsName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algorithm != null) 'algorithm': algorithm!,
    if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob!,
    if (modelMonitoringSchedule != null)
      'modelMonitoringSchedule': modelMonitoringSchedule!,
    if (objectiveType != null) 'objectiveType': objectiveType!,
    if (statsName != null) 'statsName': statsName!,
  };
}

/// Request message for ModelMonitoringService.SearchModelMonitoringStats.
class GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsRequest {
  /// The standard list page size.
  core.int? pageSize;

  /// A page token received from a previous
  /// ModelMonitoringService.SearchModelMonitoringStats call.
  core.String? pageToken;

  /// Filter for search different stats.
  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilter? statsFilter;

  /// The time interval for which results should be returned.
  GoogleTypeInterval? timeInterval;

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsRequest({
    this.pageSize,
    this.pageToken,
    this.statsFilter,
    this.timeInterval,
  });

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsRequest.fromJson(
    core.Map json_,
  ) : this(
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
        statsFilter:
            json_.containsKey('statsFilter')
                ? GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsFilter.fromJson(
                  json_['statsFilter'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        timeInterval:
            json_.containsKey('timeInterval')
                ? GoogleTypeInterval.fromJson(
                  json_['timeInterval'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
    if (statsFilter != null) 'statsFilter': statsFilter!,
    if (timeInterval != null) 'timeInterval': timeInterval!,
  };
}

/// Response message for ModelMonitoringService.SearchModelMonitoringStats.
class GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsResponse {
  /// Stats retrieved for requested objectives.
  core.List<GoogleCloudAiplatformV1beta1ModelMonitoringStats>? monitoringStats;

  /// The page token that can be used by the next
  /// ModelMonitoringService.SearchModelMonitoringStats call.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsResponse({
    this.monitoringStats,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1beta1SearchModelMonitoringStatsResponse.fromJson(
    core.Map json_,
  ) : this(
        monitoringStats:
            (json_['monitoringStats'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ModelMonitoringStats.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (monitoringStats != null) 'monitoringStats': monitoringStats!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// The request message for FeatureOnlineStoreService.SearchNearestEntities.
class GoogleCloudAiplatformV1beta1SearchNearestEntitiesRequest {
  /// The query.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1NearestNeighborQuery? query;

  /// If set to true, the full entities (including all vector values and
  /// metadata) of the nearest neighbors are returned; otherwise only entity id
  /// of the nearest neighbors will be returned.
  ///
  /// Note that returning full entities will significantly increase the latency
  /// and cost of the query.
  ///
  /// Optional.
  core.bool? returnFullEntity;

  GoogleCloudAiplatformV1beta1SearchNearestEntitiesRequest({
    this.query,
    this.returnFullEntity,
  });

  GoogleCloudAiplatformV1beta1SearchNearestEntitiesRequest.fromJson(
    core.Map json_,
  ) : this(
        query:
            json_.containsKey('query')
                ? GoogleCloudAiplatformV1beta1NearestNeighborQuery.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        returnFullEntity: json_['returnFullEntity'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (query != null) 'query': query!,
    if (returnFullEntity != null) 'returnFullEntity': returnFullEntity!,
  };
}

/// Response message for FeatureOnlineStoreService.SearchNearestEntities
class GoogleCloudAiplatformV1beta1SearchNearestEntitiesResponse {
  /// The nearest neighbors of the query entity.
  GoogleCloudAiplatformV1beta1NearestNeighbors? nearestNeighbors;

  GoogleCloudAiplatformV1beta1SearchNearestEntitiesResponse({
    this.nearestNeighbors,
  });

  GoogleCloudAiplatformV1beta1SearchNearestEntitiesResponse.fromJson(
    core.Map json_,
  ) : this(
        nearestNeighbors:
            json_.containsKey('nearestNeighbors')
                ? GoogleCloudAiplatformV1beta1NearestNeighbors.fromJson(
                  json_['nearestNeighbors']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nearestNeighbors != null) 'nearestNeighbors': nearestNeighbors!,
  };
}

/// Represents an environment variable where the value is a secret in Cloud
/// Secret Manager.
class GoogleCloudAiplatformV1beta1SecretEnvVar {
  /// Name of the secret environment variable.
  ///
  /// Required.
  core.String? name;

  /// Reference to a secret stored in the Cloud Secret Manager that will provide
  /// the value for this environment variable.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SecretRef? secretRef;

  GoogleCloudAiplatformV1beta1SecretEnvVar({this.name, this.secretRef});

  GoogleCloudAiplatformV1beta1SecretEnvVar.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        secretRef:
            json_.containsKey('secretRef')
                ? GoogleCloudAiplatformV1beta1SecretRef.fromJson(
                  json_['secretRef'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (secretRef != null) 'secretRef': secretRef!,
  };
}

/// Reference to a secret stored in the Cloud Secret Manager that will provide
/// the value for this environment variable.
typedef GoogleCloudAiplatformV1beta1SecretRef = $SecretRef;

/// Segment of the content.
typedef GoogleCloudAiplatformV1beta1Segment = $Segment00;

/// Configuration for the use of custom service account to run the workloads.
typedef GoogleCloudAiplatformV1beta1ServiceAccountSpec = $ServiceAccountSpec;

/// A session contains a set of actions between users and Vertex agents.
class GoogleCloudAiplatformV1beta1Session {
  /// Timestamp when the session was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the session.
  ///
  /// Optional.
  core.String? displayName;

  /// Timestamp of when this session is considered expired.
  ///
  /// This is *always* provided on output, regardless of what was sent on input.
  ///
  /// Optional.
  core.String? expireTime;

  /// Identifier.
  ///
  /// The resource name of the session. Format:
  /// 'projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}'.
  core.String? name;

  /// Session specific memory which stores key conversation points.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? sessionState;

  /// Input only.
  ///
  /// The TTL for this session.
  ///
  /// Optional.
  core.String? ttl;

  /// Timestamp when the session was updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// String id provided by the user
  ///
  /// Required. Immutable.
  core.String? userId;

  GoogleCloudAiplatformV1beta1Session({
    this.createTime,
    this.displayName,
    this.expireTime,
    this.name,
    this.sessionState,
    this.ttl,
    this.updateTime,
    this.userId,
  });

  GoogleCloudAiplatformV1beta1Session.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        expireTime: json_['expireTime'] as core.String?,
        name: json_['name'] as core.String?,
        sessionState:
            json_.containsKey('sessionState')
                ? json_['sessionState'] as core.Map<core.String, core.dynamic>
                : null,
        ttl: json_['ttl'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        userId: json_['userId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (expireTime != null) 'expireTime': expireTime!,
    if (name != null) 'name': name!,
    if (sessionState != null) 'sessionState': sessionState!,
    if (ttl != null) 'ttl': ttl!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (userId != null) 'userId': userId!,
  };
}

/// An event represents a message from either the user or agent.
class GoogleCloudAiplatformV1beta1SessionEvent {
  /// Actions executed by the agent.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1EventActions? actions;

  /// The name of the agent that sent the event, or user.
  ///
  /// Required.
  core.String? author;

  /// Content of the event provided by the author.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Content? content;

  /// Error code if the response is an error.
  ///
  /// Code varies by model.
  ///
  /// Optional.
  core.String? errorCode;

  /// Error message if the response is an error.
  ///
  /// Optional.
  core.String? errorMessage;

  /// Metadata relating to this event.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1EventMetadata? eventMetadata;

  /// The invocation id of the event, multiple events can have the same
  /// invocation id.
  ///
  /// Required.
  core.String? invocationId;

  /// Identifier.
  ///
  /// The resource name of the event.
  /// Format:`projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}/events/{event}`.
  core.String? name;

  /// Timestamp when the event was created on client side.
  ///
  /// Required.
  core.String? timestamp;

  GoogleCloudAiplatformV1beta1SessionEvent({
    this.actions,
    this.author,
    this.content,
    this.errorCode,
    this.errorMessage,
    this.eventMetadata,
    this.invocationId,
    this.name,
    this.timestamp,
  });

  GoogleCloudAiplatformV1beta1SessionEvent.fromJson(core.Map json_)
    : this(
        actions:
            json_.containsKey('actions')
                ? GoogleCloudAiplatformV1beta1EventActions.fromJson(
                  json_['actions'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        author: json_['author'] as core.String?,
        content:
            json_.containsKey('content')
                ? GoogleCloudAiplatformV1beta1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        errorCode: json_['errorCode'] as core.String?,
        errorMessage: json_['errorMessage'] as core.String?,
        eventMetadata:
            json_.containsKey('eventMetadata')
                ? GoogleCloudAiplatformV1beta1EventMetadata.fromJson(
                  json_['eventMetadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        invocationId: json_['invocationId'] as core.String?,
        name: json_['name'] as core.String?,
        timestamp: json_['timestamp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actions != null) 'actions': actions!,
    if (author != null) 'author': author!,
    if (content != null) 'content': content!,
    if (errorCode != null) 'errorCode': errorCode!,
    if (errorMessage != null) 'errorMessage': errorMessage!,
    if (eventMetadata != null) 'eventMetadata': eventMetadata!,
    if (invocationId != null) 'invocationId': invocationId!,
    if (name != null) 'name': name!,
    if (timestamp != null) 'timestamp': timestamp!,
  };
}

/// Request message for EndpointService.SetPublisherModelConfig.
class GoogleCloudAiplatformV1beta1SetPublisherModelConfigRequest {
  /// The publisher model config.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1PublisherModelConfig? publisherModelConfig;

  GoogleCloudAiplatformV1beta1SetPublisherModelConfigRequest({
    this.publisherModelConfig,
  });

  GoogleCloudAiplatformV1beta1SetPublisherModelConfigRequest.fromJson(
    core.Map json_,
  ) : this(
        publisherModelConfig:
            json_.containsKey('publisherModelConfig')
                ? GoogleCloudAiplatformV1beta1PublisherModelConfig.fromJson(
                  json_['publisherModelConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (publisherModelConfig != null)
      'publisherModelConfig': publisherModelConfig!,
  };
}

/// The SharePointSources to pass to ImportRagFiles.
class GoogleCloudAiplatformV1beta1SharePointSources {
  /// The SharePoint sources.
  core.List<GoogleCloudAiplatformV1beta1SharePointSourcesSharePointSource>?
  sharePointSources;

  GoogleCloudAiplatformV1beta1SharePointSources({this.sharePointSources});

  GoogleCloudAiplatformV1beta1SharePointSources.fromJson(core.Map json_)
    : this(
        sharePointSources:
            (json_['sharePointSources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1SharePointSourcesSharePointSource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sharePointSources != null) 'sharePointSources': sharePointSources!,
  };
}

/// An individual SharePointSource.
class GoogleCloudAiplatformV1beta1SharePointSourcesSharePointSource {
  /// The Application ID for the app registered in Microsoft Azure Portal.
  ///
  /// The application must also be configured with MS Graph permissions
  /// "Files.ReadAll", "Sites.ReadAll" and BrowserSiteLists.Read.All.
  core.String? clientId;

  /// The application secret for the app registered in Azure.
  GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig? clientSecret;

  /// The ID of the drive to download from.
  core.String? driveId;

  /// The name of the drive to download from.
  core.String? driveName;

  /// The SharePoint file id.
  ///
  /// Output only.
  ///
  /// Output only.
  core.String? fileId;

  /// The ID of the SharePoint folder to download from.
  core.String? sharepointFolderId;

  /// The path of the SharePoint folder to download from.
  core.String? sharepointFolderPath;

  /// The name of the SharePoint site to download from.
  ///
  /// This can be the site name or the site id.
  core.String? sharepointSiteName;

  /// Unique identifier of the Azure Active Directory Instance.
  core.String? tenantId;

  GoogleCloudAiplatformV1beta1SharePointSourcesSharePointSource({
    this.clientId,
    this.clientSecret,
    this.driveId,
    this.driveName,
    this.fileId,
    this.sharepointFolderId,
    this.sharepointFolderPath,
    this.sharepointSiteName,
    this.tenantId,
  });

  GoogleCloudAiplatformV1beta1SharePointSourcesSharePointSource.fromJson(
    core.Map json_,
  ) : this(
        clientId: json_['clientId'] as core.String?,
        clientSecret:
            json_.containsKey('clientSecret')
                ? GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig.fromJson(
                  json_['clientSecret'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        driveId: json_['driveId'] as core.String?,
        driveName: json_['driveName'] as core.String?,
        fileId: json_['fileId'] as core.String?,
        sharepointFolderId: json_['sharepointFolderId'] as core.String?,
        sharepointFolderPath: json_['sharepointFolderPath'] as core.String?,
        sharepointSiteName: json_['sharepointSiteName'] as core.String?,
        tenantId: json_['tenantId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientId != null) 'clientId': clientId!,
    if (clientSecret != null) 'clientSecret': clientSecret!,
    if (driveId != null) 'driveId': driveId!,
    if (driveName != null) 'driveName': driveName!,
    if (fileId != null) 'fileId': fileId!,
    if (sharepointFolderId != null) 'sharepointFolderId': sharepointFolderId!,
    if (sharepointFolderPath != null)
      'sharepointFolderPath': sharepointFolderPath!,
    if (sharepointSiteName != null) 'sharepointSiteName': sharepointSiteName!,
    if (tenantId != null) 'tenantId': tenantId!,
  };
}

/// A set of Shielded Instance options.
///
/// See
/// [Images using supported Shielded VM features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
typedef GoogleCloudAiplatformV1beta1ShieldedVmConfig = $ShieldedVmConfig00;

/// The Slack source for the ImportRagFilesRequest.
class GoogleCloudAiplatformV1beta1SlackSource {
  /// The Slack channels.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1SlackSourceSlackChannels>? channels;

  GoogleCloudAiplatformV1beta1SlackSource({this.channels});

  GoogleCloudAiplatformV1beta1SlackSource.fromJson(core.Map json_)
    : this(
        channels:
            (json_['channels'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1SlackSourceSlackChannels.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (channels != null) 'channels': channels!,
  };
}

/// SlackChannels contains the Slack channels and corresponding access token.
class GoogleCloudAiplatformV1beta1SlackSourceSlackChannels {
  /// The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the Slack
  /// channel access token that has access to the slack channel IDs.
  ///
  /// See: https://api.slack.com/tutorials/tracks/getting-a-token.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig? apiKeyConfig;

  /// The Slack channel IDs.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1SlackSourceSlackChannelsSlackChannel>?
  channels;

  GoogleCloudAiplatformV1beta1SlackSourceSlackChannels({
    this.apiKeyConfig,
    this.channels,
  });

  GoogleCloudAiplatformV1beta1SlackSourceSlackChannels.fromJson(core.Map json_)
    : this(
        apiKeyConfig:
            json_.containsKey('apiKeyConfig')
                ? GoogleCloudAiplatformV1beta1ApiAuthApiKeyConfig.fromJson(
                  json_['apiKeyConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        channels:
            (json_['channels'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1SlackSourceSlackChannelsSlackChannel.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!,
    if (channels != null) 'channels': channels!,
  };
}

/// SlackChannel contains the Slack channel ID and the time range to import.
typedef GoogleCloudAiplatformV1beta1SlackSourceSlackChannelsSlackChannel =
    $SlackSourceSlackChannelsSlackChannel;

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// https://arxiv.org/pdf/1706.03825.pdf
class GoogleCloudAiplatformV1beta1SmoothGradConfig {
  /// This is similar to noise_sigma, but provides additional flexibility.
  ///
  /// A separate noise sigma can be provided for each feature, which is useful
  /// if their distributions are different. No noise is added to features that
  /// are not set. If this field is unset, noise_sigma will be used for all
  /// features.
  GoogleCloudAiplatformV1beta1FeatureNoiseSigma? featureNoiseSigma;

  /// This is a single float value and will be used to add noise to all the
  /// features.
  ///
  /// Use this field when all features are normalized to have the same
  /// distribution: scale to range \[0, 1\], \[-1, 1\] or z-scoring, where
  /// features are normalized to have 0-mean and 1-variance. Learn more about
  /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
  /// For best results the recommended value is about 10% - 20% of the standard
  /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
  /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the
  /// distribution is different per feature, set feature_noise_sigma instead for
  /// each feature.
  core.double? noiseSigma;

  /// The number of gradient samples to use for approximation.
  ///
  /// The higher this number, the more accurate the gradient is, but the runtime
  /// complexity increases by this factor as well. Valid range of its value is
  /// \[1, 50\]. Defaults to 3.
  core.int? noisySampleCount;

  GoogleCloudAiplatformV1beta1SmoothGradConfig({
    this.featureNoiseSigma,
    this.noiseSigma,
    this.noisySampleCount,
  });

  GoogleCloudAiplatformV1beta1SmoothGradConfig.fromJson(core.Map json_)
    : this(
        featureNoiseSigma:
            json_.containsKey('featureNoiseSigma')
                ? GoogleCloudAiplatformV1beta1FeatureNoiseSigma.fromJson(
                  json_['featureNoiseSigma']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        noiseSigma: (json_['noiseSigma'] as core.num?)?.toDouble(),
        noisySampleCount: json_['noisySampleCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (featureNoiseSigma != null) 'featureNoiseSigma': featureNoiseSigma!,
    if (noiseSigma != null) 'noiseSigma': noiseSigma!,
    if (noisySampleCount != null) 'noisySampleCount': noisySampleCount!,
  };
}

/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs.
///
/// It includes a group of specialist managers and workers. Managers are
/// responsible for managing the workers in this pool as well as customers' data
/// labeling jobs associated with this pool. Customers create specialist pool as
/// well as start data labeling jobs on Cloud, managers and workers handle the
/// jobs using CrowdCompute console.
typedef GoogleCloudAiplatformV1beta1SpecialistPool = $SpecialistPool;

/// Configuration for Speculative Decoding.
class GoogleCloudAiplatformV1beta1SpeculativeDecodingSpec {
  /// draft model speculation.
  GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecDraftModelSpeculation?
  draftModelSpeculation;

  /// N-Gram speculation.
  GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecNgramSpeculation?
  ngramSpeculation;

  /// The number of speculative tokens to generate at each step.
  core.int? speculativeTokenCount;

  GoogleCloudAiplatformV1beta1SpeculativeDecodingSpec({
    this.draftModelSpeculation,
    this.ngramSpeculation,
    this.speculativeTokenCount,
  });

  GoogleCloudAiplatformV1beta1SpeculativeDecodingSpec.fromJson(core.Map json_)
    : this(
        draftModelSpeculation:
            json_.containsKey('draftModelSpeculation')
                ? GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecDraftModelSpeculation.fromJson(
                  json_['draftModelSpeculation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ngramSpeculation:
            json_.containsKey('ngramSpeculation')
                ? GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecNgramSpeculation.fromJson(
                  json_['ngramSpeculation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        speculativeTokenCount: json_['speculativeTokenCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (draftModelSpeculation != null)
      'draftModelSpeculation': draftModelSpeculation!,
    if (ngramSpeculation != null) 'ngramSpeculation': ngramSpeculation!,
    if (speculativeTokenCount != null)
      'speculativeTokenCount': speculativeTokenCount!,
  };
}

/// Draft model speculation works by using the smaller model to generate
/// candidate tokens for speculative decoding.
typedef GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecDraftModelSpeculation =
    $SpeculativeDecodingSpecDraftModelSpeculation;

/// N-Gram speculation works by trying to find matching tokens in the previous
/// prompt sequence and use those as speculation for generating new tokens.
typedef GoogleCloudAiplatformV1beta1SpeculativeDecodingSpecNgramSpeculation =
    $SpeculativeDecodingSpecNgramSpeculation;

/// The speech generation config.
class GoogleCloudAiplatformV1beta1SpeechConfig {
  /// Language code (ISO 639.
  ///
  /// e.g. en-US) for the speech synthesization.
  ///
  /// Optional.
  core.String? languageCode;

  /// The configuration for the speaker to use.
  GoogleCloudAiplatformV1beta1VoiceConfig? voiceConfig;

  GoogleCloudAiplatformV1beta1SpeechConfig({
    this.languageCode,
    this.voiceConfig,
  });

  GoogleCloudAiplatformV1beta1SpeechConfig.fromJson(core.Map json_)
    : this(
        languageCode: json_['languageCode'] as core.String?,
        voiceConfig:
            json_.containsKey('voiceConfig')
                ? GoogleCloudAiplatformV1beta1VoiceConfig.fromJson(
                  json_['voiceConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (languageCode != null) 'languageCode': languageCode!,
    if (voiceConfig != null) 'voiceConfig': voiceConfig!,
  };
}

/// Request message for NotebookService.StartNotebookRuntime.
typedef GoogleCloudAiplatformV1beta1StartNotebookRuntimeRequest = $Empty;

/// Request message for NotebookService.StopNotebookRuntime.
typedef GoogleCloudAiplatformV1beta1StopNotebookRuntimeRequest = $Empty;

/// Request message for VizierService.StopTrial.
typedef GoogleCloudAiplatformV1beta1StopTrialRequest = $Empty;

/// A ContentsExample to be used with GenerateContent alongside information
/// required for storage and retrieval with Example Store.
class GoogleCloudAiplatformV1beta1StoredContentsExample {
  /// The example to be used with GenerateContent.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ContentsExample? contentsExample;

  /// (Optional) the search key used for retrieval.
  ///
  /// If not provided at upload-time, the search key will be generated from
  /// `contents_example.contents` using the method provided by
  /// `search_key_generation_method`. The generated search key will be included
  /// in retrieved examples.
  ///
  /// Optional.
  core.String? searchKey;

  /// The method used to generate the search key from
  /// `contents_example.contents`.
  ///
  /// This is ignored when uploading an example if `search_key` is provided.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethod?
  searchKeyGenerationMethod;

  GoogleCloudAiplatformV1beta1StoredContentsExample({
    this.contentsExample,
    this.searchKey,
    this.searchKeyGenerationMethod,
  });

  GoogleCloudAiplatformV1beta1StoredContentsExample.fromJson(core.Map json_)
    : this(
        contentsExample:
            json_.containsKey('contentsExample')
                ? GoogleCloudAiplatformV1beta1ContentsExample.fromJson(
                  json_['contentsExample']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchKey: json_['searchKey'] as core.String?,
        searchKeyGenerationMethod:
            json_.containsKey('searchKeyGenerationMethod')
                ? GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethod.fromJson(
                  json_['searchKeyGenerationMethod']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentsExample != null) 'contentsExample': contentsExample!,
    if (searchKey != null) 'searchKey': searchKey!,
    if (searchKeyGenerationMethod != null)
      'searchKeyGenerationMethod': searchKeyGenerationMethod!,
  };
}

/// The metadata filters that will be used to remove or fetch
/// StoredContentsExamples.
///
/// If a field is unspecified, then no filtering for that field will be applied.
class GoogleCloudAiplatformV1beta1StoredContentsExampleFilter {
  /// The function names for filtering.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ExamplesArrayFilter? functionNames;

  /// The search keys for filtering.
  ///
  /// Only examples with one of the specified search keys
  /// (StoredContentsExample.search_key) are eligible to be returned.
  ///
  /// Optional.
  core.List<core.String>? searchKeys;

  GoogleCloudAiplatformV1beta1StoredContentsExampleFilter({
    this.functionNames,
    this.searchKeys,
  });

  GoogleCloudAiplatformV1beta1StoredContentsExampleFilter.fromJson(
    core.Map json_,
  ) : this(
        functionNames:
            json_.containsKey('functionNames')
                ? GoogleCloudAiplatformV1beta1ExamplesArrayFilter.fromJson(
                  json_['functionNames'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchKeys:
            (json_['searchKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (functionNames != null) 'functionNames': functionNames!,
    if (searchKeys != null) 'searchKeys': searchKeys!,
  };
}

/// The metadata filters that will be used to search StoredContentsExamples.
///
/// If a field is unspecified, then no filtering for that field will be applied
class GoogleCloudAiplatformV1beta1StoredContentsExampleParameters {
  /// The chat history to use to generate the search key for retrieval.
  GoogleCloudAiplatformV1beta1StoredContentsExampleParametersContentSearchKey?
  contentSearchKey;

  /// The function names for filtering.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ExamplesArrayFilter? functionNames;

  /// The exact search key to use for retrieval.
  core.String? searchKey;

  GoogleCloudAiplatformV1beta1StoredContentsExampleParameters({
    this.contentSearchKey,
    this.functionNames,
    this.searchKey,
  });

  GoogleCloudAiplatformV1beta1StoredContentsExampleParameters.fromJson(
    core.Map json_,
  ) : this(
        contentSearchKey:
            json_.containsKey('contentSearchKey')
                ? GoogleCloudAiplatformV1beta1StoredContentsExampleParametersContentSearchKey.fromJson(
                  json_['contentSearchKey']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        functionNames:
            json_.containsKey('functionNames')
                ? GoogleCloudAiplatformV1beta1ExamplesArrayFilter.fromJson(
                  json_['functionNames'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchKey: json_['searchKey'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentSearchKey != null) 'contentSearchKey': contentSearchKey!,
    if (functionNames != null) 'functionNames': functionNames!,
    if (searchKey != null) 'searchKey': searchKey!,
  };
}

/// The chat history to use to generate the search key for retrieval.
class GoogleCloudAiplatformV1beta1StoredContentsExampleParametersContentSearchKey {
  /// The conversation for generating a search key.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Content>? contents;

  /// The method of generating a search key.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethod?
  searchKeyGenerationMethod;

  GoogleCloudAiplatformV1beta1StoredContentsExampleParametersContentSearchKey({
    this.contents,
    this.searchKeyGenerationMethod,
  });

  GoogleCloudAiplatformV1beta1StoredContentsExampleParametersContentSearchKey.fromJson(
    core.Map json_,
  ) : this(
        contents:
            (json_['contents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        searchKeyGenerationMethod:
            json_.containsKey('searchKeyGenerationMethod')
                ? GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethod.fromJson(
                  json_['searchKeyGenerationMethod']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contents != null) 'contents': contents!,
    if (searchKeyGenerationMethod != null)
      'searchKeyGenerationMethod': searchKeyGenerationMethod!,
  };
}

/// Options for generating the search key from the conversation history.
class GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethod {
  /// Use only the last entry of the conversation history
  /// (`contents_example.contents`) as the search key.
  GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethodLastEntry?
  lastEntry;

  GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethod({
    this.lastEntry,
  });

  GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethod.fromJson(
    core.Map json_,
  ) : this(
        lastEntry:
            json_.containsKey('lastEntry')
                ? GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethodLastEntry.fromJson(
                  json_['lastEntry'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (lastEntry != null) 'lastEntry': lastEntry!,
  };
}

/// Configuration for using only the last entry of the conversation history as
/// the search key.
typedef GoogleCloudAiplatformV1beta1StoredContentsExampleSearchKeyGenerationMethodLastEntry =
    $Empty;

/// Assigns input data to the training, validation, and test sets so that the
/// distribution of values found in the categorical column (as specified by the
/// `key` field) is mirrored within each split.
///
/// The fraction values determine the relative sizes of the splits. For example,
/// if the specified column has three values, with 50% of the rows having value
/// "A", 25% value "B", and 25% value "C", and the split fractions are specified
/// as 80/10/10, then the training set will constitute 80% of the training data,
/// with about 50% of the training set rows having the value "A" for the
/// specified column, about 25% having the value "B", and about 25% having the
/// value "C". Only the top 500 occurring values are used; any values not in the
/// top 500 values are randomly assigned to a split. If less than three rows
/// contain a specific value, those rows are randomly assigned. Supported only
/// for tabular Datasets.
typedef GoogleCloudAiplatformV1beta1StratifiedSplit = $StratifiedSplit;

/// Request message for ReasoningEngineExecutionService.StreamQuery.
typedef GoogleCloudAiplatformV1beta1StreamQueryReasoningEngineRequest =
    $StreamQueryReasoningEngineRequest;

/// Request message for PredictionService.StreamRawPredict.
class GoogleCloudAiplatformV1beta1StreamRawPredictRequest {
  /// The prediction input.
  ///
  /// Supports HTTP headers and arbitrary data payload.
  GoogleApiHttpBody? httpBody;

  GoogleCloudAiplatformV1beta1StreamRawPredictRequest({this.httpBody});

  GoogleCloudAiplatformV1beta1StreamRawPredictRequest.fromJson(core.Map json_)
    : this(
        httpBody:
            json_.containsKey('httpBody')
                ? GoogleApiHttpBody.fromJson(
                  json_['httpBody'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (httpBody != null) 'httpBody': httpBody!,
  };
}

/// Request message for FeatureOnlineStoreService.StreamingFetchFeatureValues.
///
/// For the entities requested, all features under the requested feature view
/// will be returned.
class GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesRequest {
  /// Specify response data format.
  ///
  /// If not set, KeyValue format will be used.
  /// Possible string values are:
  /// - "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED" : Not set. Will be treated as the
  /// KeyValue format.
  /// - "KEY_VALUE" : Return response data in key-value format.
  /// - "PROTO_STRUCT" : Return response data in proto Struct format.
  core.String? dataFormat;
  core.List<GoogleCloudAiplatformV1beta1FeatureViewDataKey>? dataKeys;

  GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesRequest({
    this.dataFormat,
    this.dataKeys,
  });

  GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesRequest.fromJson(
    core.Map json_,
  ) : this(
        dataFormat: json_['dataFormat'] as core.String?,
        dataKeys:
            (json_['dataKeys'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureViewDataKey.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataFormat != null) 'dataFormat': dataFormat!,
    if (dataKeys != null) 'dataKeys': dataKeys!,
  };
}

/// Response message for FeatureOnlineStoreService.StreamingFetchFeatureValues.
class GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesResponse {
  core.List<GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse>? data;
  core.List<GoogleCloudAiplatformV1beta1FeatureViewDataKey>? dataKeysWithError;

  /// Response status.
  ///
  /// If OK, then StreamingFetchFeatureValuesResponse.data will be populated.
  /// Otherwise StreamingFetchFeatureValuesResponse.data_keys_with_error will be
  /// populated with the appropriate data keys. The error only applies to the
  /// listed data keys - the stream will remain open for further
  /// FeatureOnlineStoreService.StreamingFetchFeatureValuesRequest requests.
  GoogleRpcStatus? status;

  GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesResponse({
    this.data,
    this.dataKeysWithError,
    this.status,
  });

  GoogleCloudAiplatformV1beta1StreamingFetchFeatureValuesResponse.fromJson(
    core.Map json_,
  ) : this(
        data:
            (json_['data'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FetchFeatureValuesResponse.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        dataKeysWithError:
            (json_['dataKeysWithError'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FeatureViewDataKey.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        status:
            json_.containsKey('status')
                ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (data != null) 'data': data!,
    if (dataKeysWithError != null) 'dataKeysWithError': dataKeysWithError!,
    if (status != null) 'status': status!,
  };
}

/// Request message for PredictionService.StreamingPredict.
///
/// The first message must contain endpoint field and optionally input. The
/// subsequent messages must contain input.
class GoogleCloudAiplatformV1beta1StreamingPredictRequest {
  /// The prediction input.
  core.List<GoogleCloudAiplatformV1beta1Tensor>? inputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1beta1Tensor? parameters;

  GoogleCloudAiplatformV1beta1StreamingPredictRequest({
    this.inputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1StreamingPredictRequest.fromJson(core.Map json_)
    : this(
        inputs:
            (json_['inputs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tensor.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inputs != null) 'inputs': inputs!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Response message for PredictionService.StreamingPredict.
class GoogleCloudAiplatformV1beta1StreamingPredictResponse {
  /// The prediction output.
  core.List<GoogleCloudAiplatformV1beta1Tensor>? outputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1beta1Tensor? parameters;

  GoogleCloudAiplatformV1beta1StreamingPredictResponse({
    this.outputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1beta1StreamingPredictResponse.fromJson(core.Map json_)
    : this(
        outputs:
            (json_['outputs'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tensor.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        parameters:
            json_.containsKey('parameters')
                ? GoogleCloudAiplatformV1beta1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputs != null) 'outputs': outputs!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// Request message for
/// FeaturestoreOnlineServingService.StreamingReadFeatureValues.
class GoogleCloudAiplatformV1beta1StreamingReadFeatureValuesRequest {
  /// IDs of entities to read Feature values of.
  ///
  /// The maximum number of IDs is 100. For example, for a machine learning
  /// model predicting user clicks on a website, an entity ID could be
  /// `user_123`.
  ///
  /// Required.
  core.List<core.String>? entityIds;

  /// Selector choosing Features of the target EntityType.
  ///
  /// Feature IDs will be deduplicated.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1FeatureSelector? featureSelector;

  GoogleCloudAiplatformV1beta1StreamingReadFeatureValuesRequest({
    this.entityIds,
    this.featureSelector,
  });

  GoogleCloudAiplatformV1beta1StreamingReadFeatureValuesRequest.fromJson(
    core.Map json_,
  ) : this(
        entityIds:
            (json_['entityIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        featureSelector:
            json_.containsKey('featureSelector')
                ? GoogleCloudAiplatformV1beta1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityIds != null) 'entityIds': entityIds!,
    if (featureSelector != null) 'featureSelector': featureSelector!,
  };
}

/// A list of string values.
typedef GoogleCloudAiplatformV1beta1StringArray = $StringArray;

/// One field of a Struct (or object) type feature value.
class GoogleCloudAiplatformV1beta1StructFieldValue {
  /// Name of the field in the struct feature.
  core.String? name;

  /// The value for this field.
  GoogleCloudAiplatformV1beta1FeatureValue? value;

  GoogleCloudAiplatformV1beta1StructFieldValue({this.name, this.value});

  GoogleCloudAiplatformV1beta1StructFieldValue.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        value:
            json_.containsKey('value')
                ? GoogleCloudAiplatformV1beta1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (value != null) 'value': value!,
  };
}

/// Struct (or object) type feature value.
class GoogleCloudAiplatformV1beta1StructValue {
  /// A list of field values.
  core.List<GoogleCloudAiplatformV1beta1StructFieldValue>? values;

  GoogleCloudAiplatformV1beta1StructValue({this.values});

  GoogleCloudAiplatformV1beta1StructValue.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1StructFieldValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// A message representing a Study.
class GoogleCloudAiplatformV1beta1Study {
  /// Time at which the study was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Describes the Study, default value is empty string.
  ///
  /// Required.
  core.String? displayName;

  /// A human readable reason why the Study is inactive.
  ///
  /// This should be empty if a study is ACTIVE or COMPLETED.
  ///
  /// Output only.
  core.String? inactiveReason;

  /// The name of a study.
  ///
  /// The study's globally unique identifier. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  ///
  /// Output only.
  core.String? name;

  /// The detailed state of a Study.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The study state is unspecified.
  /// - "ACTIVE" : The study is active.
  /// - "INACTIVE" : The study is stopped due to an internal error.
  /// - "COMPLETED" : The study is done when the service exhausts the parameter
  /// search space or max_trial_count is reached.
  core.String? state;

  /// Configuration of the Study.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1StudySpec? studySpec;

  GoogleCloudAiplatformV1beta1Study({
    this.createTime,
    this.displayName,
    this.inactiveReason,
    this.name,
    this.state,
    this.studySpec,
  });

  GoogleCloudAiplatformV1beta1Study.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        inactiveReason: json_['inactiveReason'] as core.String?,
        name: json_['name'] as core.String?,
        state: json_['state'] as core.String?,
        studySpec:
            json_.containsKey('studySpec')
                ? GoogleCloudAiplatformV1beta1StudySpec.fromJson(
                  json_['studySpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (inactiveReason != null) 'inactiveReason': inactiveReason!,
    if (name != null) 'name': name!,
    if (state != null) 'state': state!,
    if (studySpec != null) 'studySpec': studySpec!,
  };
}

/// Represents specification of a Study.
class GoogleCloudAiplatformV1beta1StudySpec {
  /// The search algorithm specified for the Study.
  /// Possible string values are:
  /// - "ALGORITHM_UNSPECIFIED" : The default algorithm used by Vertex AI for
  /// [hyperparameter tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
  /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
  /// - "GRID_SEARCH" : Simple grid search within the feasible space. To use
  /// grid search, all parameters must be `INTEGER`, `CATEGORICAL`, or
  /// `DISCRETE`.
  /// - "RANDOM_SEARCH" : Simple random search within the feasible space.
  core.String? algorithm;

  /// The automated early stopping spec using convex stopping rule.
  GoogleCloudAiplatformV1beta1StudySpecConvexAutomatedStoppingSpec?
  convexAutomatedStoppingSpec;

  /// The automated early stopping using convex stopping rule.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1StudySpecConvexStopConfig? convexStopConfig;

  /// The automated early stopping spec using decay curve rule.
  GoogleCloudAiplatformV1beta1StudySpecDecayCurveAutomatedStoppingSpec?
  decayCurveStoppingSpec;

  /// Describe which measurement selection type will be used
  /// Possible string values are:
  /// - "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED" : Will be treated as
  /// LAST_MEASUREMENT.
  /// - "LAST_MEASUREMENT" : Use the last measurement reported.
  /// - "BEST_MEASUREMENT" : Use the best measurement reported.
  core.String? measurementSelectionType;

  /// The automated early stopping spec using median rule.
  GoogleCloudAiplatformV1beta1StudySpecMedianAutomatedStoppingSpec?
  medianAutomatedStoppingSpec;

  /// Metric specs for the Study.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1StudySpecMetricSpec>? metrics;

  /// The observation noise level of the study.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  /// Possible string values are:
  /// - "OBSERVATION_NOISE_UNSPECIFIED" : The default noise level chosen by
  /// Vertex AI.
  /// - "LOW" : Vertex AI assumes that the objective function is (nearly)
  /// perfectly reproducible, and will never repeat the same Trial parameters.
  /// - "HIGH" : Vertex AI will estimate the amount of noise in metric
  /// evaluations, it may repeat the same Trial parameters more than once.
  core.String? observationNoise;

  /// The set of parameters to tune.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1StudySpecParameterSpec>? parameters;

  /// Conditions for automated stopping of a Study.
  ///
  /// Enable automated stopping by configuring at least one condition.
  GoogleCloudAiplatformV1beta1StudySpecStudyStoppingConfig? studyStoppingConfig;

  /// The configuration info/options for transfer learning.
  ///
  /// Currently supported for Vertex AI Vizier service, not
  /// HyperParameterTuningJob
  GoogleCloudAiplatformV1beta1StudySpecTransferLearningConfig?
  transferLearningConfig;

  GoogleCloudAiplatformV1beta1StudySpec({
    this.algorithm,
    this.convexAutomatedStoppingSpec,
    this.convexStopConfig,
    this.decayCurveStoppingSpec,
    this.measurementSelectionType,
    this.medianAutomatedStoppingSpec,
    this.metrics,
    this.observationNoise,
    this.parameters,
    this.studyStoppingConfig,
    this.transferLearningConfig,
  });

  GoogleCloudAiplatformV1beta1StudySpec.fromJson(core.Map json_)
    : this(
        algorithm: json_['algorithm'] as core.String?,
        convexAutomatedStoppingSpec:
            json_.containsKey('convexAutomatedStoppingSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecConvexAutomatedStoppingSpec.fromJson(
                  json_['convexAutomatedStoppingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        convexStopConfig:
            json_.containsKey('convexStopConfig')
                ? GoogleCloudAiplatformV1beta1StudySpecConvexStopConfig.fromJson(
                  json_['convexStopConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        decayCurveStoppingSpec:
            json_.containsKey('decayCurveStoppingSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecDecayCurveAutomatedStoppingSpec.fromJson(
                  json_['decayCurveStoppingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        measurementSelectionType:
            json_['measurementSelectionType'] as core.String?,
        medianAutomatedStoppingSpec:
            json_.containsKey('medianAutomatedStoppingSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecMedianAutomatedStoppingSpec.fromJson(
                  json_['medianAutomatedStoppingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        metrics:
            (json_['metrics'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1StudySpecMetricSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        observationNoise: json_['observationNoise'] as core.String?,
        parameters:
            (json_['parameters'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1StudySpecParameterSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        studyStoppingConfig:
            json_.containsKey('studyStoppingConfig')
                ? GoogleCloudAiplatformV1beta1StudySpecStudyStoppingConfig.fromJson(
                  json_['studyStoppingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        transferLearningConfig:
            json_.containsKey('transferLearningConfig')
                ? GoogleCloudAiplatformV1beta1StudySpecTransferLearningConfig.fromJson(
                  json_['transferLearningConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algorithm != null) 'algorithm': algorithm!,
    if (convexAutomatedStoppingSpec != null)
      'convexAutomatedStoppingSpec': convexAutomatedStoppingSpec!,
    if (convexStopConfig != null) 'convexStopConfig': convexStopConfig!,
    if (decayCurveStoppingSpec != null)
      'decayCurveStoppingSpec': decayCurveStoppingSpec!,
    if (measurementSelectionType != null)
      'measurementSelectionType': measurementSelectionType!,
    if (medianAutomatedStoppingSpec != null)
      'medianAutomatedStoppingSpec': medianAutomatedStoppingSpec!,
    if (metrics != null) 'metrics': metrics!,
    if (observationNoise != null) 'observationNoise': observationNoise!,
    if (parameters != null) 'parameters': parameters!,
    if (studyStoppingConfig != null)
      'studyStoppingConfig': studyStoppingConfig!,
    if (transferLearningConfig != null)
      'transferLearningConfig': transferLearningConfig!,
  };
}

/// Configuration for ConvexAutomatedStoppingSpec.
///
/// When there are enough completed trials (configured by
/// min_measurement_count), for pending trials with enough measurements and
/// steps, the policy first computes an overestimate of the objective value at
/// max_num_steps according to the slope of the incomplete objective value
/// curve. No prediction can be made if the curve is completely flat. If the
/// overestimation is worse than the best objective value of the completed
/// trials, this pending trial will be early-stopped, but a last measurement
/// will be added to the pending trial with max_num_steps and predicted
/// objective value from the autoregression model.
typedef GoogleCloudAiplatformV1beta1StudySpecConvexAutomatedStoppingSpec =
    $StudySpecConvexAutomatedStoppingSpec;

/// Configuration for ConvexStopPolicy.
class GoogleCloudAiplatformV1beta1StudySpecConvexStopConfig {
  /// The number of Trial measurements used in autoregressive model for value
  /// prediction.
  ///
  /// A trial won't be considered early stopping if has fewer measurement
  /// points.
  core.String? autoregressiveOrder;

  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate.
  ///
  /// Leave it blank if learning rate is not in a parameter in tuning. The
  /// learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  core.String? learningRateParameterName;

  /// Steps used in predicting the final objective for early stopped trials.
  ///
  /// In general, it's set to be the same as the defined steps in training /
  /// tuning. When use_steps is false, this field is set to the maximum elapsed
  /// seconds.
  core.String? maxNumSteps;

  /// Minimum number of steps for a trial to complete.
  ///
  /// Trials which do not have a measurement with num_steps \> min_num_steps
  /// won't be considered for early stopping. It's ok to set it to 0, and a
  /// trial can be early stopped at any stage. By default, min_num_steps is set
  /// to be one-tenth of the max_num_steps. When use_steps is false, this field
  /// is set to the minimum elapsed seconds.
  core.String? minNumSteps;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps.
  ///
  /// If use_seconds==false, the early stopping decision is made according to
  /// the predicted objective values according to the target steps. If
  /// use_seconds==true, elapsed_secs is used instead of steps. Also, in this
  /// case, the parameters max_num_steps and min_num_steps are overloaded to
  /// contain max_elapsed_seconds and min_elapsed_seconds.
  core.bool? useSeconds;

  GoogleCloudAiplatformV1beta1StudySpecConvexStopConfig({
    this.autoregressiveOrder,
    this.learningRateParameterName,
    this.maxNumSteps,
    this.minNumSteps,
    this.useSeconds,
  });

  GoogleCloudAiplatformV1beta1StudySpecConvexStopConfig.fromJson(core.Map json_)
    : this(
        autoregressiveOrder: json_['autoregressiveOrder'] as core.String?,
        learningRateParameterName:
            json_['learningRateParameterName'] as core.String?,
        maxNumSteps: json_['maxNumSteps'] as core.String?,
        minNumSteps: json_['minNumSteps'] as core.String?,
        useSeconds: json_['useSeconds'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoregressiveOrder != null)
      'autoregressiveOrder': autoregressiveOrder!,
    if (learningRateParameterName != null)
      'learningRateParameterName': learningRateParameterName!,
    if (maxNumSteps != null) 'maxNumSteps': maxNumSteps!,
    if (minNumSteps != null) 'minNumSteps': minNumSteps!,
    if (useSeconds != null) 'useSeconds': useSeconds!,
  };
}

/// The decay curve automated stopping rule builds a Gaussian Process Regressor
/// to predict the final objective value of a Trial based on the already
/// completed Trials and the intermediate measurements of the current Trial.
///
/// Early stopping is requested for the current Trial if there is very low
/// probability to exceed the optimal value found so far.
typedef GoogleCloudAiplatformV1beta1StudySpecDecayCurveAutomatedStoppingSpec =
    $StudySpecDecayCurveAutomatedStoppingSpec;

/// The median automated stopping rule stops a pending Trial if the Trial's best
/// objective_value is strictly below the median 'performance' of all completed
/// Trials reported up to the Trial's last measurement.
///
/// Currently, 'performance' refers to the running average of the objective
/// values reported by the Trial in each measurement.
typedef GoogleCloudAiplatformV1beta1StudySpecMedianAutomatedStoppingSpec =
    $StudySpecMedianAutomatedStoppingSpec;

/// Represents a metric to optimize.
class GoogleCloudAiplatformV1beta1StudySpecMetricSpec {
  /// The optimization goal of the metric.
  ///
  /// Required.
  /// Possible string values are:
  /// - "GOAL_TYPE_UNSPECIFIED" : Goal Type will default to maximize.
  /// - "MAXIMIZE" : Maximize the goal metric.
  /// - "MINIMIZE" : Minimize the goal metric.
  core.String? goal;

  /// The ID of the metric.
  ///
  /// Must not contain whitespaces and must be unique amongst all MetricSpecs.
  ///
  /// Required.
  core.String? metricId;

  /// Used for safe search.
  ///
  /// In the case, the metric will be a safety metric. You must provide a
  /// separate metric for objective metric.
  GoogleCloudAiplatformV1beta1StudySpecMetricSpecSafetyMetricConfig?
  safetyConfig;

  GoogleCloudAiplatformV1beta1StudySpecMetricSpec({
    this.goal,
    this.metricId,
    this.safetyConfig,
  });

  GoogleCloudAiplatformV1beta1StudySpecMetricSpec.fromJson(core.Map json_)
    : this(
        goal: json_['goal'] as core.String?,
        metricId: json_['metricId'] as core.String?,
        safetyConfig:
            json_.containsKey('safetyConfig')
                ? GoogleCloudAiplatformV1beta1StudySpecMetricSpecSafetyMetricConfig.fromJson(
                  json_['safetyConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (goal != null) 'goal': goal!,
    if (metricId != null) 'metricId': metricId!,
    if (safetyConfig != null) 'safetyConfig': safetyConfig!,
  };
}

/// Used in safe optimization to specify threshold levels and risk tolerance.
typedef GoogleCloudAiplatformV1beta1StudySpecMetricSpecSafetyMetricConfig =
    $StudySpecMetricSpecSafetyMetricConfig;

/// Represents a single parameter to optimize.
class GoogleCloudAiplatformV1beta1StudySpecParameterSpec {
  /// The value spec for a 'CATEGORICAL' parameter.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpecCategoricalValueSpec?
  categoricalValueSpec;

  /// A conditional parameter node is active if the parameter's value matches
  /// the conditional node's parent_value_condition.
  ///
  /// If two items in conditional_parameter_specs have the same name, they must
  /// have disjoint parent_value_condition.
  core.List<
    GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpec
  >?
  conditionalParameterSpecs;

  /// The value spec for a 'DISCRETE' parameter.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpecDiscreteValueSpec?
  discreteValueSpec;

  /// The value spec for a 'DOUBLE' parameter.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpecDoubleValueSpec?
  doubleValueSpec;

  /// The value spec for an 'INTEGER' parameter.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpecIntegerValueSpec?
  integerValueSpec;

  /// The ID of the parameter.
  ///
  /// Must not contain whitespaces and must be unique amongst all
  /// ParameterSpecs.
  ///
  /// Required.
  core.String? parameterId;

  /// How the parameter should be scaled.
  ///
  /// Leave unset for `CATEGORICAL` parameters.
  /// Possible string values are:
  /// - "SCALE_TYPE_UNSPECIFIED" : By default, no scaling is applied.
  /// - "UNIT_LINEAR_SCALE" : Scales the feasible space to (0, 1) linearly.
  /// - "UNIT_LOG_SCALE" : Scales the feasible space logarithmically to (0, 1).
  /// The entire feasible space must be strictly positive.
  /// - "UNIT_REVERSE_LOG_SCALE" : Scales the feasible space "reverse"
  /// logarithmically to (0, 1). The result is that values close to the top of
  /// the feasible space are spread out more than points near the bottom. The
  /// entire feasible space must be strictly positive.
  core.String? scaleType;

  GoogleCloudAiplatformV1beta1StudySpecParameterSpec({
    this.categoricalValueSpec,
    this.conditionalParameterSpecs,
    this.discreteValueSpec,
    this.doubleValueSpec,
    this.integerValueSpec,
    this.parameterId,
    this.scaleType,
  });

  GoogleCloudAiplatformV1beta1StudySpecParameterSpec.fromJson(core.Map json_)
    : this(
        categoricalValueSpec:
            json_.containsKey('categoricalValueSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpecCategoricalValueSpec.fromJson(
                  json_['categoricalValueSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        conditionalParameterSpecs:
            (json_['conditionalParameterSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        discreteValueSpec:
            json_.containsKey('discreteValueSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpecDiscreteValueSpec.fromJson(
                  json_['discreteValueSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        doubleValueSpec:
            json_.containsKey('doubleValueSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpecDoubleValueSpec.fromJson(
                  json_['doubleValueSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        integerValueSpec:
            json_.containsKey('integerValueSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpecIntegerValueSpec.fromJson(
                  json_['integerValueSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        parameterId: json_['parameterId'] as core.String?,
        scaleType: json_['scaleType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (categoricalValueSpec != null)
      'categoricalValueSpec': categoricalValueSpec!,
    if (conditionalParameterSpecs != null)
      'conditionalParameterSpecs': conditionalParameterSpecs!,
    if (discreteValueSpec != null) 'discreteValueSpec': discreteValueSpec!,
    if (doubleValueSpec != null) 'doubleValueSpec': doubleValueSpec!,
    if (integerValueSpec != null) 'integerValueSpec': integerValueSpec!,
    if (parameterId != null) 'parameterId': parameterId!,
    if (scaleType != null) 'scaleType': scaleType!,
  };
}

/// Value specification for a parameter in `CATEGORICAL` type.
typedef GoogleCloudAiplatformV1beta1StudySpecParameterSpecCategoricalValueSpec =
    $StudySpecParameterSpecCategoricalValueSpec;

/// Represents a parameter spec with condition from its parent parameter.
class GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpec {
  /// The spec for a conditional parameter.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpec? parameterSpec;

  /// The spec for matching values from a parent parameter of `CATEGORICAL`
  /// type.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition?
  parentCategoricalValues;

  /// The spec for matching values from a parent parameter of `DISCRETE` type.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition?
  parentDiscreteValues;

  /// The spec for matching values from a parent parameter of `INTEGER` type.
  GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecIntValueCondition?
  parentIntValues;

  GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpec({
    this.parameterSpec,
    this.parentCategoricalValues,
    this.parentDiscreteValues,
    this.parentIntValues,
  });

  GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpec.fromJson(
    core.Map json_,
  ) : this(
        parameterSpec:
            json_.containsKey('parameterSpec')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpec.fromJson(
                  json_['parameterSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        parentCategoricalValues:
            json_.containsKey('parentCategoricalValues')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition.fromJson(
                  json_['parentCategoricalValues']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        parentDiscreteValues:
            json_.containsKey('parentDiscreteValues')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition.fromJson(
                  json_['parentDiscreteValues']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        parentIntValues:
            json_.containsKey('parentIntValues')
                ? GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecIntValueCondition.fromJson(
                  json_['parentIntValues']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parameterSpec != null) 'parameterSpec': parameterSpec!,
    if (parentCategoricalValues != null)
      'parentCategoricalValues': parentCategoricalValues!,
    if (parentDiscreteValues != null)
      'parentDiscreteValues': parentDiscreteValues!,
    if (parentIntValues != null) 'parentIntValues': parentIntValues!,
  };
}

/// Represents the spec to match categorical values from parent parameter.
typedef GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition =
    $StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition;

/// Represents the spec to match discrete values from parent parameter.
typedef GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition =
    $StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition;

/// Represents the spec to match integer values from parent parameter.
typedef GoogleCloudAiplatformV1beta1StudySpecParameterSpecConditionalParameterSpecIntValueCondition =
    $StudySpecParameterSpecConditionalParameterSpecIntValueCondition;

/// Value specification for a parameter in `DISCRETE` type.
typedef GoogleCloudAiplatformV1beta1StudySpecParameterSpecDiscreteValueSpec =
    $StudySpecParameterSpecDiscreteValueSpec;

/// Value specification for a parameter in `DOUBLE` type.
typedef GoogleCloudAiplatformV1beta1StudySpecParameterSpecDoubleValueSpec =
    $StudySpecParameterSpecDoubleValueSpec;

/// Value specification for a parameter in `INTEGER` type.
typedef GoogleCloudAiplatformV1beta1StudySpecParameterSpecIntegerValueSpec =
    $StudySpecParameterSpecIntegerValueSpec;

/// The configuration (stopping conditions) for automated stopping of a Study.
///
/// Conditions include trial budgets, time budgets, and convergence detection.
class GoogleCloudAiplatformV1beta1StudySpecStudyStoppingConfig {
  /// If the objective value has not improved for this much time, stop the
  /// study.
  ///
  /// WARNING: Effective only for single-objective studies.
  core.String? maxDurationNoProgress;

  /// If there are more than this many trials, stop the study.
  core.int? maxNumTrials;

  /// If the objective value has not improved for this many consecutive trials,
  /// stop the study.
  ///
  /// WARNING: Effective only for single-objective studies.
  core.int? maxNumTrialsNoProgress;

  /// If the specified time or duration has passed, stop the study.
  GoogleCloudAiplatformV1beta1StudyTimeConstraint? maximumRuntimeConstraint;

  /// If there are fewer than this many COMPLETED trials, do not stop the study.
  core.int? minNumTrials;

  /// Each "stopping rule" in this proto specifies an "if" condition.
  ///
  /// Before Vizier would generate a new suggestion, it first checks each
  /// specified stopping rule, from top to bottom in this list. Note that the
  /// first few rules (e.g. minimum_runtime_constraint, min_num_trials) will
  /// prevent other stopping rules from being evaluated until they are met. For
  /// example, setting `min_num_trials=5` and `always_stop_after= 1 hour` means
  /// that the Study will ONLY stop after it has 5 COMPLETED trials, even if
  /// more than an hour has passed since its creation. It follows the first
  /// applicable rule (whose "if" condition is satisfied) to make a stopping
  /// decision. If none of the specified rules are applicable, then Vizier
  /// decides that the study should not stop. If Vizier decides that the study
  /// should stop, the study enters STOPPING state (or STOPPING_ASAP if
  /// should_stop_asap = true). IMPORTANT: The automatic study state transition
  /// happens precisely as described above; that is, deleting trials or updating
  /// StudyConfig NEVER automatically moves the study state back to ACTIVE. If
  /// you want to _resume_ a Study that was stopped, 1) change the stopping
  /// conditions if necessary, 2) activate the study, and then 3) ask for
  /// suggestions. If the specified time or duration has not passed, do not stop
  /// the study.
  GoogleCloudAiplatformV1beta1StudyTimeConstraint? minimumRuntimeConstraint;

  /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
  /// STOPPING state.
  ///
  /// The bottom line is: set to true if you want to interrupt on-going
  /// evaluations of Trials as soon as the study stopping condition is met.
  /// (Please see Study.State documentation for the source of truth).
  core.bool? shouldStopAsap;

  GoogleCloudAiplatformV1beta1StudySpecStudyStoppingConfig({
    this.maxDurationNoProgress,
    this.maxNumTrials,
    this.maxNumTrialsNoProgress,
    this.maximumRuntimeConstraint,
    this.minNumTrials,
    this.minimumRuntimeConstraint,
    this.shouldStopAsap,
  });

  GoogleCloudAiplatformV1beta1StudySpecStudyStoppingConfig.fromJson(
    core.Map json_,
  ) : this(
        maxDurationNoProgress: json_['maxDurationNoProgress'] as core.String?,
        maxNumTrials: json_['maxNumTrials'] as core.int?,
        maxNumTrialsNoProgress: json_['maxNumTrialsNoProgress'] as core.int?,
        maximumRuntimeConstraint:
            json_.containsKey('maximumRuntimeConstraint')
                ? GoogleCloudAiplatformV1beta1StudyTimeConstraint.fromJson(
                  json_['maximumRuntimeConstraint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        minNumTrials: json_['minNumTrials'] as core.int?,
        minimumRuntimeConstraint:
            json_.containsKey('minimumRuntimeConstraint')
                ? GoogleCloudAiplatformV1beta1StudyTimeConstraint.fromJson(
                  json_['minimumRuntimeConstraint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        shouldStopAsap: json_['shouldStopAsap'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (maxDurationNoProgress != null)
      'maxDurationNoProgress': maxDurationNoProgress!,
    if (maxNumTrials != null) 'maxNumTrials': maxNumTrials!,
    if (maxNumTrialsNoProgress != null)
      'maxNumTrialsNoProgress': maxNumTrialsNoProgress!,
    if (maximumRuntimeConstraint != null)
      'maximumRuntimeConstraint': maximumRuntimeConstraint!,
    if (minNumTrials != null) 'minNumTrials': minNumTrials!,
    if (minimumRuntimeConstraint != null)
      'minimumRuntimeConstraint': minimumRuntimeConstraint!,
    if (shouldStopAsap != null) 'shouldStopAsap': shouldStopAsap!,
  };
}

/// This contains flag for manually disabling transfer learning for a study.
///
/// The names of prior studies being used for transfer learning (if any) are
/// also listed here.
class GoogleCloudAiplatformV1beta1StudySpecTransferLearningConfig {
  /// Flag to to manually prevent vizier from using transfer learning on a new
  /// study.
  ///
  /// Otherwise, vizier will automatically determine whether or not to use
  /// transfer learning.
  core.bool? disableTransferLearning;

  /// Names of previously completed studies
  ///
  /// Output only.
  core.List<core.String>? priorStudyNames;

  GoogleCloudAiplatformV1beta1StudySpecTransferLearningConfig({
    this.disableTransferLearning,
    this.priorStudyNames,
  });

  GoogleCloudAiplatformV1beta1StudySpecTransferLearningConfig.fromJson(
    core.Map json_,
  ) : this(
        disableTransferLearning: json_['disableTransferLearning'] as core.bool?,
        priorStudyNames:
            (json_['priorStudyNames'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableTransferLearning != null)
      'disableTransferLearning': disableTransferLearning!,
    if (priorStudyNames != null) 'priorStudyNames': priorStudyNames!,
  };
}

/// Time-based Constraint for Study
typedef GoogleCloudAiplatformV1beta1StudyTimeConstraint = $StudyTimeConstraint;

/// Request message for VizierService.SuggestTrials.
class GoogleCloudAiplatformV1beta1SuggestTrialsRequest {
  /// The identifier of the client that is requesting the suggestion.
  ///
  /// If multiple SuggestTrialsRequests have the same `client_id`, the service
  /// will return the identical suggested Trial if the Trial is pending, and
  /// provide a new Trial if the last suggested Trial was completed.
  ///
  /// Required.
  core.String? clientId;

  /// This allows you to specify the "context" for a Trial; a context is a slice
  /// (a subspace) of the search space.
  ///
  /// Typical uses for contexts: 1) You are using Vizier to tune a server for
  /// best performance, but there's a strong weekly cycle. The context specifies
  /// the day-of-week. This allows Tuesday to generalize from Wednesday without
  /// assuming that everything is identical. 2) Imagine you're optimizing some
  /// medical treatment for people. As they walk in the door, you know certain
  /// facts about them (e.g. sex, weight, height, blood-pressure). Put that
  /// information in the context, and Vizier will adapt its suggestions to the
  /// patient. 3) You want to do a fair A/B test efficiently. Specify the "A"
  /// and "B" conditions as contexts, and Vizier will generalize between "A" and
  /// "B" conditions. If they are similar, this will allow Vizier to converge to
  /// the optimum faster than if "A" and "B" were separate Studies. NOTE: You
  /// can also enter contexts as REQUESTED Trials, e.g. via the CreateTrial()
  /// RPC; that's the asynchronous option where you don't need a close
  /// association between contexts and suggestions. NOTE: All the Parameters you
  /// set in a context MUST be defined in the Study. NOTE: You must supply 0 or
  /// $suggestion_count contexts. If you don't supply any contexts, Vizier will
  /// make suggestions from the full search space specified in the StudySpec; if
  /// you supply a full set of context, each suggestion will match the
  /// corresponding context. NOTE: A Context with no features set matches
  /// anything, and allows suggestions from the full search space. NOTE:
  /// Contexts MUST lie within the search space specified in the StudySpec. It's
  /// an error if they don't. NOTE: Contexts preferentially match ACTIVE then
  /// REQUESTED trials before new suggestions are generated. NOTE: Generation of
  /// suggestions involves a match between a Context and (optionally) a
  /// REQUESTED trial; if that match is not fully specified, a suggestion will
  /// be geneated in the merged subspace.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1TrialContext>? contexts;

  /// The number of suggestions requested.
  ///
  /// It must be positive.
  ///
  /// Required.
  core.int? suggestionCount;

  GoogleCloudAiplatformV1beta1SuggestTrialsRequest({
    this.clientId,
    this.contexts,
    this.suggestionCount,
  });

  GoogleCloudAiplatformV1beta1SuggestTrialsRequest.fromJson(core.Map json_)
    : this(
        clientId: json_['clientId'] as core.String?,
        contexts:
            (json_['contexts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1TrialContext.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        suggestionCount: json_['suggestionCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientId != null) 'clientId': clientId!,
    if (contexts != null) 'contexts': contexts!,
    if (suggestionCount != null) 'suggestionCount': suggestionCount!,
  };
}

/// Input for summarization helpfulness metric.
class GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInput {
  /// Summarization helpfulness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInstance? instance;

  /// Spec for summarization helpfulness score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SummarizationHelpfulnessSpec? metricSpec;

  GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1SummarizationHelpfulnessSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for summarization helpfulness instance.
typedef GoogleCloudAiplatformV1beta1SummarizationHelpfulnessInstance =
    $Instance04;

/// Spec for summarization helpfulness result.
typedef GoogleCloudAiplatformV1beta1SummarizationHelpfulnessResult =
    $SummarizationHelpfulnessResult;

/// Spec for summarization helpfulness score metric.
typedef GoogleCloudAiplatformV1beta1SummarizationHelpfulnessSpec =
    $SummarizationHelpfulnessSpec;

/// Input for summarization quality metric.
class GoogleCloudAiplatformV1beta1SummarizationQualityInput {
  /// Summarization quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SummarizationQualityInstance? instance;

  /// Spec for summarization quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SummarizationQualitySpec? metricSpec;

  GoogleCloudAiplatformV1beta1SummarizationQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1SummarizationQualityInput.fromJson(core.Map json_)
    : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1SummarizationQualityInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1SummarizationQualitySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for summarization quality instance.
typedef GoogleCloudAiplatformV1beta1SummarizationQualityInstance =
    $SummarizationQualityInstance;

/// Spec for summarization quality result.
typedef GoogleCloudAiplatformV1beta1SummarizationQualityResult =
    $SummarizationQualityResult;

/// Spec for summarization quality score metric.
typedef GoogleCloudAiplatformV1beta1SummarizationQualitySpec =
    $SummarizationQualitySpec;

/// Input for summarization verbosity metric.
class GoogleCloudAiplatformV1beta1SummarizationVerbosityInput {
  /// Summarization verbosity instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SummarizationVerbosityInstance? instance;

  /// Spec for summarization verbosity score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1SummarizationVerbositySpec? metricSpec;

  GoogleCloudAiplatformV1beta1SummarizationVerbosityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1SummarizationVerbosityInput.fromJson(
    core.Map json_,
  ) : this(
        instance:
            json_.containsKey('instance')
                ? GoogleCloudAiplatformV1beta1SummarizationVerbosityInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1SummarizationVerbositySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instance != null) 'instance': instance!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for summarization verbosity instance.
typedef GoogleCloudAiplatformV1beta1SummarizationVerbosityInstance =
    $Instance04;

/// Spec for summarization verbosity result.
typedef GoogleCloudAiplatformV1beta1SummarizationVerbosityResult =
    $SummarizationVerbosityResult;

/// Spec for summarization verbosity score metric.
typedef GoogleCloudAiplatformV1beta1SummarizationVerbositySpec =
    $SummarizationVerbositySpec;

/// Hyperparameters for SFT.
class GoogleCloudAiplatformV1beta1SupervisedHyperParameters {
  /// Adapter size for tuning.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ADAPTER_SIZE_UNSPECIFIED" : Adapter size is unspecified.
  /// - "ADAPTER_SIZE_ONE" : Adapter size 1.
  /// - "ADAPTER_SIZE_TWO" : Adapter size 2.
  /// - "ADAPTER_SIZE_FOUR" : Adapter size 4.
  /// - "ADAPTER_SIZE_EIGHT" : Adapter size 8.
  /// - "ADAPTER_SIZE_SIXTEEN" : Adapter size 16.
  /// - "ADAPTER_SIZE_THIRTY_TWO" : Adapter size 32.
  core.String? adapterSize;

  /// Batch size for tuning.
  ///
  /// This feature is only available for open source models.
  ///
  /// Optional.
  core.String? batchSize;

  /// Number of complete passes the model makes over the entire training dataset
  /// during training.
  ///
  /// Optional.
  core.String? epochCount;

  /// Learning rate for tuning.
  ///
  /// Mutually exclusive with `learning_rate_multiplier`. This feature is only
  /// available for open source models.
  ///
  /// Optional.
  core.double? learningRate;

  /// Multiplier for adjusting the default learning rate.
  ///
  /// Mutually exclusive with `learning_rate`. This feature is only available
  /// for 1P models.
  ///
  /// Optional.
  core.double? learningRateMultiplier;

  GoogleCloudAiplatformV1beta1SupervisedHyperParameters({
    this.adapterSize,
    this.batchSize,
    this.epochCount,
    this.learningRate,
    this.learningRateMultiplier,
  });

  GoogleCloudAiplatformV1beta1SupervisedHyperParameters.fromJson(core.Map json_)
    : this(
        adapterSize: json_['adapterSize'] as core.String?,
        batchSize: json_['batchSize'] as core.String?,
        epochCount: json_['epochCount'] as core.String?,
        learningRate: (json_['learningRate'] as core.num?)?.toDouble(),
        learningRateMultiplier:
            (json_['learningRateMultiplier'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (adapterSize != null) 'adapterSize': adapterSize!,
    if (batchSize != null) 'batchSize': batchSize!,
    if (epochCount != null) 'epochCount': epochCount!,
    if (learningRate != null) 'learningRate': learningRate!,
    if (learningRateMultiplier != null)
      'learningRateMultiplier': learningRateMultiplier!,
  };
}

/// Tuning data statistics for Supervised Tuning.
class GoogleCloudAiplatformV1beta1SupervisedTuningDataStats {
  /// For each index in `truncated_example_indices`, the user-facing reason why
  /// the example was dropped.
  ///
  /// Output only.
  core.List<core.String>? droppedExampleReasons;

  /// Number of billable characters in the tuning dataset.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? totalBillableCharacterCount;

  /// Number of billable tokens in the tuning dataset.
  ///
  /// Output only.
  core.String? totalBillableTokenCount;

  /// The number of examples in the dataset that have been dropped.
  ///
  /// An example can be dropped for reasons including: too many tokens, contains
  /// an invalid image, contains too many images, etc.
  ///
  /// Output only.
  core.String? totalTruncatedExampleCount;

  /// Number of tuning characters in the tuning dataset.
  ///
  /// Output only.
  core.String? totalTuningCharacterCount;

  /// A partial sample of the indices (starting from 1) of the dropped examples.
  ///
  /// Output only.
  core.List<core.String>? truncatedExampleIndices;

  /// Number of examples in the tuning dataset.
  ///
  /// Output only.
  core.String? tuningDatasetExampleCount;

  /// Number of tuning steps for this Tuning Job.
  ///
  /// Output only.
  core.String? tuningStepCount;

  /// Sample user messages in the training dataset uri.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Content>? userDatasetExamples;

  /// Dataset distributions for the user input tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution?
  userInputTokenDistribution;

  /// Dataset distributions for the messages per example.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution?
  userMessagePerExampleDistribution;

  /// Dataset distributions for the user output tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution?
  userOutputTokenDistribution;

  GoogleCloudAiplatformV1beta1SupervisedTuningDataStats({
    this.droppedExampleReasons,
    this.totalBillableCharacterCount,
    this.totalBillableTokenCount,
    this.totalTruncatedExampleCount,
    this.totalTuningCharacterCount,
    this.truncatedExampleIndices,
    this.tuningDatasetExampleCount,
    this.tuningStepCount,
    this.userDatasetExamples,
    this.userInputTokenDistribution,
    this.userMessagePerExampleDistribution,
    this.userOutputTokenDistribution,
  });

  GoogleCloudAiplatformV1beta1SupervisedTuningDataStats.fromJson(core.Map json_)
    : this(
        droppedExampleReasons:
            (json_['droppedExampleReasons'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        totalBillableCharacterCount:
            json_['totalBillableCharacterCount'] as core.String?,
        totalBillableTokenCount:
            json_['totalBillableTokenCount'] as core.String?,
        totalTruncatedExampleCount:
            json_['totalTruncatedExampleCount'] as core.String?,
        totalTuningCharacterCount:
            json_['totalTuningCharacterCount'] as core.String?,
        truncatedExampleIndices:
            (json_['truncatedExampleIndices'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        tuningDatasetExampleCount:
            json_['tuningDatasetExampleCount'] as core.String?,
        tuningStepCount: json_['tuningStepCount'] as core.String?,
        userDatasetExamples:
            (json_['userDatasetExamples'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Content.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        userInputTokenDistribution:
            json_.containsKey('userInputTokenDistribution')
                ? GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution.fromJson(
                  json_['userInputTokenDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userMessagePerExampleDistribution:
            json_.containsKey('userMessagePerExampleDistribution')
                ? GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution.fromJson(
                  json_['userMessagePerExampleDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userOutputTokenDistribution:
            json_.containsKey('userOutputTokenDistribution')
                ? GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution.fromJson(
                  json_['userOutputTokenDistribution']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (droppedExampleReasons != null)
      'droppedExampleReasons': droppedExampleReasons!,
    if (totalBillableCharacterCount != null)
      'totalBillableCharacterCount': totalBillableCharacterCount!,
    if (totalBillableTokenCount != null)
      'totalBillableTokenCount': totalBillableTokenCount!,
    if (totalTruncatedExampleCount != null)
      'totalTruncatedExampleCount': totalTruncatedExampleCount!,
    if (totalTuningCharacterCount != null)
      'totalTuningCharacterCount': totalTuningCharacterCount!,
    if (truncatedExampleIndices != null)
      'truncatedExampleIndices': truncatedExampleIndices!,
    if (tuningDatasetExampleCount != null)
      'tuningDatasetExampleCount': tuningDatasetExampleCount!,
    if (tuningStepCount != null) 'tuningStepCount': tuningStepCount!,
    if (userDatasetExamples != null)
      'userDatasetExamples': userDatasetExamples!,
    if (userInputTokenDistribution != null)
      'userInputTokenDistribution': userInputTokenDistribution!,
    if (userMessagePerExampleDistribution != null)
      'userMessagePerExampleDistribution': userMessagePerExampleDistribution!,
    if (userOutputTokenDistribution != null)
      'userOutputTokenDistribution': userOutputTokenDistribution!,
  };
}

/// Dataset distribution for Supervised Tuning.
class GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution {
  /// Sum of a given population of values that are billable.
  ///
  /// Output only.
  core.String? billableSum;

  /// Defines the histogram bucket.
  ///
  /// Output only.
  core.List<
    GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistributionDatasetBucket
  >?
  buckets;

  /// The maximum of the population values.
  ///
  /// Output only.
  core.double? max;

  /// The arithmetic mean of the values in the population.
  ///
  /// Output only.
  core.double? mean;

  /// The median of the values in the population.
  ///
  /// Output only.
  core.double? median;

  /// The minimum of the population values.
  ///
  /// Output only.
  core.double? min;

  /// The 5th percentile of the values in the population.
  ///
  /// Output only.
  core.double? p5;

  /// The 95th percentile of the values in the population.
  ///
  /// Output only.
  core.double? p95;

  /// Sum of a given population of values.
  ///
  /// Output only.
  core.String? sum;

  GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution({
    this.billableSum,
    this.buckets,
    this.max,
    this.mean,
    this.median,
    this.min,
    this.p5,
    this.p95,
    this.sum,
  });

  GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistribution.fromJson(
    core.Map json_,
  ) : this(
        billableSum: json_['billableSum'] as core.String?,
        buckets:
            (json_['buckets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistributionDatasetBucket.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        max: (json_['max'] as core.num?)?.toDouble(),
        mean: (json_['mean'] as core.num?)?.toDouble(),
        median: (json_['median'] as core.num?)?.toDouble(),
        min: (json_['min'] as core.num?)?.toDouble(),
        p5: (json_['p5'] as core.num?)?.toDouble(),
        p95: (json_['p95'] as core.num?)?.toDouble(),
        sum: json_['sum'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (billableSum != null) 'billableSum': billableSum!,
    if (buckets != null) 'buckets': buckets!,
    if (max != null) 'max': max!,
    if (mean != null) 'mean': mean!,
    if (median != null) 'median': median!,
    if (min != null) 'min': min!,
    if (p5 != null) 'p5': p5!,
    if (p95 != null) 'p95': p95!,
    if (sum != null) 'sum': sum!,
  };
}

/// Dataset bucket used to create a histogram for the distribution given a
/// population of values.
typedef GoogleCloudAiplatformV1beta1SupervisedTuningDatasetDistributionDatasetBucket =
    $SupervisedTuningDatasetDistributionDatasetBucket;

/// Tuning Spec for Supervised Tuning for first party models.
class GoogleCloudAiplatformV1beta1SupervisedTuningSpec {
  /// If set to true, disable intermediate checkpoints for SFT and only the last
  /// checkpoint will be exported.
  ///
  /// Otherwise, enable intermediate checkpoints for SFT. Default is false.
  ///
  /// Optional.
  core.bool? exportLastCheckpointOnly;

  /// Hyperparameters for SFT.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1SupervisedHyperParameters? hyperParameters;

  /// Training dataset used for tuning.
  ///
  /// The dataset can be specified as either a Cloud Storage path to a JSONL
  /// file or as the resource name of a Vertex Multimodal Dataset.
  ///
  /// Required.
  core.String? trainingDatasetUri;

  /// Tuning mode.
  /// Possible string values are:
  /// - "TUNING_MODE_UNSPECIFIED" : Tuning mode is unspecified.
  /// - "TUNING_MODE_FULL" : Full fine-tuning mode.
  /// - "TUNING_MODE_PEFT_ADAPTER" : PEFT adapter tuning mode.
  core.String? tuningMode;

  /// Validation dataset used for tuning.
  ///
  /// The dataset can be specified as either a Cloud Storage path to a JSONL
  /// file or as the resource name of a Vertex Multimodal Dataset.
  ///
  /// Optional.
  core.String? validationDatasetUri;

  GoogleCloudAiplatformV1beta1SupervisedTuningSpec({
    this.exportLastCheckpointOnly,
    this.hyperParameters,
    this.trainingDatasetUri,
    this.tuningMode,
    this.validationDatasetUri,
  });

  GoogleCloudAiplatformV1beta1SupervisedTuningSpec.fromJson(core.Map json_)
    : this(
        exportLastCheckpointOnly:
            json_['exportLastCheckpointOnly'] as core.bool?,
        hyperParameters:
            json_.containsKey('hyperParameters')
                ? GoogleCloudAiplatformV1beta1SupervisedHyperParameters.fromJson(
                  json_['hyperParameters']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingDatasetUri: json_['trainingDatasetUri'] as core.String?,
        tuningMode: json_['tuningMode'] as core.String?,
        validationDatasetUri: json_['validationDatasetUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exportLastCheckpointOnly != null)
      'exportLastCheckpointOnly': exportLastCheckpointOnly!,
    if (hyperParameters != null) 'hyperParameters': hyperParameters!,
    if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri!,
    if (tuningMode != null) 'tuningMode': tuningMode!,
    if (validationDatasetUri != null)
      'validationDatasetUri': validationDatasetUri!,
  };
}

/// Request message for FeatureOnlineStoreAdminService.SyncFeatureView.
typedef GoogleCloudAiplatformV1beta1SyncFeatureViewRequest = $Empty;

/// Response message for FeatureOnlineStoreAdminService.SyncFeatureView.
typedef GoogleCloudAiplatformV1beta1SyncFeatureViewResponse =
    $SyncFeatureViewResponse;

/// The storage details for TFRecord output content.
class GoogleCloudAiplatformV1beta1TFRecordDestination {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1beta1TFRecordDestination({this.gcsDestination});

  GoogleCloudAiplatformV1beta1TFRecordDestination.fromJson(core.Map json_)
    : this(
        gcsDestination:
            json_.containsKey('gcsDestination')
                ? GoogleCloudAiplatformV1beta1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!,
  };
}

/// A tensor value type.
class GoogleCloudAiplatformV1beta1Tensor {
  /// Type specific representations that make it easy to create tensor protos in
  /// all languages.
  ///
  /// Only the representation corresponding to "dtype" can be set. The values
  /// hold the flattened representation of the tensor in row major order. BOOL
  core.List<core.bool>? boolVal;

  /// STRING
  core.List<core.String>? bytesVal;

  /// DOUBLE
  core.List<core.double>? doubleVal;

  /// The data type of tensor.
  /// Possible string values are:
  /// - "DATA_TYPE_UNSPECIFIED" : Not a legal value for DataType. Used to
  /// indicate a DataType field has not been set.
  /// - "BOOL" : Data types that all computation devices are expected to be
  /// capable to support.
  /// - "STRING"
  /// - "FLOAT"
  /// - "DOUBLE"
  /// - "INT8"
  /// - "INT16"
  /// - "INT32"
  /// - "INT64"
  /// - "UINT8"
  /// - "UINT16"
  /// - "UINT32"
  /// - "UINT64"
  core.String? dtype;

  /// FLOAT
  core.List<core.double>? floatVal;

  /// INT64
  core.List<core.String>? int64Val;

  /// INT_8 INT_16 INT_32
  core.List<core.int>? intVal;

  /// A list of tensor values.
  core.List<GoogleCloudAiplatformV1beta1Tensor>? listVal;

  /// Shape of the tensor.
  core.List<core.String>? shape;

  /// STRING
  core.List<core.String>? stringVal;

  /// A map of string to tensor.
  core.Map<core.String, GoogleCloudAiplatformV1beta1Tensor>? structVal;

  /// Serialized raw tensor content.
  core.String? tensorVal;
  core.List<core.int> get tensorValAsBytes => convert.base64.decode(tensorVal!);

  set tensorValAsBytes(core.List<core.int> bytes_) {
    tensorVal = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// UINT64
  core.List<core.String>? uint64Val;

  /// UINT8 UINT16 UINT32
  core.List<core.int>? uintVal;

  GoogleCloudAiplatformV1beta1Tensor({
    this.boolVal,
    this.bytesVal,
    this.doubleVal,
    this.dtype,
    this.floatVal,
    this.int64Val,
    this.intVal,
    this.listVal,
    this.shape,
    this.stringVal,
    this.structVal,
    this.tensorVal,
    this.uint64Val,
    this.uintVal,
  });

  GoogleCloudAiplatformV1beta1Tensor.fromJson(core.Map json_)
    : this(
        boolVal:
            (json_['boolVal'] as core.List?)
                ?.map((value) => value as core.bool)
                .toList(),
        bytesVal:
            (json_['bytesVal'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        doubleVal:
            (json_['doubleVal'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
        dtype: json_['dtype'] as core.String?,
        floatVal:
            (json_['floatVal'] as core.List?)
                ?.map((value) => (value as core.num).toDouble())
                .toList(),
        int64Val:
            (json_['int64Val'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        intVal:
            (json_['intVal'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
        listVal:
            (json_['listVal'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Tensor.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        shape:
            (json_['shape'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        stringVal:
            (json_['stringVal'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        structVal: (json_['structVal'] as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1Tensor.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        tensorVal: json_['tensorVal'] as core.String?,
        uint64Val:
            (json_['uint64Val'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        uintVal:
            (json_['uintVal'] as core.List?)
                ?.map((value) => value as core.int)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boolVal != null) 'boolVal': boolVal!,
    if (bytesVal != null) 'bytesVal': bytesVal!,
    if (doubleVal != null) 'doubleVal': doubleVal!,
    if (dtype != null) 'dtype': dtype!,
    if (floatVal != null) 'floatVal': floatVal!,
    if (int64Val != null) 'int64Val': int64Val!,
    if (intVal != null) 'intVal': intVal!,
    if (listVal != null) 'listVal': listVal!,
    if (shape != null) 'shape': shape!,
    if (stringVal != null) 'stringVal': stringVal!,
    if (structVal != null) 'structVal': structVal!,
    if (tensorVal != null) 'tensorVal': tensorVal!,
    if (uint64Val != null) 'uint64Val': uint64Val!,
    if (uintVal != null) 'uintVal': uintVal!,
  };
}

/// Tensorboard is a physical database that stores users' training metrics.
///
/// A default Tensorboard is provided in each region of a Google Cloud project.
/// If needed users can also create extra Tensorboards in their projects.
class GoogleCloudAiplatformV1beta1Tensorboard {
  /// Consumer project Cloud Storage path prefix used to store blob data, which
  /// can either be a bucket or directory.
  ///
  /// Does not end with a '/'.
  ///
  /// Output only.
  core.String? blobStoragePathPrefix;

  /// Timestamp when this Tensorboard was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this Tensorboard.
  core.String? description;

  /// User provided name of this Tensorboard.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Tensorboard.
  ///
  /// If set, this Tensorboard and all sub-resources of this Tensorboard will be
  /// secured by this key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Used to indicate if the TensorBoard instance is the default one.
  ///
  /// Each project & region can have at most one default TensorBoard instance.
  /// Creation of a default TensorBoard instance and updating an existing
  /// TensorBoard instance to be default will mark all other TensorBoard
  /// instances (if any) as non default.
  core.bool? isDefault;

  /// The labels with user-defined metadata to organize your Tensorboards.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Tensorboard (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  core.Map<core.String, core.String>? labels;

  /// Name of the Tensorboard.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  ///
  /// Output only.
  core.String? name;

  /// The number of Runs stored in this Tensorboard.
  ///
  /// Output only.
  core.int? runCount;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this Tensorboard was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1Tensorboard({
    this.blobStoragePathPrefix,
    this.createTime,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.isDefault,
    this.labels,
    this.name,
    this.runCount,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1Tensorboard.fromJson(core.Map json_)
    : this(
        blobStoragePathPrefix: json_['blobStoragePathPrefix'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        etag: json_['etag'] as core.String?,
        isDefault: json_['isDefault'] as core.bool?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        runCount: json_['runCount'] as core.int?,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobStoragePathPrefix != null)
      'blobStoragePathPrefix': blobStoragePathPrefix!,
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (etag != null) 'etag': etag!,
    if (isDefault != null) 'isDefault': isDefault!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (runCount != null) 'runCount': runCount!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// One blob (e.g, image, graph) viewable on a blob metric plot.
typedef GoogleCloudAiplatformV1beta1TensorboardBlob = $TensorboardBlob;

/// One point viewable on a blob metric plot, but mostly just a wrapper message
/// to work around repeated fields can't be used directly within `oneof` fields.
class GoogleCloudAiplatformV1beta1TensorboardBlobSequence {
  /// List of blobs contained within the sequence.
  core.List<GoogleCloudAiplatformV1beta1TensorboardBlob>? values;

  GoogleCloudAiplatformV1beta1TensorboardBlobSequence({this.values});

  GoogleCloudAiplatformV1beta1TensorboardBlobSequence.fromJson(core.Map json_)
    : this(
        values:
            (json_['values'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TensorboardBlob.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (values != null) 'values': values!,
  };
}

/// A TensorboardExperiment is a group of TensorboardRuns, that are typically
/// the results of a training job run, in a Tensorboard.
typedef GoogleCloudAiplatformV1beta1TensorboardExperiment =
    $TensorboardExperiment;

/// TensorboardRun maps to a specific execution of a training job with a given
/// set of hyperparameter values, model definition, dataset, etc
typedef GoogleCloudAiplatformV1beta1TensorboardRun = $TensorboardRun;

/// One point viewable on a tensor metric plot.
typedef GoogleCloudAiplatformV1beta1TensorboardTensor = $TensorboardTensor;

/// TensorboardTimeSeries maps to times series produced in training runs
class GoogleCloudAiplatformV1beta1TensorboardTimeSeries {
  /// Timestamp when this TensorboardTimeSeries was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardTimeSeries.
  core.String? description;

  /// User provided name of this TensorboardTimeSeries.
  ///
  /// This value should be unique among all TensorboardTimeSeries resources
  /// belonging to the same TensorboardRun resource (parent resource).
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Scalar, Tensor, or Blob metadata for this TensorboardTimeSeries.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1TensorboardTimeSeriesMetadata? metadata;

  /// Name of the TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? name;

  /// Data of the current plugin, with the size limited to 65KB.
  core.String? pluginData;
  core.List<core.int> get pluginDataAsBytes =>
      convert.base64.decode(pluginData!);

  set pluginDataAsBytes(core.List<core.int> bytes_) {
    pluginData = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Name of the plugin this time series pertain to.
  ///
  /// Such as Scalar, Tensor, Blob
  ///
  /// Immutable.
  core.String? pluginName;

  /// Timestamp when this TensorboardTimeSeries was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Type of TensorboardTimeSeries value.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "SCALAR" : Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  /// - "TENSOR" : Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  /// - "BLOB_SEQUENCE" : Used for TensorboardTimeSeries that is a list of blob
  /// sequences. E.g. set of sample images with labels over epochs/time.
  core.String? valueType;

  GoogleCloudAiplatformV1beta1TensorboardTimeSeries({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.metadata,
    this.name,
    this.pluginData,
    this.pluginName,
    this.updateTime,
    this.valueType,
  });

  GoogleCloudAiplatformV1beta1TensorboardTimeSeries.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        etag: json_['etag'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? GoogleCloudAiplatformV1beta1TensorboardTimeSeriesMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        pluginData: json_['pluginData'] as core.String?,
        pluginName: json_['pluginName'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
        valueType: json_['valueType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (etag != null) 'etag': etag!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (pluginData != null) 'pluginData': pluginData!,
    if (pluginName != null) 'pluginName': pluginName!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (valueType != null) 'valueType': valueType!,
  };
}

/// Describes metadata for a TensorboardTimeSeries.
typedef GoogleCloudAiplatformV1beta1TensorboardTimeSeriesMetadata =
    $TensorboardTimeSeriesMetadata;

/// The config for feature monitoring threshold.
typedef GoogleCloudAiplatformV1beta1ThresholdConfig = $ThresholdConfig;

/// All the data stored in a TensorboardTimeSeries.
class GoogleCloudAiplatformV1beta1TimeSeriesData {
  /// The ID of the TensorboardTimeSeries, which will become the final component
  /// of the TensorboardTimeSeries' resource name
  ///
  /// Required.
  core.String? tensorboardTimeSeriesId;

  /// The value type of this time series.
  ///
  /// All the values in this time series data must match this value type.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "SCALAR" : Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  /// - "TENSOR" : Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  /// - "BLOB_SEQUENCE" : Used for TensorboardTimeSeries that is a list of blob
  /// sequences. E.g. set of sample images with labels over epochs/time.
  core.String? valueType;

  /// Data points in this time series.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TimeSeriesDataPoint>? values;

  GoogleCloudAiplatformV1beta1TimeSeriesData({
    this.tensorboardTimeSeriesId,
    this.valueType,
    this.values,
  });

  GoogleCloudAiplatformV1beta1TimeSeriesData.fromJson(core.Map json_)
    : this(
        tensorboardTimeSeriesId:
            json_['tensorboardTimeSeriesId'] as core.String?,
        valueType: json_['valueType'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TimeSeriesDataPoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tensorboardTimeSeriesId != null)
      'tensorboardTimeSeriesId': tensorboardTimeSeriesId!,
    if (valueType != null) 'valueType': valueType!,
    if (values != null) 'values': values!,
  };
}

/// A TensorboardTimeSeries data point.
class GoogleCloudAiplatformV1beta1TimeSeriesDataPoint {
  /// A blob sequence value.
  GoogleCloudAiplatformV1beta1TensorboardBlobSequence? blobs;

  /// A scalar value.
  GoogleCloudAiplatformV1beta1Scalar? scalar;

  /// Step index of this data point within the run.
  core.String? step;

  /// A tensor value.
  GoogleCloudAiplatformV1beta1TensorboardTensor? tensor;

  /// Wall clock timestamp when this data point is generated by the end user.
  core.String? wallTime;

  GoogleCloudAiplatformV1beta1TimeSeriesDataPoint({
    this.blobs,
    this.scalar,
    this.step,
    this.tensor,
    this.wallTime,
  });

  GoogleCloudAiplatformV1beta1TimeSeriesDataPoint.fromJson(core.Map json_)
    : this(
        blobs:
            json_.containsKey('blobs')
                ? GoogleCloudAiplatformV1beta1TensorboardBlobSequence.fromJson(
                  json_['blobs'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        scalar:
            json_.containsKey('scalar')
                ? GoogleCloudAiplatformV1beta1Scalar.fromJson(
                  json_['scalar'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        step: json_['step'] as core.String?,
        tensor:
            json_.containsKey('tensor')
                ? GoogleCloudAiplatformV1beta1TensorboardTensor.fromJson(
                  json_['tensor'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        wallTime: json_['wallTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobs != null) 'blobs': blobs!,
    if (scalar != null) 'scalar': scalar!,
    if (step != null) 'step': step!,
    if (tensor != null) 'tensor': tensor!,
    if (wallTime != null) 'wallTime': wallTime!,
  };
}

/// Assigns input data to training, validation, and test sets based on a
/// provided timestamps.
///
/// The youngest data pieces are assigned to training set, next to validation
/// set, and the oldest to the test set. Supported only for tabular Datasets.
typedef GoogleCloudAiplatformV1beta1TimestampSplit = $TimestampSplit;

/// Tokens info with a list of tokens and the corresponding list of token ids.
typedef GoogleCloudAiplatformV1beta1TokensInfo = $TokensInfo;

/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with
/// external systems to perform an action, or set of actions, outside of
/// knowledge and scope of the model. A Tool object should contain exactly one
/// type of Tool (e.g FunctionDeclaration, Retrieval or GoogleSearchRetrieval).
class GoogleCloudAiplatformV1beta1Tool {
  /// CodeExecution tool type.
  ///
  /// Enables the model to execute code as part of generation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ToolCodeExecution? codeExecution;

  /// Tool to support searching public web data, powered by Vertex AI Search and
  /// Sec4 compliance.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1EnterpriseWebSearch? enterpriseWebSearch;

  /// Function tool type.
  ///
  /// One or more function declarations to be passed to the model along with the
  /// current user query. Model may decide to call a subset of these functions
  /// by populating FunctionCall in the response. User should provide a
  /// FunctionResponse for each function call in the next turn. Based on the
  /// function responses, Model will generate the final response back to the
  /// user. Maximum 512 function declarations can be provided.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1FunctionDeclaration>?
  functionDeclarations;

  /// GoogleMaps tool type.
  ///
  /// Tool to support Google Maps in Model.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GoogleMaps? googleMaps;

  /// GoogleSearch tool type.
  ///
  /// Tool to support Google Search in Model. Powered by Google.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1ToolGoogleSearch? googleSearch;

  /// GoogleSearchRetrieval tool type.
  ///
  /// Specialized retrieval tool that is powered by Google search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1GoogleSearchRetrieval? googleSearchRetrieval;

  /// Retrieval tool type.
  ///
  /// System will always execute the provided retrieval tool(s) to get external
  /// knowledge to answer the prompt. Retrieval results are presented to the
  /// model for generation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1Retrieval? retrieval;

  /// Tool to support URL context retrieval.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1UrlContext? urlContext;

  GoogleCloudAiplatformV1beta1Tool({
    this.codeExecution,
    this.enterpriseWebSearch,
    this.functionDeclarations,
    this.googleMaps,
    this.googleSearch,
    this.googleSearchRetrieval,
    this.retrieval,
    this.urlContext,
  });

  GoogleCloudAiplatformV1beta1Tool.fromJson(core.Map json_)
    : this(
        codeExecution:
            json_.containsKey('codeExecution')
                ? GoogleCloudAiplatformV1beta1ToolCodeExecution.fromJson(
                  json_['codeExecution'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        enterpriseWebSearch:
            json_.containsKey('enterpriseWebSearch')
                ? GoogleCloudAiplatformV1beta1EnterpriseWebSearch.fromJson(
                  json_['enterpriseWebSearch']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        functionDeclarations:
            (json_['functionDeclarations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1FunctionDeclaration.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        googleMaps:
            json_.containsKey('googleMaps')
                ? GoogleCloudAiplatformV1beta1GoogleMaps.fromJson(
                  json_['googleMaps'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        googleSearch:
            json_.containsKey('googleSearch')
                ? GoogleCloudAiplatformV1beta1ToolGoogleSearch.fromJson(
                  json_['googleSearch'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        googleSearchRetrieval:
            json_.containsKey('googleSearchRetrieval')
                ? GoogleCloudAiplatformV1beta1GoogleSearchRetrieval.fromJson(
                  json_['googleSearchRetrieval']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        retrieval:
            json_.containsKey('retrieval')
                ? GoogleCloudAiplatformV1beta1Retrieval.fromJson(
                  json_['retrieval'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        urlContext:
            json_.containsKey('urlContext')
                ? GoogleCloudAiplatformV1beta1UrlContext.fromJson(
                  json_['urlContext'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (codeExecution != null) 'codeExecution': codeExecution!,
    if (enterpriseWebSearch != null)
      'enterpriseWebSearch': enterpriseWebSearch!,
    if (functionDeclarations != null)
      'functionDeclarations': functionDeclarations!,
    if (googleMaps != null) 'googleMaps': googleMaps!,
    if (googleSearch != null) 'googleSearch': googleSearch!,
    if (googleSearchRetrieval != null)
      'googleSearchRetrieval': googleSearchRetrieval!,
    if (retrieval != null) 'retrieval': retrieval!,
    if (urlContext != null) 'urlContext': urlContext!,
  };
}

/// Spec for tool call.
typedef GoogleCloudAiplatformV1beta1ToolCall = $ToolCall00;

/// Input for tool call valid metric.
class GoogleCloudAiplatformV1beta1ToolCallValidInput {
  /// Repeated tool call valid instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ToolCallValidInstance>? instances;

  /// Spec for tool call valid metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ToolCallValidSpec? metricSpec;

  GoogleCloudAiplatformV1beta1ToolCallValidInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1ToolCallValidInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolCallValidInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1ToolCallValidSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for tool call valid instance.
typedef GoogleCloudAiplatformV1beta1ToolCallValidInstance = $Instance00;

/// Tool call valid metric value for an instance.
typedef GoogleCloudAiplatformV1beta1ToolCallValidMetricValue =
    $ToolCallValidMetricValue;

/// Results for tool call valid metric.
class GoogleCloudAiplatformV1beta1ToolCallValidResults {
  /// Tool call valid metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ToolCallValidMetricValue>?
  toolCallValidMetricValues;

  GoogleCloudAiplatformV1beta1ToolCallValidResults({
    this.toolCallValidMetricValues,
  });

  GoogleCloudAiplatformV1beta1ToolCallValidResults.fromJson(core.Map json_)
    : this(
        toolCallValidMetricValues:
            (json_['toolCallValidMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolCallValidMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (toolCallValidMetricValues != null)
      'toolCallValidMetricValues': toolCallValidMetricValues!,
  };
}

/// Spec for tool call valid metric.
typedef GoogleCloudAiplatformV1beta1ToolCallValidSpec = $Empty;

/// Tool that executes code generated by the model, and automatically returns
/// the result to the model.
///
/// See also \[ExecutableCode\]and \[CodeExecutionResult\] which are input and
/// output to this tool.
typedef GoogleCloudAiplatformV1beta1ToolCodeExecution = $Empty;

/// Tool config.
///
/// This config is shared for all tools provided in the request.
class GoogleCloudAiplatformV1beta1ToolConfig {
  /// Function calling config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1FunctionCallingConfig? functionCallingConfig;

  /// Retrieval config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RetrievalConfig? retrievalConfig;

  GoogleCloudAiplatformV1beta1ToolConfig({
    this.functionCallingConfig,
    this.retrievalConfig,
  });

  GoogleCloudAiplatformV1beta1ToolConfig.fromJson(core.Map json_)
    : this(
        functionCallingConfig:
            json_.containsKey('functionCallingConfig')
                ? GoogleCloudAiplatformV1beta1FunctionCallingConfig.fromJson(
                  json_['functionCallingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        retrievalConfig:
            json_.containsKey('retrievalConfig')
                ? GoogleCloudAiplatformV1beta1RetrievalConfig.fromJson(
                  json_['retrievalConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (functionCallingConfig != null)
      'functionCallingConfig': functionCallingConfig!,
    if (retrievalConfig != null) 'retrievalConfig': retrievalConfig!,
  };
}

/// GoogleSearch tool type.
///
/// Tool to support Google Search in Model. Powered by Google.
typedef GoogleCloudAiplatformV1beta1ToolGoogleSearch = $ToolGoogleSearch;

/// Input for tool name match metric.
class GoogleCloudAiplatformV1beta1ToolNameMatchInput {
  /// Repeated tool name match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ToolNameMatchInstance>? instances;

  /// Spec for tool name match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ToolNameMatchSpec? metricSpec;

  GoogleCloudAiplatformV1beta1ToolNameMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1ToolNameMatchInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolNameMatchInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1ToolNameMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for tool name match instance.
typedef GoogleCloudAiplatformV1beta1ToolNameMatchInstance = $Instance00;

/// Tool name match metric value for an instance.
typedef GoogleCloudAiplatformV1beta1ToolNameMatchMetricValue =
    $ToolNameMatchMetricValue;

/// Results for tool name match metric.
class GoogleCloudAiplatformV1beta1ToolNameMatchResults {
  /// Tool name match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ToolNameMatchMetricValue>?
  toolNameMatchMetricValues;

  GoogleCloudAiplatformV1beta1ToolNameMatchResults({
    this.toolNameMatchMetricValues,
  });

  GoogleCloudAiplatformV1beta1ToolNameMatchResults.fromJson(core.Map json_)
    : this(
        toolNameMatchMetricValues:
            (json_['toolNameMatchMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolNameMatchMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (toolNameMatchMetricValues != null)
      'toolNameMatchMetricValues': toolNameMatchMetricValues!,
  };
}

/// Spec for tool name match metric.
typedef GoogleCloudAiplatformV1beta1ToolNameMatchSpec = $Empty;

/// Input for tool parameter key value match metric.
class GoogleCloudAiplatformV1beta1ToolParameterKVMatchInput {
  /// Repeated tool parameter key value match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ToolParameterKVMatchInstance>?
  instances;

  /// Spec for tool parameter key value match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ToolParameterKVMatchSpec? metricSpec;

  GoogleCloudAiplatformV1beta1ToolParameterKVMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1ToolParameterKVMatchInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolParameterKVMatchInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1ToolParameterKVMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for tool parameter key value match instance.
typedef GoogleCloudAiplatformV1beta1ToolParameterKVMatchInstance = $Instance00;

/// Tool parameter key value match metric value for an instance.
typedef GoogleCloudAiplatformV1beta1ToolParameterKVMatchMetricValue =
    $ToolParameterKVMatchMetricValue;

/// Results for tool parameter key value match metric.
class GoogleCloudAiplatformV1beta1ToolParameterKVMatchResults {
  /// Tool parameter key value match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ToolParameterKVMatchMetricValue>?
  toolParameterKvMatchMetricValues;

  GoogleCloudAiplatformV1beta1ToolParameterKVMatchResults({
    this.toolParameterKvMatchMetricValues,
  });

  GoogleCloudAiplatformV1beta1ToolParameterKVMatchResults.fromJson(
    core.Map json_,
  ) : this(
        toolParameterKvMatchMetricValues:
            (json_['toolParameterKvMatchMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolParameterKVMatchMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (toolParameterKvMatchMetricValues != null)
      'toolParameterKvMatchMetricValues': toolParameterKvMatchMetricValues!,
  };
}

/// Spec for tool parameter key value match metric.
typedef GoogleCloudAiplatformV1beta1ToolParameterKVMatchSpec =
    $ToolParameterKVMatchSpec;

/// Input for tool parameter key match metric.
class GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInput {
  /// Repeated tool parameter key match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInstance>?
  instances;

  /// Spec for tool parameter key match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1ToolParameterKeyMatchSpec? metricSpec;

  GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInput.fromJson(
    core.Map json_,
  ) : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1ToolParameterKeyMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for tool parameter key match instance.
typedef GoogleCloudAiplatformV1beta1ToolParameterKeyMatchInstance = $Instance00;

/// Tool parameter key match metric value for an instance.
typedef GoogleCloudAiplatformV1beta1ToolParameterKeyMatchMetricValue =
    $ToolParameterKeyMatchMetricValue;

/// Results for tool parameter key match metric.
class GoogleCloudAiplatformV1beta1ToolParameterKeyMatchResults {
  /// Tool parameter key match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1ToolParameterKeyMatchMetricValue>?
  toolParameterKeyMatchMetricValues;

  GoogleCloudAiplatformV1beta1ToolParameterKeyMatchResults({
    this.toolParameterKeyMatchMetricValues,
  });

  GoogleCloudAiplatformV1beta1ToolParameterKeyMatchResults.fromJson(
    core.Map json_,
  ) : this(
        toolParameterKeyMatchMetricValues:
            (json_['toolParameterKeyMatchMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1ToolParameterKeyMatchMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (toolParameterKeyMatchMetricValues != null)
      'toolParameterKeyMatchMetricValues': toolParameterKeyMatchMetricValues!,
  };
}

/// Spec for tool parameter key match metric.
typedef GoogleCloudAiplatformV1beta1ToolParameterKeyMatchSpec = $Empty;

/// A single example of the tool usage.
class GoogleCloudAiplatformV1beta1ToolUseExample {
  /// The display name for example.
  ///
  /// Required.
  core.String? displayName;

  /// Extension operation to call.
  GoogleCloudAiplatformV1beta1ToolUseExampleExtensionOperation?
  extensionOperation;

  /// Function name to call.
  core.String? functionName;

  /// Query that should be routed to this tool.
  ///
  /// Required.
  core.String? query;

  /// Request parameters used for executing this tool.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? requestParams;

  /// Response parameters generated by this tool.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? responseParams;

  /// Summary of the tool response to the user query.
  core.String? responseSummary;

  GoogleCloudAiplatformV1beta1ToolUseExample({
    this.displayName,
    this.extensionOperation,
    this.functionName,
    this.query,
    this.requestParams,
    this.responseParams,
    this.responseSummary,
  });

  GoogleCloudAiplatformV1beta1ToolUseExample.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        extensionOperation:
            json_.containsKey('extensionOperation')
                ? GoogleCloudAiplatformV1beta1ToolUseExampleExtensionOperation.fromJson(
                  json_['extensionOperation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        functionName: json_['functionName'] as core.String?,
        query: json_['query'] as core.String?,
        requestParams:
            json_.containsKey('requestParams')
                ? json_['requestParams'] as core.Map<core.String, core.dynamic>
                : null,
        responseParams:
            json_.containsKey('responseParams')
                ? json_['responseParams'] as core.Map<core.String, core.dynamic>
                : null,
        responseSummary: json_['responseSummary'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (extensionOperation != null) 'extensionOperation': extensionOperation!,
    if (functionName != null) 'functionName': functionName!,
    if (query != null) 'query': query!,
    if (requestParams != null) 'requestParams': requestParams!,
    if (responseParams != null) 'responseParams': responseParams!,
    if (responseSummary != null) 'responseSummary': responseSummary!,
  };
}

/// Identifies one operation of the extension.
class GoogleCloudAiplatformV1beta1ToolUseExampleExtensionOperation {
  /// Resource name of the extension.
  core.String? extension;

  /// Operation ID of the extension.
  ///
  /// Required.
  core.String? operationId;

  GoogleCloudAiplatformV1beta1ToolUseExampleExtensionOperation({
    this.extension,
    this.operationId,
  });

  GoogleCloudAiplatformV1beta1ToolUseExampleExtensionOperation.fromJson(
    core.Map json_,
  ) : this(
        extension: json_['extension'] as core.String?,
        operationId: json_['operationId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (extension != null) 'extension': extension!,
    if (operationId != null) 'operationId': operationId!,
  };
}

/// CMLE training config.
///
/// For every active learning labeling iteration, system will train a machine
/// learning model on CMLE. The trained model will be used by data sampling
/// algorithm to select DataItems.
typedef GoogleCloudAiplatformV1beta1TrainingConfig = $TrainingConfig;

/// The TrainingPipeline orchestrates tasks associated with training a Model.
///
/// It always executes the training task, and optionally may also export data
/// from Vertex AI's Dataset which becomes the training input, upload the Model
/// to Vertex AI, and evaluate the Model.
class GoogleCloudAiplatformV1beta1TrainingPipeline {
  /// Time when the TrainingPipeline was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of this TrainingPipeline.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a TrainingPipeline.
  ///
  /// If set, this TrainingPipeline will be secured by this key. Note: Model
  /// trained by this TrainingPipeline is also secured by this key if
  /// model_to_upload is not set separately.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Time when the TrainingPipeline entered any of the following states:
  /// `PIPELINE_STATE_SUCCEEDED`, `PIPELINE_STATE_FAILED`,
  /// `PIPELINE_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when the pipeline's state is `PIPELINE_STATE_FAILED` or
  /// `PIPELINE_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Specifies Vertex AI owned input data that may be used for training the
  /// Model.
  ///
  /// The TrainingPipeline's training_task_definition should make clear whether
  /// this config is used and if there are any special requirements on how it
  /// should be filled. If nothing about this config is mentioned in the
  /// training_task_definition, then it should be assumed that the
  /// TrainingPipeline does not depend on this configuration.
  GoogleCloudAiplatformV1beta1InputDataConfig? inputDataConfig;

  /// The labels with user-defined metadata to organize TrainingPipelines.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// Describes the Model that may be uploaded (via ModelService.UploadModel) by
  /// this TrainingPipeline.
  ///
  /// The TrainingPipeline's training_task_definition should make clear whether
  /// this Model description should be populated, and if there are any special
  /// requirements regarding how it should be filled. If nothing is mentioned in
  /// the training_task_definition, then it should be assumed that this field
  /// should not be filled and the training task either uploads the Model
  /// without a need of this information, or that training task does not support
  /// uploading a Model as part of the pipeline. When the Pipeline's state
  /// becomes `PIPELINE_STATE_SUCCEEDED` and the trained Model had been uploaded
  /// into Vertex AI, then the model_to_upload's resource name is populated. The
  /// Model is always uploaded into the Project and Location in which this
  /// pipeline is.
  GoogleCloudAiplatformV1beta1Model? modelToUpload;

  /// Resource name of the TrainingPipeline.
  ///
  /// Output only.
  core.String? name;

  /// When specify this field, the `model_to_upload` will not be uploaded as a
  /// new model, instead, it will become a new version of this `parent_model`.
  ///
  /// Optional.
  core.String? parentModel;

  /// Time when the TrainingPipeline for the first time entered the
  /// `PIPELINE_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the pipeline.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PIPELINE_STATE_UNSPECIFIED" : The pipeline state is unspecified.
  /// - "PIPELINE_STATE_QUEUED" : The pipeline has been created or resumed, and
  /// processing has not yet begun.
  /// - "PIPELINE_STATE_PENDING" : The service is preparing to run the pipeline.
  /// - "PIPELINE_STATE_RUNNING" : The pipeline is in progress.
  /// - "PIPELINE_STATE_SUCCEEDED" : The pipeline completed successfully.
  /// - "PIPELINE_STATE_FAILED" : The pipeline failed.
  /// - "PIPELINE_STATE_CANCELLING" : The pipeline is being cancelled. From this
  /// state, the pipeline may only go to either PIPELINE_STATE_SUCCEEDED,
  /// PIPELINE_STATE_FAILED or PIPELINE_STATE_CANCELLED.
  /// - "PIPELINE_STATE_CANCELLED" : The pipeline has been cancelled.
  /// - "PIPELINE_STATE_PAUSED" : The pipeline has been stopped, and can be
  /// resumed.
  core.String? state;

  /// A Google Cloud Storage path to the YAML file that defines the training
  /// task which is responsible for producing the model artifact, and may also
  /// include additional auxiliary work.
  ///
  /// The definition files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/trainingjob/definition/. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Required.
  core.String? trainingTaskDefinition;

  /// The training task's parameter(s), as specified in the
  /// training_task_definition's `inputs`.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? trainingTaskInputs;

  /// The metadata information as specified in the training_task_definition's
  /// `metadata`.
  ///
  /// This metadata is an auxiliary runtime and final information about the
  /// training task. While the pipeline is running this information is populated
  /// only at a best effort basis. Only present if the pipeline's
  /// training_task_definition contains `metadata` object.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? trainingTaskMetadata;

  /// Time when the TrainingPipeline was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1beta1TrainingPipeline({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.inputDataConfig,
    this.labels,
    this.modelId,
    this.modelToUpload,
    this.name,
    this.parentModel,
    this.startTime,
    this.state,
    this.trainingTaskDefinition,
    this.trainingTaskInputs,
    this.trainingTaskMetadata,
    this.updateTime,
  });

  GoogleCloudAiplatformV1beta1TrainingPipeline.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inputDataConfig:
            json_.containsKey('inputDataConfig')
                ? GoogleCloudAiplatformV1beta1InputDataConfig.fromJson(
                  json_['inputDataConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        modelId: json_['modelId'] as core.String?,
        modelToUpload:
            json_.containsKey('modelToUpload')
                ? GoogleCloudAiplatformV1beta1Model.fromJson(
                  json_['modelToUpload'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        parentModel: json_['parentModel'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        trainingTaskDefinition: json_['trainingTaskDefinition'] as core.String?,
        trainingTaskInputs: json_['trainingTaskInputs'],
        trainingTaskMetadata: json_['trainingTaskMetadata'],
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (displayName != null) 'displayName': displayName!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (inputDataConfig != null) 'inputDataConfig': inputDataConfig!,
    if (labels != null) 'labels': labels!,
    if (modelId != null) 'modelId': modelId!,
    if (modelToUpload != null) 'modelToUpload': modelToUpload!,
    if (name != null) 'name': name!,
    if (parentModel != null) 'parentModel': parentModel!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (trainingTaskDefinition != null)
      'trainingTaskDefinition': trainingTaskDefinition!,
    if (trainingTaskInputs != null) 'trainingTaskInputs': trainingTaskInputs!,
    if (trainingTaskMetadata != null)
      'trainingTaskMetadata': trainingTaskMetadata!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Spec for trajectory.
class GoogleCloudAiplatformV1beta1Trajectory {
  /// Tool calls in the trajectory.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1ToolCall>? toolCalls;

  GoogleCloudAiplatformV1beta1Trajectory({this.toolCalls});

  GoogleCloudAiplatformV1beta1Trajectory.fromJson(core.Map json_)
    : this(
        toolCalls:
            (json_['toolCalls'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1ToolCall.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (toolCalls != null) 'toolCalls': toolCalls!,
  };
}

/// Instances and metric spec for TrajectoryAnyOrderMatch metric.
class GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInput {
  /// Repeated TrajectoryAnyOrderMatch instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInstance>?
  instances;

  /// Spec for TrajectoryAnyOrderMatch metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchSpec? metricSpec;

  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInput.fromJson(
    core.Map json_,
  ) : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for TrajectoryAnyOrderMatch instance.
class GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchInstance.fromJson(
    core.Map json_,
  ) : this(
        predictedTrajectory:
            json_.containsKey('predictedTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        referenceTrajectory:
            json_.containsKey('referenceTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!,
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!,
  };
}

/// TrajectoryAnyOrderMatch metric value for an instance.
typedef GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchMetricValue =
    $TrajectoryAnyOrderMatchMetricValue;

/// Results for TrajectoryAnyOrderMatch metric.
class GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchResults {
  /// TrajectoryAnyOrderMatch metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchMetricValue>?
  trajectoryAnyOrderMatchMetricValues;

  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchResults({
    this.trajectoryAnyOrderMatchMetricValues,
  });

  GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchResults.fromJson(
    core.Map json_,
  ) : this(
        trajectoryAnyOrderMatchMetricValues:
            (json_['trajectoryAnyOrderMatchMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (trajectoryAnyOrderMatchMetricValues != null)
      'trajectoryAnyOrderMatchMetricValues':
          trajectoryAnyOrderMatchMetricValues!,
  };
}

/// Spec for TrajectoryAnyOrderMatch metric - returns 1 if all tool calls in the
/// reference trajectory appear in the predicted trajectory in any order, else
/// 0.
typedef GoogleCloudAiplatformV1beta1TrajectoryAnyOrderMatchSpec = $Empty;

/// Instances and metric spec for TrajectoryExactMatch metric.
class GoogleCloudAiplatformV1beta1TrajectoryExactMatchInput {
  /// Repeated TrajectoryExactMatch instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryExactMatchInstance>?
  instances;

  /// Spec for TrajectoryExactMatch metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TrajectoryExactMatchSpec? metricSpec;

  GoogleCloudAiplatformV1beta1TrajectoryExactMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1TrajectoryExactMatchInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryExactMatchInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1TrajectoryExactMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for TrajectoryExactMatch instance.
class GoogleCloudAiplatformV1beta1TrajectoryExactMatchInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1beta1TrajectoryExactMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1beta1TrajectoryExactMatchInstance.fromJson(
    core.Map json_,
  ) : this(
        predictedTrajectory:
            json_.containsKey('predictedTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        referenceTrajectory:
            json_.containsKey('referenceTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!,
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!,
  };
}

/// TrajectoryExactMatch metric value for an instance.
typedef GoogleCloudAiplatformV1beta1TrajectoryExactMatchMetricValue =
    $TrajectoryExactMatchMetricValue;

/// Results for TrajectoryExactMatch metric.
class GoogleCloudAiplatformV1beta1TrajectoryExactMatchResults {
  /// TrajectoryExactMatch metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryExactMatchMetricValue>?
  trajectoryExactMatchMetricValues;

  GoogleCloudAiplatformV1beta1TrajectoryExactMatchResults({
    this.trajectoryExactMatchMetricValues,
  });

  GoogleCloudAiplatformV1beta1TrajectoryExactMatchResults.fromJson(
    core.Map json_,
  ) : this(
        trajectoryExactMatchMetricValues:
            (json_['trajectoryExactMatchMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryExactMatchMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (trajectoryExactMatchMetricValues != null)
      'trajectoryExactMatchMetricValues': trajectoryExactMatchMetricValues!,
  };
}

/// Spec for TrajectoryExactMatch metric - returns 1 if tool calls in the
/// reference trajectory exactly match the predicted trajectory, else 0.
typedef GoogleCloudAiplatformV1beta1TrajectoryExactMatchSpec = $Empty;

/// Instances and metric spec for TrajectoryInOrderMatch metric.
class GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInput {
  /// Repeated TrajectoryInOrderMatch instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInstance>?
  instances;

  /// Spec for TrajectoryInOrderMatch metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchSpec? metricSpec;

  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInput.fromJson(
    core.Map json_,
  ) : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for TrajectoryInOrderMatch instance.
class GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchInstance.fromJson(
    core.Map json_,
  ) : this(
        predictedTrajectory:
            json_.containsKey('predictedTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        referenceTrajectory:
            json_.containsKey('referenceTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!,
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!,
  };
}

/// TrajectoryInOrderMatch metric value for an instance.
typedef GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchMetricValue =
    $TrajectoryInOrderMatchMetricValue;

/// Results for TrajectoryInOrderMatch metric.
class GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchResults {
  /// TrajectoryInOrderMatch metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchMetricValue>?
  trajectoryInOrderMatchMetricValues;

  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchResults({
    this.trajectoryInOrderMatchMetricValues,
  });

  GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchResults.fromJson(
    core.Map json_,
  ) : this(
        trajectoryInOrderMatchMetricValues:
            (json_['trajectoryInOrderMatchMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (trajectoryInOrderMatchMetricValues != null)
      'trajectoryInOrderMatchMetricValues': trajectoryInOrderMatchMetricValues!,
  };
}

/// Spec for TrajectoryInOrderMatch metric - returns 1 if tool calls in the
/// reference trajectory appear in the predicted trajectory in the same order,
/// else 0.
typedef GoogleCloudAiplatformV1beta1TrajectoryInOrderMatchSpec = $Empty;

/// Instances and metric spec for TrajectoryPrecision metric.
class GoogleCloudAiplatformV1beta1TrajectoryPrecisionInput {
  /// Repeated TrajectoryPrecision instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryPrecisionInstance>? instances;

  /// Spec for TrajectoryPrecision metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TrajectoryPrecisionSpec? metricSpec;

  GoogleCloudAiplatformV1beta1TrajectoryPrecisionInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1TrajectoryPrecisionInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryPrecisionInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1TrajectoryPrecisionSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for TrajectoryPrecision instance.
class GoogleCloudAiplatformV1beta1TrajectoryPrecisionInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1beta1TrajectoryPrecisionInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1beta1TrajectoryPrecisionInstance.fromJson(
    core.Map json_,
  ) : this(
        predictedTrajectory:
            json_.containsKey('predictedTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        referenceTrajectory:
            json_.containsKey('referenceTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!,
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!,
  };
}

/// TrajectoryPrecision metric value for an instance.
typedef GoogleCloudAiplatformV1beta1TrajectoryPrecisionMetricValue =
    $TrajectoryPrecisionMetricValue;

/// Results for TrajectoryPrecision metric.
class GoogleCloudAiplatformV1beta1TrajectoryPrecisionResults {
  /// TrajectoryPrecision metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryPrecisionMetricValue>?
  trajectoryPrecisionMetricValues;

  GoogleCloudAiplatformV1beta1TrajectoryPrecisionResults({
    this.trajectoryPrecisionMetricValues,
  });

  GoogleCloudAiplatformV1beta1TrajectoryPrecisionResults.fromJson(
    core.Map json_,
  ) : this(
        trajectoryPrecisionMetricValues:
            (json_['trajectoryPrecisionMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryPrecisionMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (trajectoryPrecisionMetricValues != null)
      'trajectoryPrecisionMetricValues': trajectoryPrecisionMetricValues!,
  };
}

/// Spec for TrajectoryPrecision metric - returns a float score based on average
/// precision of individual tool calls.
typedef GoogleCloudAiplatformV1beta1TrajectoryPrecisionSpec = $Empty;

/// Instances and metric spec for TrajectoryRecall metric.
class GoogleCloudAiplatformV1beta1TrajectoryRecallInput {
  /// Repeated TrajectoryRecall instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryRecallInstance>? instances;

  /// Spec for TrajectoryRecall metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TrajectoryRecallSpec? metricSpec;

  GoogleCloudAiplatformV1beta1TrajectoryRecallInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1TrajectoryRecallInput.fromJson(core.Map json_)
    : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryRecallInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1TrajectoryRecallSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for TrajectoryRecall instance.
class GoogleCloudAiplatformV1beta1TrajectoryRecallInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1beta1TrajectoryRecallInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1beta1TrajectoryRecallInstance.fromJson(core.Map json_)
    : this(
        predictedTrajectory:
            json_.containsKey('predictedTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        referenceTrajectory:
            json_.containsKey('referenceTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!,
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!,
  };
}

/// TrajectoryRecall metric value for an instance.
typedef GoogleCloudAiplatformV1beta1TrajectoryRecallMetricValue =
    $TrajectoryRecallMetricValue;

/// Results for TrajectoryRecall metric.
class GoogleCloudAiplatformV1beta1TrajectoryRecallResults {
  /// TrajectoryRecall metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TrajectoryRecallMetricValue>?
  trajectoryRecallMetricValues;

  GoogleCloudAiplatformV1beta1TrajectoryRecallResults({
    this.trajectoryRecallMetricValues,
  });

  GoogleCloudAiplatformV1beta1TrajectoryRecallResults.fromJson(core.Map json_)
    : this(
        trajectoryRecallMetricValues:
            (json_['trajectoryRecallMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectoryRecallMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (trajectoryRecallMetricValues != null)
      'trajectoryRecallMetricValues': trajectoryRecallMetricValues!,
  };
}

/// Spec for TrajectoryRecall metric - returns a float score based on average
/// recall of individual tool calls.
typedef GoogleCloudAiplatformV1beta1TrajectoryRecallSpec = $Empty;

/// Instances and metric spec for TrajectorySingleToolUse metric.
class GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInput {
  /// Repeated TrajectorySingleToolUse instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInstance>?
  instances;

  /// Spec for TrajectorySingleToolUse metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseSpec? metricSpec;

  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInput.fromJson(
    core.Map json_,
  ) : this(
        instances:
            (json_['instances'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInstance.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        metricSpec:
            json_.containsKey('metricSpec')
                ? GoogleCloudAiplatformV1beta1TrajectorySingleToolUseSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (instances != null) 'instances': instances!,
    if (metricSpec != null) 'metricSpec': metricSpec!,
  };
}

/// Spec for TrajectorySingleToolUse instance.
class GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Trajectory? predictedTrajectory;

  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInstance({
    this.predictedTrajectory,
  });

  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseInstance.fromJson(
    core.Map json_,
  ) : this(
        predictedTrajectory:
            json_.containsKey('predictedTrajectory')
                ? GoogleCloudAiplatformV1beta1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!,
  };
}

/// TrajectorySingleToolUse metric value for an instance.
typedef GoogleCloudAiplatformV1beta1TrajectorySingleToolUseMetricValue =
    $TrajectorySingleToolUseMetricValue;

/// Results for TrajectorySingleToolUse metric.
class GoogleCloudAiplatformV1beta1TrajectorySingleToolUseResults {
  /// TrajectorySingleToolUse metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TrajectorySingleToolUseMetricValue>?
  trajectorySingleToolUseMetricValues;

  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseResults({
    this.trajectorySingleToolUseMetricValues,
  });

  GoogleCloudAiplatformV1beta1TrajectorySingleToolUseResults.fromJson(
    core.Map json_,
  ) : this(
        trajectorySingleToolUseMetricValues:
            (json_['trajectorySingleToolUseMetricValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrajectorySingleToolUseMetricValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (trajectorySingleToolUseMetricValues != null)
      'trajectorySingleToolUseMetricValues':
          trajectorySingleToolUseMetricValues!,
  };
}

/// Spec for TrajectorySingleToolUse metric - returns 1 if tool is present in
/// the predicted trajectory, else 0.
typedef GoogleCloudAiplatformV1beta1TrajectorySingleToolUseSpec =
    $TrajectorySingleToolUseSpec;

/// A message representing a Trial.
///
/// A Trial contains a unique set of Parameters that has been or will be
/// evaluated, along with the objective metrics got by running the Trial.
class GoogleCloudAiplatformV1beta1Trial {
  /// The identifier of the client that originally requested this Trial.
  ///
  /// Each client is identified by a unique client_id. When a client asks for a
  /// suggestion, Vertex AI Vizier will assign it a Trial. The client should
  /// evaluate the Trial, complete it, and report back to Vertex AI Vizier. If
  /// suggestion is asked again by same client_id before the Trial is completed,
  /// the same Trial will be returned. Multiple clients with different
  /// client_ids can ask for suggestions simultaneously, each of them will get
  /// their own Trial.
  ///
  /// Output only.
  core.String? clientId;

  /// The CustomJob name linked to the Trial.
  ///
  /// It's set for a HyperparameterTuningJob's Trial.
  ///
  /// Output only.
  core.String? customJob;

  /// Time when the Trial's status changed to `SUCCEEDED` or `INFEASIBLE`.
  ///
  /// Output only.
  core.String? endTime;

  /// The final measurement containing the objective value.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1Measurement? finalMeasurement;

  /// The identifier of the Trial assigned by the service.
  ///
  /// Output only.
  core.String? id;

  /// A human readable string describing why the Trial is infeasible.
  ///
  /// This is set only if Trial state is `INFEASIBLE`.
  ///
  /// Output only.
  core.String? infeasibleReason;

  /// A list of measurements that are strictly lexicographically ordered by
  /// their induced tuples (steps, elapsed_duration).
  ///
  /// These are used for early stopping computations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1Measurement>? measurements;

  /// Resource name of the Trial assigned by the service.
  ///
  /// Output only.
  core.String? name;

  /// The parameters of the Trial.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TrialParameter>? parameters;

  /// Time when the Trial was started.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the Trial.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The Trial state is unspecified.
  /// - "REQUESTED" : Indicates that a specific Trial has been requested, but it
  /// has not yet been suggested by the service.
  /// - "ACTIVE" : Indicates that the Trial has been suggested.
  /// - "STOPPING" : Indicates that the Trial should stop according to the
  /// service.
  /// - "SUCCEEDED" : Indicates that the Trial is completed successfully.
  /// - "INFEASIBLE" : Indicates that the Trial should not be attempted again.
  /// The service will set a Trial to INFEASIBLE when it's done but missing the
  /// final_measurement.
  core.String? state;

  /// URIs for accessing
  /// [interactive shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node).
  ///
  /// Only available if this trial is part of a HyperparameterTuningJob and the
  /// job's trial_job_spec.enable_web_access field is `true`. The keys are names
  /// of each node used for the trial; for example, `workerpool0-0` for the
  /// primary node, `workerpool1-0` for the first node in the second worker
  /// pool, and `workerpool1-1` for the second node in the second worker pool.
  /// The values are the URIs for each node's interactive shell.
  ///
  /// Output only.
  core.Map<core.String, core.String>? webAccessUris;

  GoogleCloudAiplatformV1beta1Trial({
    this.clientId,
    this.customJob,
    this.endTime,
    this.finalMeasurement,
    this.id,
    this.infeasibleReason,
    this.measurements,
    this.name,
    this.parameters,
    this.startTime,
    this.state,
    this.webAccessUris,
  });

  GoogleCloudAiplatformV1beta1Trial.fromJson(core.Map json_)
    : this(
        clientId: json_['clientId'] as core.String?,
        customJob: json_['customJob'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        finalMeasurement:
            json_.containsKey('finalMeasurement')
                ? GoogleCloudAiplatformV1beta1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        id: json_['id'] as core.String?,
        infeasibleReason: json_['infeasibleReason'] as core.String?,
        measurements:
            (json_['measurements'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Measurement.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        name: json_['name'] as core.String?,
        parameters:
            (json_['parameters'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrialParameter.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        webAccessUris: (json_['webAccessUris']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (clientId != null) 'clientId': clientId!,
    if (customJob != null) 'customJob': customJob!,
    if (endTime != null) 'endTime': endTime!,
    if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
    if (id != null) 'id': id!,
    if (infeasibleReason != null) 'infeasibleReason': infeasibleReason!,
    if (measurements != null) 'measurements': measurements!,
    if (name != null) 'name': name!,
    if (parameters != null) 'parameters': parameters!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (webAccessUris != null) 'webAccessUris': webAccessUris!,
  };
}

class GoogleCloudAiplatformV1beta1TrialContext {
  /// A human-readable field which can store a description of this context.
  ///
  /// This will become part of the resulting Trial's description field.
  core.String? description;

  /// If/when a Trial is generated or selected from this Context, its Parameters
  /// will match any parameters specified here.
  ///
  /// (I.e. if this context specifies parameter name:'a' int_value:3, then a
  /// resulting Trial will have int_value:3 for its parameter named 'a'.) Note
  /// that we first attempt to match existing REQUESTED Trials with contexts,
  /// and if there are no matches, we generate suggestions in the subspace
  /// defined by the parameters specified here. NOTE: a Context without any
  /// Parameters matches the entire feasible search space.
  core.List<GoogleCloudAiplatformV1beta1TrialParameter>? parameters;

  GoogleCloudAiplatformV1beta1TrialContext({this.description, this.parameters});

  GoogleCloudAiplatformV1beta1TrialContext.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        parameters:
            (json_['parameters'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TrialParameter.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (parameters != null) 'parameters': parameters!,
  };
}

/// A message representing a parameter to be tuned.
typedef GoogleCloudAiplatformV1beta1TrialParameter = $TrialParameter;

/// The Model Registry Model and Online Prediction Endpoint associated with this
/// TuningJob.
class GoogleCloudAiplatformV1beta1TunedModel {
  /// The checkpoints associated with this TunedModel.
  ///
  /// This field is only populated for tuning jobs that enable intermediate
  /// checkpoints.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1TunedModelCheckpoint>? checkpoints;

  /// A resource name of an Endpoint.
  ///
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`.
  ///
  /// Output only.
  core.String? endpoint;

  /// The resource name of the TunedModel.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}@{version_id}` When
  /// tuning from a base model, the version_id will be 1. For continuous tuning,
  /// the version id will be incremented by 1 from the last version id in the
  /// parent model. E.g.,
  /// `projects/{project}/locations/{location}/models/{model}@{last_version_id +
  /// 1}`
  ///
  /// Output only.
  core.String? model;

  GoogleCloudAiplatformV1beta1TunedModel({
    this.checkpoints,
    this.endpoint,
    this.model,
  });

  GoogleCloudAiplatformV1beta1TunedModel.fromJson(core.Map json_)
    : this(
        checkpoints:
            (json_['checkpoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TunedModelCheckpoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        endpoint: json_['endpoint'] as core.String?,
        model: json_['model'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checkpoints != null) 'checkpoints': checkpoints!,
    if (endpoint != null) 'endpoint': endpoint!,
    if (model != null) 'model': model!,
  };
}

/// TunedModelCheckpoint for the Tuned Model of a Tuning Job.
typedef GoogleCloudAiplatformV1beta1TunedModelCheckpoint =
    $TunedModelCheckpoint;

/// TunedModel Reference for legacy model migration.
typedef GoogleCloudAiplatformV1beta1TunedModelRef = $TunedModelRef;

/// The tuning data statistic values for TuningJob.
class GoogleCloudAiplatformV1beta1TuningDataStats {
  /// Statistics for distillation.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1DistillationDataStats? distillationDataStats;

  /// Statistics for preference optimization.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1PreferenceOptimizationDataStats?
  preferenceOptimizationDataStats;

  /// The SFT Tuning data stats.
  GoogleCloudAiplatformV1beta1SupervisedTuningDataStats?
  supervisedTuningDataStats;

  GoogleCloudAiplatformV1beta1TuningDataStats({
    this.distillationDataStats,
    this.preferenceOptimizationDataStats,
    this.supervisedTuningDataStats,
  });

  GoogleCloudAiplatformV1beta1TuningDataStats.fromJson(core.Map json_)
    : this(
        distillationDataStats:
            json_.containsKey('distillationDataStats')
                ? GoogleCloudAiplatformV1beta1DistillationDataStats.fromJson(
                  json_['distillationDataStats']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        preferenceOptimizationDataStats:
            json_.containsKey('preferenceOptimizationDataStats')
                ? GoogleCloudAiplatformV1beta1PreferenceOptimizationDataStats.fromJson(
                  json_['preferenceOptimizationDataStats']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        supervisedTuningDataStats:
            json_.containsKey('supervisedTuningDataStats')
                ? GoogleCloudAiplatformV1beta1SupervisedTuningDataStats.fromJson(
                  json_['supervisedTuningDataStats']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (distillationDataStats != null)
      'distillationDataStats': distillationDataStats!,
    if (preferenceOptimizationDataStats != null)
      'preferenceOptimizationDataStats': preferenceOptimizationDataStats!,
    if (supervisedTuningDataStats != null)
      'supervisedTuningDataStats': supervisedTuningDataStats!,
  };
}

/// Represents a TuningJob that runs with Google owned models.
class GoogleCloudAiplatformV1beta1TuningJob {
  /// The base model that is being tuned.
  ///
  /// See
  /// [Supported models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/tuning#supported_models).
  core.String? baseModel;

  /// Time when the TuningJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-provided path to custom model weights.
  ///
  /// Set this field to tune a custom model. The path must be a Cloud Storage
  /// directory that contains the model weights in .safetensors format along
  /// with associated model metadata files. If this field is set, the base_model
  /// field must still be set to indicate which base model the custom model is
  /// derived from. This feature is only available for open source models.
  ///
  /// Optional.
  core.String? customBaseModel;

  /// The description of the TuningJob.
  ///
  /// Optional.
  core.String? description;

  /// Tuning Spec for Distillation.
  GoogleCloudAiplatformV1beta1DistillationSpec? distillationSpec;

  /// Customer-managed encryption key options for a TuningJob.
  ///
  /// If this is set, then all resources created by the TuningJob will be
  /// encrypted with the provided encryption key.
  GoogleCloudAiplatformV1beta1EncryptionSpec? encryptionSpec;

  /// Time when the TuningJob entered any of the following JobStates:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`,
  /// `JOB_STATE_EXPIRED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The Experiment associated with this TuningJob.
  ///
  /// Output only.
  core.String? experiment;

  /// The labels with user-defined metadata to organize TuningJob and generated
  /// resources such as Model and Endpoint.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Resource name of a TuningJob. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  ///
  /// Output only.
  core.String? name;

  /// Cloud Storage path to the directory where tuning job outputs are written
  /// to.
  ///
  /// This field is only available and required for open source models.
  ///
  /// Optional.
  core.String? outputUri;

  /// Tuning Spec for open sourced and third party Partner models.
  GoogleCloudAiplatformV1beta1PartnerModelTuningSpec? partnerModelTuningSpec;

  /// The resource name of the PipelineJob associated with the TuningJob.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? pipelineJob;

  /// The pre-tuned model for continuous tuning.
  GoogleCloudAiplatformV1beta1PreTunedModel? preTunedModel;

  /// Tuning Spec for Preference Optimization.
  GoogleCloudAiplatformV1beta1PreferenceOptimizationSpec?
  preferenceOptimizationSpec;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// The service account that the tuningJob workload runs as.
  ///
  /// If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the
  /// project will be used. See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-secure-fine-tuning-service-agent
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  core.String? serviceAccount;

  /// Time when the TuningJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Tuning Spec for Supervised Fine Tuning.
  GoogleCloudAiplatformV1beta1SupervisedTuningSpec? supervisedTuningSpec;

  /// The tuned model resources associated with this TuningJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1TunedModel? tunedModel;

  /// The display name of the TunedModel.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Optional.
  core.String? tunedModelDisplayName;

  /// The tuning data statistics associated with this TuningJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1beta1TuningDataStats? tuningDataStats;

  /// Time when the TuningJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Tuning Spec for Veo Tuning.
  GoogleCloudAiplatformV1beta1VeoTuningSpec? veoTuningSpec;

  GoogleCloudAiplatformV1beta1TuningJob({
    this.baseModel,
    this.createTime,
    this.customBaseModel,
    this.description,
    this.distillationSpec,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.experiment,
    this.labels,
    this.name,
    this.outputUri,
    this.partnerModelTuningSpec,
    this.pipelineJob,
    this.preTunedModel,
    this.preferenceOptimizationSpec,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.supervisedTuningSpec,
    this.tunedModel,
    this.tunedModelDisplayName,
    this.tuningDataStats,
    this.updateTime,
    this.veoTuningSpec,
  });

  GoogleCloudAiplatformV1beta1TuningJob.fromJson(core.Map json_)
    : this(
        baseModel: json_['baseModel'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        customBaseModel: json_['customBaseModel'] as core.String?,
        description: json_['description'] as core.String?,
        distillationSpec:
            json_.containsKey('distillationSpec')
                ? GoogleCloudAiplatformV1beta1DistillationSpec.fromJson(
                  json_['distillationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        encryptionSpec:
            json_.containsKey('encryptionSpec')
                ? GoogleCloudAiplatformV1beta1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        experiment: json_['experiment'] as core.String?,
        labels: (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(key, value as core.String),
        ),
        name: json_['name'] as core.String?,
        outputUri: json_['outputUri'] as core.String?,
        partnerModelTuningSpec:
            json_.containsKey('partnerModelTuningSpec')
                ? GoogleCloudAiplatformV1beta1PartnerModelTuningSpec.fromJson(
                  json_['partnerModelTuningSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        pipelineJob: json_['pipelineJob'] as core.String?,
        preTunedModel:
            json_.containsKey('preTunedModel')
                ? GoogleCloudAiplatformV1beta1PreTunedModel.fromJson(
                  json_['preTunedModel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        preferenceOptimizationSpec:
            json_.containsKey('preferenceOptimizationSpec')
                ? GoogleCloudAiplatformV1beta1PreferenceOptimizationSpec.fromJson(
                  json_['preferenceOptimizationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
        satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
        serviceAccount: json_['serviceAccount'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        supervisedTuningSpec:
            json_.containsKey('supervisedTuningSpec')
                ? GoogleCloudAiplatformV1beta1SupervisedTuningSpec.fromJson(
                  json_['supervisedTuningSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        tunedModel:
            json_.containsKey('tunedModel')
                ? GoogleCloudAiplatformV1beta1TunedModel.fromJson(
                  json_['tunedModel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        tunedModelDisplayName: json_['tunedModelDisplayName'] as core.String?,
        tuningDataStats:
            json_.containsKey('tuningDataStats')
                ? GoogleCloudAiplatformV1beta1TuningDataStats.fromJson(
                  json_['tuningDataStats']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
        veoTuningSpec:
            json_.containsKey('veoTuningSpec')
                ? GoogleCloudAiplatformV1beta1VeoTuningSpec.fromJson(
                  json_['veoTuningSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (baseModel != null) 'baseModel': baseModel!,
    if (createTime != null) 'createTime': createTime!,
    if (customBaseModel != null) 'customBaseModel': customBaseModel!,
    if (description != null) 'description': description!,
    if (distillationSpec != null) 'distillationSpec': distillationSpec!,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (experiment != null) 'experiment': experiment!,
    if (labels != null) 'labels': labels!,
    if (name != null) 'name': name!,
    if (outputUri != null) 'outputUri': outputUri!,
    if (partnerModelTuningSpec != null)
      'partnerModelTuningSpec': partnerModelTuningSpec!,
    if (pipelineJob != null) 'pipelineJob': pipelineJob!,
    if (preTunedModel != null) 'preTunedModel': preTunedModel!,
    if (preferenceOptimizationSpec != null)
      'preferenceOptimizationSpec': preferenceOptimizationSpec!,
    if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
    if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (supervisedTuningSpec != null)
      'supervisedTuningSpec': supervisedTuningSpec!,
    if (tunedModel != null) 'tunedModel': tunedModel!,
    if (tunedModelDisplayName != null)
      'tunedModelDisplayName': tunedModelDisplayName!,
    if (tuningDataStats != null) 'tuningDataStats': tuningDataStats!,
    if (updateTime != null) 'updateTime': updateTime!,
    if (veoTuningSpec != null) 'veoTuningSpec': veoTuningSpec!,
  };
}

/// Request message for IndexEndpointService.UndeployIndex.
typedef GoogleCloudAiplatformV1beta1UndeployIndexRequest =
    $UndeployIndexRequest;

/// Request message for EndpointService.UndeployModel.
typedef GoogleCloudAiplatformV1beta1UndeployModelRequest =
    $UndeployModelRequest;

/// Contains model information necessary to perform batch prediction without
/// requiring a full model import.
class GoogleCloudAiplatformV1beta1UnmanagedContainerModel {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  core.String? artifactUri;

  /// Input only.
  ///
  /// The specification of the container that is to be used when deploying this
  /// Model.
  GoogleCloudAiplatformV1beta1ModelContainerSpec? containerSpec;

  /// Contains the schemata used in Model's predictions and explanations
  GoogleCloudAiplatformV1beta1PredictSchemata? predictSchemata;

  GoogleCloudAiplatformV1beta1UnmanagedContainerModel({
    this.artifactUri,
    this.containerSpec,
    this.predictSchemata,
  });

  GoogleCloudAiplatformV1beta1UnmanagedContainerModel.fromJson(core.Map json_)
    : this(
        artifactUri: json_['artifactUri'] as core.String?,
        containerSpec:
            json_.containsKey('containerSpec')
                ? GoogleCloudAiplatformV1beta1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        predictSchemata:
            json_.containsKey('predictSchemata')
                ? GoogleCloudAiplatformV1beta1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (artifactUri != null) 'artifactUri': artifactUri!,
    if (containerSpec != null) 'containerSpec': containerSpec!,
    if (predictSchemata != null) 'predictSchemata': predictSchemata!,
  };
}

/// Request message for EndpointService.UpdateEndpointLongRunning.
class GoogleCloudAiplatformV1beta1UpdateEndpointLongRunningRequest {
  /// The Endpoint which replaces the resource on the server.
  ///
  /// Currently we only support updating the `client_connection_config` field,
  /// all the other fields' update will be blocked.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Endpoint? endpoint;

  GoogleCloudAiplatformV1beta1UpdateEndpointLongRunningRequest({this.endpoint});

  GoogleCloudAiplatformV1beta1UpdateEndpointLongRunningRequest.fromJson(
    core.Map json_,
  ) : this(
        endpoint:
            json_.containsKey('endpoint')
                ? GoogleCloudAiplatformV1beta1Endpoint.fromJson(
                  json_['endpoint'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endpoint != null) 'endpoint': endpoint!,
  };
}

/// Request message for ModelService.UpdateExplanationDataset.
class GoogleCloudAiplatformV1beta1UpdateExplanationDatasetRequest {
  /// The example config containing the location of the dataset.
  GoogleCloudAiplatformV1beta1Examples? examples;

  GoogleCloudAiplatformV1beta1UpdateExplanationDatasetRequest({this.examples});

  GoogleCloudAiplatformV1beta1UpdateExplanationDatasetRequest.fromJson(
    core.Map json_,
  ) : this(
        examples:
            json_.containsKey('examples')
                ? GoogleCloudAiplatformV1beta1Examples.fromJson(
                  json_['examples'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (examples != null) 'examples': examples!,
  };
}

/// Request message for NotebookService.UpgradeNotebookRuntime.
typedef GoogleCloudAiplatformV1beta1UpgradeNotebookRuntimeRequest = $Empty;

/// Request message for ModelService.UploadModel.
class GoogleCloudAiplatformV1beta1UploadModelRequest {
  /// The Model to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1Model? model;

  /// The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// The resource name of the model into which to upload the version.
  ///
  /// Only specify this field when uploading a new version.
  ///
  /// Optional.
  core.String? parentModel;

  /// The user-provided custom service account to use to do the model upload.
  ///
  /// If empty,
  /// [Vertex AI Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used to access resources needed to upload the model. This account
  /// must belong to the target project where the model is uploaded to, i.e.,
  /// the project specified in the `parent` field of this request and have
  /// necessary read permissions (to Google Cloud Storage, Artifact Registry,
  /// etc.).
  ///
  /// Optional.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1beta1UploadModelRequest({
    this.model,
    this.modelId,
    this.parentModel,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1beta1UploadModelRequest.fromJson(core.Map json_)
    : this(
        model:
            json_.containsKey('model')
                ? GoogleCloudAiplatformV1beta1Model.fromJson(
                  json_['model'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelId: json_['modelId'] as core.String?,
        parentModel: json_['parentModel'] as core.String?,
        serviceAccount: json_['serviceAccount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (model != null) 'model': model!,
    if (modelId != null) 'modelId': modelId!,
    if (parentModel != null) 'parentModel': parentModel!,
    if (serviceAccount != null) 'serviceAccount': serviceAccount!,
  };
}

/// Config for uploading RagFile.
class GoogleCloudAiplatformV1beta1UploadRagFileConfig {
  /// Specifies the size and overlap of chunks after uploading RagFile.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1beta1RagFileChunkingConfig? ragFileChunkingConfig;

  /// Specifies the metadata config for RagFiles.
  ///
  /// Including paths for metadata schema and metadata. Alteratively, inline
  /// metadata schema and metadata can be provided.
  GoogleCloudAiplatformV1beta1RagFileMetadataConfig? ragFileMetadataConfig;

  /// Specifies the parsing config for RagFiles.
  ///
  /// RAG will use the default parser if this field is not set.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagFileParsingConfig? ragFileParsingConfig;

  /// Specifies the transformation config for RagFiles.
  GoogleCloudAiplatformV1beta1RagFileTransformationConfig?
  ragFileTransformationConfig;

  GoogleCloudAiplatformV1beta1UploadRagFileConfig({
    this.ragFileChunkingConfig,
    this.ragFileMetadataConfig,
    this.ragFileParsingConfig,
    this.ragFileTransformationConfig,
  });

  GoogleCloudAiplatformV1beta1UploadRagFileConfig.fromJson(core.Map json_)
    : this(
        ragFileChunkingConfig:
            json_.containsKey('ragFileChunkingConfig')
                ? GoogleCloudAiplatformV1beta1RagFileChunkingConfig.fromJson(
                  json_['ragFileChunkingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFileMetadataConfig:
            json_.containsKey('ragFileMetadataConfig')
                ? GoogleCloudAiplatformV1beta1RagFileMetadataConfig.fromJson(
                  json_['ragFileMetadataConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFileParsingConfig:
            json_.containsKey('ragFileParsingConfig')
                ? GoogleCloudAiplatformV1beta1RagFileParsingConfig.fromJson(
                  json_['ragFileParsingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFileTransformationConfig:
            json_.containsKey('ragFileTransformationConfig')
                ? GoogleCloudAiplatformV1beta1RagFileTransformationConfig.fromJson(
                  json_['ragFileTransformationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragFileChunkingConfig != null)
      'ragFileChunkingConfig': ragFileChunkingConfig!,
    if (ragFileMetadataConfig != null)
      'ragFileMetadataConfig': ragFileMetadataConfig!,
    if (ragFileParsingConfig != null)
      'ragFileParsingConfig': ragFileParsingConfig!,
    if (ragFileTransformationConfig != null)
      'ragFileTransformationConfig': ragFileTransformationConfig!,
  };
}

/// Request message for VertexRagDataService.UploadRagFile.
class GoogleCloudAiplatformV1beta1UploadRagFileRequest {
  /// The RagFile to upload.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1RagFile? ragFile;

  /// The config for the RagFiles to be uploaded into the RagCorpus.
  ///
  /// VertexRagDataService.UploadRagFile.
  ///
  /// Required.
  GoogleCloudAiplatformV1beta1UploadRagFileConfig? uploadRagFileConfig;

  GoogleCloudAiplatformV1beta1UploadRagFileRequest({
    this.ragFile,
    this.uploadRagFileConfig,
  });

  GoogleCloudAiplatformV1beta1UploadRagFileRequest.fromJson(core.Map json_)
    : this(
        ragFile:
            json_.containsKey('ragFile')
                ? GoogleCloudAiplatformV1beta1RagFile.fromJson(
                  json_['ragFile'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        uploadRagFileConfig:
            json_.containsKey('uploadRagFileConfig')
                ? GoogleCloudAiplatformV1beta1UploadRagFileConfig.fromJson(
                  json_['uploadRagFileConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragFile != null) 'ragFile': ragFile!,
    if (uploadRagFileConfig != null)
      'uploadRagFileConfig': uploadRagFileConfig!,
  };
}

/// Response message for VertexRagDataService.UploadRagFile.
class GoogleCloudAiplatformV1beta1UploadRagFileResponse {
  /// The error that occurred while processing the RagFile.
  GoogleRpcStatus? error;

  /// The RagFile that had been uploaded into the RagCorpus.
  GoogleCloudAiplatformV1beta1RagFile? ragFile;

  GoogleCloudAiplatformV1beta1UploadRagFileResponse({this.error, this.ragFile});

  GoogleCloudAiplatformV1beta1UploadRagFileResponse.fromJson(core.Map json_)
    : this(
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        ragFile:
            json_.containsKey('ragFile')
                ? GoogleCloudAiplatformV1beta1RagFile.fromJson(
                  json_['ragFile'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
    if (ragFile != null) 'ragFile': ragFile!,
  };
}

/// Request message for IndexService.UpsertDatapoints
class GoogleCloudAiplatformV1beta1UpsertDatapointsRequest {
  /// A list of datapoints to be created/updated.
  core.List<GoogleCloudAiplatformV1beta1IndexDatapoint>? datapoints;

  /// Update mask is used to specify the fields to be overwritten in the
  /// datapoints by the update.
  ///
  /// The fields specified in the update_mask are relative to each
  /// IndexDatapoint inside datapoints, not the full request. Updatable fields:
  /// * Use `all_restricts` to update both restricts and numeric_restricts.
  ///
  /// Optional.
  core.String? updateMask;

  GoogleCloudAiplatformV1beta1UpsertDatapointsRequest({
    this.datapoints,
    this.updateMask,
  });

  GoogleCloudAiplatformV1beta1UpsertDatapointsRequest.fromJson(core.Map json_)
    : this(
        datapoints:
            (json_['datapoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1IndexDatapoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        updateMask: json_['updateMask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datapoints != null) 'datapoints': datapoints!,
    if (updateMask != null) 'updateMask': updateMask!,
  };
}

/// Response message for IndexService.UpsertDatapoints
typedef GoogleCloudAiplatformV1beta1UpsertDatapointsResponse = $Empty;

/// Request message for ExampleStoreService.UpsertExamples.
class GoogleCloudAiplatformV1beta1UpsertExamplesRequest {
  /// A list of examples to be created/updated.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1Example>? examples;

  /// A flag indicating whether an example can be overwritten if it already
  /// exists.
  ///
  /// If False (default) and the example already exists, the example will not be
  /// updated. This does not affect behavior if the example does not exist
  /// already.
  ///
  /// Optional.
  core.bool? overwrite;

  GoogleCloudAiplatformV1beta1UpsertExamplesRequest({
    this.examples,
    this.overwrite,
  });

  GoogleCloudAiplatformV1beta1UpsertExamplesRequest.fromJson(core.Map json_)
    : this(
        examples:
            (json_['examples'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1Example.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        overwrite: json_['overwrite'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (examples != null) 'examples': examples!,
    if (overwrite != null) 'overwrite': overwrite!,
  };
}

/// Response message for ExampleStoreService.UpsertExamples.
class GoogleCloudAiplatformV1beta1UpsertExamplesResponse {
  /// A list of results for creating/updating.
  ///
  /// It's either a successfully created/updated example or a status with an
  /// error message.
  core.List<GoogleCloudAiplatformV1beta1UpsertExamplesResponseUpsertResult>?
  results;

  GoogleCloudAiplatformV1beta1UpsertExamplesResponse({this.results});

  GoogleCloudAiplatformV1beta1UpsertExamplesResponse.fromJson(core.Map json_)
    : this(
        results:
            (json_['results'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1UpsertExamplesResponseUpsertResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (results != null) 'results': results!,
  };
}

/// The result for creating/updating a single example.
class GoogleCloudAiplatformV1beta1UpsertExamplesResponseUpsertResult {
  /// The example created/updated successfully.
  GoogleCloudAiplatformV1beta1Example? example;

  /// The error message of the example that was not created/updated
  /// successfully.
  GoogleRpcStatus? status;

  GoogleCloudAiplatformV1beta1UpsertExamplesResponseUpsertResult({
    this.example,
    this.status,
  });

  GoogleCloudAiplatformV1beta1UpsertExamplesResponseUpsertResult.fromJson(
    core.Map json_,
  ) : this(
        example:
            json_.containsKey('example')
                ? GoogleCloudAiplatformV1beta1Example.fromJson(
                  json_['example'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        status:
            json_.containsKey('status')
                ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (example != null) 'example': example!,
    if (status != null) 'status': status!,
  };
}

/// Tool to support URL context.
typedef GoogleCloudAiplatformV1beta1UrlContext = $Empty;

/// Metadata related to url context retrieval tool.
class GoogleCloudAiplatformV1beta1UrlContextMetadata {
  /// List of url context.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1beta1UrlMetadata>? urlMetadata;

  GoogleCloudAiplatformV1beta1UrlContextMetadata({this.urlMetadata});

  GoogleCloudAiplatformV1beta1UrlContextMetadata.fromJson(core.Map json_)
    : this(
        urlMetadata:
            (json_['urlMetadata'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1UrlMetadata.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (urlMetadata != null) 'urlMetadata': urlMetadata!,
  };
}

/// Context of the a single url retrieval.
typedef GoogleCloudAiplatformV1beta1UrlMetadata = $UrlMetadata;

/// References an API call.
///
/// It contains more information about long running operation and Jobs that are
/// triggered by the API call.
typedef GoogleCloudAiplatformV1beta1UserActionReference = $UserActionReference;

/// Value is the value of the field.
typedef GoogleCloudAiplatformV1beta1Value = $Value;

/// Hyperparameters for Veo.
class GoogleCloudAiplatformV1beta1VeoHyperParameters {
  /// Number of complete passes the model makes over the entire training dataset
  /// during training.
  ///
  /// Optional.
  core.String? epochCount;

  /// Multiplier for adjusting the default learning rate.
  ///
  /// Optional.
  core.double? learningRateMultiplier;

  /// The tuning task.
  ///
  /// Either I2V or T2V.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TUNING_TASK_UNSPECIFIED" : Default value. This value is unused.
  /// - "TUNING_TASK_I2V" : Tuning task for image to video.
  /// - "TUNING_TASK_T2V" : Tuning task for text to video.
  core.String? tuningTask;

  GoogleCloudAiplatformV1beta1VeoHyperParameters({
    this.epochCount,
    this.learningRateMultiplier,
    this.tuningTask,
  });

  GoogleCloudAiplatformV1beta1VeoHyperParameters.fromJson(core.Map json_)
    : this(
        epochCount: json_['epochCount'] as core.String?,
        learningRateMultiplier:
            (json_['learningRateMultiplier'] as core.num?)?.toDouble(),
        tuningTask: json_['tuningTask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (epochCount != null) 'epochCount': epochCount!,
    if (learningRateMultiplier != null)
      'learningRateMultiplier': learningRateMultiplier!,
    if (tuningTask != null) 'tuningTask': tuningTask!,
  };
}

/// Tuning Spec for Veo Model Tuning.
class GoogleCloudAiplatformV1beta1VeoTuningSpec {
  /// Hyperparameters for Veo.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1VeoHyperParameters? hyperParameters;

  /// Training dataset used for tuning.
  ///
  /// The dataset can be specified as either a Cloud Storage path to a JSONL
  /// file or as the resource name of a Vertex Multimodal Dataset.
  ///
  /// Required.
  core.String? trainingDatasetUri;

  /// Validation dataset used for tuning.
  ///
  /// The dataset can be specified as either a Cloud Storage path to a JSONL
  /// file or as the resource name of a Vertex Multimodal Dataset.
  ///
  /// Optional.
  core.String? validationDatasetUri;

  GoogleCloudAiplatformV1beta1VeoTuningSpec({
    this.hyperParameters,
    this.trainingDatasetUri,
    this.validationDatasetUri,
  });

  GoogleCloudAiplatformV1beta1VeoTuningSpec.fromJson(core.Map json_)
    : this(
        hyperParameters:
            json_.containsKey('hyperParameters')
                ? GoogleCloudAiplatformV1beta1VeoHyperParameters.fromJson(
                  json_['hyperParameters']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingDatasetUri: json_['trainingDatasetUri'] as core.String?,
        validationDatasetUri: json_['validationDatasetUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (hyperParameters != null) 'hyperParameters': hyperParameters!,
    if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri!,
    if (validationDatasetUri != null)
      'validationDatasetUri': validationDatasetUri!,
  };
}

/// Retrieve from Vertex AI Search datastore or engine for grounding.
///
/// datastore and engine are mutually exclusive. See
/// https://cloud.google.com/products/agent-builder
class GoogleCloudAiplatformV1beta1VertexAISearch {
  /// Specifications that define the specific DataStores to be searched, along
  /// with configurations for those data stores.
  ///
  /// This is only considered for Engines with multiple data stores. It should
  /// only be set if engine is used.
  core.List<GoogleCloudAiplatformV1beta1VertexAISearchDataStoreSpec>?
  dataStoreSpecs;

  /// Fully-qualified Vertex AI Search data store resource ID.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
  ///
  /// Optional.
  core.String? datastore;

  /// Fully-qualified Vertex AI Search engine resource ID.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  ///
  /// Optional.
  core.String? engine;

  /// Filter strings to be passed to the search API.
  ///
  /// Optional.
  core.String? filter;

  /// Number of search results to return per query.
  ///
  /// The default value is 10. The maximumm allowed value is 10.
  ///
  /// Optional.
  core.int? maxResults;

  GoogleCloudAiplatformV1beta1VertexAISearch({
    this.dataStoreSpecs,
    this.datastore,
    this.engine,
    this.filter,
    this.maxResults,
  });

  GoogleCloudAiplatformV1beta1VertexAISearch.fromJson(core.Map json_)
    : this(
        dataStoreSpecs:
            (json_['dataStoreSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1VertexAISearchDataStoreSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        datastore: json_['datastore'] as core.String?,
        engine: json_['engine'] as core.String?,
        filter: json_['filter'] as core.String?,
        maxResults: json_['maxResults'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStoreSpecs != null) 'dataStoreSpecs': dataStoreSpecs!,
    if (datastore != null) 'datastore': datastore!,
    if (engine != null) 'engine': engine!,
    if (filter != null) 'filter': filter!,
    if (maxResults != null) 'maxResults': maxResults!,
  };
}

/// Define data stores within engine to filter on in a search call and
/// configurations for those data stores.
///
/// For more information, see
/// https://cloud.google.com/generative-ai-app-builder/docs/reference/rpc/google.cloud.discoveryengine.v1#datastorespec
typedef GoogleCloudAiplatformV1beta1VertexAISearchDataStoreSpec =
    $VertexAISearchDataStoreSpec;

/// Config for the Vertex AI Search.
typedef GoogleCloudAiplatformV1beta1VertexAiSearchConfig =
    $VertexAiSearchConfig;

/// Retrieve from Vertex RAG Store for grounding.
class GoogleCloudAiplatformV1beta1VertexRagStore {
  /// Please use rag_resources instead.
  ///
  /// Optional. Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<core.String>? ragCorpora;

  /// The representation of the rag source.
  ///
  /// It can be used to specify corpus only or ragfiles. Currently only support
  /// one corpus or multiple files from one corpus. In the future we may open up
  /// multiple corpora support.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1VertexRagStoreRagResource>?
  ragResources;

  /// The retrieval config for the Rag query.
  ///
  /// Optional.
  GoogleCloudAiplatformV1beta1RagRetrievalConfig? ragRetrievalConfig;

  /// Number of top k results to return from the selected corpora.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? similarityTopK;

  /// Currently only supported for Gemini Multimodal Live API.
  ///
  /// In Gemini Multimodal Live API, if `store_context` bool is specified,
  /// Gemini will leverage it to automatically memorize the interactions between
  /// the client and Gemini, and retrieve context when needed to augment the
  /// response generation for users' ongoing and future interactions.
  ///
  /// Optional.
  core.bool? storeContext;

  /// Only return results with vector distance smaller than the threshold.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? vectorDistanceThreshold;

  GoogleCloudAiplatformV1beta1VertexRagStore({
    this.ragCorpora,
    this.ragResources,
    this.ragRetrievalConfig,
    this.similarityTopK,
    this.storeContext,
    this.vectorDistanceThreshold,
  });

  GoogleCloudAiplatformV1beta1VertexRagStore.fromJson(core.Map json_)
    : this(
        ragCorpora:
            (json_['ragCorpora'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        ragResources:
            (json_['ragResources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1VertexRagStoreRagResource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        ragRetrievalConfig:
            json_.containsKey('ragRetrievalConfig')
                ? GoogleCloudAiplatformV1beta1RagRetrievalConfig.fromJson(
                  json_['ragRetrievalConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        similarityTopK: json_['similarityTopK'] as core.int?,
        storeContext: json_['storeContext'] as core.bool?,
        vectorDistanceThreshold:
            (json_['vectorDistanceThreshold'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ragCorpora != null) 'ragCorpora': ragCorpora!,
    if (ragResources != null) 'ragResources': ragResources!,
    if (ragRetrievalConfig != null) 'ragRetrievalConfig': ragRetrievalConfig!,
    if (similarityTopK != null) 'similarityTopK': similarityTopK!,
    if (storeContext != null) 'storeContext': storeContext!,
    if (vectorDistanceThreshold != null)
      'vectorDistanceThreshold': vectorDistanceThreshold!,
  };
}

/// The definition of the Rag resource.
typedef GoogleCloudAiplatformV1beta1VertexRagStoreRagResource =
    $VertexRagStoreRagResource;

/// Metadata describes the input video content.
typedef GoogleCloudAiplatformV1beta1VideoMetadata = $VideoMetadata;

/// The configuration for the voice to use.
class GoogleCloudAiplatformV1beta1VoiceConfig {
  /// The configuration for the prebuilt voice to use.
  GoogleCloudAiplatformV1beta1PrebuiltVoiceConfig? prebuiltVoiceConfig;

  GoogleCloudAiplatformV1beta1VoiceConfig({this.prebuiltVoiceConfig});

  GoogleCloudAiplatformV1beta1VoiceConfig.fromJson(core.Map json_)
    : this(
        prebuiltVoiceConfig:
            json_.containsKey('prebuiltVoiceConfig')
                ? GoogleCloudAiplatformV1beta1PrebuiltVoiceConfig.fromJson(
                  json_['prebuiltVoiceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (prebuiltVoiceConfig != null)
      'prebuiltVoiceConfig': prebuiltVoiceConfig!,
  };
}

/// Represents the spec of a worker pool in a job.
class GoogleCloudAiplatformV1beta1WorkerPoolSpec {
  /// The custom container task.
  GoogleCloudAiplatformV1beta1ContainerSpec? containerSpec;

  /// Disk spec.
  GoogleCloudAiplatformV1beta1DiskSpec? diskSpec;

  /// The specification of a single machine.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1beta1MachineSpec? machineSpec;

  /// List of NFS mount spec.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1beta1NfsMount>? nfsMounts;

  /// The Python packaged task.
  GoogleCloudAiplatformV1beta1PythonPackageSpec? pythonPackageSpec;

  /// The number of worker replicas to use for this worker pool.
  ///
  /// Optional.
  core.String? replicaCount;

  GoogleCloudAiplatformV1beta1WorkerPoolSpec({
    this.containerSpec,
    this.diskSpec,
    this.machineSpec,
    this.nfsMounts,
    this.pythonPackageSpec,
    this.replicaCount,
  });

  GoogleCloudAiplatformV1beta1WorkerPoolSpec.fromJson(core.Map json_)
    : this(
        containerSpec:
            json_.containsKey('containerSpec')
                ? GoogleCloudAiplatformV1beta1ContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        diskSpec:
            json_.containsKey('diskSpec')
                ? GoogleCloudAiplatformV1beta1DiskSpec.fromJson(
                  json_['diskSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        machineSpec:
            json_.containsKey('machineSpec')
                ? GoogleCloudAiplatformV1beta1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        nfsMounts:
            (json_['nfsMounts'] as core.List?)
                ?.map(
                  (value) => GoogleCloudAiplatformV1beta1NfsMount.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        pythonPackageSpec:
            json_.containsKey('pythonPackageSpec')
                ? GoogleCloudAiplatformV1beta1PythonPackageSpec.fromJson(
                  json_['pythonPackageSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        replicaCount: json_['replicaCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (containerSpec != null) 'containerSpec': containerSpec!,
    if (diskSpec != null) 'diskSpec': diskSpec!,
    if (machineSpec != null) 'machineSpec': machineSpec!,
    if (nfsMounts != null) 'nfsMounts': nfsMounts!,
    if (pythonPackageSpec != null) 'pythonPackageSpec': pythonPackageSpec!,
    if (replicaCount != null) 'replicaCount': replicaCount!,
  };
}

/// Contains Feature values to be written for a specific entity.
class GoogleCloudAiplatformV1beta1WriteFeatureValuesPayload {
  /// The ID of the entity.
  ///
  /// Required.
  core.String? entityId;

  /// Feature values to be written, mapping from Feature ID to value.
  ///
  /// Up to 100,000 `feature_values` entries may be written across all payloads.
  /// The feature generation time, aligned by days, must be no older than five
  /// years (1825 days) and no later than one year (366 days) in the future.
  ///
  /// Required.
  core.Map<core.String, GoogleCloudAiplatformV1beta1FeatureValue>?
  featureValues;

  GoogleCloudAiplatformV1beta1WriteFeatureValuesPayload({
    this.entityId,
    this.featureValues,
  });

  GoogleCloudAiplatformV1beta1WriteFeatureValuesPayload.fromJson(core.Map json_)
    : this(
        entityId: json_['entityId'] as core.String?,
        featureValues: (json_['featureValues']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudAiplatformV1beta1FeatureValue.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entityId != null) 'entityId': entityId!,
    if (featureValues != null) 'featureValues': featureValues!,
  };
}

/// Request message for FeaturestoreOnlineServingService.WriteFeatureValues.
class GoogleCloudAiplatformV1beta1WriteFeatureValuesRequest {
  /// The entities to be written.
  ///
  /// Up to 100,000 feature values can be written across all `payloads`.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1WriteFeatureValuesPayload>? payloads;

  GoogleCloudAiplatformV1beta1WriteFeatureValuesRequest({this.payloads});

  GoogleCloudAiplatformV1beta1WriteFeatureValuesRequest.fromJson(core.Map json_)
    : this(
        payloads:
            (json_['payloads'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1WriteFeatureValuesPayload.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (payloads != null) 'payloads': payloads!,
  };
}

/// Response message for FeaturestoreOnlineServingService.WriteFeatureValues.
typedef GoogleCloudAiplatformV1beta1WriteFeatureValuesResponse = $Empty;

/// Request message for TensorboardService.WriteTensorboardExperimentData.
class GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataRequest {
  /// Requests containing per-run TensorboardTimeSeries data to write.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1WriteTensorboardRunDataRequest>?
  writeRunDataRequests;

  GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataRequest({
    this.writeRunDataRequests,
  });

  GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataRequest.fromJson(
    core.Map json_,
  ) : this(
        writeRunDataRequests:
            (json_['writeRunDataRequests'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1WriteTensorboardRunDataRequest.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (writeRunDataRequests != null)
      'writeRunDataRequests': writeRunDataRequests!,
  };
}

/// Response message for TensorboardService.WriteTensorboardExperimentData.
typedef GoogleCloudAiplatformV1beta1WriteTensorboardExperimentDataResponse =
    $Empty;

/// Request message for TensorboardService.WriteTensorboardRunData.
class GoogleCloudAiplatformV1beta1WriteTensorboardRunDataRequest {
  /// The resource name of the TensorboardRun to write data to.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Required.
  core.String? tensorboardRun;

  /// The TensorboardTimeSeries data to write.
  ///
  /// Values with in a time series are indexed by their step value. Repeated
  /// writes to the same step will overwrite the existing value for that step.
  /// The upper limit of data points per write request is 5000.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1beta1TimeSeriesData>? timeSeriesData;

  GoogleCloudAiplatformV1beta1WriteTensorboardRunDataRequest({
    this.tensorboardRun,
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1beta1WriteTensorboardRunDataRequest.fromJson(
    core.Map json_,
  ) : this(
        tensorboardRun: json_['tensorboardRun'] as core.String?,
        timeSeriesData:
            (json_['timeSeriesData'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudAiplatformV1beta1TimeSeriesData.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!,
    if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
  };
}

/// Response message for TensorboardService.WriteTensorboardRunData.
typedef GoogleCloudAiplatformV1beta1WriteTensorboardRunDataResponse = $Empty;

/// An explanation method that redistributes Integrated Gradients attributions
/// to segmented regions, taking advantage of the model's fully differentiable
/// structure.
///
/// Refer to this paper for more details: https://arxiv.org/abs/1906.02825
/// Supported only by image Models.
class GoogleCloudAiplatformV1beta1XraiAttribution {
  /// Config for XRAI with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image)
  /// is motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  GoogleCloudAiplatformV1beta1BlurBaselineConfig? blurBaselineConfig;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding noise can help
  /// improve the computed gradients. Refer to this paper for more details:
  /// https://arxiv.org/pdf/1706.03825.pdf
  GoogleCloudAiplatformV1beta1SmoothGradConfig? smoothGradConfig;

  /// The number of steps for approximating the path integral.
  ///
  /// A good value to start is 50 and gradually increase until the sum to diff
  /// property is met within the desired error range. Valid range of its value
  /// is \[1, 100\], inclusively.
  ///
  /// Required.
  core.int? stepCount;

  GoogleCloudAiplatformV1beta1XraiAttribution({
    this.blurBaselineConfig,
    this.smoothGradConfig,
    this.stepCount,
  });

  GoogleCloudAiplatformV1beta1XraiAttribution.fromJson(core.Map json_)
    : this(
        blurBaselineConfig:
            json_.containsKey('blurBaselineConfig')
                ? GoogleCloudAiplatformV1beta1BlurBaselineConfig.fromJson(
                  json_['blurBaselineConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        smoothGradConfig:
            json_.containsKey('smoothGradConfig')
                ? GoogleCloudAiplatformV1beta1SmoothGradConfig.fromJson(
                  json_['smoothGradConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        stepCount: json_['stepCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blurBaselineConfig != null) 'blurBaselineConfig': blurBaselineConfig!,
    if (smoothGradConfig != null) 'smoothGradConfig': smoothGradConfig!,
    if (stepCount != null) 'stepCount': stepCount!,
  };
}

/// The response message for Locations.ListLocations.
class GoogleCloudLocationListLocationsResponse {
  /// A list of locations that matches the specified filter in the request.
  core.List<GoogleCloudLocationLocation>? locations;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudLocationListLocationsResponse({
    this.locations,
    this.nextPageToken,
  });

  GoogleCloudLocationListLocationsResponse.fromJson(core.Map json_)
    : this(
        locations:
            (json_['locations'] as core.List?)
                ?.map(
                  (value) => GoogleCloudLocationLocation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (locations != null) 'locations': locations!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// A resource that represents a Google Cloud location.
typedef GoogleCloudLocationLocation = $Location00;

/// Associates `members`, or principals, with a `role`.
class GoogleIamV1Binding {
  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request. If the condition evaluates to `false`, then this binding
  /// does not apply to the current request. However, a different role binding
  /// might grant the same role to one or more of the principals in this
  /// binding. To learn which resources support conditions in their IAM
  /// policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  GoogleTypeExpr? condition;

  /// Specifies the principals requesting access for a Google Cloud resource.
  ///
  /// `members` can have the following values: * `allUsers`: A special
  /// identifier that represents anyone who is on the internet; with or without
  /// a Google account. * `allAuthenticatedUsers`: A special identifier that
  /// represents anyone who is authenticated with a Google account or a service
  /// account. Does not include identities that come from external identity
  /// providers (IdPs) through identity federation. * `user:{emailid}`: An email
  /// address that represents a specific Google account. For example,
  /// `alice@example.com` . * `serviceAccount:{emailid}`: An email address that
  /// represents a Google service account. For example,
  /// `my-other-app@appspot.gserviceaccount.com`. *
  /// `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
  /// identifier for a
  /// [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
  /// For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
  /// `group:{emailid}`: An email address that represents a Google group. For
  /// example, `admins@example.com`. * `domain:{domain}`: The G Suite domain
  /// (primary) that represents all the users of that domain. For example,
  /// `google.com` or `example.com`. *
  /// `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
  /// A single identity in a workforce identity pool. *
  /// `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
  /// All workforce identities in a group. *
  /// `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
  /// All workforce identities with a specific attribute value. *
  /// `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}
  /// / * `: All identities in a workforce identity pool. *
  /// `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
  /// A single identity in a workload identity pool. *
  /// `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
  /// A workload identity pool group. *
  /// `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
  /// All identities in a workload identity pool with a certain attribute. *
  /// `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}
  /// / * `: All identities in a workload identity pool. *
  /// `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a user that has been recently deleted. For
  /// example, `alice@example.com?uid=123456789012345678901`. If the user is
  /// recovered, this value reverts to `user:{emailid}` and the recovered user
  /// retains the role in the binding. *
  /// `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
  /// unique identifier) representing a service account that has been recently
  /// deleted. For example,
  /// `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
  /// the service account is undeleted, this value reverts to
  /// `serviceAccount:{emailid}` and the undeleted service account retains the
  /// role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
  /// address (plus unique identifier) representing a Google group that has been
  /// recently deleted. For example,
  /// `admins@example.com?uid=123456789012345678901`. If the group is recovered,
  /// this value reverts to `group:{emailid}` and the recovered group retains
  /// the role in the binding. *
  /// `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
  /// Deleted single identity in a workforce identity pool. For example,
  /// `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
  core.List<core.String>? members;

  /// Role that is assigned to the list of `members`, or principals.
  ///
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an
  /// overview of the IAM roles and permissions, see the
  /// [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For
  /// a list of the available pre-defined roles, see
  /// [here](https://cloud.google.com/iam/docs/understanding-roles).
  core.String? role;

  GoogleIamV1Binding({this.condition, this.members, this.role});

  GoogleIamV1Binding.fromJson(core.Map json_)
    : this(
        condition:
            json_.containsKey('condition')
                ? GoogleTypeExpr.fromJson(
                  json_['condition'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        members:
            (json_['members'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        role: json_['role'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (condition != null) 'condition': condition!,
    if (members != null) 'members': members!,
    if (role != null) 'role': role!,
  };
}

/// Request message for `GetIamPolicy` method.
class GoogleIamV1GetIamPolicyRequest {
  /// OPTIONAL: A `GetPolicyOptions` object for specifying options to
  /// `GetIamPolicy`.
  GoogleIamV1GetPolicyOptions? options;

  GoogleIamV1GetIamPolicyRequest({this.options});

  GoogleIamV1GetIamPolicyRequest.fromJson(core.Map json_)
    : this(
        options:
            json_.containsKey('options')
                ? GoogleIamV1GetPolicyOptions.fromJson(
                  json_['options'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (options != null) 'options': options!,
  };
}

/// Encapsulates settings provided to GetIamPolicy.
typedef GoogleIamV1GetPolicyOptions = $GetPolicyOptions00;

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role. For some types of Google Cloud
/// resources, a `binding` can also specify a `condition`, which is a logical
/// expression that allows access to a resource only if the expression evaluates
/// to `true`. A condition can add constraints based on attributes of the
/// request, the resource, or both. To learn which resources support conditions
/// in their IAM policies, see the
/// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
/// **JSON example:** ``` { "bindings": [ { "role":
/// "roles/resourcemanager.organizationAdmin", "members": [
/// "user:mike@example.com", "group:admins@example.com", "domain:google.com",
/// "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role":
/// "roles/resourcemanager.organizationViewer", "members": [
/// "user:eve@example.com" ], "condition": { "title": "expirable access",
/// "description": "Does not grant access after Sep 2020", "expression":
/// "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
/// "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
/// members: - user:mike@example.com - group:admins@example.com -
/// domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com
/// role: roles/resourcemanager.organizationAdmin - members: -
/// user:eve@example.com role: roles/resourcemanager.organizationViewer
/// condition: title: expirable access description: Does not grant access after
/// Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
/// etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features,
/// see the [IAM documentation](https://cloud.google.com/iam/docs/).
class GoogleIamV1Policy {
  /// Associates a list of `members`, or principals, with a `role`.
  ///
  /// Optionally, may specify a `condition` that determines how and when the
  /// `bindings` are applied. Each of the `bindings` must contain at least one
  /// principal. The `bindings` in a `Policy` can refer to up to 1,500
  /// principals; up to 250 of these principals can be Google groups. Each
  /// occurrence of a principal counts towards these limits. For example, if the
  /// `bindings` grant 50 different roles to `user:alice@example.com`, and not
  /// to any other principal, then you can add another 1,450 principals to the
  /// `bindings` in the `Policy`.
  core.List<GoogleIamV1Binding>? bindings;

  /// `etag` is used for optimistic concurrency control as a way to help prevent
  /// simultaneous updates of a policy from overwriting each other.
  ///
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the
  /// policy. **Important:** If you use IAM Conditions, you must include the
  /// `etag` field whenever you call `setIamPolicy`. If you omit this field,
  /// then IAM allows you to overwrite a version `3` policy with a version `1`
  /// policy, and all of the conditions in the version `3` policy are lost.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> bytes_) {
    etag = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected. Any operation that affects conditional role bindings must
  /// specify version `3`. This requirement applies to the following operations:
  /// * Getting a policy that includes a conditional role binding * Adding a
  /// conditional role binding to a policy * Changing a conditional role binding
  /// in a policy * Removing any role binding, with or without a condition, from
  /// a policy that includes conditions **Important:** If you use IAM
  /// Conditions, you must include the `etag` field whenever you call
  /// `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
  /// version `3` policy with a version `1` policy, and all of the conditions in
  /// the version `3` policy are lost. If a policy does not include any
  /// conditions, operations on that policy may specify any valid version or
  /// leave the field unset. To learn which resources support conditions in
  /// their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  core.int? version;

  GoogleIamV1Policy({this.bindings, this.etag, this.version});

  GoogleIamV1Policy.fromJson(core.Map json_)
    : this(
        bindings:
            (json_['bindings'] as core.List?)
                ?.map(
                  (value) => GoogleIamV1Binding.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        etag: json_['etag'] as core.String?,
        version: json_['version'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bindings != null) 'bindings': bindings!,
    if (etag != null) 'etag': etag!,
    if (version != null) 'version': version!,
  };
}

/// Request message for `SetIamPolicy` method.
class GoogleIamV1SetIamPolicyRequest {
  /// REQUIRED: The complete policy to be applied to the `resource`.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is a
  /// valid policy but certain Google Cloud services (such as Projects) might
  /// reject them.
  GoogleIamV1Policy? policy;

  GoogleIamV1SetIamPolicyRequest({this.policy});

  GoogleIamV1SetIamPolicyRequest.fromJson(core.Map json_)
    : this(
        policy:
            json_.containsKey('policy')
                ? GoogleIamV1Policy.fromJson(
                  json_['policy'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (policy != null) 'policy': policy!,
  };
}

/// Request message for `TestIamPermissions` method.
typedef GoogleIamV1TestIamPermissionsRequest = $TestIamPermissionsRequest00;

/// Response message for `TestIamPermissions` method.
typedef GoogleIamV1TestIamPermissionsResponse = $PermissionsResponse;

/// The response message for Operations.ListOperations.
class GoogleLongrunningListOperationsResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of operations that matches the specified filter in the request.
  core.List<GoogleLongrunningOperation>? operations;

  GoogleLongrunningListOperationsResponse({
    this.nextPageToken,
    this.operations,
  });

  GoogleLongrunningListOperationsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        operations:
            (json_['operations'] as core.List?)
                ?.map(
                  (value) => GoogleLongrunningOperation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (operations != null) 'operations': operations!,
  };
}

/// This resource represents a long-running operation that is the result of a
/// network API call.
class GoogleLongrunningOperation {
  /// If the value is `false`, it means the operation is still in progress.
  ///
  /// If `true`, the operation is completed, and either `error` or `response` is
  /// available.
  core.bool? done;

  /// The error result of the operation in case of failure or cancellation.
  GoogleRpcStatus? error;

  /// Service-specific metadata associated with the operation.
  ///
  /// It typically contains progress information and common metadata such as
  /// create time. Some services might not provide such metadata. Any method
  /// that returns a long-running operation should document the metadata type,
  /// if any.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The server-assigned name, which is only unique within the same service
  /// that originally returns it.
  ///
  /// If you use the default HTTP mapping, the `name` should be a resource name
  /// ending with `operations/{unique_id}`.
  core.String? name;

  /// The normal, successful response of the operation.
  ///
  /// If the original method returns no data on success, such as `Delete`, the
  /// response is `google.protobuf.Empty`. If the original method is standard
  /// `Get`/`Create`/`Update`, the response should be the resource. For other
  /// methods, the response should have the type `XxxResponse`, where `Xxx` is
  /// the original method name. For example, if the original method name is
  /// `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? response;

  GoogleLongrunningOperation({
    this.done,
    this.error,
    this.metadata,
    this.name,
    this.response,
  });

  GoogleLongrunningOperation.fromJson(core.Map json_)
    : this(
        done: json_['done'] as core.bool?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
        response:
            json_.containsKey('response')
                ? json_['response'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (done != null) 'done': done!,
    if (error != null) 'error': error!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (response != null) 'response': response!,
  };
}

/// A generic empty message that you can re-use to avoid defining duplicated
/// empty messages in your APIs.
///
/// A typical example is to use it as the request or the response type of an API
/// method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns
/// (google.protobuf.Empty); }
typedef GoogleProtobufEmpty = $Empty;

/// The `Status` type defines a logical error model that is suitable for
/// different programming environments, including REST APIs and RPC APIs.
///
/// It is used by [gRPC](https://github.com/grpc). Each `Status` message
/// contains three pieces of data: error code, error message, and error details.
/// You can find out more about this error model and how to work with it in the
/// [API Design Guide](https://cloud.google.com/apis/design/errors).
typedef GoogleRpcStatus = $Status00;

/// Represents a whole or partial calendar date, such as a birthday.
///
/// The time of day and time zone are either specified elsewhere or are
/// insignificant. The date is relative to the Gregorian Calendar. This can
/// represent one of the following: * A full date, with non-zero year, month,
/// and day values. * A month and day, with a zero year (for example, an
/// anniversary). * A year on its own, with a zero month and a zero day. * A
/// year and month, with a zero day (for example, a credit card expiration
/// date). Related types: * google.type.TimeOfDay * google.type.DateTime *
/// google.protobuf.Timestamp
typedef GoogleTypeDate = $Date;

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax.
///
/// CEL is a C-like expression language. The syntax and semantics of CEL are
/// documented at https://github.com/google/cel-spec. Example (Comparison):
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() \< 100" Example
/// (Equality): title: "Requestor is owner" description: "Determines if
/// requestor is the document owner" expression: "document.owner ==
/// request.auth.claims.email" Example (Logic): title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// Example (Data Manipulation): title: "Notification string" description:
/// "Create a notification string with a timestamp." expression: "'New message
/// received at ' + string(document.create_time)" The exact variables and
/// functions that may be referenced within an expression are determined by the
/// service that evaluates it. See the service documentation for additional
/// information.
typedef GoogleTypeExpr = $Expr;

/// Represents a time interval, encoded as a Timestamp start (inclusive) and a
/// Timestamp end (exclusive).
///
/// The start must be less than or equal to the end. When the start equals the
/// end, the interval is empty (matches no time). When both start and end are
/// unspecified, the interval matches any time.
typedef GoogleTypeInterval = $Interval00;

/// An object that represents a latitude/longitude pair.
///
/// This is expressed as a pair of doubles to represent degrees latitude and
/// degrees longitude. Unless specified otherwise, this object must conform to
/// the WGS84 standard. Values must be within normalized ranges.
typedef GoogleTypeLatLng = $LatLng;

/// Represents an amount of money with its currency type.
typedef GoogleTypeMoney = $Money;
