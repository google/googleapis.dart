// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: doc_directive_unknown
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_string_interpolations

/// Vertex AI API - v1
///
/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
///
/// For more information, see <https://cloud.google.com/vertex-ai/>
///
/// Create an instance of [AiplatformApi] to access these resources:
///
/// - [DatasetsResource]
///   - [DatasetsDatasetVersionsResource]
/// - [EndpointsResource]
/// - [MediaResource]
/// - [ProjectsResource]
///   - [ProjectsLocationsResource]
///     - [ProjectsLocationsBatchPredictionJobsResource]
///     - [ProjectsLocationsCachedContentsResource]
///     - [ProjectsLocationsCustomJobsResource]
///       - [ProjectsLocationsCustomJobsOperationsResource]
///     - [ProjectsLocationsDataLabelingJobsResource]
///       - [ProjectsLocationsDataLabelingJobsOperationsResource]
///     - [ProjectsLocationsDatasetsResource]
///       - [ProjectsLocationsDatasetsAnnotationSpecsResource]
///         - [ProjectsLocationsDatasetsAnnotationSpecsOperationsResource]
///       - [ProjectsLocationsDatasetsDataItemsResource]
///         - [ProjectsLocationsDatasetsDataItemsAnnotationsResource]
/// - [ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource]
///         - [ProjectsLocationsDatasetsDataItemsOperationsResource]
///       - [ProjectsLocationsDatasetsDatasetVersionsResource]
///       - [ProjectsLocationsDatasetsOperationsResource]
///       - [ProjectsLocationsDatasetsSavedQueriesResource]
///         - [ProjectsLocationsDatasetsSavedQueriesOperationsResource]
///     - [ProjectsLocationsDeploymentResourcePoolsResource]
///       - [ProjectsLocationsDeploymentResourcePoolsOperationsResource]
///     - [ProjectsLocationsEndpointsResource]
///       - [ProjectsLocationsEndpointsChatResource]
///       - [ProjectsLocationsEndpointsOperationsResource]
///     - [ProjectsLocationsFeatureGroupsResource]
///       - [ProjectsLocationsFeatureGroupsFeaturesResource]
///         - [ProjectsLocationsFeatureGroupsFeaturesOperationsResource]
///       - [ProjectsLocationsFeatureGroupsOperationsResource]
///     - [ProjectsLocationsFeatureOnlineStoresResource]
///       - [ProjectsLocationsFeatureOnlineStoresFeatureViewsResource]
/// - [ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource]
/// - [ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource]
///       - [ProjectsLocationsFeatureOnlineStoresOperationsResource]
///     - [ProjectsLocationsFeaturestoresResource]
///       - [ProjectsLocationsFeaturestoresEntityTypesResource]
///         - [ProjectsLocationsFeaturestoresEntityTypesFeaturesResource]
/// - [ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource]
///         - [ProjectsLocationsFeaturestoresEntityTypesOperationsResource]
///       - [ProjectsLocationsFeaturestoresOperationsResource]
///     - [ProjectsLocationsHyperparameterTuningJobsResource]
///       - [ProjectsLocationsHyperparameterTuningJobsOperationsResource]
///     - [ProjectsLocationsIndexEndpointsResource]
///       - [ProjectsLocationsIndexEndpointsOperationsResource]
///     - [ProjectsLocationsIndexesResource]
///       - [ProjectsLocationsIndexesOperationsResource]
///     - [ProjectsLocationsMetadataStoresResource]
///       - [ProjectsLocationsMetadataStoresArtifactsResource]
///         - [ProjectsLocationsMetadataStoresArtifactsOperationsResource]
///       - [ProjectsLocationsMetadataStoresContextsResource]
///         - [ProjectsLocationsMetadataStoresContextsOperationsResource]
///       - [ProjectsLocationsMetadataStoresExecutionsResource]
///         - [ProjectsLocationsMetadataStoresExecutionsOperationsResource]
///       - [ProjectsLocationsMetadataStoresMetadataSchemasResource]
///       - [ProjectsLocationsMetadataStoresOperationsResource]
///     - [ProjectsLocationsMigratableResourcesResource]
///       - [ProjectsLocationsMigratableResourcesOperationsResource]
///     - [ProjectsLocationsModelDeploymentMonitoringJobsResource]
///       - [ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource]
///     - [ProjectsLocationsModelsResource]
///       - [ProjectsLocationsModelsEvaluationsResource]
///         - [ProjectsLocationsModelsEvaluationsOperationsResource]
///         - [ProjectsLocationsModelsEvaluationsSlicesResource]
///       - [ProjectsLocationsModelsOperationsResource]
///     - [ProjectsLocationsNasJobsResource]
///       - [ProjectsLocationsNasJobsNasTrialDetailsResource]
///     - [ProjectsLocationsNotebookExecutionJobsResource]
///       - [ProjectsLocationsNotebookExecutionJobsOperationsResource]
///     - [ProjectsLocationsNotebookRuntimeTemplatesResource]
///       - [ProjectsLocationsNotebookRuntimeTemplatesOperationsResource]
///     - [ProjectsLocationsNotebookRuntimesResource]
///       - [ProjectsLocationsNotebookRuntimesOperationsResource]
///     - [ProjectsLocationsOperationsResource]
///     - [ProjectsLocationsPersistentResourcesResource]
///       - [ProjectsLocationsPersistentResourcesOperationsResource]
///     - [ProjectsLocationsPipelineJobsResource]
///       - [ProjectsLocationsPipelineJobsOperationsResource]
///     - [ProjectsLocationsPublishersResource]
///       - [ProjectsLocationsPublishersModelsResource]
///     - [ProjectsLocationsRagCorporaResource]
///       - [ProjectsLocationsRagCorporaOperationsResource]
///       - [ProjectsLocationsRagCorporaRagFilesResource]
///         - [ProjectsLocationsRagCorporaRagFilesOperationsResource]
///     - [ProjectsLocationsReasoningEnginesResource]
///       - [ProjectsLocationsReasoningEnginesOperationsResource]
///     - [ProjectsLocationsSchedulesResource]
///       - [ProjectsLocationsSchedulesOperationsResource]
///     - [ProjectsLocationsSpecialistPoolsResource]
///       - [ProjectsLocationsSpecialistPoolsOperationsResource]
///     - [ProjectsLocationsStudiesResource]
///       - [ProjectsLocationsStudiesOperationsResource]
///       - [ProjectsLocationsStudiesTrialsResource]
///         - [ProjectsLocationsStudiesTrialsOperationsResource]
///     - [ProjectsLocationsTensorboardsResource]
///       - [ProjectsLocationsTensorboardsExperimentsResource]
///         - [ProjectsLocationsTensorboardsExperimentsOperationsResource]
///         - [ProjectsLocationsTensorboardsExperimentsRunsResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsOperationsResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource]
///       - [ProjectsLocationsTensorboardsOperationsResource]
///     - [ProjectsLocationsTrainingPipelinesResource]
///       - [ProjectsLocationsTrainingPipelinesOperationsResource]
///     - [ProjectsLocationsTuningJobsResource]
///       - [ProjectsLocationsTuningJobsOperationsResource]
/// - [PublishersResource]
///   - [PublishersModelsResource]
library;

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

import '../shared.dart';
import '../src/user_agent.dart';

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show
        ApiRequestError,
        ByteRange,
        DetailedApiRequestError,
        DownloadOptions,
        Media,
        PartialDownloadOptions,
        ResumableUploadOptions,
        UploadOptions;

/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
class AiplatformApi {
  /// See, edit, configure, and delete your Google Cloud data and see the email
  /// address for your Google Account.
  static const cloudPlatformScope =
      'https://www.googleapis.com/auth/cloud-platform';

  /// View your data across Google Cloud services and see the email address of
  /// your Google Account
  static const cloudPlatformReadOnlyScope =
      'https://www.googleapis.com/auth/cloud-platform.read-only';

  final commons.ApiRequester _requester;

  DatasetsResource get datasets => DatasetsResource(_requester);
  EndpointsResource get endpoints => EndpointsResource(_requester);
  MediaResource get media => MediaResource(_requester);
  ProjectsResource get projects => ProjectsResource(_requester);
  PublishersResource get publishers => PublishersResource(_requester);

  AiplatformApi(http.Client client,
      {core.String rootUrl = 'https://aiplatform.googleapis.com/',
      core.String servicePath = ''})
      : _requester =
            commons.ApiRequester(client, rootUrl, servicePath, requestHeaders);
}

class DatasetsResource {
  final commons.ApiRequester _requester;

  DatasetsDatasetVersionsResource get datasetVersions =>
      DatasetsDatasetVersionsResource(_requester);

  DatasetsResource(commons.ApiRequester client) : _requester = client;

  /// Creates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Dataset in. Format: `projects/{project}/locations/{location}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Dataset request, {
    core.String? parent,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (parent != null) 'parent': [parent],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1/datasets';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource.
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Dataset> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Dataset.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Datasets in a Location.
  ///
  /// Request parameters:
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. *
  /// \`display_name\`: supports = and != * \`metadata_schema_uri\`: supports =
  /// and != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. Some examples: * \`displayName="myDisplayName"\` *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [parent] - Required. The name of the Dataset's parent resource. Format:
  /// `projects/{project}/locations/{location}`
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDatasetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDatasetsResponse> list({
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? parent,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (parent != null) 'parent': [parent],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    const url_ = 'v1/datasets';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDatasetsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the Dataset.
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name` * `description` * `labels`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Dataset> patch(
    GoogleCloudAiplatformV1Dataset request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Dataset.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class DatasetsDatasetVersionsResource {
  final commons.ApiRequester _requester;

  DatasetsDatasetVersionsResource(commons.ApiRequester client)
      : _requester = client;

  /// Create a version from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1DatasetVersion request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DatasetVersion> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DatasetVersion.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists DatasetVersions in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list
  /// DatasetVersions from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern `^datasets/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDatasetVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDatasetVersionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDatasetVersionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a DatasetVersion.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the DatasetVersion.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DatasetVersion> patch(
    GoogleCloudAiplatformV1DatasetVersion request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DatasetVersion.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Restores a dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DatasetVersion resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern `^datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> restore(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':restore';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class EndpointsResource {
  final commons.ApiRequester _requester;

  EndpointsResource(commons.ApiRequester client) : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ComputeTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CountTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse> generateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PredictResponse> predict(
    GoogleCloudAiplatformV1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse>
      streamGenerateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class MediaResource {
  final commons.ApiRequester _requester;

  MediaResource(commons.ApiRequester client) : _requester = client;

  /// Upload a file into a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the RagCorpus resource into which to
  /// upload the file. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// [uploadMedia] - The media to upload.
  ///
  /// Completes with a [GoogleCloudAiplatformV1UploadRagFileResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1UploadRagFileResponse> upload(
    GoogleCloudAiplatformV1UploadRagFileRequest request,
    core.String parent, {
    core.String? $fields,
    commons.Media? uploadMedia,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    core.String url_;
    if (uploadMedia == null) {
      url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/ragFiles:upload';
    } else {
      url_ =
          '/upload/v1/' + core.Uri.encodeFull('$parent') + '/ragFiles:upload';
    }

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
      uploadMedia: uploadMedia,
      uploadOptions: commons.UploadOptions.defaultOptions,
    );
    return GoogleCloudAiplatformV1UploadRagFileResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsResource get locations =>
      ProjectsLocationsResource(_requester);

  ProjectsResource(commons.ApiRequester client) : _requester = client;

  /// Gets a GenAI cache config.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Name of the cache config. Format: -
  /// `projects/{project}/cacheConfig`.
  /// Value must have pattern `^projects/\[^/\]+/cacheConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CacheConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CacheConfig> getCacheConfig(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CacheConfig.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a cache config.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the cache config. Format: -
  /// `projects/{project}/cacheConfig`.
  /// Value must have pattern `^projects/\[^/\]+/cacheConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> updateCacheConfig(
    GoogleCloudAiplatformV1CacheConfig request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsBatchPredictionJobsResource get batchPredictionJobs =>
      ProjectsLocationsBatchPredictionJobsResource(_requester);
  ProjectsLocationsCachedContentsResource get cachedContents =>
      ProjectsLocationsCachedContentsResource(_requester);
  ProjectsLocationsCustomJobsResource get customJobs =>
      ProjectsLocationsCustomJobsResource(_requester);
  ProjectsLocationsDataLabelingJobsResource get dataLabelingJobs =>
      ProjectsLocationsDataLabelingJobsResource(_requester);
  ProjectsLocationsDatasetsResource get datasets =>
      ProjectsLocationsDatasetsResource(_requester);
  ProjectsLocationsDeploymentResourcePoolsResource
      get deploymentResourcePools =>
          ProjectsLocationsDeploymentResourcePoolsResource(_requester);
  ProjectsLocationsEndpointsResource get endpoints =>
      ProjectsLocationsEndpointsResource(_requester);
  ProjectsLocationsFeatureGroupsResource get featureGroups =>
      ProjectsLocationsFeatureGroupsResource(_requester);
  ProjectsLocationsFeatureOnlineStoresResource get featureOnlineStores =>
      ProjectsLocationsFeatureOnlineStoresResource(_requester);
  ProjectsLocationsFeaturestoresResource get featurestores =>
      ProjectsLocationsFeaturestoresResource(_requester);
  ProjectsLocationsHyperparameterTuningJobsResource
      get hyperparameterTuningJobs =>
          ProjectsLocationsHyperparameterTuningJobsResource(_requester);
  ProjectsLocationsIndexEndpointsResource get indexEndpoints =>
      ProjectsLocationsIndexEndpointsResource(_requester);
  ProjectsLocationsIndexesResource get indexes =>
      ProjectsLocationsIndexesResource(_requester);
  ProjectsLocationsMetadataStoresResource get metadataStores =>
      ProjectsLocationsMetadataStoresResource(_requester);
  ProjectsLocationsMigratableResourcesResource get migratableResources =>
      ProjectsLocationsMigratableResourcesResource(_requester);
  ProjectsLocationsModelDeploymentMonitoringJobsResource
      get modelDeploymentMonitoringJobs =>
          ProjectsLocationsModelDeploymentMonitoringJobsResource(_requester);
  ProjectsLocationsModelsResource get models =>
      ProjectsLocationsModelsResource(_requester);
  ProjectsLocationsNasJobsResource get nasJobs =>
      ProjectsLocationsNasJobsResource(_requester);
  ProjectsLocationsNotebookExecutionJobsResource get notebookExecutionJobs =>
      ProjectsLocationsNotebookExecutionJobsResource(_requester);
  ProjectsLocationsNotebookRuntimeTemplatesResource
      get notebookRuntimeTemplates =>
          ProjectsLocationsNotebookRuntimeTemplatesResource(_requester);
  ProjectsLocationsNotebookRuntimesResource get notebookRuntimes =>
      ProjectsLocationsNotebookRuntimesResource(_requester);
  ProjectsLocationsOperationsResource get operations =>
      ProjectsLocationsOperationsResource(_requester);
  ProjectsLocationsPersistentResourcesResource get persistentResources =>
      ProjectsLocationsPersistentResourcesResource(_requester);
  ProjectsLocationsPipelineJobsResource get pipelineJobs =>
      ProjectsLocationsPipelineJobsResource(_requester);
  ProjectsLocationsPublishersResource get publishers =>
      ProjectsLocationsPublishersResource(_requester);
  ProjectsLocationsRagCorporaResource get ragCorpora =>
      ProjectsLocationsRagCorporaResource(_requester);
  ProjectsLocationsReasoningEnginesResource get reasoningEngines =>
      ProjectsLocationsReasoningEnginesResource(_requester);
  ProjectsLocationsSchedulesResource get schedules =>
      ProjectsLocationsSchedulesResource(_requester);
  ProjectsLocationsSpecialistPoolsResource get specialistPools =>
      ProjectsLocationsSpecialistPoolsResource(_requester);
  ProjectsLocationsStudiesResource get studies =>
      ProjectsLocationsStudiesResource(_requester);
  ProjectsLocationsTensorboardsResource get tensorboards =>
      ProjectsLocationsTensorboardsResource(_requester);
  ProjectsLocationsTrainingPipelinesResource get trainingPipelines =>
      ProjectsLocationsTrainingPipelinesResource(_requester);
  ProjectsLocationsTuningJobsResource get tuningJobs =>
      ProjectsLocationsTuningJobsResource(_requester);

  ProjectsLocationsResource(commons.ApiRequester client) : _requester = client;

  /// Given an input prompt, it returns augmented prompt from vertex rag store
  /// to guide LLM towards generating grounded responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to
  /// augment prompt. The users must have permission to make a call in the
  /// project. Format: `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1AugmentPromptResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AugmentPromptResponse> augmentPrompt(
    GoogleCloudAiplatformV1AugmentPromptRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + ':augmentPrompt';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AugmentPromptResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Given an input text, it returns a score that evaluates the factuality of
  /// the text.
  ///
  /// It also extracts and returns claims from the text and provides supporting
  /// facts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to
  /// corroborate text. The users must have permission to make a call in the
  /// project. Format: `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CorroborateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CorroborateContentResponse>
      corroborateContent(
    GoogleCloudAiplatformV1CorroborateContentRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + ':corroborateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CorroborateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Evaluates a dataset based on a set of given metrics.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The resource name of the Location to evaluate the
  /// dataset. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> evaluateDataset(
    GoogleCloudAiplatformV1EvaluateDatasetRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$location') + ':evaluateDataset';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Evaluates instances based on a given metric.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The resource name of the Location to evaluate the
  /// instances. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1EvaluateInstancesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1EvaluateInstancesResponse>
      evaluateInstances(
    GoogleCloudAiplatformV1EvaluateInstancesRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$location') + ':evaluateInstances';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1EvaluateInstancesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets information about a location.
  ///
  /// Request parameters:
  ///
  /// [name] - Resource name for the location.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudLocationLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudLocationLocation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudLocationLocation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource that owns the locations collection, if applicable.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [filter] - A filter to narrow down results to a preferred subset. The
  /// filtering language accepts strings like `"displayName=tokyo"`, and is
  /// documented in more detail in \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - The maximum number of results to return. If not set, the
  /// service selects a default.
  ///
  /// [pageToken] - A page token received from the `next_page_token` field in
  /// the response. Send that page token to receive the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudLocationListLocationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudLocationListLocationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/locations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudLocationListLocationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves relevant contexts for a query.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to
  /// retrieve RagContexts. The users must have permission to make a call in the
  /// project. Format: `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1RetrieveContextsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1RetrieveContextsResponse>
      retrieveContexts(
    GoogleCloudAiplatformV1RetrieveContextsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + ':retrieveContexts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1RetrieveContextsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsBatchPredictionJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsBatchPredictionJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a BatchPredictionJob.
  ///
  /// Starts asynchronous cancellation on the BatchPredictionJob. The server
  /// makes the best effort to cancel the job, but success is not guaranteed.
  /// Clients can use JobService.GetBatchPredictionJob or other methods to check
  /// whether the cancellation succeeded or whether the job completed despite
  /// cancellation. On a successful cancellation, the BatchPredictionJob is not
  /// deleted;instead its BatchPredictionJob.state is set to `CANCELLED`. Any
  /// files already outputted by the job are not deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob to cancel. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelBatchPredictionJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a BatchPredictionJob.
  ///
  /// A BatchPredictionJob once created will right away be attempted to start.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchPredictionJob> create(
    GoogleCloudAiplatformV1BatchPredictionJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a BatchPredictionJob.
  ///
  /// Can only be called on jobs that already finished.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a BatchPredictionJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob resource. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchPredictionJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists BatchPredictionJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// BatchPredictionJobs from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. *
  /// \`model_display_name\` supports \`=\`, \`!=\` comparisons. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListBatchPredictionJobsResponse.next_page_token of the previous
  /// JobService.ListBatchPredictionJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListBatchPredictionJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListBatchPredictionJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListBatchPredictionJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsCachedContentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCachedContentsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates cached content, this call will initialize the cached content in
  /// the data storage, and users need to pay for the cache data storage.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource where the cached content will be
  /// created
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CachedContent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CachedContent> create(
    GoogleCloudAiplatformV1CachedContent request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/cachedContents';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CachedContent.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes cached content
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name referring to the cached content
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cachedContents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets cached content configurations
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name referring to the cached content
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cachedContents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CachedContent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CachedContent> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CachedContent.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists cached contents in a project
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent, which owns this collection of cached
  /// contents.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The maximum number of cached contents to return.
  /// The service may return fewer than this value. If unspecified, some default
  /// (under maximum) number of items will be returned. The maximum value is
  /// 1000; values above 1000 will be coerced to 1000.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListCachedContents` call. Provide this to retrieve the subsequent page.
  /// When paginating, all other parameters provided to `ListCachedContents`
  /// must match the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListCachedContentsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListCachedContentsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/cachedContents';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListCachedContentsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates cached content configurations
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Identifier. The server-generated resource name of the
  /// cached content Format:
  /// projects/{project}/locations/{location}/cachedContents/{cached_content}
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cachedContents/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The list of fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CachedContent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CachedContent> patch(
    GoogleCloudAiplatformV1CachedContent request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CachedContent.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsCustomJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCustomJobsOperationsResource get operations =>
      ProjectsLocationsCustomJobsOperationsResource(_requester);

  ProjectsLocationsCustomJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a CustomJob.
  ///
  /// Starts asynchronous cancellation on the CustomJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// JobService.GetCustomJob or other methods to check whether the cancellation
  /// succeeded or whether the job completed despite cancellation. On successful
  /// cancellation, the CustomJob is not deleted; instead it becomes a job with
  /// a CustomJob.error value with a google.rpc.Status.code of 1, corresponding
  /// to `Code.CANCELLED`, and CustomJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob to cancel. Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelCustomJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a CustomJob.
  ///
  /// A created CustomJob right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// CustomJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CustomJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CustomJob> create(
    GoogleCloudAiplatformV1CustomJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/customJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CustomJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a CustomJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a CustomJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob resource. Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CustomJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CustomJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CustomJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists CustomJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// CustomJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListCustomJobsResponse.next_page_token of the previous
  /// JobService.ListCustomJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListCustomJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListCustomJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/customJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListCustomJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsCustomJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCustomJobsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDataLabelingJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataLabelingJobsOperationsResource get operations =>
      ProjectsLocationsDataLabelingJobsOperationsResource(_requester);

  ProjectsLocationsDataLabelingJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a DataLabelingJob.
  ///
  /// Success of cancellation is not guaranteed.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelDataLabelingJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a DataLabelingJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DataLabelingJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DataLabelingJob> create(
    GoogleCloudAiplatformV1DataLabelingJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/dataLabelingJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DataLabelingJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a DataLabelingJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob to be deleted. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a DataLabelingJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DataLabelingJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DataLabelingJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DataLabelingJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists DataLabelingJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order by default. Use `desc` after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read. FieldMask represents a
  /// set of symbolic field paths. For example, the mask can be `paths: "name"`.
  /// The "name" here is a field in DataLabelingJob. If this field is not set,
  /// all fields of the DataLabelingJob are returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDataLabelingJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDataLabelingJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/dataLabelingJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDataLabelingJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDataLabelingJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataLabelingJobsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsResource get annotationSpecs =>
      ProjectsLocationsDatasetsAnnotationSpecsResource(_requester);
  ProjectsLocationsDatasetsDataItemsResource get dataItems =>
      ProjectsLocationsDatasetsDataItemsResource(_requester);
  ProjectsLocationsDatasetsDatasetVersionsResource get datasetVersions =>
      ProjectsLocationsDatasetsDatasetVersionsResource(_requester);
  ProjectsLocationsDatasetsOperationsResource get operations =>
      ProjectsLocationsDatasetsOperationsResource(_requester);
  ProjectsLocationsDatasetsSavedQueriesResource get savedQueries =>
      ProjectsLocationsDatasetsSavedQueriesResource(_requester);

  ProjectsLocationsDatasetsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Dataset in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Dataset request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasets';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports data from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> export(
    GoogleCloudAiplatformV1ExportDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':export';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Dataset> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Dataset.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Imports data into a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudAiplatformV1ImportDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Datasets in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset's parent resource. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. *
  /// \`display_name\`: supports = and != * \`metadata_schema_uri\`: supports =
  /// and != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. Some examples: * \`displayName="myDisplayName"\` *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDatasetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDatasetsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasets';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDatasetsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the Dataset.
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name` * `description` * `labels`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Dataset> patch(
    GoogleCloudAiplatformV1Dataset request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Dataset.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches DataItems in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [dataset] - Required. The resource name of the Dataset from which to
  /// search DataItems. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [annotationFilters] - An expression that specifies what Annotations will
  /// be returned per DataItem. Annotations satisfied either of the conditions
  /// will be returned. * `annotation_spec_id` - for = or !=. Must specify
  /// `saved_query_id=` - saved query id that annotations should belong to.
  ///
  /// [annotationsFilter] - An expression for filtering the Annotations that
  /// will be returned per DataItem. * `annotation_spec_id` - for = or !=.
  ///
  /// [annotationsLimit] - If set, only up to this many of Annotations will be
  /// returned per DataItemView. The maximum value is 1000. If not set, the
  /// maximum value will be used.
  ///
  /// [dataItemFilter] - An expression for filtering the DataItem that will be
  /// returned. * `data_item_id` - for = or !=. * `labeled` - for = or !=. *
  /// `has_annotation(ANNOTATION_SPEC_ID)` - true only for DataItem that have at
  /// least one annotation with annotation_spec_id = `ANNOTATION_SPEC_ID` in the
  /// context of SavedQuery or DataLabelingJob. For example: * `data_item=1` *
  /// `has_annotation(5)`
  ///
  /// [dataLabelingJob] - The resource name of a DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// If this field is set, all of the search will be done in the context of
  /// this DataLabelingJob.
  ///
  /// [fieldMask] - Mask specifying which fields of DataItemView to read.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [orderByAnnotation_orderBy] - A comma-separated list of annotation fields
  /// to order by, sorted in ascending order. Use "desc" after a field name for
  /// descending. Must also specify saved_query.
  ///
  /// [orderByAnnotation_savedQuery] - Required. Saved query of the Annotation.
  /// Only Annotations belong to this saved query will be considered for
  /// ordering.
  ///
  /// [orderByDataItem] - A comma-separated list of data item fields to order
  /// by, sorted in ascending order. Use "desc" after a field name for
  /// descending.
  ///
  /// [pageSize] - Requested page size. Server may return fewer results than
  /// requested. Default and maximum page size is 100.
  ///
  /// [pageToken] - A token identifying a page of results for the server to
  /// return Typically obtained via SearchDataItemsResponse.next_page_token of
  /// the previous DatasetService.SearchDataItems call.
  ///
  /// [savedQuery] - The resource name of a SavedQuery(annotation set in UI).
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// All of the search will be done in the context of this SavedQuery.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SearchDataItemsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SearchDataItemsResponse> searchDataItems(
    core.String dataset, {
    core.List<core.String>? annotationFilters,
    core.String? annotationsFilter,
    core.int? annotationsLimit,
    core.String? dataItemFilter,
    core.String? dataLabelingJob,
    core.String? fieldMask,
    core.String? orderBy,
    core.String? orderByAnnotation_orderBy,
    core.String? orderByAnnotation_savedQuery,
    core.String? orderByDataItem,
    core.int? pageSize,
    core.String? pageToken,
    core.String? savedQuery,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (annotationFilters != null) 'annotationFilters': annotationFilters,
      if (annotationsFilter != null) 'annotationsFilter': [annotationsFilter],
      if (annotationsLimit != null) 'annotationsLimit': ['${annotationsLimit}'],
      if (dataItemFilter != null) 'dataItemFilter': [dataItemFilter],
      if (dataLabelingJob != null) 'dataLabelingJob': [dataLabelingJob],
      if (fieldMask != null) 'fieldMask': [fieldMask],
      if (orderBy != null) 'orderBy': [orderBy],
      if (orderByAnnotation_orderBy != null)
        'orderByAnnotation.orderBy': [orderByAnnotation_orderBy],
      if (orderByAnnotation_savedQuery != null)
        'orderByAnnotation.savedQuery': [orderByAnnotation_savedQuery],
      if (orderByDataItem != null) 'orderByDataItem': [orderByDataItem],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (savedQuery != null) 'savedQuery': [savedQuery],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$dataset') + ':searchDataItems';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchDataItemsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsAnnotationSpecsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsOperationsResource get operations =>
      ProjectsLocationsDatasetsAnnotationSpecsOperationsResource(_requester);

  ProjectsLocationsDatasetsAnnotationSpecsResource(commons.ApiRequester client)
      : _requester = client;

  /// Gets an AnnotationSpec.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the AnnotationSpec resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1AnnotationSpec].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AnnotationSpec> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AnnotationSpec.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsAnnotationSpecsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsResource get annotations =>
      ProjectsLocationsDatasetsDataItemsAnnotationsResource(_requester);
  ProjectsLocationsDatasetsDataItemsOperationsResource get operations =>
      ProjectsLocationsDatasetsDataItemsOperationsResource(_requester);

  ProjectsLocationsDatasetsDataItemsResource(commons.ApiRequester client)
      : _requester = client;

  /// Lists DataItems in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list DataItems
  /// from. Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDataItemsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDataItemsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/dataItems';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDataItemsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsAnnotationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource
      get operations =>
          ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource(
              _requester);

  ProjectsLocationsDatasetsDataItemsAnnotationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Lists Annotations belongs to a dataitem This RPC is only available in
  /// InternalDatasetService.
  ///
  /// It is only used for exporting conversation data to CCAI Insights.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the DataItem to list Annotations
  /// from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListAnnotationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListAnnotationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/annotations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListAnnotationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDatasetVersionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDatasetVersionsResource(commons.ApiRequester client)
      : _requester = client;

  /// Create a version from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1DatasetVersion request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DatasetVersion> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DatasetVersion.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists DatasetVersions in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list
  /// DatasetVersions from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDatasetVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDatasetVersionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDatasetVersionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a DatasetVersion.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Identifier. The resource name of the DatasetVersion.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DatasetVersion> patch(
    GoogleCloudAiplatformV1DatasetVersion request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DatasetVersion.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Restores a dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DatasetVersion resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> restore(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':restore';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsSavedQueriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsSavedQueriesOperationsResource get operations =>
      ProjectsLocationsDatasetsSavedQueriesOperationsResource(_requester);

  ProjectsLocationsDatasetsSavedQueriesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes a SavedQuery.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SavedQuery to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists SavedQueries in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list SavedQueries
  /// from. Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListSavedQueriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListSavedQueriesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/savedQueries';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListSavedQueriesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsSavedQueriesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsSavedQueriesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDeploymentResourcePoolsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDeploymentResourcePoolsOperationsResource get operations =>
      ProjectsLocationsDeploymentResourcePoolsOperationsResource(_requester);

  ProjectsLocationsDeploymentResourcePoolsResource(commons.ApiRequester client)
      : _requester = client;

  /// Create a DeploymentResourcePool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent location resource where this
  /// DeploymentResourcePool will be created. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/deploymentResourcePools';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Delete a DeploymentResourcePool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DeploymentResourcePool to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Get a DeploymentResourcePool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DeploymentResourcePool to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DeploymentResourcePool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DeploymentResourcePool> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DeploymentResourcePool.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// List DeploymentResourcePools in a location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent Location which owns this collection of
  /// DeploymentResourcePools. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of DeploymentResourcePools to return. The
  /// service may return fewer than this value.
  ///
  /// [pageToken] - A page token, received from a previous
  /// `ListDeploymentResourcePools` call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// `ListDeploymentResourcePools` must match the call that provided the page
  /// token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/deploymentResourcePools';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Update a DeploymentResourcePool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the DeploymentResourcePool.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The list of fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1DeploymentResourcePool request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// List DeployedModels that have been deployed on this
  /// DeploymentResourcePool.
  ///
  /// Request parameters:
  ///
  /// [deploymentResourcePool] - Required. The name of the target
  /// DeploymentResourcePool to query. Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of DeployedModels to return. The service
  /// may return fewer than this value.
  ///
  /// [pageToken] - A page token, received from a previous `QueryDeployedModels`
  /// call. Provide this to retrieve the subsequent page. When paginating, all
  /// other parameters provided to `QueryDeployedModels` must match the call
  /// that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1QueryDeployedModelsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1QueryDeployedModelsResponse>
      queryDeployedModels(
    core.String deploymentResourcePool, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$deploymentResourcePool') +
        ':queryDeployedModels';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1QueryDeployedModelsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDeploymentResourcePoolsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDeploymentResourcePoolsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsEndpointsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsChatResource get chat =>
      ProjectsLocationsEndpointsChatResource(_requester);
  ProjectsLocationsEndpointsOperationsResource get operations =>
      ProjectsLocationsEndpointsOperationsResource(_requester);

  ProjectsLocationsEndpointsResource(commons.ApiRequester client)
      : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ComputeTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CountTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates an Endpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Endpoint in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [endpointId] - Immutable. The ID to use for endpoint, which will become
  /// the final component of the endpoint resource name. If not provided, Vertex
  /// AI will generate a value for this ID. If the first character is a letter,
  /// this value may be up to 63 characters, and valid characters are
  /// `[a-z0-9-]`. The last character must be a letter or number. If the first
  /// character is a number, this value may be up to 9 characters, and valid
  /// characters are `[0-9]` with no leading zeros. When using HTTP/JSON, this
  /// field is populated based on a query string argument, such as
  /// `?endpoint_id=12345`. This is the fallback for fields that are not
  /// included in either the URI or the body.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Endpoint request,
    core.String parent, {
    core.String? endpointId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (endpointId != null) 'endpointId': [endpointId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/endpoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Endpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Endpoint resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deploys a Model into this Endpoint, creating a DeployedModel within it.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource into which to
  /// deploy a Model. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deployModel(
    GoogleCloudAiplatformV1DeployModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':deployModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// Vertex first-party products and frameworks.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DirectPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DirectPredictResponse> directPredict(
    GoogleCloudAiplatformV1DirectPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':directPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DirectPredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// custom containers.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DirectRawPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DirectRawPredictResponse>
      directRawPredict(
    GoogleCloudAiplatformV1DirectRawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':directRawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DirectRawPredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online explanation.
  ///
  /// If deployed_model_id is specified, the corresponding DeployModel must have
  /// explanation_spec populated. If deployed_model_id is not specified, all
  /// DeployedModels must have explanation_spec populated.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// explanation. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ExplainResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ExplainResponse> explain(
    GoogleCloudAiplatformV1ExplainRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':explain';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ExplainResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Fetch an asynchronous online prediction operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> fetchPredictOperation(
    GoogleCloudAiplatformV1FetchPredictOperationRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':fetchPredictOperation';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse> generateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets an Endpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Endpoint resource. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Endpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Endpoint> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Endpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Endpoints in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the Endpoints. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `endpoint` supports `=` and `!=`. `endpoint` represents the Endpoint ID,
  /// i.e. the last segment of the Endpoint's resource name. * `display_name`
  /// supports `=` and `!=`. * `labels` supports general map functions that is:
  /// * `labels.key=value` - key:value equality * `labels.key:*` or `labels:key`
  /// - key existence * A key including a space must be quoted. `labels."a
  /// key"`. * `base_model_name` only supports `=`. Some examples: *
  /// `endpoint=1` * `displayName="myDisplayName"` * `labels.myKey="myValue"` *
  /// `baseModelName="text-bison"`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time` Example:
  /// `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListEndpointsResponse.next_page_token of the previous
  /// EndpointService.ListEndpoints call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListEndpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListEndpointsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/endpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListEndpointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an existing deployed model.
  ///
  /// Updatable fields include `min_replica_count`, `max_replica_count`,
  /// `autoscaling_metric_specs`, `disable_container_logging` (v1 only), and
  /// `enable_container_logging` (v1beta1 only).
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource into which to
  /// mutate a DeployedModel. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> mutateDeployedModel(
    GoogleCloudAiplatformV1MutateDeployedModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':mutateDeployedModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an Endpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Endpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Endpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Endpoint> patch(
    GoogleCloudAiplatformV1Endpoint request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Endpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PredictResponse> predict(
    GoogleCloudAiplatformV1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> predictLongRunning(
    GoogleCloudAiplatformV1PredictLongRunningRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':predictLongRunning';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers: *
  /// `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction.
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's DeployedModel that
  /// served this prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> rawPredict(
    GoogleCloudAiplatformV1RawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':rawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a server-side streaming online prediction request for Vertex LLM
  /// streaming.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1StreamingPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1StreamingPredictResponse>
      serverStreamingPredict(
    GoogleCloudAiplatformV1StreamingPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':serverStreamingPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1StreamingPredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse>
      streamGenerateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a streaming online prediction with an arbitrary HTTP payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> streamRawPredict(
    GoogleCloudAiplatformV1StreamRawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':streamRawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Undeploys a Model from an Endpoint, removing a DeployedModel from it, and
  /// freeing all resources it's using.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource from which to
  /// undeploy a Model. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> undeployModel(
    GoogleCloudAiplatformV1UndeployModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':undeployModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an Endpoint with a long running operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Endpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> update(
    GoogleCloudAiplatformV1UpdateEndpointLongRunningRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':update';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsEndpointsChatResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsChatResource(commons.ApiRequester client)
      : _requester = client;

  /// Exposes an OpenAI-compatible endpoint for chat completions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> completions(
    GoogleApiHttpBody request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + '/chat/completions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsEndpointsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureGroupsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeaturesResource get features =>
      ProjectsLocationsFeatureGroupsFeaturesResource(_requester);
  ProjectsLocationsFeatureGroupsOperationsResource get operations =>
      ProjectsLocationsFeatureGroupsOperationsResource(_requester);

  ProjectsLocationsFeatureGroupsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a new FeatureGroup in a given project and location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create
  /// FeatureGroups. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [featureGroupId] - Required. The ID to use for this FeatureGroup, which
  /// will become the final component of the FeatureGroup's resource name. This
  /// value may be up to 128 characters, and valid characters are `[a-z0-9_]`.
  /// The first character cannot be a number. The value must be unique within
  /// the project and location.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1FeatureGroup request,
    core.String parent, {
    core.String? featureGroupId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureGroupId != null) 'featureGroupId': [featureGroupId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featureGroups';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single FeatureGroup.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureGroup to be deleted. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [force] - If set to true, any Features under this FeatureGroup will also
  /// be deleted. (Otherwise, the request will only work if the FeatureGroup has
  /// no Features.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single FeatureGroup.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureGroup resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1FeatureGroup].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1FeatureGroup> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1FeatureGroup.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists FeatureGroups in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// FeatureGroups. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureGroups that match the filter expression. The
  /// following fields are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// and key presence. Examples: * `create_time > "2020-01-01" OR update_time >
  /// "2020-01-01"` FeatureGroups created or updated after 2020-01-01. *
  /// `labels.env = "prod"` FeatureGroups with label "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// Fields: * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of FeatureGroups to return. The service
  /// may return fewer than this value. If unspecified, at most 100
  /// FeatureGroups will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureRegistryService.ListFeatureGroups call. Provide this to retrieve
  /// the subsequent page. When paginating, all other parameters provided to
  /// FeatureRegistryService.ListFeatureGroups must match the call that provided
  /// the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeatureGroupsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeatureGroupsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featureGroups';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeatureGroupsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single FeatureGroup.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the FeatureGroup. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the FeatureGroup resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `labels` * `description` * `big_query` *
  /// `big_query.entity_id_columns` * `service_agent_type`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1FeatureGroup request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureGroupsFeaturesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeaturesOperationsResource get operations =>
      ProjectsLocationsFeatureGroupsFeaturesOperationsResource(_requester);

  ProjectsLocationsFeatureGroupsFeaturesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a batch of Features in a given FeatureGroup.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType/FeatureGroup to
  /// create the batch of Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCreate(
    GoogleCloudAiplatformV1BatchCreateFeaturesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/features:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new Feature in a given FeatureGroup.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType or FeatureGroup
  /// to create a Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [featureId] - Required. The ID to use for the Feature, which will become
  /// the final component of the Feature's resource name. This value may be up
  /// to 128 characters, and valid characters are `[a-z0-9_]`. The first
  /// character cannot be a number. The value must be unique within an
  /// EntityType/FeatureGroup.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Feature request,
    core.String parent, {
    core.String? featureId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureId != null) 'featureId': [featureId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Features to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Feature resource. Format for
  /// entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Feature> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Feature.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Features in a given FeatureGroup.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+$`.
  ///
  /// [filter] - Lists the Features that match the filter expression. The
  /// following filters are supported: * `value_type`: Supports = and !=
  /// comparisons. * `create_time`: Supports =, !=, \<, \>, \>=, and \<=
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// =, !=, \<, \>, \>=, and \<= comparisons. Values must be in RFC 3339
  /// format. * `labels`: Supports key-value equality as well as key presence.
  /// Examples: * `value_type = DOUBLE` --\> Features whose type is DOUBLE. *
  /// `create_time > \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with 'env' as the key.
  ///
  /// [latestStatsCount] - Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent ListFeaturesRequest.latest_stats_count of
  /// stats for each Feature in response. Valid value is \[0, 10\]. If number of
  /// stats exists \< ListFeaturesRequest.latest_stats_count, return all
  /// existing stats.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `feature_id` * `value_type` (Not supported for FeatureRegistry
  /// Feature) * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 Features will
  /// be returned. The maximum value is 1000; any value greater than 1000 will
  /// be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeatures call or
  /// FeatureRegistryService.ListFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeatures or FeatureRegistryService.ListFeatures
  /// must match the call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeaturesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? latestStatsCount,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (latestStatsCount != null) 'latestStatsCount': ['${latestStatsCount}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeaturesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single Feature.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the Feature. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Features resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` * `disable_monitoring` (Not supported
  /// for FeatureRegistryService Feature) * `point_of_contact` (Not supported
  /// for FeaturestoreService FeatureStore)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1Feature request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureGroupsFeaturesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsFeaturesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> listWait(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureGroupsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureGroupsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> listWait(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureGroups/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureOnlineStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsResource get featureViews =>
      ProjectsLocationsFeatureOnlineStoresFeatureViewsResource(_requester);
  ProjectsLocationsFeatureOnlineStoresOperationsResource get operations =>
      ProjectsLocationsFeatureOnlineStoresOperationsResource(_requester);

  ProjectsLocationsFeatureOnlineStoresResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a new FeatureOnlineStore in a given project and location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create
  /// FeatureOnlineStores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [featureOnlineStoreId] - Required. The ID to use for this
  /// FeatureOnlineStore, which will become the final component of the
  /// FeatureOnlineStore's resource name. This value may be up to 60 characters,
  /// and valid characters are `[a-z0-9_]`. The first character cannot be a
  /// number. The value must be unique within the project and location.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1FeatureOnlineStore request,
    core.String parent, {
    core.String? featureOnlineStoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureOnlineStoreId != null)
        'featureOnlineStoreId': [featureOnlineStoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/featureOnlineStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single FeatureOnlineStore.
  ///
  /// The FeatureOnlineStore must not contain any FeatureViews.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureOnlineStore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [force] - If set to true, any FeatureViews and Features for this
  /// FeatureOnlineStore will also be deleted. (Otherwise, the request will only
  /// work if the FeatureOnlineStore has no FeatureViews.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single FeatureOnlineStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureOnlineStore resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1FeatureOnlineStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1FeatureOnlineStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1FeatureOnlineStore.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists FeatureOnlineStores in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// FeatureOnlineStores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureOnlineStores that match the filter expression.
  /// The following fields are supported: * `create_time`: Supports `=`, `!=`,
  /// `<`, `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// and key presence. Examples: * `create_time > "2020-01-01" OR update_time >
  /// "2020-01-01"` FeatureOnlineStores created or updated after 2020-01-01. *
  /// `labels.env = "prod"` FeatureOnlineStores with label "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// Fields: * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of FeatureOnlineStores to return. The
  /// service may return fewer than this value. If unspecified, at most 100
  /// FeatureOnlineStores will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureOnlineStoreAdminService.ListFeatureOnlineStores call. Provide this
  /// to retrieve the subsequent page. When paginating, all other parameters
  /// provided to FeatureOnlineStoreAdminService.ListFeatureOnlineStores must
  /// match the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/featureOnlineStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single FeatureOnlineStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the FeatureOnlineStore. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the FeatureOnlineStore resource by the update. The fields specified in
  /// the update_mask are relative to the resource, not the full request. A
  /// field will be overwritten if it is in the mask. If the user does not
  /// provide a mask then only the non-empty fields present in the request will
  /// be overwritten. Set the update_mask to `*` to override all fields.
  /// Updatable fields: * `labels` * `description` * `bigtable` *
  /// `bigtable.auto_scaling` * `bigtable.enable_multi_region_replica`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1FeatureOnlineStore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureOnlineStoresFeatureViewsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource
      get featureViewSyncs =>
          ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource(
              _requester);
  ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource
      get operations =>
          ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource(
              _requester);

  ProjectsLocationsFeatureOnlineStoresFeatureViewsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a new FeatureView in a given FeatureOnlineStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureOnlineStore to create
  /// FeatureViews. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [featureViewId] - Required. The ID to use for the FeatureView, which will
  /// become the final component of the FeatureView's resource name. This value
  /// may be up to 60 characters, and valid characters are `[a-z0-9_]`. The
  /// first character cannot be a number. The value must be unique within a
  /// FeatureOnlineStore.
  ///
  /// [runSyncImmediately] - Immutable. If set to true, one on demand sync will
  /// be run immediately, regardless whether the FeatureView.sync_config is
  /// configured or not.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1FeatureView request,
    core.String parent, {
    core.String? featureViewId,
    core.bool? runSyncImmediately,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureViewId != null) 'featureViewId': [featureViewId],
      if (runSyncImmediately != null)
        'runSyncImmediately': ['${runSyncImmediately}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featureViews';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single FeatureView.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureView to be deleted. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Fetch feature values under a FeatureView.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1FetchFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1FetchFeatureValuesResponse>
      fetchFeatureValues(
    GoogleCloudAiplatformV1FetchFeatureValuesRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$featureView') + ':fetchFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1FetchFeatureValuesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single FeatureView.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureView resource. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1FeatureView].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1FeatureView> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1FeatureView.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists FeatureViews in a given FeatureOnlineStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureOnlineStore to list
  /// FeatureViews. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureViews that match the filter expression. The
  /// following filters are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `>=`, and `<=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// as well as key presence. Examples: * `create_time >
  /// \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> FeatureViews created or updated
  /// after 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env =
  /// prod` --\> FeatureViews having both (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --\> Any FeatureView which has a label with 'env' as the
  /// key.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `feature_view_id` * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of FeatureViews to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 FeatureViews
  /// will be returned. The maximum value is 1000; any value greater than 1000
  /// will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureOnlineStoreAdminService.ListFeatureViews call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to FeatureOnlineStoreAdminService.ListFeatureViews must match the
  /// call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeatureViewsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeatureViewsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featureViews';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeatureViewsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single FeatureView.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. Name of the FeatureView. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the FeatureView resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `labels` * `service_agent_type` * `big_query_source` *
  /// `big_query_source.uri` * `big_query_source.entity_id_columns` *
  /// `feature_registry_source` * `feature_registry_source.feature_groups` *
  /// `sync_config` * `sync_config.cron` *
  /// `optimized_config.automatic_resources`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1FeatureView request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Search the nearest entities under a FeatureView.
  ///
  /// Search only works for indexable feature view; if a feature view isn't
  /// indexable, returns Invalid argument response.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SearchNearestEntitiesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SearchNearestEntitiesResponse>
      searchNearestEntities(
    GoogleCloudAiplatformV1SearchNearestEntitiesRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$featureView') + ':searchNearestEntities';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchNearestEntitiesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Triggers on-demand sync for the FeatureView.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featureView] - Required. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SyncFeatureViewResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SyncFeatureViewResponse> sync(
    GoogleCloudAiplatformV1SyncFeatureViewRequest request,
    core.String featureView, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$featureView') + ':sync';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SyncFeatureViewResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsFeatureViewSyncsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Gets details of a single FeatureViewSync.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the FeatureViewSync resource. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/featureViewSyncs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1FeatureViewSync].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1FeatureViewSync> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1FeatureViewSync.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists FeatureViewSyncs in a given FeatureView.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the FeatureView to list
  /// FeatureViewSyncs. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+$`.
  ///
  /// [filter] - Lists the FeatureViewSyncs that match the filter expression.
  /// The following filters are supported: * `create_time`: Supports `=`, `!=`,
  /// `<`, `>`, `>=`, and `<=` comparisons. Values must be in RFC 3339 format.
  /// Examples: * `create_time > \"2020-01-31T15:30:00.000000Z\"` --\>
  /// FeatureViewSyncs created after 2020-01-31T15:30:00.000000Z.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `create_time`
  ///
  /// [pageSize] - The maximum number of FeatureViewSyncs to return. The service
  /// may return fewer than this value. If unspecified, at most 1000
  /// FeatureViewSyncs will be returned. The maximum value is 1000; any value
  /// greater than 1000 will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeatureOnlineStoreAdminService.ListFeatureViewSyncs call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to FeatureOnlineStoreAdminService.ListFeatureViewSyncs must match
  /// the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeatureViewSyncsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeatureViewSyncsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featureViewSyncs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeatureViewSyncsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresFeatureViewsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> listWait(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/featureViews/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeatureOnlineStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeatureOnlineStoresOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> listWait(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featureOnlineStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesResource get entityTypes =>
      ProjectsLocationsFeaturestoresEntityTypesResource(_requester);
  ProjectsLocationsFeaturestoresOperationsResource get operations =>
      ProjectsLocationsFeaturestoresOperationsResource(_requester);

  ProjectsLocationsFeaturestoresResource(commons.ApiRequester client)
      : _requester = client;

  /// Batch reads Feature values from a Featurestore.
  ///
  /// This API enables batch reading Feature values, where each read instance in
  /// the batch may read Feature values of entities from one or more
  /// EntityTypes. Point-in-time correctness is guaranteed for Feature values of
  /// each read instance as of each instance's read timestamp.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featurestore] - Required. The resource name of the Featurestore from
  /// which to query Feature values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchReadFeatureValues(
    GoogleCloudAiplatformV1BatchReadFeatureValuesRequest request,
    core.String featurestore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$featurestore') +
        ':batchReadFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new Featurestore in a given project and location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create
  /// Featurestores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [featurestoreId] - Required. The ID to use for this Featurestore, which
  /// will become the final component of the Featurestore's resource name. This
  /// value may be up to 60 characters, and valid characters are `[a-z0-9_]`.
  /// The first character cannot be a number. The value must be unique within
  /// the project and location.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Featurestore request,
    core.String parent, {
    core.String? featurestoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featurestoreId != null) 'featurestoreId': [featurestoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featurestores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single Featurestore.
  ///
  /// The Featurestore must not contain any EntityTypes or `force` must be set
  /// to true for the request to succeed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Featurestore to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [force] - If set to true, any EntityTypes and Features for this
  /// Featurestore will also be deleted. (Otherwise, the request will only work
  /// if the Featurestore has no EntityTypes.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single Featurestore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Featurestore resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Featurestore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Featurestore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Featurestore.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Featurestores in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// Featurestores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the featurestores that match the filter expression. The
  /// following fields are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. *
  /// `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
  /// `<=`, and `>=` comparisons. * `labels`: Supports key-value equality and
  /// key presence. Examples: * `create_time > "2020-01-01" OR update_time >
  /// "2020-01-01"` Featurestores created or updated after 2020-01-01. *
  /// `labels.env = "prod"` Featurestores with label "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// Fields: * `create_time` * `update_time` *
  /// `online_serving_config.fixed_node_count`
  ///
  /// [pageSize] - The maximum number of Featurestores to return. The service
  /// may return fewer than this value. If unspecified, at most 100
  /// Featurestores will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeaturestores call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeaturestores must match the call that provided
  /// the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeaturestoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeaturestoresResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featurestores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeaturestoresResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single Featurestore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the Featurestore. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Featurestore resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `labels` * `online_serving_config.fixed_node_count` *
  /// `online_serving_config.scaling` * `online_storage_ttl_days`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1Featurestore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches Features matching a query in a given project.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The resource name of the Location to search
  /// Features. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Features will be
  /// returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.SearchFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.SearchFeatures, except `page_size`, must match the
  /// call that provided the page token.
  ///
  /// [query] - Query string that is a conjunction of field-restricted queries
  /// and/or field-restricted filters. Field-restricted queries and filters can
  /// be combined using `AND` to form a conjunction. A field query is in the
  /// form FIELD:QUERY. This implicitly checks if QUERY exists as a substring
  /// within Feature's FIELD. The QUERY and the FIELD are converted to a
  /// sequence of words (i.e. tokens) for comparison. This is done by: *
  /// Removing leading/trailing whitespace and tokenizing the search value.
  /// Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore `_`,
  /// or asterisk `*` are treated as delimiters for tokens. `*` is treated as a
  /// wildcard that matches characters within a token. * Ignoring case. *
  /// Prepending an asterisk to the first and appending an asterisk to the last
  /// token in QUERY. A QUERY must be either a singular token or a phrase. A
  /// phrase is one or multiple words enclosed in double quotation marks (").
  /// With phrases, the order of the words is important. Words in the phrase
  /// must be matching in order and consecutively. Supported FIELDs for
  /// field-restricted queries: * `feature_id` * `description` *
  /// `entity_type_id` Examples: * `feature_id: foo` --\> Matches a Feature with
  /// ID containing the substring `foo` (eg. `foo`, `foofeature`, `barfoo`). *
  /// `feature_id: foo*feature` --\> Matches a Feature with ID containing the
  /// substring `foo*feature` (eg. `foobarfeature`). * `feature_id: foo AND
  /// description: bar` --\> Matches a Feature with ID containing the substring
  /// `foo` and description containing the substring `bar`. Besides field
  /// queries, the following exact-match filters are supported. The exact-match
  /// filters do not support wildcards. Unlike field-restricted queries,
  /// exact-match filters are case-sensitive. * `feature_id`: Supports =
  /// comparisons. * `description`: Supports = comparisons. Multi-token filters
  /// should be enclosed in quotes. * `entity_type_id`: Supports = comparisons.
  /// * `value_type`: Supports = and != comparisons. * `labels`: Supports
  /// key-value equality as well as key presence. * `featurestore_id`: Supports
  /// = comparisons. Examples: * `description = "foo bar"` --\> Any Feature with
  /// description exactly equal to `foo bar` * `value_type = DOUBLE` --\>
  /// Features whose type is DOUBLE. * `labels.active = yes AND labels.env =
  /// prod` --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with `env` as the key.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SearchFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SearchFeaturesResponse> searchFeatures(
    core.String location, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? query,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (query != null) 'query': [query],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$location') +
        '/featurestores:searchFeatures';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchFeaturesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesResource get features =>
      ProjectsLocationsFeaturestoresEntityTypesFeaturesResource(_requester);
  ProjectsLocationsFeaturestoresEntityTypesOperationsResource get operations =>
      ProjectsLocationsFeaturestoresEntityTypesOperationsResource(_requester);

  ProjectsLocationsFeaturestoresEntityTypesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a new EntityType in a given Featurestore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Featurestore to create
  /// EntityTypes. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [entityTypeId] - Required. The ID to use for the EntityType, which will
  /// become the final component of the EntityType's resource name. This value
  /// may be up to 60 characters, and valid characters are `[a-z0-9_]`. The
  /// first character cannot be a number. The value must be unique within a
  /// featurestore.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1EntityType request,
    core.String parent, {
    core.String? entityTypeId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (entityTypeId != null) 'entityTypeId': [entityTypeId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/entityTypes';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single EntityType.
  ///
  /// The EntityType must not have any Features or `force` must be set to true
  /// for the request to succeed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the EntityType to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [force] - If set to true, any Features for this EntityType will also be
  /// deleted. (Otherwise, the request will only work if the EntityType has no
  /// Features.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Delete Feature values from Featurestore.
  ///
  /// The progress of the deletion is tracked by the returned operation. The
  /// deleted feature values are guaranteed to be invisible to subsequent read
  /// operations after the operation is marked as successfully done. If a delete
  /// feature values operation fails, the feature values returned from reads and
  /// exports may be inconsistent. If consistency is required, the caller must
  /// retry the same delete request again and wait till the new operation
  /// returned is marked as successfully done.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType grouping the
  /// Features for which values are being deleted from. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deleteFeatureValues(
    GoogleCloudAiplatformV1DeleteFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':deleteFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports Feature values from all the entities of a target EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType from which to
  /// export Feature values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> exportFeatureValues(
    GoogleCloudAiplatformV1ExportFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':exportFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single EntityType.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the EntityType resource. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1EntityType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1EntityType> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1EntityType.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Imports Feature values into the Featurestore from a source storage.
  ///
  /// The progress of the import is tracked by the returned operation. The
  /// imported features are guaranteed to be visible to subsequent read
  /// operations after the operation is marked as successfully done. If an
  /// import operation fails, the Feature values returned from reads and exports
  /// may be inconsistent. If consistency is required, the caller must retry the
  /// same import request again and wait till the new operation returned is
  /// marked as successfully done. There are also scenarios where the caller can
  /// cause inconsistency. - Source data for import contains multiple distinct
  /// Feature values for the same entity ID and timestamp. - Source is modified
  /// during an import. This includes adding, updating, or removing source data
  /// and/or metadata. Examples of updating metadata include but are not limited
  /// to changing storage location, storage class, or retention policy. - Online
  /// serving cluster is under-provisioned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType grouping the
  /// Features for which values are being imported. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> importFeatureValues(
    GoogleCloudAiplatformV1ImportFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':importFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists EntityTypes in a given Featurestore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Featurestore to list
  /// EntityTypes. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [filter] - Lists the EntityTypes that match the filter expression. The
  /// following filters are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `>=`, and `<=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// as well as key presence. Examples: * `create_time >
  /// \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> EntityTypes having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any EntityType which has a label with 'env' as the
  /// key.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `entity_type_id` * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of EntityTypes to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 EntityTypes
  /// will be returned. The maximum value is 1000; any value greater than 1000
  /// will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListEntityTypes call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListEntityTypes must match the call that provided the
  /// page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListEntityTypesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListEntityTypesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/entityTypes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListEntityTypesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the EntityType. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// The last part entity_type is assigned by the client. The entity_type can
  /// be up to 64 characters long and can consist only of ASCII Latin letters
  /// A-Z and a-z and underscore(_), and ASCII digits 0-9 starting with a
  /// letter. The value will be unique given a featurestore.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the EntityType resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` *
  /// `monitoring_config.snapshot_analysis.disabled` *
  /// `monitoring_config.snapshot_analysis.monitoring_interval_days` *
  /// `monitoring_config.snapshot_analysis.staleness_days` *
  /// `monitoring_config.import_features_analysis.state` *
  /// `monitoring_config.import_features_analysis.anomaly_detection_baseline` *
  /// `monitoring_config.numerical_threshold_config.value` *
  /// `monitoring_config.categorical_threshold_config.value` *
  /// `offline_storage_ttl_days`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1EntityType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1EntityType> patch(
    GoogleCloudAiplatformV1EntityType request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1EntityType.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads Feature values of a specific entity of an EntityType.
  ///
  /// For reading feature values of multiple entities of an EntityType, please
  /// use StreamingReadFeatureValues.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType for the
  /// entity being read. Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadFeatureValuesResponse>
      readFeatureValues(
    GoogleCloudAiplatformV1ReadFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':readFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadFeatureValuesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads Feature values for multiple entities.
  ///
  /// Depending on their size, data for different entities may be broken up
  /// across multiple responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the entities' type. Value
  /// format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadFeatureValuesResponse>
      streamingReadFeatureValues(
    GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$entityType') +
        ':streamingReadFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadFeatureValuesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Writes Feature values of one or more entities of an EntityType.
  ///
  /// The Feature values are merged into existing entities if any. The Feature
  /// values to be written must have timestamp within the online storage
  /// retention.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType for the
  /// entities being written. Value format:
  /// `projects/{project}/locations/{location}/featurestores/
  /// {featurestore}/entityTypes/{entityType}`. For example, for a machine
  /// learning model predicting user clicks on a website, an EntityType ID could
  /// be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1WriteFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1WriteFeatureValuesResponse>
      writeFeatureValues(
    GoogleCloudAiplatformV1WriteFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':writeFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1WriteFeatureValuesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesFeaturesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource
      get operations =>
          ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource(
              _requester);

  ProjectsLocationsFeaturestoresEntityTypesFeaturesResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a batch of Features in a given EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType/FeatureGroup to
  /// create the batch of Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCreate(
    GoogleCloudAiplatformV1BatchCreateFeaturesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/features:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new Feature in a given EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType or FeatureGroup
  /// to create a Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [featureId] - Required. The ID to use for the Feature, which will become
  /// the final component of the Feature's resource name. This value may be up
  /// to 128 characters, and valid characters are `[a-z0-9_]`. The first
  /// character cannot be a number. The value must be unique within an
  /// EntityType/FeatureGroup.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Feature request,
    core.String parent, {
    core.String? featureId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureId != null) 'featureId': [featureId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Features to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Feature resource. Format for
  /// entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Feature> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Feature.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Features in a given EntityType.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [filter] - Lists the Features that match the filter expression. The
  /// following filters are supported: * `value_type`: Supports = and !=
  /// comparisons. * `create_time`: Supports =, !=, \<, \>, \>=, and \<=
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// =, !=, \<, \>, \>=, and \<= comparisons. Values must be in RFC 3339
  /// format. * `labels`: Supports key-value equality as well as key presence.
  /// Examples: * `value_type = DOUBLE` --\> Features whose type is DOUBLE. *
  /// `create_time > \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with 'env' as the key.
  ///
  /// [latestStatsCount] - Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent ListFeaturesRequest.latest_stats_count of
  /// stats for each Feature in response. Valid value is \[0, 10\]. If number of
  /// stats exists \< ListFeaturesRequest.latest_stats_count, return all
  /// existing stats.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `feature_id` * `value_type` (Not supported for FeatureRegistry
  /// Feature) * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 Features will
  /// be returned. The maximum value is 1000; any value greater than 1000 will
  /// be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeatures call or
  /// FeatureRegistryService.ListFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeatures or FeatureRegistryService.ListFeatures
  /// must match the call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeaturesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? latestStatsCount,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (latestStatsCount != null) 'latestStatsCount': ['${latestStatsCount}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeaturesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single Feature.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the Feature. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Features resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` * `disable_monitoring` (Not supported
  /// for FeatureRegistryService Feature) * `point_of_contact` (Not supported
  /// for FeaturestoreService FeatureStore)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Feature> patch(
    GoogleCloudAiplatformV1Feature request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Feature.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsHyperparameterTuningJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsHyperparameterTuningJobsOperationsResource get operations =>
      ProjectsLocationsHyperparameterTuningJobsOperationsResource(_requester);

  ProjectsLocationsHyperparameterTuningJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a HyperparameterTuningJob.
  ///
  /// Starts asynchronous cancellation on the HyperparameterTuningJob. The
  /// server makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use JobService.GetHyperparameterTuningJob or other
  /// methods to check whether the cancellation succeeded or whether the job
  /// completed despite cancellation. On successful cancellation, the
  /// HyperparameterTuningJob is not deleted; instead it becomes a job with a
  /// HyperparameterTuningJob.error value with a google.rpc.Status.code of 1,
  /// corresponding to `Code.CANCELLED`, and HyperparameterTuningJob.state is
  /// set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HyperparameterTuningJob
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// HyperparameterTuningJob in. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1HyperparameterTuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1HyperparameterTuningJob> create(
    GoogleCloudAiplatformV1HyperparameterTuningJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/hyperparameterTuningJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a HyperparameterTuningJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a HyperparameterTuningJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1HyperparameterTuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1HyperparameterTuningJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists HyperparameterTuningJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// HyperparameterTuningJobs from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListHyperparameterTuningJobsResponse.next_page_token of the previous
  /// JobService.ListHyperparameterTuningJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse>
      list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/hyperparameterTuningJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsHyperparameterTuningJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsHyperparameterTuningJobsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexEndpointsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexEndpointsOperationsResource get operations =>
      ProjectsLocationsIndexEndpointsOperationsResource(_requester);

  ProjectsLocationsIndexEndpointsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// IndexEndpoint in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1IndexEndpoint request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexEndpoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an IndexEndpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the IndexEndpoint resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deploys an Index into this IndexEndpoint, creating a DeployedIndex within
  /// it.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource into
  /// which to deploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deployIndex(
    GoogleCloudAiplatformV1DeployIndexRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':deployIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Finds the nearest neighbors of each vector within the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the index endpoint. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1FindNeighborsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1FindNeighborsResponse> findNeighbors(
    GoogleCloudAiplatformV1FindNeighborsRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':findNeighbors';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1FindNeighborsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets an IndexEndpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the IndexEndpoint resource. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1IndexEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1IndexEndpoint> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1IndexEndpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists IndexEndpoints in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the IndexEndpoints. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `index_endpoint` supports = and !=. `index_endpoint` represents the
  /// IndexEndpoint ID, ie. the last segment of the IndexEndpoint's
  /// resourcename. * `display_name` supports =, != and regex() (uses
  /// [re2](https://github.com/google/re2/wiki/Syntax) syntax) * `labels`
  /// supports general map functions that is: `labels.key=value` - key:value
  /// equality `labels.key:* or labels:key - key existence A key including a
  /// space must be quoted. `labels."a key"`. Some examples: *
  /// `index_endpoint="1"` * `display_name="myDisplayName"` *
  /// `regex(display_name, "^A") -\> The display name starts with an A. *
  /// `labels.myKey="myValue"`
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListIndexEndpointsResponse.next_page_token of the previous
  /// IndexEndpointService.ListIndexEndpoints call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListIndexEndpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListIndexEndpointsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexEndpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListIndexEndpointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Update an existing DeployedIndex under an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource into
  /// which to deploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> mutateDeployedIndex(
    GoogleCloudAiplatformV1DeployedIndex request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':mutateDeployedIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the IndexEndpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1IndexEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1IndexEndpoint> patch(
    GoogleCloudAiplatformV1IndexEndpoint request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1IndexEndpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads the datapoints/vectors of the given IDs.
  ///
  /// A maximum of 1000 datapoints can be retrieved in a batch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the index endpoint. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadIndexDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadIndexDatapointsResponse>
      readIndexDatapoints(
    GoogleCloudAiplatformV1ReadIndexDatapointsRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':readIndexDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadIndexDatapointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Undeploys an Index from an IndexEndpoint, removing a DeployedIndex from
  /// it, and freeing all resources it's using.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource from
  /// which to undeploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> undeployIndex(
    GoogleCloudAiplatformV1UndeployIndexRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':undeployIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexEndpointsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexEndpointsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexesOperationsResource get operations =>
      ProjectsLocationsIndexesOperationsResource(_requester);

  ProjectsLocationsIndexesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the Index
  /// in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Index request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexes';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Index.
  ///
  /// An Index can only be deleted when all its DeployedIndexes had been
  /// undeployed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Index resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets an Index.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Index resource. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Index].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Index> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Index.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Indexes in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the Indexes. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListIndexesResponse.next_page_token of the previous
  /// IndexService.ListIndexes call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListIndexesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListIndexesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListIndexesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Index.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [updateMask] - The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1Index request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Remove Datapoints from an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [index] - Required. The name of the Index resource to be updated. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1RemoveDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1RemoveDatapointsResponse>
      removeDatapoints(
    GoogleCloudAiplatformV1RemoveDatapointsRequest request,
    core.String index, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$index') + ':removeDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1RemoveDatapointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Add/update Datapoints into an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [index] - Required. The name of the Index resource to be updated. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1UpsertDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1UpsertDatapointsResponse>
      upsertDatapoints(
    GoogleCloudAiplatformV1UpsertDatapointsRequest request,
    core.String index, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$index') + ':upsertDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1UpsertDatapointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexesOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsResource get artifacts =>
      ProjectsLocationsMetadataStoresArtifactsResource(_requester);
  ProjectsLocationsMetadataStoresContextsResource get contexts =>
      ProjectsLocationsMetadataStoresContextsResource(_requester);
  ProjectsLocationsMetadataStoresExecutionsResource get executions =>
      ProjectsLocationsMetadataStoresExecutionsResource(_requester);
  ProjectsLocationsMetadataStoresMetadataSchemasResource get metadataSchemas =>
      ProjectsLocationsMetadataStoresMetadataSchemasResource(_requester);
  ProjectsLocationsMetadataStoresOperationsResource get operations =>
      ProjectsLocationsMetadataStoresOperationsResource(_requester);

  ProjectsLocationsMetadataStoresResource(commons.ApiRequester client)
      : _requester = client;

  /// Initializes a MetadataStore, including allocation of resources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location where the
  /// MetadataStore should be created. Format:
  /// `projects/{project}/locations/{location}/`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [metadataStoreId] - The {metadatastore} portion of the resource name with
  /// the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all MetadataStores in the parent Location.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting MetadataStore.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1MetadataStore request,
    core.String parent, {
    core.String? metadataStoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (metadataStoreId != null) 'metadataStoreId': [metadataStoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single MetadataStore and all its child resources (Artifacts,
  /// Executions, and Contexts).
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataStore to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [force] - Deprecated: Field is no longer supported.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataStore to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1MetadataStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1MetadataStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1MetadataStore.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists MetadataStores for a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The Location whose MetadataStores should be listed.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Metadata Stores to return. The service
  /// may return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListMetadataStores call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListMetadataStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListMetadataStoresResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListMetadataStoresResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresArtifactsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsOperationsResource get operations =>
      ProjectsLocationsMetadataStoresArtifactsOperationsResource(_requester);

  ProjectsLocationsMetadataStoresArtifactsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates an Artifact associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Artifact should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [artifactId] - The {artifact} portion of the resource name with the
  /// format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// If not provided, the Artifact's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all Artifacts in the parent MetadataStore.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting Artifact.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Artifact> create(
    GoogleCloudAiplatformV1Artifact request,
    core.String parent, {
    core.String? artifactId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (artifactId != null) 'artifactId': [artifactId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/artifacts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Artifact.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Artifact.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Artifact to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Artifact to delete. If this is
  /// provided, it must match the server's etag. Otherwise, the request will
  /// fail with a FAILED_PRECONDITION.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific Artifact.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Artifact to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Artifact> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Artifact.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Artifacts in the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Artifacts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Artifacts to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. The supported set of filters
  /// include the following: * **Attribute filtering**: For example:
  /// `display_name = "test"`. Supported fields include: `name`, `display_name`,
  /// `uri`, `state`, `schema_title`, `create_time`, and `update_time`. Time
  /// fields, such as `create_time` and `update_time`, require values specified
  /// in RFC-3339 format. For example: `create_time =
  /// "2020-11-19T11:30:00-04:00"` * **Metadata field**: To filter on metadata
  /// fields use traversal operation as follows: `metadata..`. For example:
  /// `metadata.field_1.number_value = 10.0` In case the field name contains
  /// special characters (such as colon), one can embed it inside double quote.
  /// For example: `metadata."field:1".number_value = 10.0` * **Context based
  /// filtering**: To filter Artifacts based on the contexts to which they
  /// belong, use the function operator with the full resource name
  /// `in_context()`. For example:
  /// `in_context("projects//locations//metadataStores//contexts/")` Each of the
  /// above supported filter types can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Artifacts to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListArtifacts call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListArtifactsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListArtifactsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/artifacts';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListArtifactsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a stored Artifact.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Artifact.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Artifact is not found, a new
  /// Artifact is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Artifact> patch(
    GoogleCloudAiplatformV1Artifact request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Artifact.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Purges Artifacts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Artifacts from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1PurgeArtifactsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/artifacts:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves lineage of an Artifact represented through Artifacts and
  /// Executions connected by Event edges and returned as a LineageSubgraph.
  ///
  /// Request parameters:
  ///
  /// [artifact] - Required. The resource name of the Artifact whose Lineage
  /// needs to be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Artifacts to
  /// satisfy in order to be part of the Lineage Subgraph. The syntax to define
  /// filter query is based on https://google.aip.dev/160. The supported set of
  /// filters include the following: * **Attribute filtering**: For example:
  /// `display_name = "test"` Supported fields include: `name`, `display_name`,
  /// `uri`, `state`, `schema_title`, `create_time`, and `update_time`. Time
  /// fields, such as `create_time` and `update_time`, require values specified
  /// in RFC-3339 format. For example: `create_time =
  /// "2020-11-19T11:30:00-04:00"` * **Metadata field**: To filter on metadata
  /// fields use traversal operation as follows: `metadata..`. For example:
  /// `metadata.field_1.number_value = 10.0` In case the field name contains
  /// special characters (such as colon), one can embed it inside double quote.
  /// For example: `metadata."field:1".number_value = 10.0` Each of the above
  /// supported filter types can be combined together using logical operators
  /// (`AND` & `OR`). Maximum nested expression depth allowed is 5. For example:
  /// `display_name = "test" AND metadata.field1.bool_value = true`.
  ///
  /// [maxHops] - Specifies the size of the lineage graph in terms of number of
  /// hops from the specified artifact. Negative Value: INVALID_ARGUMENT error
  /// is returned 0: Only input artifact is returned. No value: Transitive
  /// closure is performed to return the complete graph.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1LineageSubgraph>
      queryArtifactLineageSubgraph(
    core.String artifact, {
    core.String? filter,
    core.int? maxHops,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxHops != null) 'maxHops': ['${maxHops}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$artifact') +
        ':queryArtifactLineageSubgraph';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1LineageSubgraph.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresArtifactsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresContextsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresContextsOperationsResource get operations =>
      ProjectsLocationsMetadataStoresContextsOperationsResource(_requester);

  ProjectsLocationsMetadataStoresContextsResource(commons.ApiRequester client)
      : _requester = client;

  /// Adds a set of Artifacts and Executions to a Context.
  ///
  /// If any of the Artifacts or Executions have already been added to a
  /// Context, they are simply skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the Context that the Artifacts
  /// and Executions belong to. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse>
      addContextArtifactsAndExecutions(
    GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$context') +
        ':addContextArtifactsAndExecutions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Adds a set of Contexts as children to a parent Context.
  ///
  /// If any of the child Contexts have already been added to the parent
  /// Context, they are simply skipped. If this call would create a cycle or
  /// cause any Context to have more than 10 parents, the request will fail with
  /// an INVALID_ARGUMENT error.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the parent Context. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1AddContextChildrenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AddContextChildrenResponse>
      addContextChildren(
    GoogleCloudAiplatformV1AddContextChildrenRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$context') + ':addContextChildren';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AddContextChildrenResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Context associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Context should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [contextId] - The {context} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`.
  /// If not provided, the Context's ID will be a UUID generated by the service.
  /// Must be 4-128 characters in length. Valid characters are `/a-z-/`. Must be
  /// unique across all Contexts in the parent MetadataStore. (Otherwise the
  /// request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the caller
  /// can't view the preexisting Context.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Context> create(
    GoogleCloudAiplatformV1Context request,
    core.String parent, {
    core.String? contextId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (contextId != null) 'contextId': [contextId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/contexts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Context.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a stored Context.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Context to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Context to delete. If this is provided,
  /// it must match the server's etag. Otherwise, the request will fail with a
  /// FAILED_PRECONDITION.
  ///
  /// [force] - The force deletion semantics is still undefined. Users should
  /// not use this field.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific Context.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Context to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Context> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Context.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Contexts on the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Contexts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Contexts to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. Following are the supported
  /// set of filters: * **Attribute filtering**: For example: `display_name =
  /// "test"`. Supported fields include: `name`, `display_name`, `schema_title`,
  /// `create_time`, and `update_time`. Time fields, such as `create_time` and
  /// `update_time`, require values specified in RFC-3339 format. For example:
  /// `create_time = "2020-11-19T11:30:00-04:00"`. * **Metadata field**: To
  /// filter on metadata fields use traversal operation as follows:
  /// `metadata..`. For example: `metadata.field_1.number_value = 10.0`. In case
  /// the field name contains special characters (such as colon), one can embed
  /// it inside double quote. For example: `metadata."field:1".number_value =
  /// 10.0` * **Parent Child filtering**: To filter Contexts based on
  /// parent-child relationship use the HAS operator as follows: ```
  /// parent_contexts: "projects//locations//metadataStores//contexts/"
  /// child_contexts: "projects//locations//metadataStores//contexts/" ``` Each
  /// of the above supported filters can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Contexts to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListContexts call. Provide this to retrieve the subsequent
  /// page. When paginating, all other provided parameters must match the call
  /// that provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListContextsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListContextsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/contexts';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListContextsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a stored Context.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the Context.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Context is not found, a new
  /// Context is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Context> patch(
    GoogleCloudAiplatformV1Context request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Context.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Purges Contexts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Contexts from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1PurgeContextsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/contexts:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves Artifacts and Executions within the specified Context, connected
  /// by Event edges and returned as a LineageSubgraph.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the Context whose Artifacts and
  /// Executions should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1LineageSubgraph>
      queryContextLineageSubgraph(
    core.String context, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$context') +
        ':queryContextLineageSubgraph';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1LineageSubgraph.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Remove a set of children contexts from a parent Context.
  ///
  /// If any of the child Contexts were NOT added to the parent Context, they
  /// are simply skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the parent Context. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1RemoveContextChildrenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1RemoveContextChildrenResponse>
      removeContextChildren(
    GoogleCloudAiplatformV1RemoveContextChildrenRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$context') + ':removeContextChildren';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1RemoveContextChildrenResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresContextsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresContextsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresExecutionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresExecutionsOperationsResource get operations =>
      ProjectsLocationsMetadataStoresExecutionsOperationsResource(_requester);

  ProjectsLocationsMetadataStoresExecutionsResource(commons.ApiRequester client)
      : _requester = client;

  /// Adds Events to the specified Execution.
  ///
  /// An Event indicates whether an Artifact was used as an input or output for
  /// an Execution. If an Event already exists between the Execution and the
  /// Artifact, the Event is skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [execution] - Required. The resource name of the Execution that the Events
  /// connect Artifacts with. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1AddExecutionEventsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AddExecutionEventsResponse>
      addExecutionEvents(
    GoogleCloudAiplatformV1AddExecutionEventsRequest request,
    core.String execution, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$execution') + ':addExecutionEvents';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AddExecutionEventsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates an Execution associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Execution should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [executionId] - The {execution} portion of the resource name with the
  /// format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// If not provided, the Execution's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all Executions in the parent
  /// MetadataStore. (Otherwise the request will fail with ALREADY_EXISTS, or
  /// PERMISSION_DENIED if the caller can't view the preexisting Execution.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Execution> create(
    GoogleCloudAiplatformV1Execution request,
    core.String parent, {
    core.String? executionId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (executionId != null) 'executionId': [executionId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/executions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Execution.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Execution.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Execution to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Execution to delete. If this is
  /// provided, it must match the server's etag. Otherwise, the request will
  /// fail with a FAILED_PRECONDITION.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific Execution.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Execution to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Execution> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Execution.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Executions in the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Executions should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Executions to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. Following are the supported
  /// set of filters: * **Attribute filtering**: For example: `display_name =
  /// "test"`. Supported fields include: `name`, `display_name`, `state`,
  /// `schema_title`, `create_time`, and `update_time`. Time fields, such as
  /// `create_time` and `update_time`, require values specified in RFC-3339
  /// format. For example: `create_time = "2020-11-19T11:30:00-04:00"`. *
  /// **Metadata field**: To filter on metadata fields use traversal operation
  /// as follows: `metadata..` For example: `metadata.field_1.number_value =
  /// 10.0` In case the field name contains special characters (such as colon),
  /// one can embed it inside double quote. For example:
  /// `metadata."field:1".number_value = 10.0` * **Context based filtering**: To
  /// filter Executions based on the contexts to which they belong use the
  /// function operator with the full resource name: `in_context()`. For
  /// example: `in_context("projects//locations//metadataStores//contexts/")`
  /// Each of the above supported filters can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Executions to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListExecutions call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with an INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListExecutionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListExecutionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/executions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListExecutionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a stored Execution.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Execution.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Execution is not found, a new
  /// Execution is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Execution> patch(
    GoogleCloudAiplatformV1Execution request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Execution.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Purges Executions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Executions from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1PurgeExecutionsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/executions:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Obtains the set of input and output Artifacts for this Execution, in the
  /// form of LineageSubgraph that also contains the Execution and connecting
  /// Events.
  ///
  /// Request parameters:
  ///
  /// [execution] - Required. The resource name of the Execution whose input and
  /// output Artifacts should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1LineageSubgraph>
      queryExecutionInputsAndOutputs(
    core.String execution, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$execution') +
        ':queryExecutionInputsAndOutputs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1LineageSubgraph.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresExecutionsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresExecutionsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresMetadataSchemasResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresMetadataSchemasResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a MetadataSchema.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// MetadataSchema should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [metadataSchemaId] - The {metadata_schema} portion of the resource name
  /// with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all MetadataSchemas in the parent
  /// Location. (Otherwise the request will fail with ALREADY_EXISTS, or
  /// PERMISSION_DENIED if the caller can't view the preexisting
  /// MetadataSchema.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1MetadataSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1MetadataSchema> create(
    GoogleCloudAiplatformV1MetadataSchema request,
    core.String parent, {
    core.String? metadataSchemaId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (metadataSchemaId != null) 'metadataSchemaId': [metadataSchemaId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataSchemas';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1MetadataSchema.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific MetadataSchema.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataSchema to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/metadataSchemas/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1MetadataSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1MetadataSchema> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1MetadataSchema.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists MetadataSchemas.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose MetadataSchemas should be
  /// listed. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - A query to filter available MetadataSchemas for matching
  /// results.
  ///
  /// [pageSize] - The maximum number of MetadataSchemas to return. The service
  /// may return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListMetadataSchemas call. Provide this to retrieve the
  /// next page. When paginating, all other provided parameters must match the
  /// call that provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListMetadataSchemasResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListMetadataSchemasResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataSchemas';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListMetadataSchemasResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMigratableResourcesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMigratableResourcesOperationsResource get operations =>
      ProjectsLocationsMigratableResourcesOperationsResource(_requester);

  ProjectsLocationsMigratableResourcesResource(commons.ApiRequester client)
      : _requester = client;

  /// Batch migrates resources from ml.googleapis.com, automl.googleapis.com,
  /// and datalabeling.googleapis.com to Vertex AI.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The location of the migrated resource will live in.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchMigrate(
    GoogleCloudAiplatformV1BatchMigrateResourcesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$parent') +
        '/migratableResources:batchMigrate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches all of the resources in automl.googleapis.com,
  /// datalabeling.googleapis.com and ml.googleapis.com that can be migrated to
  /// Vertex AI's given location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The location that the migratable resources should be
  /// searched from. It's the Vertex AI location that the resources can be
  /// migrated to, not the resources' original location. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1SearchMigratableResourcesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SearchMigratableResourcesResponse> search(
    GoogleCloudAiplatformV1SearchMigratableResourcesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/migratableResources:search';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchMigratableResourcesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMigratableResourcesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMigratableResourcesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelDeploymentMonitoringJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource
      get operations =>
          ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource(
              _requester);

  ProjectsLocationsModelDeploymentMonitoringJobsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a ModelDeploymentMonitoringJob.
  ///
  /// It will run periodically on a configured interval.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelDeploymentMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelDeploymentMonitoringJob> create(
    GoogleCloudAiplatformV1ModelDeploymentMonitoringJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$parent') +
        '/modelDeploymentMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a ModelDeploymentMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the model monitoring job to
  /// delete. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a ModelDeploymentMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelDeploymentMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelDeploymentMonitoringJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists ModelDeploymentMonitoringJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse>
      list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$parent') +
        '/modelDeploymentMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a ModelDeploymentMonitoringJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Resource name of a ModelDeploymentMonitoringJob.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask is used to specify the fields to
  /// be overwritten in the ModelDeploymentMonitoringJob resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields. For the objective config, the user can either provide the update
  /// mask for model_deployment_monitoring_objective_configs or any combination
  /// of its nested fields, such as:
  /// model_deployment_monitoring_objective_configs.objective_config.training_dataset.
  /// Updatable fields: * `display_name` *
  /// `model_deployment_monitoring_schedule_config` *
  /// `model_monitoring_alert_config` * `logging_sampling_strategy` * `labels` *
  /// `log_ttl` * `enable_monitoring_pipeline_logs` . and *
  /// `model_deployment_monitoring_objective_configs` . or *
  /// `model_deployment_monitoring_objective_configs.objective_config.training_dataset`
  /// *
  /// `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config`
  /// *
  /// `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1ModelDeploymentMonitoringJob request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Pauses a ModelDeploymentMonitoringJob.
  ///
  /// If the job is running, the server makes a best effort to cancel the job.
  /// Will mark ModelDeploymentMonitoringJob.state to 'PAUSED'.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob
  /// to pause. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> pause(
    GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':pause';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Resumes a paused ModelDeploymentMonitoringJob.
  ///
  /// It will start to run from next scheduled time. A deleted
  /// ModelDeploymentMonitoringJob can't be resumed.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob
  /// to resume. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> resume(
    GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':resume';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches Model Monitoring Statistics generated within a given time window.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [modelDeploymentMonitoringJob] - Required. ModelDeploymentMonitoring Job
  /// resource name. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
          GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse>
      searchModelDeploymentMonitoringStatsAnomalies(
    GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest
        request,
    core.String modelDeploymentMonitoringJob, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$modelDeploymentMonitoringJob') +
        ':searchModelDeploymentMonitoringStatsAnomalies';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsResource get evaluations =>
      ProjectsLocationsModelsEvaluationsResource(_requester);
  ProjectsLocationsModelsOperationsResource get operations =>
      ProjectsLocationsModelsOperationsResource(_requester);

  ProjectsLocationsModelsResource(commons.ApiRequester client)
      : _requester = client;

  /// Copies an already existing Vertex AI Model into the specified Location.
  ///
  /// The source Model must exist in the same Project. When copying custom
  /// Models, the users themselves are responsible for Model.metadata content to
  /// be region-agnostic, as well as making sure that any resources (e.g. files)
  /// it depends on remain accessible.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to copy
  /// the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> copy(
    GoogleCloudAiplatformV1CopyModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/models:copy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Model.
  ///
  /// A model cannot be deleted if any Endpoint resource has a DeployedModel
  /// based on the model in its deployed_models field.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Model resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Model version.
  ///
  /// Model version can only be deleted if there are no DeployedModels created
  /// from it. Deleting the only version in the Model is not allowed. Use
  /// DeleteModel for deleting the Model instead.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to be deleted, with a
  /// version ID explicitly included. Example:
  /// `projects/{project}/locations/{location}/models/{model}@1234`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deleteVersion(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':deleteVersion';

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports a trained, exportable Model to a location specified by the user.
  ///
  /// A Model is considered to be exportable if it has at least one supported
  /// export format.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Model to export. The resource
  /// name may contain version id or version alias to specify the version, if no
  /// version is specified, the default version will be exported.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> export(
    GoogleCloudAiplatformV1ExportModelRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':export';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Model resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}` In order to
  /// retrieve a specific version of the model, also provide the version ID or
  /// version alias. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` If no
  /// version ID or alias is specified, the "default" version will be returned.
  /// The "default" version alias is created for the first version of the model,
  /// and can be moved to other versions later on. There will be exactly one
  /// default version.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Model> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Model.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Models in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the Models
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. * \`model\`
  /// supports = and !=. \`model\` represents the Model ID, i.e. the last
  /// segment of the Model's resource name. * \`display_name\` supports = and !=
  /// * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. * \`base_model_name\` only supports = Some examples: *
  /// \`model=1234\` * \`displayName="myDisplayName"\` *
  /// \`labels.myKey="myValue"\` * \`baseModelName="text-bison"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time` Example:
  /// `display_name, create_time desc`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelsResponse.next_page_token of the previous ModelService.ListModels
  /// call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListModelsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/models';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists checkpoints of the specified model version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to list checkpoints for.
  /// `projects/{project}/locations/{location}/models/{model}@{version}`
  /// Example: `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` If no
  /// version ID or alias is specified, the latest version will be used.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via next_page_token of the previous ListModelVersionCheckpoints call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListModelVersionCheckpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelVersionCheckpointsResponse>
      listCheckpoints(
    core.String name, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':listCheckpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelVersionCheckpointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists versions of the specified model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model to list versions for.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. * \`labels\`
  /// supports general map functions that is: * \`labels.key=value\` - key:value
  /// equality * \`labels.key:* or labels:key - key existence * A key including
  /// a space must be quoted. \`labels."a key"\`. Some examples: *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `create_time` * `update_time` Example: `update_time asc,
  /// create_time desc`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// next_page_token of the previous ListModelVersions call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListModelVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelVersionsResponse> listVersions(
    core.String name, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':listVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelVersionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Merges a set of aliases for a Model version.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to merge aliases, with a
  /// version ID explicitly included. Example:
  /// `projects/{project}/locations/{location}/models/{model}@1234`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Model> mergeVersionAliases(
    GoogleCloudAiplatformV1MergeVersionAliasesRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':mergeVersionAliases';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Model.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a Model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource name of the Model.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Model> patch(
    GoogleCloudAiplatformV1Model request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Model.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Incrementally update the dataset used for an examples model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The resource name of the Model to update. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> updateExplanationDataset(
    GoogleCloudAiplatformV1UpdateExplanationDatasetRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$model') + ':updateExplanationDataset';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Uploads a Model artifact into Vertex AI.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to
  /// upload the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> upload(
    GoogleCloudAiplatformV1UploadModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/models:upload';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsEvaluationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsOperationsResource get operations =>
      ProjectsLocationsModelsEvaluationsOperationsResource(_requester);
  ProjectsLocationsModelsEvaluationsSlicesResource get slices =>
      ProjectsLocationsModelsEvaluationsSlicesResource(_requester);

  ProjectsLocationsModelsEvaluationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Gets a ModelEvaluation.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelEvaluation resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelEvaluation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelEvaluation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelEvaluation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Imports an externally generated ModelEvaluation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the parent model resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelEvaluation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelEvaluation> import(
    GoogleCloudAiplatformV1ImportModelEvaluationRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/evaluations:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelEvaluation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists ModelEvaluations in a Model.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Model to list the
  /// ModelEvaluations from. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelEvaluationsResponse.next_page_token of the previous
  /// ModelService.ListModelEvaluations call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListModelEvaluationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelEvaluationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/evaluations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelEvaluationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsEvaluationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsEvaluationsSlicesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsSlicesResource(commons.ApiRequester client)
      : _requester = client;

  /// Imports a list of externally generated EvaluatedAnnotations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the parent ModelEvaluationSlice resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/slices/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse>
      batchImport(
    GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + ':batchImport';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a ModelEvaluationSlice.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelEvaluationSlice resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/slices/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelEvaluationSlice].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelEvaluationSlice> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelEvaluationSlice.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists ModelEvaluationSlices in a ModelEvaluation.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ModelEvaluation to list the
  /// ModelEvaluationSlices from. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. * `slice.dimension` - for =.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelEvaluationSlicesResponse.next_page_token of the previous
  /// ModelService.ListModelEvaluationSlices call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/slices';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNasJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNasJobsNasTrialDetailsResource get nasTrialDetails =>
      ProjectsLocationsNasJobsNasTrialDetailsResource(_requester);

  ProjectsLocationsNasJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a NasJob.
  ///
  /// Starts asynchronous cancellation on the NasJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// JobService.GetNasJob or other methods to check whether the cancellation
  /// succeeded or whether the job completed despite cancellation. On successful
  /// cancellation, the NasJob is not deleted; instead it becomes a job with a
  /// NasJob.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`, and NasJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob to cancel. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelNasJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a NasJob
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NasJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NasJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NasJob> create(
    GoogleCloudAiplatformV1NasJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/nasJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NasJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a NasJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a NasJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NasJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NasJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NasJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists NasJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the NasJobs
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListNasJobsResponse.next_page_token of the previous JobService.ListNasJobs
  /// call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListNasJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNasJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/nasJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNasJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNasJobsNasTrialDetailsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNasJobsNasTrialDetailsResource(commons.ApiRequester client)
      : _requester = client;

  /// Gets a NasTrialDetail.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasTrialDetail resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}/nasTrialDetails/{nas_trial_detail}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+/nasTrialDetails/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NasTrialDetail].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NasTrialDetail> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NasTrialDetail.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// List top NasTrialDetails of a NasJob.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the NasJob resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListNasTrialDetailsResponse.next_page_token of the previous
  /// JobService.ListNasTrialDetails call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListNasTrialDetailsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNasTrialDetailsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/nasTrialDetails';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNasTrialDetailsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookExecutionJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookExecutionJobsOperationsResource get operations =>
      ProjectsLocationsNotebookExecutionJobsOperationsResource(_requester);

  ProjectsLocationsNotebookExecutionJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a NotebookExecutionJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [notebookExecutionJobId] - Optional. User specified ID for the
  /// NotebookExecutionJob.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1NotebookExecutionJob request,
    core.String parent, {
    core.String? notebookExecutionJobId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (notebookExecutionJobId != null)
        'notebookExecutionJobId': [notebookExecutionJobId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookExecutionJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a NotebookExecutionJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookExecutionJob resource to be
  /// deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a NotebookExecutionJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookExecutionJob resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [view] - Optional. The NotebookExecutionJob view. Defaults to BASIC.
  /// Possible string values are:
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED" : When unspecified, the API
  /// defaults to the BASIC view.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC" : Includes all fields except for
  /// direct notebook inputs.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_FULL" : Includes all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NotebookExecutionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NotebookExecutionJob> get(
    core.String name, {
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NotebookExecutionJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists NotebookExecutionJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookExecutionJobs. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `notebookExecutionJob` supports = and !=. `notebookExecutionJob`
  /// represents the NotebookExecutionJob ID. * `displayName` supports = and !=
  /// and regex. * `schedule` supports = and != and regex. Some examples: *
  /// `notebookExecutionJob="123"` * `notebookExecutionJob="my-execution-job"` *
  /// `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookExecutionJobsResponse.next_page_token of the previous
  /// NotebookService.ListNotebookExecutionJobs call.
  ///
  /// [view] - Optional. The NotebookExecutionJob view. Defaults to BASIC.
  /// Possible string values are:
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED" : When unspecified, the API
  /// defaults to the BASIC view.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_BASIC" : Includes all fields except for
  /// direct notebook inputs.
  /// - "NOTEBOOK_EXECUTION_JOB_VIEW_FULL" : Includes all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListNotebookExecutionJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNotebookExecutionJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookExecutionJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNotebookExecutionJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookExecutionJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookExecutionJobsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookExecutionJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookRuntimeTemplatesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimeTemplatesOperationsResource get operations =>
      ProjectsLocationsNotebookRuntimeTemplatesOperationsResource(_requester);

  ProjectsLocationsNotebookRuntimeTemplatesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a NotebookRuntimeTemplate.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NotebookRuntimeTemplate. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [notebookRuntimeTemplateId] - Optional. User specified ID for the notebook
  /// runtime template.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1NotebookRuntimeTemplate request,
    core.String parent, {
    core.String? notebookRuntimeTemplateId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (notebookRuntimeTemplateId != null)
        'notebookRuntimeTemplateId': [notebookRuntimeTemplateId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimeTemplates';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a NotebookRuntimeTemplate.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntimeTemplate resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a NotebookRuntimeTemplate.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntimeTemplate resource.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NotebookRuntimeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NotebookRuntimeTemplate> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists NotebookRuntimeTemplates in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookRuntimeTemplates. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// \`notebookRuntimeTemplate\` supports = and !=. \`notebookRuntimeTemplate\`
  /// represents the NotebookRuntimeTemplate ID, i.e. the last segment of the
  /// NotebookRuntimeTemplate's resource name. * \`display_name\` supports = and
  /// != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. * \`notebookRuntimeType\` supports = and !=. notebookRuntimeType
  /// enum: \[USER_DEFINED, ONE_CLICK\]. * \`machineType\` supports = and !=. *
  /// \`acceleratorType\` supports = and !=. Some examples: *
  /// \`notebookRuntimeTemplate=notebookRuntimeTemplate123\` *
  /// \`displayName="myDisplayName"\` * \`labels.myKey="myValue"\` *
  /// \`notebookRuntimeType=USER_DEFINED\` * \`machineType=e2-standard-4\` *
  /// \`acceleratorType=NVIDIA_TESLA_T4\`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookRuntimeTemplatesResponse.next_page_token of the previous
  /// NotebookService.ListNotebookRuntimeTemplates call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse>
      list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimeTemplates';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a NotebookRuntimeTemplate.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource name of the NotebookRuntimeTemplate.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Input format:
  /// `{paths: "${updated_filed}"}` Updatable fields: *
  /// `encryption_spec.kms_key_name`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NotebookRuntimeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NotebookRuntimeTemplate> patch(
    GoogleCloudAiplatformV1NotebookRuntimeTemplate request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookRuntimeTemplatesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimeTemplatesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookRuntimesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimesOperationsResource get operations =>
      ProjectsLocationsNotebookRuntimesOperationsResource(_requester);

  ProjectsLocationsNotebookRuntimesResource(commons.ApiRequester client)
      : _requester = client;

  /// Assigns a NotebookRuntime to a user for a particular Notebook file.
  ///
  /// This method will either returns an existing assignment or generates a new
  /// one.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to get the
  /// NotebookRuntime assignment. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> assign(
    GoogleCloudAiplatformV1AssignNotebookRuntimeRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimes:assign';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a NotebookRuntime.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be deleted.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a NotebookRuntime.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource. Instead of
  /// checking whether the name is in valid NotebookRuntime resource name
  /// format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NotebookRuntime].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NotebookRuntime> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NotebookRuntime.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists NotebookRuntimes in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookRuntimes. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `notebookRuntime` supports = and !=. `notebookRuntime` represents the
  /// NotebookRuntime ID, i.e. the last segment of the NotebookRuntime's
  /// resource name. * `displayName` supports = and != and regex. *
  /// `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
  /// represents the NotebookRuntimeTemplate ID, i.e. the last segment of the
  /// NotebookRuntimeTemplate's resource name. * `healthState` supports = and
  /// !=. healthState enum: \[HEALTHY, UNHEALTHY, HEALTH_STATE_UNSPECIFIED\]. *
  /// `runtimeState` supports = and !=. runtimeState enum:
  /// \[RUNTIME_STATE_UNSPECIFIED, RUNNING, BEING_STARTED, BEING_STOPPED,
  /// STOPPED, BEING_UPGRADED, ERROR, INVALID\]. * `runtimeUser` supports = and
  /// !=. * API version is UI only: `uiState` supports = and !=. uiState enum:
  /// \[UI_RESOURCE_STATE_UNSPECIFIED, UI_RESOURCE_STATE_BEING_CREATED,
  /// UI_RESOURCE_STATE_ACTIVE, UI_RESOURCE_STATE_BEING_DELETED,
  /// UI_RESOURCE_STATE_CREATION_FAILED\]. * `notebookRuntimeType` supports =
  /// and !=. notebookRuntimeType enum: \[USER_DEFINED, ONE_CLICK\]. *
  /// `machineType` supports = and !=. * `acceleratorType` supports = and !=.
  /// Some examples: * `notebookRuntime="notebookRuntime123"` *
  /// `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"` *
  /// `notebookRuntimeTemplate="notebookRuntimeTemplate321"` *
  /// `healthState=HEALTHY` * `runtimeState=RUNNING` *
  /// `runtimeUser="test@google.com"` *
  /// `uiState=UI_RESOURCE_STATE_BEING_DELETED` *
  /// `notebookRuntimeType=USER_DEFINED` * `machineType=e2-standard-4` *
  /// `acceleratorType=NVIDIA_TESLA_T4`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookRuntimesResponse.next_page_token of the previous
  /// NotebookService.ListNotebookRuntimes call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListNotebookRuntimesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNotebookRuntimesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNotebookRuntimesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Starts a NotebookRuntime.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be started.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> start(
    GoogleCloudAiplatformV1StartNotebookRuntimeRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':start';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Stops a NotebookRuntime.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be stopped.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> stop(
    GoogleCloudAiplatformV1StopNotebookRuntimeRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':stop';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Upgrades a NotebookRuntime.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be upgrade.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> upgrade(
    GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':upgrade';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookRuntimesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPersistentResourcesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPersistentResourcesOperationsResource get operations =>
      ProjectsLocationsPersistentResourcesOperationsResource(_requester);

  ProjectsLocationsPersistentResourcesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a PersistentResource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// PersistentResource in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [persistentResourceId] - Required. The ID to use for the
  /// PersistentResource, which become the final component of the
  /// PersistentResource's resource name. The maximum length is 63 characters,
  /// and valid characters are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1PersistentResource request,
    core.String parent, {
    core.String? persistentResourceId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (persistentResourceId != null)
        'persistentResourceId': [persistentResourceId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/persistentResources';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a PersistentResource.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PersistentResource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a PersistentResource.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PersistentResource resource. Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PersistentResource].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PersistentResource> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PersistentResource.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists PersistentResources in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// PersistentResources from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListPersistentResourcesResponse.next_page_token of the previous
  /// PersistentResourceService.ListPersistentResource call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListPersistentResourcesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListPersistentResourcesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/persistentResources';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListPersistentResourcesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a PersistentResource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Resource name of a PersistentResource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Specify the fields to be overwritten in the
  /// PersistentResource by the update method.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1PersistentResource request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reboots a PersistentResource.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PersistentResource resource. Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> reboot(
    GoogleCloudAiplatformV1RebootPersistentResourceRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':reboot';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPersistentResourcesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPersistentResourcesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/persistentResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPipelineJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPipelineJobsOperationsResource get operations =>
      ProjectsLocationsPipelineJobsOperationsResource(_requester);

  ProjectsLocationsPipelineJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Batch cancel PipelineJobs.
  ///
  /// Firstly the server will check if all the jobs are in non-terminal states,
  /// and skip the jobs that are already terminated. If the operation failed,
  /// none of the pipeline jobs are cancelled. The server will poll the states
  /// of all the pipeline jobs periodically to check the cancellation status.
  /// This operation will return an LRO.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCancel(
    GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs:batchCancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Batch deletes PipelineJobs The Operation is atomic.
  ///
  /// If it fails, none of the PipelineJobs are deleted. If it succeeds, all of
  /// the PipelineJobs are deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchDelete(
    GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs:batchDelete';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Cancels a PipelineJob.
  ///
  /// Starts asynchronous cancellation on the PipelineJob. The server makes a
  /// best effort to cancel the pipeline, but success is not guaranteed. Clients
  /// can use PipelineService.GetPipelineJob or other methods to check whether
  /// the cancellation succeeded or whether the pipeline completed despite
  /// cancellation. On successful cancellation, the PipelineJob is not deleted;
  /// instead it becomes a pipeline with a PipelineJob.error value with a
  /// google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`, and
  /// PipelineJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob to cancel. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelPipelineJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a PipelineJob.
  ///
  /// A PipelineJob will run immediately when created.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// PipelineJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pipelineJobId] - The ID to use for the PipelineJob, which will become the
  /// final component of the PipelineJob name. If not provided, an ID will be
  /// automatically generated. This value should be less than 128 characters,
  /// and valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PipelineJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PipelineJob> create(
    GoogleCloudAiplatformV1PipelineJob request,
    core.String parent, {
    core.String? pipelineJobId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pipelineJobId != null) 'pipelineJobId': [pipelineJobId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PipelineJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a PipelineJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a PipelineJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob resource. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PipelineJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PipelineJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PipelineJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists PipelineJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// PipelineJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the PipelineJobs that match the filter expression. The
  /// following fields are supported: * `pipeline_name`: Supports `=` and `!=`
  /// comparisons. * `display_name`: Supports `=`, `!=` comparisons, and `:`
  /// wildcard. * `pipeline_job_user_id`: Supports `=`, `!=` comparisons, and
  /// `:` wildcard. for example, can check if pipeline's display_name contains
  /// *step* by doing display_name:\"*step*\" * `state`: Supports `=` and `!=`
  /// comparisons. * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons. Values must be in RFC
  /// 3339 format. * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  /// comparisons. Values must be in RFC 3339 format. * `labels`: Supports
  /// key-value equality and key presence. * `template_uri`: Supports `=`, `!=`
  /// comparisons, and `:` wildcard. * `template_metadata.version`: Supports
  /// `=`, `!=` comparisons, and `:` wildcard. Filter expressions can be
  /// combined together using logical operators (`AND` & `OR`). For example:
  /// `pipeline_name="test" AND create_time>"2020-05-18T13:30:00Z"`. The syntax
  /// to define filter expression is based on https://google.aip.dev/160.
  /// Examples: * `create_time>"2021-05-18T00:00:00Z" OR
  /// update_time>"2020-05-18T00:00:00Z"` PipelineJobs created or updated after
  /// 2020-05-18 00:00:00 UTC. * `labels.env = "prod"` PipelineJobs with label
  /// "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by. The default sort
  /// order is in ascending order. Use "desc" after a field name for descending.
  /// You can have multiple order_by fields provided e.g. "create_time desc,
  /// end_time", "end_time, start_time, update_time" For example, using
  /// "create_time desc, end_time" will order results by create time in
  /// descending order, and if there are multiple jobs having the same create
  /// time, order them by the end time in ascending order. if order_by is not
  /// specified, it will order by default order is create time in descending
  /// order. Supported fields: * `create_time` * `update_time` * `end_time` *
  /// `start_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListPipelineJobsResponse.next_page_token of the previous
  /// PipelineService.ListPipelineJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListPipelineJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListPipelineJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListPipelineJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPipelineJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPipelineJobsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPublishersResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPublishersModelsResource get models =>
      ProjectsLocationsPublishersModelsResource(_requester);

  ProjectsLocationsPublishersResource(commons.ApiRequester client)
      : _requester = client;
}

class ProjectsLocationsPublishersModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPublishersModelsResource(commons.ApiRequester client)
      : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ComputeTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CountTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Fetch an asynchronous online prediction operation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> fetchPredictOperation(
    GoogleCloudAiplatformV1FetchPredictOperationRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':fetchPredictOperation';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse> generateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PredictResponse> predict(
    GoogleCloudAiplatformV1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> predictLongRunning(
    GoogleCloudAiplatformV1PredictLongRunningRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':predictLongRunning';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers: *
  /// `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction.
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's DeployedModel that
  /// served this prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> rawPredict(
    GoogleCloudAiplatformV1RawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':rawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a server-side streaming online prediction request for Vertex LLM
  /// streaming.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1StreamingPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1StreamingPredictResponse>
      serverStreamingPredict(
    GoogleCloudAiplatformV1StreamingPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':serverStreamingPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1StreamingPredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse>
      streamGenerateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a streaming online prediction with an arbitrary HTTP payload.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> streamRawPredict(
    GoogleCloudAiplatformV1StreamRawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':streamRawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsRagCorporaResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaOperationsResource get operations =>
      ProjectsLocationsRagCorporaOperationsResource(_requester);
  ProjectsLocationsRagCorporaRagFilesResource get ragFiles =>
      ProjectsLocationsRagCorporaRagFilesResource(_requester);

  ProjectsLocationsRagCorporaResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// RagCorpus in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1RagCorpus request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/ragCorpora';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a RagCorpus.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagCorpus resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [force] - Optional. If set to true, any RagFiles in this RagCorpus will
  /// also be deleted. Otherwise, the request will only work if the RagCorpus
  /// has no RagFiles.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a RagCorpus.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagCorpus resource. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1RagCorpus].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1RagCorpus> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1RagCorpus.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists RagCorpora in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the RagCorpora. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListRagCorporaResponse.next_page_token of the previous
  /// VertexRagDataService.ListRagCorpora call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListRagCorporaResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListRagCorporaResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/ragCorpora';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListRagCorporaResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the RagCorpus.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1RagCorpus request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsRagCorporaOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsRagCorporaRagFilesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaRagFilesOperationsResource get operations =>
      ProjectsLocationsRagCorporaRagFilesOperationsResource(_requester);

  ProjectsLocationsRagCorporaRagFilesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes a RagFile.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagFile resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a RagFile.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the RagFile resource. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1RagFile].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1RagFile> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1RagFile.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Import files from Google Cloud Storage or Google Drive into a RagCorpus.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the RagCorpus resource into which to
  /// import files. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudAiplatformV1ImportRagFilesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/ragFiles:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists RagFiles in a RagCorpus.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the RagCorpus from which to list
  /// the RagFiles. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListRagFilesResponse.next_page_token of the previous
  /// VertexRagDataService.ListRagFiles call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListRagFilesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListRagFilesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/ragFiles';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListRagFilesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsRagCorporaRagFilesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRagCorporaRagFilesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/ragCorpora/\[^/\]+/ragFiles/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsReasoningEnginesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesOperationsResource get operations =>
      ProjectsLocationsReasoningEnginesOperationsResource(_requester);

  ProjectsLocationsReasoningEnginesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// ReasoningEngine in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1ReasoningEngine request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/reasoningEngines';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a reasoning engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReasoningEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReasoningEngine> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReasoningEngine.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists reasoning engines in a location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// ReasoningEngines from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter. More detail in
  /// \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListReasoningEnginesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListReasoningEnginesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/reasoningEngines';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListReasoningEnginesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The resource name of the ReasoningEngine.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Mask specifying which fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1ReasoningEngine request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Queries using a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1QueryReasoningEngineResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1QueryReasoningEngineResponse> query(
    GoogleCloudAiplatformV1QueryReasoningEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':query';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1QueryReasoningEngineResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Streams queries using a reasoning engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> streamQuery(
    GoogleCloudAiplatformV1StreamQueryReasoningEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':streamQuery';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsReasoningEnginesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsReasoningEnginesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/reasoningEngines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSchedulesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSchedulesOperationsResource get operations =>
      ProjectsLocationsSchedulesOperationsResource(_requester);

  ProjectsLocationsSchedulesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a Schedule.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Schedule in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Schedule> create(
    GoogleCloudAiplatformV1Schedule request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/schedules';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Schedule.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Schedule.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Schedule.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource. Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Schedule> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Schedule.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Schedules in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// Schedules from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the Schedules that match the filter expression. The
  /// following fields are supported: * `display_name`: Supports `=`, `!=`
  /// comparisons, and `:` wildcard. * `state`: Supports `=` and `!=`
  /// comparisons. * `request`: Supports existence of the check. (e.g.
  /// `create_pipeline_job_request:*` --\> Schedule has
  /// create_pipeline_job_request). * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `start_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. * `end_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, `>=` comparisons and `:*` existence check. Values must be in
  /// RFC 3339 format. * `next_run_time`: Supports `=`, `!=`, `<`, `>`, `<=`,
  /// and `>=` comparisons. Values must be in RFC 3339 format. Filter
  /// expressions can be combined together using logical operators (`NOT`, `AND`
  /// & `OR`). The syntax to define filter expression is based on
  /// https://google.aip.dev/160. Examples: * `state="ACTIVE" AND
  /// display_name:"my_schedule_*"` * `NOT display_name="my_schedule"` *
  /// `create_time>"2021-05-18T00:00:00Z"` * `end_time>"2021-05-18T00:00:00Z" OR
  /// NOT end_time:*` * `create_pipeline_job_request:*`
  ///
  /// [orderBy] - A comma-separated list of fields to order by. The default sort
  /// order is in ascending order. Use "desc" after a field name for descending.
  /// You can have multiple order_by fields provided. For example, using
  /// "create_time desc, end_time" will order results by create time in
  /// descending order, and if there are multiple schedules having the same
  /// create time, order them by the end time in ascending order. If order_by is
  /// not specified, it will order by default with create_time in descending
  /// order. Supported fields: * `create_time` * `start_time` * `end_time` *
  /// `next_run_time`
  ///
  /// [pageSize] - The standard list page size. Default to 100 if not specified.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListSchedulesResponse.next_page_token of the previous
  /// ScheduleService.ListSchedules call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListSchedulesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListSchedulesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/schedules';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListSchedulesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an active or paused Schedule.
  ///
  /// When the Schedule is updated, new runs will be scheduled starting from the
  /// updated next execution time after the update time based on the
  /// time_specification in the updated Schedule. All unstarted runs before the
  /// update time will be skipped while already created runs will NOT be paused
  /// or canceled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the Schedule.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Schedule> patch(
    GoogleCloudAiplatformV1Schedule request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Schedule.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Pauses a Schedule.
  ///
  /// Will mark Schedule.state to 'PAUSED'. If the schedule is paused, no new
  /// runs will be created. Already created runs will NOT be paused or canceled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be paused. Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> pause(
    GoogleCloudAiplatformV1PauseScheduleRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':pause';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Resumes a paused Schedule to start scheduling new runs.
  ///
  /// Will mark Schedule.state to 'ACTIVE'. Only paused Schedule can be resumed.
  /// When the Schedule is resumed, new runs will be scheduled starting from the
  /// next execution time after the current time based on the time_specification
  /// in the Schedule. If Schedule.catch_up is set up true, all missed runs will
  /// be scheduled for backfill first.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be resumed.
  /// Format: `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> resume(
    GoogleCloudAiplatformV1ResumeScheduleRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':resume';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSchedulesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSchedulesOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSpecialistPoolsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSpecialistPoolsOperationsResource get operations =>
      ProjectsLocationsSpecialistPoolsOperationsResource(_requester);

  ProjectsLocationsSpecialistPoolsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a SpecialistPool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent Project name for the new SpecialistPool.
  /// The form is `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1SpecialistPool request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/specialistPools';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a SpecialistPool as well as all Specialists in the pool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SpecialistPool to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [force] - If set to true, any specialist managers in this SpecialistPool
  /// will also be deleted. (Otherwise, the request will only work if the
  /// SpecialistPool has no specialist managers.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a SpecialistPool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the SpecialistPool resource. The form is
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SpecialistPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SpecialistPool> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SpecialistPool.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists SpecialistPools in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the SpecialistPool's parent resource.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained by
  /// ListSpecialistPoolsResponse.next_page_token of the previous
  /// SpecialistPoolService.ListSpecialistPools call. Return first page if
  /// empty.
  ///
  /// [readMask] - Mask specifying which fields to read. FieldMask represents a
  /// set of
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListSpecialistPoolsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListSpecialistPoolsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/specialistPools';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListSpecialistPoolsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a SpecialistPool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SpecialistPool.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1SpecialistPool request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSpecialistPoolsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSpecialistPoolsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesOperationsResource get operations =>
      ProjectsLocationsStudiesOperationsResource(_requester);
  ProjectsLocationsStudiesTrialsResource get trials =>
      ProjectsLocationsStudiesTrialsResource(_requester);

  ProjectsLocationsStudiesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a Study.
  ///
  /// A resource name will be generated after creation of the Study.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// CustomJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Study> create(
    GoogleCloudAiplatformV1Study request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/studies';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Study.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Study.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Study resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Study by name.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Study resource. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Study> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Study.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the studies in a region for an associated project.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the Study
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The maximum number of studies to return per "page"
  /// of results. If unspecified, service will pick an appropriate default.
  ///
  /// [pageToken] - Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListStudiesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListStudiesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/studies';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListStudiesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Looks a study up using the user-defined display_name field instead of the
  /// fully qualified resource name.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to get the Study
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Study> lookup(
    GoogleCloudAiplatformV1LookupStudyRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/studies:lookup';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Study.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesTrialsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesTrialsOperationsResource get operations =>
      ProjectsLocationsStudiesTrialsOperationsResource(_requester);

  ProjectsLocationsStudiesTrialsResource(commons.ApiRequester client)
      : _requester = client;

  /// Adds a measurement of the objective metrics to a Trial.
  ///
  /// This measurement is assumed to have been taken before the Trial is
  /// complete.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [trialName] - Required. The name of the trial to add measurement. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> addTrialMeasurement(
    GoogleCloudAiplatformV1AddTrialMeasurementRequest request,
    core.String trialName, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$trialName') + ':addTrialMeasurement';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Checks whether a Trial should stop or not.
  ///
  /// Returns a long-running operation. When the operation is successful, it
  /// will contain a CheckTrialEarlyStoppingStateResponse.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [trialName] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> checkTrialEarlyStoppingState(
    GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest request,
    core.String trialName, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$trialName') +
        ':checkTrialEarlyStoppingState';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Marks a Trial as complete.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> complete(
    GoogleCloudAiplatformV1CompleteTrialRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':complete';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Adds a user provided Trial to a Study.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Study to create the Trial
  /// in. Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> create(
    GoogleCloudAiplatformV1Trial request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trials';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Trial.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Trial.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Trial resource. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists the Trials associated with a Study.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Study to list the Trial
  /// from. Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The number of Trials to retrieve per "page" of
  /// results. If unspecified, the service will pick an appropriate default.
  ///
  /// [pageToken] - Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTrialsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTrialsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trials';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTrialsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists the pareto-optimal Trials for multi-objective Study or the optimal
  /// Trials for single-objective Study.
  ///
  /// The definition of pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Study that the optimal Trial belongs
  /// to.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListOptimalTrialsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListOptimalTrialsResponse>
      listOptimalTrials(
    GoogleCloudAiplatformV1ListOptimalTrialsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/trials:listOptimalTrials';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListOptimalTrialsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Stops a Trial.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> stop(
    GoogleCloudAiplatformV1StopTrialRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':stop';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Adds one or more Trials to a Study, with parameter values suggested by
  /// Vertex AI Vizier.
  ///
  /// Returns a long-running operation associated with the generation of Trial
  /// suggestions. When this long-running operation succeeds, it will contain a
  /// SuggestTrialsResponse.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The project and location that the Study belongs to.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> suggest(
    GoogleCloudAiplatformV1SuggestTrialsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trials:suggest';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesTrialsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesTrialsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsResource get experiments =>
      ProjectsLocationsTensorboardsExperimentsResource(_requester);
  ProjectsLocationsTensorboardsOperationsResource get operations =>
      ProjectsLocationsTensorboardsOperationsResource(_requester);

  ProjectsLocationsTensorboardsResource(commons.ApiRequester client)
      : _requester = client;

  /// Reads multiple TensorboardTimeSeries' data.
  ///
  /// The data point number limit is 1000 for scalars, 100 for tensors and blob
  /// references. If the number of data points stored is less than the limit,
  /// all data is returned. Otherwise, the number limit of data points is
  /// randomly selected from this time series and returned.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The resource name of the Tensorboard containing
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`. The
  /// TensorboardTimeSeries referenced by time_series must be sub resources of
  /// this Tensorboard.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [timeSeries] - Required. The resource names of the TensorboardTimeSeries
  /// to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async
      .Future<GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse>
      batchRead(
    core.String tensorboard, {
    core.List<core.String>? timeSeries,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeSeries != null) 'timeSeries': timeSeries,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$tensorboard') + ':batchRead';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Tensorboard.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Tensorboard in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Tensorboard request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/tensorboards';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Tensorboard.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Tensorboard to be deleted. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Tensorboard.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Tensorboard].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Tensorboard> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Tensorboard.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Tensorboards in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// Tensorboards. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the Tensorboards that match the filter expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of Tensorboards to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Tensorboards are
  /// returned. The maximum value is 100; values above 100 are coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboards call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// TensorboardService.ListTensorboards must match the call that provided the
  /// page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTensorboardsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/tensorboards';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a Tensorboard.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the Tensorboard. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the Tensorboard resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field is overwritten if it's in the mask. If the user does not
  /// provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1Tensorboard request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns the storage size for a given TensorBoard instance.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadTensorboardSizeResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardSizeResponse> readSize(
    core.String tensorboard, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$tensorboard') + ':readSize';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardSizeResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns a list of monthly active users for a given TensorBoard instance.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadTensorboardUsageResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardUsageResponse> readUsage(
    core.String tensorboard, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$tensorboard') + ':readUsage';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardUsageResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsOperationsResource get operations =>
      ProjectsLocationsTensorboardsExperimentsOperationsResource(_requester);
  ProjectsLocationsTensorboardsExperimentsRunsResource get runs =>
      ProjectsLocationsTensorboardsExperimentsRunsResource(_requester);

  ProjectsLocationsTensorboardsExperimentsResource(commons.ApiRequester client)
      : _requester = client;

  /// Batch create TensorboardTimeSeries that belong to a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardTimeSeries in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The TensorboardRuns referenced by the parent fields in the
  /// CreateTensorboardTimeSeriesRequest messages must be sub resources of this
  /// TensorboardExperiment.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse>
      batchCreate(
    GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + ':batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Tensorboard to create the
  /// TensorboardExperiment in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [tensorboardExperimentId] - Required. The ID to use for the Tensorboard
  /// experiment, which becomes the final component of the Tensorboard
  /// experiment's resource name. This value should be 1-128 characters, and
  /// valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardExperiment> create(
    GoogleCloudAiplatformV1TensorboardExperiment request,
    core.String parent, {
    core.String? tensorboardExperimentId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardExperimentId != null)
        'tensorboardExperimentId': [tensorboardExperimentId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/experiments';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TensorboardExperiment.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardExperiment to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TensorboardExperiment.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardExperiment resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardExperiment> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TensorboardExperiments in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Tensorboard to list
  /// TensorboardExperiments. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardExperiments that match the filter
  /// expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardExperiments to return. The
  /// service may return fewer than this value. If unspecified, at most 50
  /// TensorboardExperiments are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardExperiments call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to TensorboardService.ListTensorboardExperiments must match the
  /// call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListTensorboardExperimentsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardExperimentsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/experiments';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardExperimentsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardExperiment. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardExperiment resource by the update. The
  /// fields specified in the update_mask are relative to the resource, not the
  /// full request. A field is overwritten if it's in the mask. If the user does
  /// not provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardExperiment> patch(
    GoogleCloudAiplatformV1TensorboardExperiment request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Write time series data points of multiple TensorboardTimeSeries in
  /// multiple TensorboardRun's.
  ///
  /// If any data fail to be ingested, an error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardExperiment] - Required. The resource name of the
  /// TensorboardExperiment to write data to. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse>
      write(
    GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest request,
    core.String tensorboardExperiment, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$tensorboardExperiment') + ':write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsOperationsResource
      get operations =>
          ProjectsLocationsTensorboardsExperimentsRunsOperationsResource(
              _requester);
  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource
      get timeSeries =>
          ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource(
              _requester);

  ProjectsLocationsTensorboardsExperimentsRunsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Batch create TensorboardRuns.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardRuns in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The parent field in the CreateTensorboardRunRequest messages must match
  /// this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse>
      batchCreate(
    GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/runs:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TensorboardRun.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardRun in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [tensorboardRunId] - Required. The ID to use for the Tensorboard run,
  /// which becomes the final component of the Tensorboard run's resource name.
  /// This value should be 1-128 characters, and valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardRun> create(
    GoogleCloudAiplatformV1TensorboardRun request,
    core.String parent, {
    core.String? tensorboardRunId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardRunId != null) 'tensorboardRunId': [tensorboardRunId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/runs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardRun.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TensorboardRun.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardRun to be deleted. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TensorboardRun.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardRun resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardRun> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardRun.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TensorboardRuns in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// list TensorboardRuns. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardRuns that match the filter expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardRuns to return. The service
  /// may return fewer than this value. If unspecified, at most 50
  /// TensorboardRuns are returned. The maximum value is 1000; values above 1000
  /// are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardRuns call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// TensorboardService.ListTensorboardRuns must match the call that provided
  /// the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTensorboardRunsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardRunsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/runs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardRunsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a TensorboardRun.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardRun. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardRun resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field is overwritten if it's in the mask. If the user does not
  /// provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardRun> patch(
    GoogleCloudAiplatformV1TensorboardRun request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardRun.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Write time series data points into multiple TensorboardTimeSeries under a
  /// TensorboardRun.
  ///
  /// If any data fail to be ingested, an error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardRun] - Required. The resource name of the TensorboardRun to
  /// write data to. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1WriteTensorboardRunDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1WriteTensorboardRunDataResponse> write(
    GoogleCloudAiplatformV1WriteTensorboardRunDataRequest request,
    core.String tensorboardRun, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$tensorboardRun') + ':write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1WriteTensorboardRunDataResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource
      get operations =>
          ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource(
              _requester);

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a TensorboardTimeSeries.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [tensorboardTimeSeriesId] - Optional. The user specified unique ID to use
  /// for the TensorboardTimeSeries, which becomes the final component of the
  /// TensorboardTimeSeries's resource name. This value should match "a-z0-9{0,
  /// 127}"
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardTimeSeries> create(
    GoogleCloudAiplatformV1TensorboardTimeSeries request,
    core.String parent, {
    core.String? tensorboardTimeSeriesId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId': [tensorboardTimeSeriesId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/timeSeries';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TensorboardTimeSeries.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardTimeSeries to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports a TensorboardTimeSeries' data.
  ///
  /// Data is returned in paginated responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardTimeSeries] - Required. The resource name of the
  /// TensorboardTimeSeries to export data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse>
      exportTensorboardTimeSeries(
    GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest request,
    core.String tensorboardTimeSeries, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$tensorboardTimeSeries') +
        ':exportTensorboardTimeSeries';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TensorboardTimeSeries.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardTimeSeries resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardTimeSeries> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TensorboardTimeSeries in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardRun to list
  /// TensorboardTimeSeries. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardTimeSeries that match the filter
  /// expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardTimeSeries to return. The
  /// service may return fewer than this value. If unspecified, at most 50
  /// TensorboardTimeSeries are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardTimeSeries call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to TensorboardService.ListTensorboardTimeSeries must match the
  /// call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/timeSeries';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a TensorboardTimeSeries.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardTimeSeries.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardTimeSeries resource by the update. The
  /// fields specified in the update_mask are relative to the resource, not the
  /// full request. A field is overwritten if it's in the mask. If the user does
  /// not provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardTimeSeries> patch(
    GoogleCloudAiplatformV1TensorboardTimeSeries request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads a TensorboardTimeSeries' data.
  ///
  /// By default, if the number of data points stored is less than 1000, all
  /// data is returned. Otherwise, 1000 data points is randomly selected from
  /// this time series and returned. This value can be changed by changing
  /// max_data_points, which can't be greater than 10k.
  ///
  /// Request parameters:
  ///
  /// [tensorboardTimeSeries] - Required. The resource name of the
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [filter] - Reads the TensorboardTimeSeries' data that match the filter
  /// expression.
  ///
  /// [maxDataPoints] - The maximum number of TensorboardTimeSeries' data to
  /// return. This value should be a positive integer. This value can be set to
  /// -1 to return all data.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse>
      read(
    core.String tensorboardTimeSeries, {
    core.String? filter,
    core.int? maxDataPoints,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxDataPoints != null) 'maxDataPoints': ['${maxDataPoints}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$tensorboardTimeSeries') + ':read';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets bytes of TensorboardBlobs.
  ///
  /// This is to allow reading blob data stored in consumer project's Cloud
  /// Storage bucket without users having to obtain Cloud Storage access
  /// permission.
  ///
  /// Request parameters:
  ///
  /// [timeSeries] - Required. The resource name of the TensorboardTimeSeries to
  /// list Blobs. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [blobIds] - IDs of the blobs to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse>
      readBlobData(
    core.String timeSeries, {
    core.List<core.String>? blobIds,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (blobIds != null) 'blobIds': blobIds,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$timeSeries') + ':readBlobData';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTrainingPipelinesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTrainingPipelinesOperationsResource get operations =>
      ProjectsLocationsTrainingPipelinesOperationsResource(_requester);

  ProjectsLocationsTrainingPipelinesResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a TrainingPipeline.
  ///
  /// Starts asynchronous cancellation on the TrainingPipeline. The server makes
  /// a best effort to cancel the pipeline, but success is not guaranteed.
  /// Clients can use PipelineService.GetTrainingPipeline or other methods to
  /// check whether the cancellation succeeded or whether the pipeline completed
  /// despite cancellation. On successful cancellation, the TrainingPipeline is
  /// not deleted; instead it becomes a pipeline with a TrainingPipeline.error
  /// value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`, and TrainingPipeline.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline to cancel. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelTrainingPipelineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TrainingPipeline.
  ///
  /// A created TrainingPipeline right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// TrainingPipeline in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TrainingPipeline].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TrainingPipeline> create(
    GoogleCloudAiplatformV1TrainingPipeline request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trainingPipelines';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TrainingPipeline.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TrainingPipeline.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TrainingPipeline.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline resource. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TrainingPipeline].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TrainingPipeline> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TrainingPipeline.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TrainingPipelines in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// TrainingPipelines from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`training_task_definition\` \`=\`,
  /// \`!=\` comparisons, and \`:\` wildcard. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="PIPELINE_STATE_SUCCEEDED" AND display_name:"my_pipeline_*"\` *
  /// \`state!="PIPELINE_STATE_FAILED" OR display_name="my_pipeline"\` * \`NOT
  /// display_name="my_pipeline"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`training_task_definition:"*automl_text_classification*"\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListTrainingPipelinesResponse.next_page_token of the previous
  /// PipelineService.ListTrainingPipelines call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTrainingPipelinesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTrainingPipelinesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trainingPipelines';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTrainingPipelinesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTrainingPipelinesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTrainingPipelinesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTuningJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTuningJobsOperationsResource get operations =>
      ProjectsLocationsTuningJobsOperationsResource(_requester);

  ProjectsLocationsTuningJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a TuningJob.
  ///
  /// Starts asynchronous cancellation on the TuningJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// GenAiTuningService.GetTuningJob or other methods to check whether the
  /// cancellation succeeded or whether the job completed despite cancellation.
  /// On successful cancellation, the TuningJob is not deleted; instead it
  /// becomes a job with a TuningJob.error value with a google.rpc.Status.code
  /// of 1, corresponding to `Code.CANCELLED`, and TuningJob.state is set to
  /// `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TuningJob to cancel. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelTuningJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TuningJob.
  ///
  /// A created TuningJob right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// TuningJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TuningJob> create(
    GoogleCloudAiplatformV1TuningJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/tuningJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TuningJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TuningJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TuningJob resource. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TuningJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TuningJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TuningJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// TuningJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListTuningJobsResponse.next_page_token of the previous
  /// GenAiTuningService.ListTuningJob\]\[\] call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTuningJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTuningJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/tuningJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTuningJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Rebase a TunedModel.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to
  /// rebase the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> rebaseTunedModel(
    GoogleCloudAiplatformV1RebaseTunedModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/tuningJobs:rebaseTunedModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTuningJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTuningJobsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tuningJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class PublishersResource {
  final commons.ApiRequester _requester;

  PublishersModelsResource get models => PublishersModelsResource(_requester);

  PublishersResource(commons.ApiRequester client) : _requester = client;
}

class PublishersModelsResource {
  final commons.ApiRequester _requester;

  PublishersModelsResource(commons.ApiRequester client) : _requester = client;

  /// Return a list of tokens based on the input text.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to get lists of
  /// tokens and token ids.
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ComputeTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ComputeTokensResponse> computeTokens(
    GoogleCloudAiplatformV1ComputeTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':computeTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ComputeTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a token counting.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to perform token
  /// counting. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CountTokensResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CountTokensResponse> countTokens(
    GoogleCloudAiplatformV1CountTokensRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':countTokens';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CountTokensResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse> generateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$model') + ':generateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Model Garden publisher model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PublisherModel resource. Format:
  /// `publishers/{publisher}/models/{publisher_model}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [huggingFaceToken] - Optional. Token used to access Hugging Face gated
  /// models.
  ///
  /// [isHuggingFaceModel] - Optional. Boolean indicates whether the requested
  /// model is a Hugging Face model.
  ///
  /// [languageCode] - Optional. The IETF BCP-47 language code representing the
  /// language in which the publisher model's text information should be written
  /// in.
  ///
  /// [view] - Optional. PublisherModel view specifying which fields to read.
  /// Possible string values are:
  /// - "PUBLISHER_MODEL_VIEW_UNSPECIFIED" : The default / unset value. The API
  /// will default to the BASIC view.
  /// - "PUBLISHER_MODEL_VIEW_BASIC" : Include basic metadata about the
  /// publisher model, but not the full contents.
  /// - "PUBLISHER_MODEL_VIEW_FULL" : Include everything.
  /// - "PUBLISHER_MODEL_VERSION_VIEW_BASIC" : Include: VersionId,
  /// ModelVersionExternalName, and SupportedActions.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PublisherModel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PublisherModel> get(
    core.String name, {
    core.String? huggingFaceToken,
    core.bool? isHuggingFaceModel,
    core.String? languageCode,
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (huggingFaceToken != null) 'huggingFaceToken': [huggingFaceToken],
      if (isHuggingFaceModel != null)
        'isHuggingFaceModel': ['${isHuggingFaceModel}'],
      if (languageCode != null) 'languageCode': [languageCode],
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PublisherModel.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PredictResponse> predict(
    GoogleCloudAiplatformV1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The fully qualified name of the publisher model or
  /// tuned model endpoint to use. Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1GenerateContentResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1GenerateContentResponse>
      streamGenerateContent(
    GoogleCloudAiplatformV1GenerateContentRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$model') + ':streamGenerateContent';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1GenerateContentResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

/// Message that represents an arbitrary HTTP body.
///
/// It should only be used for payload formats that can't be represented as
/// JSON, such as raw binary or an HTML page. This message can be used both in
/// streaming and non-streaming API methods in the request as well as the
/// response. It can be used as a top-level request field, which is convenient
/// if one wants to extract parameters from either the URL or HTTP template into
/// the request fields and also want access to the raw HTTP body. Example:
/// message GetResourceRequest { // A unique request id. string request_id = 1;
/// // The raw HTTP body is bound to this field. google.api.HttpBody http_body =
/// 2; } service ResourceService { rpc GetResource(GetResourceRequest) returns
/// (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns
/// (google.protobuf.Empty); } Example with streaming methods: service
/// CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream
/// google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
/// (stream google.api.HttpBody); } Use of this type only changes how the
/// request and response bodies are handled, all other features will continue to
/// work unchanged.
typedef GoogleApiHttpBody = $HttpBody;

/// Parameters that configure the active learning pipeline.
///
/// Active learning will label the data incrementally by several iterations. For
/// every iteration, it will select a batch of data based on the sampling
/// strategy.
class GoogleCloudAiplatformV1ActiveLearningConfig {
  /// Max number of human labeled DataItems.
  core.String? maxDataItemCount;

  /// Max percent of total DataItems for human labeling.
  core.int? maxDataItemPercentage;

  /// Active learning data sampling config.
  ///
  /// For every active learning labeling iteration, it will select a batch of
  /// data based on the sampling strategy.
  GoogleCloudAiplatformV1SampleConfig? sampleConfig;

  /// CMLE training config.
  ///
  /// For every active learning labeling iteration, system will train a machine
  /// learning model on CMLE. The trained model will be used by data sampling
  /// algorithm to select DataItems.
  GoogleCloudAiplatformV1TrainingConfig? trainingConfig;

  GoogleCloudAiplatformV1ActiveLearningConfig({
    this.maxDataItemCount,
    this.maxDataItemPercentage,
    this.sampleConfig,
    this.trainingConfig,
  });

  GoogleCloudAiplatformV1ActiveLearningConfig.fromJson(core.Map json_)
      : this(
          maxDataItemCount: json_['maxDataItemCount'] as core.String?,
          maxDataItemPercentage: json_['maxDataItemPercentage'] as core.int?,
          sampleConfig: json_.containsKey('sampleConfig')
              ? GoogleCloudAiplatformV1SampleConfig.fromJson(
                  json_['sampleConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          trainingConfig: json_.containsKey('trainingConfig')
              ? GoogleCloudAiplatformV1TrainingConfig.fromJson(
                  json_['trainingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxDataItemCount != null) 'maxDataItemCount': maxDataItemCount!,
        if (maxDataItemPercentage != null)
          'maxDataItemPercentage': maxDataItemPercentage!,
        if (sampleConfig != null) 'sampleConfig': sampleConfig!,
        if (trainingConfig != null) 'trainingConfig': trainingConfig!,
      };
}

/// Request message for MetadataService.AddContextArtifactsAndExecutions.
class GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest {
  /// The resource names of the Artifacts to attribute to the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  core.List<core.String>? artifacts;

  /// The resource names of the Executions to associate with the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  core.List<core.String>? executions;

  GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest({
    this.artifacts,
    this.executions,
  });

  GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest.fromJson(
      core.Map json_)
      : this(
          artifacts: (json_['artifacts'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          executions: (json_['executions'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
        if (executions != null) 'executions': executions!,
      };
}

/// Response message for MetadataService.AddContextArtifactsAndExecutions.
typedef GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse
    = $Empty;

/// Request message for MetadataService.AddContextChildren.
typedef GoogleCloudAiplatformV1AddContextChildrenRequest
    = $ContextChildrenRequest;

/// Response message for MetadataService.AddContextChildren.
typedef GoogleCloudAiplatformV1AddContextChildrenResponse = $Empty;

/// Request message for MetadataService.AddExecutionEvents.
class GoogleCloudAiplatformV1AddExecutionEventsRequest {
  /// The Events to create and add.
  core.List<GoogleCloudAiplatformV1Event>? events;

  GoogleCloudAiplatformV1AddExecutionEventsRequest({
    this.events,
  });

  GoogleCloudAiplatformV1AddExecutionEventsRequest.fromJson(core.Map json_)
      : this(
          events: (json_['events'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Event.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (events != null) 'events': events!,
      };
}

/// Response message for MetadataService.AddExecutionEvents.
typedef GoogleCloudAiplatformV1AddExecutionEventsResponse = $Empty;

/// Request message for VizierService.AddTrialMeasurement.
class GoogleCloudAiplatformV1AddTrialMeasurementRequest {
  /// The measurement to be added to a Trial.
  ///
  /// Required.
  GoogleCloudAiplatformV1Measurement? measurement;

  GoogleCloudAiplatformV1AddTrialMeasurementRequest({
    this.measurement,
  });

  GoogleCloudAiplatformV1AddTrialMeasurementRequest.fromJson(core.Map json_)
      : this(
          measurement: json_.containsKey('measurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['measurement'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (measurement != null) 'measurement': measurement!,
      };
}

/// Used to assign specific AnnotationSpec to a particular area of a DataItem or
/// the whole part of the DataItem.
class GoogleCloudAiplatformV1Annotation {
  /// The source of the Annotation.
  ///
  /// Output only.
  GoogleCloudAiplatformV1UserActionReference? annotationSource;

  /// Timestamp when this Annotation was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Annotations.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Annotation(System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for each Annotation: *
  /// "aiplatform.googleapis.com/annotation_set_name": optional, name of the
  /// UI's annotation set this Annotation belongs to. If not set, the Annotation
  /// is not visible in the UI. * "aiplatform.googleapis.com/payload_schema":
  /// output only, its value is the payload_schema's title.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the Annotation.
  ///
  /// Output only.
  core.String? name;

  /// The schema of the payload can be found in payload_schema.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? payload;

  /// Google Cloud Storage URI points to a YAML file describing payload.
  ///
  /// The schema is defined as an
  /// [OpenAPI 3.0.2 Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
  /// chosen schema must be consistent with the parent Dataset's metadata.
  ///
  /// Required.
  core.String? payloadSchemaUri;

  /// Timestamp when this Annotation was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Annotation({
    this.annotationSource,
    this.createTime,
    this.etag,
    this.labels,
    this.name,
    this.payload,
    this.payloadSchemaUri,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Annotation.fromJson(core.Map json_)
      : this(
          annotationSource: json_.containsKey('annotationSource')
              ? GoogleCloudAiplatformV1UserActionReference.fromJson(
                  json_['annotationSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          payload: json_['payload'],
          payloadSchemaUri: json_['payloadSchemaUri'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationSource != null) 'annotationSource': annotationSource!,
        if (createTime != null) 'createTime': createTime!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (payload != null) 'payload': payload!,
        if (payloadSchemaUri != null) 'payloadSchemaUri': payloadSchemaUri!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Identifies a concept with which DataItems may be annotated with.
class GoogleCloudAiplatformV1AnnotationSpec {
  /// Timestamp when this AnnotationSpec was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the AnnotationSpec.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Resource name of the AnnotationSpec.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when AnnotationSpec was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1AnnotationSpec({
    this.createTime,
    this.displayName,
    this.etag,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1AnnotationSpec.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          name: json_['name'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// The generic reusable api auth config.
///
/// Deprecated. Please use AuthConfig
/// (google/cloud/aiplatform/master/auth.proto) instead.
class GoogleCloudAiplatformV1ApiAuth {
  /// The API secret.
  GoogleCloudAiplatformV1ApiAuthApiKeyConfig? apiKeyConfig;

  GoogleCloudAiplatformV1ApiAuth({
    this.apiKeyConfig,
  });

  GoogleCloudAiplatformV1ApiAuth.fromJson(core.Map json_)
      : this(
          apiKeyConfig: json_.containsKey('apiKeyConfig')
              ? GoogleCloudAiplatformV1ApiAuthApiKeyConfig.fromJson(
                  json_['apiKeyConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!,
      };
}

/// The API secret.
class GoogleCloudAiplatformV1ApiAuthApiKeyConfig {
  /// The SecretManager secret version resource name storing API key.
  ///
  /// e.g. projects/{project}/secrets/{secret}/versions/{version}
  ///
  /// Required.
  core.String? apiKeySecretVersion;

  GoogleCloudAiplatformV1ApiAuthApiKeyConfig({
    this.apiKeySecretVersion,
  });

  GoogleCloudAiplatformV1ApiAuthApiKeyConfig.fromJson(core.Map json_)
      : this(
          apiKeySecretVersion: json_['apiKeySecretVersion'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (apiKeySecretVersion != null)
          'apiKeySecretVersion': apiKeySecretVersion!,
      };
}

/// Instance of a general artifact.
class GoogleCloudAiplatformV1Artifact {
  /// Timestamp when this Artifact was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Artifact
  core.String? description;

  /// User provided display name of the Artifact.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Artifacts.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Artifact (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Artifact.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Artifact.
  ///
  /// Output only.
  core.String? name;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// The state of this Artifact.
  ///
  /// This is a property of the Artifact, and does not imply or capture any
  /// ongoing process. This property is managed by clients (such as Vertex AI
  /// Pipelines), and the system does not prescribe or check the validity of
  /// state transitions.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified state for the Artifact.
  /// - "PENDING" : A state used by systems like Vertex AI Pipelines to indicate
  /// that the underlying data item represented by this Artifact is being
  /// created.
  /// - "LIVE" : A state indicating that the Artifact should exist, unless
  /// something external to the system deletes it.
  core.String? state;

  /// Timestamp when this Artifact was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The uniform resource identifier of the artifact file.
  ///
  /// May be empty if there is no actual artifact file.
  core.String? uri;

  GoogleCloudAiplatformV1Artifact({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.schemaTitle,
    this.schemaVersion,
    this.state,
    this.updateTime,
    this.uri,
  });

  GoogleCloudAiplatformV1Artifact.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_['name'] as core.String?,
          schemaTitle: json_['schemaTitle'] as core.String?,
          schemaVersion: json_['schemaVersion'] as core.String?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
          uri: json_['uri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (schemaTitle != null) 'schemaTitle': schemaTitle!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (uri != null) 'uri': uri!,
      };
}

/// Request message for NotebookService.AssignNotebookRuntime.
class GoogleCloudAiplatformV1AssignNotebookRuntimeRequest {
  /// Provide runtime specific information (e.g. runtime owner, notebook id)
  /// used for NotebookRuntime assignment.
  ///
  /// Required.
  GoogleCloudAiplatformV1NotebookRuntime? notebookRuntime;

  /// User specified ID for the notebook runtime.
  ///
  /// Optional.
  core.String? notebookRuntimeId;

  /// The resource name of the NotebookRuntimeTemplate based on which a
  /// NotebookRuntime will be assigned (reuse or create a new one).
  ///
  /// Required.
  core.String? notebookRuntimeTemplate;

  GoogleCloudAiplatformV1AssignNotebookRuntimeRequest({
    this.notebookRuntime,
    this.notebookRuntimeId,
    this.notebookRuntimeTemplate,
  });

  GoogleCloudAiplatformV1AssignNotebookRuntimeRequest.fromJson(core.Map json_)
      : this(
          notebookRuntime: json_.containsKey('notebookRuntime')
              ? GoogleCloudAiplatformV1NotebookRuntime.fromJson(
                  json_['notebookRuntime']
                      as core.Map<core.String, core.dynamic>)
              : null,
          notebookRuntimeId: json_['notebookRuntimeId'] as core.String?,
          notebookRuntimeTemplate:
              json_['notebookRuntimeTemplate'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (notebookRuntime != null) 'notebookRuntime': notebookRuntime!,
        if (notebookRuntimeId != null) 'notebookRuntimeId': notebookRuntimeId!,
        if (notebookRuntimeTemplate != null)
          'notebookRuntimeTemplate': notebookRuntimeTemplate!,
      };
}

/// Attribution that explains a particular prediction output.
class GoogleCloudAiplatformV1Attribution {
  /// Error of feature_attributions caused by approximation used in the
  /// explanation method.
  ///
  /// Lower value means more precise attributions. * For Sampled Shapley
  /// attribution, increasing path_count might reduce the error. * For
  /// Integrated Gradients attribution, increasing step_count might reduce the
  /// error. * For XRAI attribution, increasing step_count might reduce the
  /// error. See \[this introduction\](/vertex-ai/docs/explainable-ai/overview)
  /// for more information.
  ///
  /// Output only.
  core.double? approximationError;

  /// Model predicted output if the input instance is constructed from the
  /// baselines of all the features defined in ExplanationMetadata.inputs.
  ///
  /// The field name of the output is determined by the key in
  /// ExplanationMetadata.outputs. If the Model's predicted output has multiple
  /// dimensions (rank \> 1), this is the value in the output located by
  /// output_index. If there are multiple baselines, their output values are
  /// averaged.
  ///
  /// Output only.
  core.double? baselineOutputValue;

  /// Attributions of each explained feature.
  ///
  /// Features are extracted from the prediction instances according to
  /// explanation metadata for inputs. The value is a struct, whose keys are the
  /// name of the feature. The values are how much the feature in the instance
  /// contributed to the predicted result. The format of the value is determined
  /// by the feature's input format: * If the feature is a scalar value, the
  /// attribution value is a floating number. * If the feature is an array of
  /// scalar values, the attribution value is an array. * If the feature is a
  /// struct, the attribution value is a struct. The keys in the attribution
  /// value struct are the same as the keys in the feature struct. The formats
  /// of the values in the attribution struct are determined by the formats of
  /// the values in the feature struct. The
  /// ExplanationMetadata.feature_attributions_schema_uri field, pointed to by
  /// the ExplanationSpec field of the Endpoint.deployed_models object, points
  /// to the schema file that describes the features and their attribution
  /// values (if it is populated).
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? featureAttributions;

  /// Model predicted output on the corresponding explanation instance.
  ///
  /// The field name of the output is determined by the key in
  /// ExplanationMetadata.outputs. If the Model predicted output has multiple
  /// dimensions, this is the value in the output located by output_index.
  ///
  /// Output only.
  core.double? instanceOutputValue;

  /// The display name of the output identified by output_index.
  ///
  /// For example, the predicted class name by a multi-classification Model.
  /// This field is only populated iff the Model predicts display names as a
  /// separate field along with the explained output. The predicted display name
  /// must has the same shape of the explained output, and can be located using
  /// output_index.
  ///
  /// Output only.
  core.String? outputDisplayName;

  /// The index that locates the explained prediction output.
  ///
  /// If the prediction output is a scalar value, output_index is not populated.
  /// If the prediction output has multiple dimensions, the length of the
  /// output_index list is the same as the number of dimensions of the output.
  /// The i-th element in output_index is the element index of the i-th
  /// dimension of the output vector. Indices start from 0.
  ///
  /// Output only.
  core.List<core.int>? outputIndex;

  /// Name of the explain output.
  ///
  /// Specified as the key in ExplanationMetadata.outputs.
  ///
  /// Output only.
  core.String? outputName;

  GoogleCloudAiplatformV1Attribution({
    this.approximationError,
    this.baselineOutputValue,
    this.featureAttributions,
    this.instanceOutputValue,
    this.outputDisplayName,
    this.outputIndex,
    this.outputName,
  });

  GoogleCloudAiplatformV1Attribution.fromJson(core.Map json_)
      : this(
          approximationError:
              (json_['approximationError'] as core.num?)?.toDouble(),
          baselineOutputValue:
              (json_['baselineOutputValue'] as core.num?)?.toDouble(),
          featureAttributions: json_['featureAttributions'],
          instanceOutputValue:
              (json_['instanceOutputValue'] as core.num?)?.toDouble(),
          outputDisplayName: json_['outputDisplayName'] as core.String?,
          outputIndex: (json_['outputIndex'] as core.List?)
              ?.map((value) => value as core.int)
              .toList(),
          outputName: json_['outputName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (approximationError != null)
          'approximationError': approximationError!,
        if (baselineOutputValue != null)
          'baselineOutputValue': baselineOutputValue!,
        if (featureAttributions != null)
          'featureAttributions': featureAttributions!,
        if (instanceOutputValue != null)
          'instanceOutputValue': instanceOutputValue!,
        if (outputDisplayName != null) 'outputDisplayName': outputDisplayName!,
        if (outputIndex != null) 'outputIndex': outputIndex!,
        if (outputName != null) 'outputName': outputName!,
      };
}

/// Request message for AugmentPrompt.
class GoogleCloudAiplatformV1AugmentPromptRequest {
  /// Input content to augment, only text format is supported for now.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Content>? contents;

  /// Metadata of the backend deployed model.
  ///
  /// Optional.
  GoogleCloudAiplatformV1AugmentPromptRequestModel? model;

  /// Retrieves contexts from the Vertex RagStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1VertexRagStore? vertexRagStore;

  GoogleCloudAiplatformV1AugmentPromptRequest({
    this.contents,
    this.model,
    this.vertexRagStore,
  });

  GoogleCloudAiplatformV1AugmentPromptRequest.fromJson(core.Map json_)
      : this(
          contents: (json_['contents'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Content.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          model: json_.containsKey('model')
              ? GoogleCloudAiplatformV1AugmentPromptRequestModel.fromJson(
                  json_['model'] as core.Map<core.String, core.dynamic>)
              : null,
          vertexRagStore: json_.containsKey('vertexRagStore')
              ? GoogleCloudAiplatformV1VertexRagStore.fromJson(
                  json_['vertexRagStore']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (model != null) 'model': model!,
        if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!,
      };
}

/// Metadata of the backend deployed model.
class GoogleCloudAiplatformV1AugmentPromptRequestModel {
  /// The model that the user will send the augmented prompt for content
  /// generation.
  ///
  /// Optional.
  core.String? model;

  /// The model version of the backend deployed model.
  ///
  /// Optional.
  core.String? modelVersion;

  GoogleCloudAiplatformV1AugmentPromptRequestModel({
    this.model,
    this.modelVersion,
  });

  GoogleCloudAiplatformV1AugmentPromptRequestModel.fromJson(core.Map json_)
      : this(
          model: json_['model'] as core.String?,
          modelVersion: json_['modelVersion'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
        if (modelVersion != null) 'modelVersion': modelVersion!,
      };
}

/// Response message for AugmentPrompt.
class GoogleCloudAiplatformV1AugmentPromptResponse {
  /// Augmented prompt, only text format is supported for now.
  core.List<GoogleCloudAiplatformV1Content>? augmentedPrompt;

  /// Retrieved facts from RAG data sources.
  core.List<GoogleCloudAiplatformV1Fact>? facts;

  GoogleCloudAiplatformV1AugmentPromptResponse({
    this.augmentedPrompt,
    this.facts,
  });

  GoogleCloudAiplatformV1AugmentPromptResponse.fromJson(core.Map json_)
      : this(
          augmentedPrompt: (json_['augmentedPrompt'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Content.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          facts: (json_['facts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Fact.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (augmentedPrompt != null) 'augmentedPrompt': augmentedPrompt!,
        if (facts != null) 'facts': facts!,
      };
}

/// A description of resources that to large degree are decided by Vertex AI,
/// and require only a modest additional configuration.
///
/// Each Model supporting these resources documents its specific guidelines.
class GoogleCloudAiplatformV1AutomaticResources {
  /// The maximum number of replicas that may be deployed on when the traffic
  /// against it increases.
  ///
  /// If the requested value is too large, the deployment will error, but if
  /// deployment succeeds then the ability to scale to that many replicas is
  /// guaranteed (barring service outages). If traffic increases beyond what its
  /// replicas at maximum may handle, a portion of the traffic will be dropped.
  /// If this value is not provided, a no upper bound for scaling under heavy
  /// traffic will be assume, though Vertex AI may be unable to scale beyond
  /// certain replica number.
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The minimum number of replicas that will be always deployed on.
  ///
  /// If traffic against it increases, it may dynamically be deployed onto more
  /// replicas up to max_replica_count, and as traffic decreases, some of these
  /// extra replicas may be freed. If the requested value is too large, the
  /// deployment will error.
  ///
  /// Immutable.
  core.int? minReplicaCount;

  GoogleCloudAiplatformV1AutomaticResources({
    this.maxReplicaCount,
    this.minReplicaCount,
  });

  GoogleCloudAiplatformV1AutomaticResources.fromJson(core.Map json_)
      : this(
          maxReplicaCount: json_['maxReplicaCount'] as core.int?,
          minReplicaCount: json_['minReplicaCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
        if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
      };
}

/// The configs for autorater.
///
/// This is applicable to both EvaluateInstances and EvaluateDataset.
class GoogleCloudAiplatformV1AutoraterConfig {
  /// The fully qualified name of the publisher model or tuned autorater
  /// endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers / * /models / * `
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Optional.
  core.String? autoraterModel;

  /// Whether to flip the candidate and baseline responses.
  ///
  /// This is only applicable to the pairwise metric. If enabled, also provide
  /// PairwiseMetricSpec.candidate_response_field_name and
  /// PairwiseMetricSpec.baseline_response_field_name. When rendering
  /// PairwiseMetricSpec.metric_prompt_template, the candidate and baseline
  /// fields will be flipped for half of the samples to reduce bias.
  ///
  /// Optional.
  core.bool? flipEnabled;

  /// Number of samples for each instance in the dataset.
  ///
  /// If not specified, the default is 4. Minimum value is 1, maximum value is
  /// 32.
  ///
  /// Optional.
  core.int? samplingCount;

  GoogleCloudAiplatformV1AutoraterConfig({
    this.autoraterModel,
    this.flipEnabled,
    this.samplingCount,
  });

  GoogleCloudAiplatformV1AutoraterConfig.fromJson(core.Map json_)
      : this(
          autoraterModel: json_['autoraterModel'] as core.String?,
          flipEnabled: json_['flipEnabled'] as core.bool?,
          samplingCount: json_['samplingCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoraterModel != null) 'autoraterModel': autoraterModel!,
        if (flipEnabled != null) 'flipEnabled': flipEnabled!,
        if (samplingCount != null) 'samplingCount': samplingCount!,
      };
}

/// The metric specification that defines the target resource utilization (CPU
/// utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
class GoogleCloudAiplatformV1AutoscalingMetricSpec {
  /// The resource metric name.
  ///
  /// Supported metrics: * For Online Prediction: *
  /// `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` *
  /// `aiplatform.googleapis.com/prediction/online/cpu/utilization`
  ///
  /// Required.
  core.String? metricName;

  /// The target resource utilization in percentage (1% - 100%) for the given
  /// metric; once the real usage deviates from the target by a certain
  /// percentage, the machine replicas change.
  ///
  /// The default value is 60 (representing 60%) if not provided.
  core.int? target;

  GoogleCloudAiplatformV1AutoscalingMetricSpec({
    this.metricName,
    this.target,
  });

  GoogleCloudAiplatformV1AutoscalingMetricSpec.fromJson(core.Map json_)
      : this(
          metricName: json_['metricName'] as core.String?,
          target: json_['target'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metricName != null) 'metricName': metricName!,
        if (target != null) 'target': target!,
      };
}

/// The storage details for Avro input content.
class GoogleCloudAiplatformV1AvroSource {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  GoogleCloudAiplatformV1AvroSource({
    this.gcsSource,
  });

  GoogleCloudAiplatformV1AvroSource.fromJson(core.Map json_)
      : this(
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsSource != null) 'gcsSource': gcsSource!,
      };
}

/// Request message for PipelineService.BatchCancelPipelineJobs.
class GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest {
  /// The names of the PipelineJobs to cancel.
  ///
  /// A maximum of 32 PipelineJobs can be cancelled in a batch. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  ///
  /// Required.
  core.List<core.String>? names;

  GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest({
    this.names,
  });

  GoogleCloudAiplatformV1BatchCancelPipelineJobsRequest.fromJson(core.Map json_)
      : this(
          names: (json_['names'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (names != null) 'names': names!,
      };
}

/// Request message for FeaturestoreService.BatchCreateFeatures.
///
/// Request message for FeatureRegistryService.BatchCreateFeatures.
class GoogleCloudAiplatformV1BatchCreateFeaturesRequest {
  /// The request message specifying the Features to create.
  ///
  /// All Features must be created under the same parent EntityType /
  /// FeatureGroup. The `parent` field in each child request message can be
  /// omitted. If `parent` is set in a child request, then the value must match
  /// the `parent` value in this request message.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1CreateFeatureRequest>? requests;

  GoogleCloudAiplatformV1BatchCreateFeaturesRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1BatchCreateFeaturesRequest.fromJson(core.Map json_)
      : this(
          requests: (json_['requests'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1CreateFeatureRequest.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (requests != null) 'requests': requests!,
      };
}

/// Request message for TensorboardService.BatchCreateTensorboardRuns.
class GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest {
  /// The request message specifying the TensorboardRuns to create.
  ///
  /// A maximum of 1000 TensorboardRuns can be created in a batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1CreateTensorboardRunRequest>? requests;

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest.fromJson(
      core.Map json_)
      : this(
          requests: (json_['requests'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1CreateTensorboardRunRequest.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (requests != null) 'requests': requests!,
      };
}

/// Response message for TensorboardService.BatchCreateTensorboardRuns.
class GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse {
  /// The created TensorboardRuns.
  core.List<GoogleCloudAiplatformV1TensorboardRun>? tensorboardRuns;

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse({
    this.tensorboardRuns,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse.fromJson(
      core.Map json_)
      : this(
          tensorboardRuns: (json_['tensorboardRuns'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TensorboardRun.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardRuns != null) 'tensorboardRuns': tensorboardRuns!,
      };
}

/// Request message for TensorboardService.BatchCreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest {
  /// The request message specifying the TensorboardTimeSeries to create.
  ///
  /// A maximum of 1000 TensorboardTimeSeries can be created in a batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest>?
      requests;

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest.fromJson(
      core.Map json_)
      : this(
          requests: (json_['requests'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (requests != null) 'requests': requests!,
      };
}

/// Response message for TensorboardService.BatchCreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse {
  /// The created TensorboardTimeSeries.
  core.List<GoogleCloudAiplatformV1TensorboardTimeSeries>?
      tensorboardTimeSeries;

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse({
    this.tensorboardTimeSeries,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse.fromJson(
      core.Map json_)
      : this(
          tensorboardTimeSeries: (json_['tensorboardTimeSeries'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardTimeSeries != null)
          'tensorboardTimeSeries': tensorboardTimeSeries!,
      };
}

/// A description of resources that are used for performing batch operations,
/// are dedicated to a Model, and need manual configuration.
class GoogleCloudAiplatformV1BatchDedicatedResources {
  /// The specification of a single machine.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The maximum number of machine replicas the batch operation may be scaled
  /// to.
  ///
  /// The default value is 10.
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The number of machine replicas used at the start of the batch operation.
  ///
  /// If not set, Vertex AI decides starting number, not greater than
  /// max_replica_count
  ///
  /// Immutable.
  core.int? startingReplicaCount;

  GoogleCloudAiplatformV1BatchDedicatedResources({
    this.machineSpec,
    this.maxReplicaCount,
    this.startingReplicaCount,
  });

  GoogleCloudAiplatformV1BatchDedicatedResources.fromJson(core.Map json_)
      : this(
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          maxReplicaCount: json_['maxReplicaCount'] as core.int?,
          startingReplicaCount: json_['startingReplicaCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
        if (startingReplicaCount != null)
          'startingReplicaCount': startingReplicaCount!,
      };
}

/// Request message for PipelineService.BatchDeletePipelineJobs.
class GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest {
  /// The names of the PipelineJobs to delete.
  ///
  /// A maximum of 32 PipelineJobs can be deleted in a batch. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  ///
  /// Required.
  core.List<core.String>? names;

  GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest({
    this.names,
  });

  GoogleCloudAiplatformV1BatchDeletePipelineJobsRequest.fromJson(core.Map json_)
      : this(
          names: (json_['names'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (names != null) 'names': names!,
      };
}

/// Request message for ModelService.BatchImportEvaluatedAnnotations
class GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest {
  /// Evaluated annotations resource to be imported.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1EvaluatedAnnotation>? evaluatedAnnotations;

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest({
    this.evaluatedAnnotations,
  });

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest.fromJson(
      core.Map json_)
      : this(
          evaluatedAnnotations: (json_['evaluatedAnnotations'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1EvaluatedAnnotation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (evaluatedAnnotations != null)
          'evaluatedAnnotations': evaluatedAnnotations!,
      };
}

/// Response message for ModelService.BatchImportEvaluatedAnnotations
class GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse {
  /// Number of EvaluatedAnnotations imported.
  ///
  /// Output only.
  core.int? importedEvaluatedAnnotationsCount;

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse({
    this.importedEvaluatedAnnotationsCount,
  });

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse.fromJson(
      core.Map json_)
      : this(
          importedEvaluatedAnnotationsCount:
              json_['importedEvaluatedAnnotationsCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (importedEvaluatedAnnotationsCount != null)
          'importedEvaluatedAnnotationsCount':
              importedEvaluatedAnnotationsCount!,
      };
}

/// Request message for MigrationService.BatchMigrateResources.
class GoogleCloudAiplatformV1BatchMigrateResourcesRequest {
  /// The request messages specifying the resources to migrate.
  ///
  /// They must be in the same location as the destination. Up to 50 resources
  /// can be migrated in one batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1MigrateResourceRequest>?
      migrateResourceRequests;

  GoogleCloudAiplatformV1BatchMigrateResourcesRequest({
    this.migrateResourceRequests,
  });

  GoogleCloudAiplatformV1BatchMigrateResourcesRequest.fromJson(core.Map json_)
      : this(
          migrateResourceRequests:
              (json_['migrateResourceRequests'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1MigrateResourceRequest.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (migrateResourceRequests != null)
          'migrateResourceRequests': migrateResourceRequests!,
      };
}

/// A job that uses a Model to produce predictions on multiple input instances.
///
/// If predictions for significant portion of the instances fail, the job may
/// finish without attempting predictions for all remaining instances.
class GoogleCloudAiplatformV1BatchPredictionJob {
  /// Statistics on completed and failed prediction instances.
  ///
  /// Output only.
  GoogleCloudAiplatformV1CompletionStats? completionStats;

  /// Time when the BatchPredictionJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The config of resources used by the Model during the batch prediction.
  ///
  /// If the Model supports DEDICATED_RESOURCES this config may be provided (and
  /// the job will use these resources), if the Model doesn't support
  /// AUTOMATIC_RESOURCES, this config must be provided.
  GoogleCloudAiplatformV1BatchDedicatedResources? dedicatedResources;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to Cloud
  /// Logging by default.
  ///
  /// Please note that the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging/pricing). User
  /// can disable container logging by setting this flag to true.
  core.bool? disableContainerLogging;

  /// The user-defined name of this BatchPredictionJob.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a BatchPredictionJob.
  ///
  /// If this is set, then all resources created by the BatchPredictionJob will
  /// be encrypted with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the BatchPredictionJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when the job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Explanation configuration for this BatchPredictionJob.
  ///
  /// Can be specified only if generate_explanation is set to `true`. This value
  /// overrides the value of Model.explanation_spec. All fields of
  /// explanation_spec are optional in the request. If a field of the
  /// explanation_spec object is not populated, the corresponding field of the
  /// Model.explanation_spec object is inherited.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// Generate explanation with the batch prediction results.
  ///
  /// When set to `true`, the batch prediction output changes based on the
  /// `predictions_format` field of the BatchPredictionJob.output_config object:
  /// * `bigquery`: output includes a column named `explanation`. The value is a
  /// struct that conforms to the Explanation object. * `jsonl`: The JSON
  /// objects on each line include an additional entry keyed `explanation`. The
  /// value of the entry is a JSON object that conforms to the Explanation
  /// object. * `csv`: Generating explanations for CSV format is not supported.
  /// If this field is set to true, either the Model.explanation_spec or
  /// explanation_spec must be populated.
  core.bool? generateExplanation;

  /// Input configuration of the instances on which predictions are performed.
  ///
  /// The schema of any single instance may be specified via the Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  GoogleCloudAiplatformV1BatchPredictionJobInputConfig? inputConfig;

  /// Configuration for how to convert batch prediction input instances to the
  /// prediction instances that are sent to the Model.
  GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig? instanceConfig;

  /// The labels with user-defined metadata to organize BatchPredictionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Parameters configuring the batch behavior.
  ///
  /// Currently only applicable when dedicated_resources are used (in other
  /// cases Vertex AI does the tuning itself).
  ///
  /// Immutable.
  GoogleCloudAiplatformV1ManualBatchTuningParameters?
      manualBatchTuningParameters;

  /// The name of the Model resource that produces the predictions via this job,
  /// must share the same ancestor Location.
  ///
  /// Starting this job has no impact on any existing deployments of the Model
  /// and their resources. Exactly one of model and unmanaged_container_model
  /// must be set. The model resource name may contain version id or version
  /// alias to specify the version. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` if no
  /// version is specified, the default version will be deployed. The model
  /// resource could also be a publisher model. Example:
  /// `publishers/{publisher}/models/{model}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  core.String? model;

  /// The parameters that govern the predictions.
  ///
  /// The schema of the parameters may be specified via the Model's
  /// PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? modelParameters;

  /// The version ID of the Model that produces the predictions via this job.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// Resource name of the BatchPredictionJob.
  ///
  /// Output only.
  core.String? name;

  /// The Configuration specifying where output predictions should be written.
  ///
  /// The schema of any single prediction may be specified as a concatenation of
  /// Model's PredictSchemata's instance_schema_uri and prediction_schema_uri.
  ///
  /// Required.
  GoogleCloudAiplatformV1BatchPredictionJobOutputConfig? outputConfig;

  /// Information further describing the output of this job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1BatchPredictionJobOutputInfo? outputInfo;

  /// Partial failures encountered.
  ///
  /// For example, single files that can't be read. This field never exceeds 20
  /// entries. Status details fields contain standard Google Cloud error
  /// details.
  ///
  /// Output only.
  core.List<GoogleRpcStatus>? partialFailures;

  /// Information about resources that had been consumed by this job.
  ///
  /// Provided in real time at best effort basis, as well as a final value once
  /// the job completes. Note: This field currently may be not populated for
  /// batch predictions that use AutoML Models.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ResourcesConsumed? resourcesConsumed;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// The service account that the DeployedModel's container runs as.
  ///
  /// If not specified, a system generated one will be used, which has minimal
  /// permissions and the custom container, if used, may not have enough
  /// permission to access other Google Cloud resources. Users deploying the
  /// Model must have the `iam.serviceAccounts.actAs` permission on this service
  /// account.
  core.String? serviceAccount;

  /// Time when the BatchPredictionJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Contains model information necessary to perform batch prediction without
  /// requiring uploading to model registry.
  ///
  /// Exactly one of model and unmanaged_container_model must be set.
  GoogleCloudAiplatformV1UnmanagedContainerModel? unmanagedContainerModel;

  /// Time when the BatchPredictionJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1BatchPredictionJob({
    this.completionStats,
    this.createTime,
    this.dedicatedResources,
    this.disableContainerLogging,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.explanationSpec,
    this.generateExplanation,
    this.inputConfig,
    this.instanceConfig,
    this.labels,
    this.manualBatchTuningParameters,
    this.model,
    this.modelParameters,
    this.modelVersionId,
    this.name,
    this.outputConfig,
    this.outputInfo,
    this.partialFailures,
    this.resourcesConsumed,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.unmanagedContainerModel,
    this.updateTime,
  });

  GoogleCloudAiplatformV1BatchPredictionJob.fromJson(core.Map json_)
      : this(
          completionStats: json_.containsKey('completionStats')
              ? GoogleCloudAiplatformV1CompletionStats.fromJson(
                  json_['completionStats']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1BatchDedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          disableContainerLogging:
              json_['disableContainerLogging'] as core.bool?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          generateExplanation: json_['generateExplanation'] as core.bool?,
          inputConfig: json_.containsKey('inputConfig')
              ? GoogleCloudAiplatformV1BatchPredictionJobInputConfig.fromJson(
                  json_['inputConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          instanceConfig: json_.containsKey('instanceConfig')
              ? GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig
                  .fromJson(json_['instanceConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          manualBatchTuningParameters:
              json_.containsKey('manualBatchTuningParameters')
                  ? GoogleCloudAiplatformV1ManualBatchTuningParameters.fromJson(
                      json_['manualBatchTuningParameters']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          model: json_['model'] as core.String?,
          modelParameters: json_['modelParameters'],
          modelVersionId: json_['modelVersionId'] as core.String?,
          name: json_['name'] as core.String?,
          outputConfig: json_.containsKey('outputConfig')
              ? GoogleCloudAiplatformV1BatchPredictionJobOutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          outputInfo: json_.containsKey('outputInfo')
              ? GoogleCloudAiplatformV1BatchPredictionJobOutputInfo.fromJson(
                  json_['outputInfo'] as core.Map<core.String, core.dynamic>)
              : null,
          partialFailures: (json_['partialFailures'] as core.List?)
              ?.map((value) => GoogleRpcStatus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          resourcesConsumed: json_.containsKey('resourcesConsumed')
              ? GoogleCloudAiplatformV1ResourcesConsumed.fromJson(
                  json_['resourcesConsumed']
                      as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          serviceAccount: json_['serviceAccount'] as core.String?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          unmanagedContainerModel: json_.containsKey('unmanagedContainerModel')
              ? GoogleCloudAiplatformV1UnmanagedContainerModel.fromJson(
                  json_['unmanagedContainerModel']
                      as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (completionStats != null) 'completionStats': completionStats!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (disableContainerLogging != null)
          'disableContainerLogging': disableContainerLogging!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (generateExplanation != null)
          'generateExplanation': generateExplanation!,
        if (inputConfig != null) 'inputConfig': inputConfig!,
        if (instanceConfig != null) 'instanceConfig': instanceConfig!,
        if (labels != null) 'labels': labels!,
        if (manualBatchTuningParameters != null)
          'manualBatchTuningParameters': manualBatchTuningParameters!,
        if (model != null) 'model': model!,
        if (modelParameters != null) 'modelParameters': modelParameters!,
        if (modelVersionId != null) 'modelVersionId': modelVersionId!,
        if (name != null) 'name': name!,
        if (outputConfig != null) 'outputConfig': outputConfig!,
        if (outputInfo != null) 'outputInfo': outputInfo!,
        if (partialFailures != null) 'partialFailures': partialFailures!,
        if (resourcesConsumed != null) 'resourcesConsumed': resourcesConsumed!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (unmanagedContainerModel != null)
          'unmanagedContainerModel': unmanagedContainerModel!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Configures the input to BatchPredictionJob.
///
/// See Model.supported_input_storage_formats for Model's supported input
/// formats, and how instances should be expressed via any of them.
class GoogleCloudAiplatformV1BatchPredictionJobInputConfig {
  /// The BigQuery location of the input table.
  ///
  /// The schema of the table should be in the format described by the given
  /// context OpenAPI Schema, if one is provided. The table may contain
  /// additional columns that are not described by the schema, and they will be
  /// ignored.
  GoogleCloudAiplatformV1BigQuerySource? bigquerySource;

  /// The Cloud Storage location for the input instances.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// The format in which instances are given, must be one of the Model's
  /// supported_input_storage_formats.
  ///
  /// Required.
  core.String? instancesFormat;

  GoogleCloudAiplatformV1BatchPredictionJobInputConfig({
    this.bigquerySource,
    this.gcsSource,
    this.instancesFormat,
  });

  GoogleCloudAiplatformV1BatchPredictionJobInputConfig.fromJson(core.Map json_)
      : this(
          bigquerySource: json_.containsKey('bigquerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          instancesFormat: json_['instancesFormat'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigquerySource != null) 'bigquerySource': bigquerySource!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (instancesFormat != null) 'instancesFormat': instancesFormat!,
      };
}

/// Configuration defining how to transform batch prediction input instances to
/// the instances that the Model accepts.
class GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig {
  /// Fields that will be excluded in the prediction instance that is sent to
  /// the Model.
  ///
  /// Excluded will be attached to the batch prediction output if key_field is
  /// not specified. When excluded_fields is populated, included_fields must be
  /// empty. The input must be JSONL with objects at each line, BigQuery or
  /// TfRecord.
  core.List<core.String>? excludedFields;

  /// Fields that will be included in the prediction instance that is sent to
  /// the Model.
  ///
  /// If instance_type is `array`, the order of field names in included_fields
  /// also determines the order of the values in the array. When included_fields
  /// is populated, excluded_fields must be empty. The input must be JSONL with
  /// objects at each line, BigQuery or TfRecord.
  core.List<core.String>? includedFields;

  /// The format of the instance that the Model accepts.
  ///
  /// Vertex AI will convert compatible batch prediction input instance formats
  /// to the specified format. Supported values are: * `object`: Each input is
  /// converted to JSON object format. * For `bigquery`, each row is converted
  /// to an object. * For `jsonl`, each line of the JSONL input must be an
  /// object. * Does not apply to `csv`, `file-list`, `tf-record`, or
  /// `tf-record-gzip`. * `array`: Each input is converted to JSON array format.
  /// * For `bigquery`, each row is converted to an array. The order of columns
  /// is determined by the BigQuery column order, unless included_fields is
  /// populated. included_fields must be populated for specifying field orders.
  /// * For `jsonl`, if each line of the JSONL input is an object,
  /// included_fields must be populated for specifying field orders. * Does not
  /// apply to `csv`, `file-list`, `tf-record`, or `tf-record-gzip`. If not
  /// specified, Vertex AI converts the batch prediction input as follows: * For
  /// `bigquery` and `csv`, the behavior is the same as `array`. The order of
  /// columns is the same as defined in the file or table, unless
  /// included_fields is populated. * For `jsonl`, the prediction instance
  /// format is determined by each line of the input. * For
  /// `tf-record`/`tf-record-gzip`, each record will be converted to an object
  /// in the format of `{"b64": }`, where `` is the Base64-encoded string of the
  /// content of the record. * For `file-list`, each file in the list will be
  /// converted to an object in the format of `{"b64": }`, where `` is the
  /// Base64-encoded string of the content of the file.
  core.String? instanceType;

  /// The name of the field that is considered as a key.
  ///
  /// The values identified by the key field is not included in the transformed
  /// instances that is sent to the Model. This is similar to specifying this
  /// name of the field in excluded_fields. In addition, the batch prediction
  /// output will not include the instances. Instead the output will only
  /// include the value of the key field, in a field named `key` in the output:
  /// * For `jsonl` output format, the output will have a `key` field instead of
  /// the `instance` field. * For `csv`/`bigquery` output format, the output
  /// will have have a `key` column instead of the instance feature columns. The
  /// input must be JSONL with objects at each line, CSV, BigQuery or TfRecord.
  core.String? keyField;

  GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig({
    this.excludedFields,
    this.includedFields,
    this.instanceType,
    this.keyField,
  });

  GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig.fromJson(
      core.Map json_)
      : this(
          excludedFields: (json_['excludedFields'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          includedFields: (json_['includedFields'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          instanceType: json_['instanceType'] as core.String?,
          keyField: json_['keyField'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (excludedFields != null) 'excludedFields': excludedFields!,
        if (includedFields != null) 'includedFields': includedFields!,
        if (instanceType != null) 'instanceType': instanceType!,
        if (keyField != null) 'keyField': keyField!,
      };
}

/// Configures the output of BatchPredictionJob.
///
/// See Model.supported_output_storage_formats for supported output formats, and
/// how predictions are expressed via any of them.
class GoogleCloudAiplatformV1BatchPredictionJobOutputConfig {
  /// The BigQuery project or dataset location where the output is to be written
  /// to.
  ///
  /// If project is provided, a new dataset is created with name `prediction__`
  /// where is made BigQuery-dataset-name compatible (for example, most special
  /// characters become underscores), and timestamp is in
  /// YYYY_MM_DDThh_mm_ss_sssZ "based on ISO-8601" format. In the dataset two
  /// tables will be created, `predictions`, and `errors`. If the Model has both
  /// instance and prediction schemata defined then the tables have columns as
  /// follows: The `predictions` table contains instances for which the
  /// prediction succeeded, it has columns as per a concatenation of the Model's
  /// instance and prediction schemata. The `errors` table contains rows for
  /// which the prediction has failed, it has instance columns, as per the
  /// instance schema, followed by a single "errors" column, which as values has
  /// google.rpc.Status represented as a STRUCT, and containing only `code` and
  /// `message`.
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// The Cloud Storage location of the directory where the output is to be
  /// written to.
  ///
  /// In the given directory a new directory is created. Its name is
  /// `prediction--`, where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601
  /// format. Inside of it files `predictions_0001.`, `predictions_0002.`, ...,
  /// `predictions_N.` are created where `` depends on chosen
  /// predictions_format, and N may equal 0001 and depends on the total number
  /// of successfully predicted instances. If the Model has both instance and
  /// prediction schemata defined then each such file contains predictions as
  /// per the predictions_format. If prediction for any instance failed
  /// (partially or completely), then an additional `errors_0001.`,
  /// `errors_0002.`,..., `errors_N.` files are created (N depends on total
  /// number of failed predictions). These files contain the failed instances,
  /// as per their schema, followed by an additional `error` field which as
  /// value has google.rpc.Status containing only `code` and `message` fields.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  /// The format in which Vertex AI gives the predictions, must be one of the
  /// Model's supported_output_storage_formats.
  ///
  /// Required.
  core.String? predictionsFormat;

  GoogleCloudAiplatformV1BatchPredictionJobOutputConfig({
    this.bigqueryDestination,
    this.gcsDestination,
    this.predictionsFormat,
  });

  GoogleCloudAiplatformV1BatchPredictionJobOutputConfig.fromJson(core.Map json_)
      : this(
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          predictionsFormat: json_['predictionsFormat'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
        if (predictionsFormat != null) 'predictionsFormat': predictionsFormat!,
      };
}

/// Further describes this job's output.
///
/// Supplements output_config.
class GoogleCloudAiplatformV1BatchPredictionJobOutputInfo {
  /// The path of the BigQuery dataset created, in `bq://projectId.bqDatasetId`
  /// format, into which the prediction output is written.
  ///
  /// Output only.
  core.String? bigqueryOutputDataset;

  /// The name of the BigQuery table created, in `predictions_` format, into
  /// which the prediction output is written.
  ///
  /// Can be used by UI to generate the BigQuery output path, for example.
  ///
  /// Output only.
  core.String? bigqueryOutputTable;

  /// The full path of the Cloud Storage directory created, into which the
  /// prediction output is written.
  ///
  /// Output only.
  core.String? gcsOutputDirectory;

  GoogleCloudAiplatformV1BatchPredictionJobOutputInfo({
    this.bigqueryOutputDataset,
    this.bigqueryOutputTable,
    this.gcsOutputDirectory,
  });

  GoogleCloudAiplatformV1BatchPredictionJobOutputInfo.fromJson(core.Map json_)
      : this(
          bigqueryOutputDataset: json_['bigqueryOutputDataset'] as core.String?,
          bigqueryOutputTable: json_['bigqueryOutputTable'] as core.String?,
          gcsOutputDirectory: json_['gcsOutputDirectory'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryOutputDataset != null)
          'bigqueryOutputDataset': bigqueryOutputDataset!,
        if (bigqueryOutputTable != null)
          'bigqueryOutputTable': bigqueryOutputTable!,
        if (gcsOutputDirectory != null)
          'gcsOutputDirectory': gcsOutputDirectory!,
      };
}

/// Request message for FeaturestoreService.BatchReadFeatureValues.
class GoogleCloudAiplatformV1BatchReadFeatureValuesRequest {
  /// Similar to csv_read_instances, but from BigQuery source.
  GoogleCloudAiplatformV1BigQuerySource? bigqueryReadInstances;

  /// Each read instance consists of exactly one read timestamp and one or more
  /// entity IDs identifying entities of the corresponding EntityTypes whose
  /// Features are requested.
  ///
  /// Each output instance contains Feature values of requested entities
  /// concatenated together as of the read time. An example read instance may be
  /// `foo_entity_id, bar_entity_id, 2020-01-01T10:00:00.123Z`. An example
  /// output instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
  /// bar_entity_feature2_value`. Timestamp in each read instance must be
  /// millisecond-aligned. `csv_read_instances` are read instances stored in a
  /// plain-text CSV file. The header should be: \[ENTITY_TYPE_ID1\],
  /// \[ENTITY_TYPE_ID2\], ..., timestamp The columns can be in any order.
  /// Values in the timestamp column must use the RFC 3339 format, e.g.
  /// `2012-07-30T10:43:17.123Z`.
  GoogleCloudAiplatformV1CsvSource? csvReadInstances;

  /// Specifies output location and format.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureValueDestination? destination;

  /// Specifies EntityType grouping Features to read values of and settings.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec>?
      entityTypeSpecs;

  /// When not empty, the specified fields in the *_read_instances source will
  /// be joined as-is in the output, in addition to those fields from the
  /// Featurestore Entity.
  ///
  /// For BigQuery source, the type of the pass-through values will be
  /// automatically inferred. For CSV source, the pass-through values will be
  /// passed as opaque bytes.
  core.List<
          GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField>?
      passThroughFields;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  ///
  /// Optional.
  core.String? startTime;

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequest({
    this.bigqueryReadInstances,
    this.csvReadInstances,
    this.destination,
    this.entityTypeSpecs,
    this.passThroughFields,
    this.startTime,
  });

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          bigqueryReadInstances: json_.containsKey('bigqueryReadInstances')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigqueryReadInstances']
                      as core.Map<core.String, core.dynamic>)
              : null,
          csvReadInstances: json_.containsKey('csvReadInstances')
              ? GoogleCloudAiplatformV1CsvSource.fromJson(
                  json_['csvReadInstances']
                      as core.Map<core.String, core.dynamic>)
              : null,
          destination: json_.containsKey('destination')
              ? GoogleCloudAiplatformV1FeatureValueDestination.fromJson(
                  json_['destination'] as core.Map<core.String, core.dynamic>)
              : null,
          entityTypeSpecs: (json_['entityTypeSpecs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          passThroughFields: (json_['passThroughFields'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          startTime: json_['startTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryReadInstances != null)
          'bigqueryReadInstances': bigqueryReadInstances!,
        if (csvReadInstances != null) 'csvReadInstances': csvReadInstances!,
        if (destination != null) 'destination': destination!,
        if (entityTypeSpecs != null) 'entityTypeSpecs': entityTypeSpecs!,
        if (passThroughFields != null) 'passThroughFields': passThroughFields!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Selects Features of an EntityType to read values of and specifies read
/// settings.
class GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec {
  /// ID of the EntityType to select Features.
  ///
  /// The EntityType id is the entity_type_id specified during EntityType
  /// creation.
  ///
  /// Required.
  core.String? entityTypeId;

  /// Selectors choosing which Feature values to read from the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  /// Per-Feature settings for the batch read.
  core.List<GoogleCloudAiplatformV1DestinationFeatureSetting>? settings;

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec({
    this.entityTypeId,
    this.featureSelector,
    this.settings,
  });

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec.fromJson(
      core.Map json_)
      : this(
          entityTypeId: json_['entityTypeId'] as core.String?,
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
          settings: (json_['settings'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1DestinationFeatureSetting.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityTypeId != null) 'entityTypeId': entityTypeId!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
        if (settings != null) 'settings': settings!,
      };
}

/// Describe pass-through fields in read_instance source.
class GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField {
  /// The name of the field in the CSV header or the name of the column in
  /// BigQuery table.
  ///
  /// The naming restriction is the same as Feature.name.
  ///
  /// Required.
  core.String? fieldName;

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField({
    this.fieldName,
  });

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField.fromJson(
      core.Map json_)
      : this(
          fieldName: json_['fieldName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fieldName != null) 'fieldName': fieldName!,
      };
}

/// Response message for TensorboardService.BatchReadTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse {
  /// The returned time series data.
  core.List<GoogleCloudAiplatformV1TimeSeriesData>? timeSeriesData;

  GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse({
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse.fromJson(
      core.Map json_)
      : this(
          timeSeriesData: (json_['timeSeriesData'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TimeSeriesData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
      };
}

/// The BigQuery location for the output content.
class GoogleCloudAiplatformV1BigQueryDestination {
  /// BigQuery URI to a project or table, up to 2000 characters long.
  ///
  /// When only the project is specified, the Dataset and Table is created. When
  /// the full table reference is specified, the Dataset must exist and table
  /// must not exist. Accepted forms: * BigQuery path. For example:
  /// `bq://projectId` or `bq://projectId.bqDatasetId` or
  /// `bq://projectId.bqDatasetId.bqTableId`.
  ///
  /// Required.
  core.String? outputUri;

  GoogleCloudAiplatformV1BigQueryDestination({
    this.outputUri,
  });

  GoogleCloudAiplatformV1BigQueryDestination.fromJson(core.Map json_)
      : this(
          outputUri: json_['outputUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputUri != null) 'outputUri': outputUri!,
      };
}

/// The BigQuery location for the input content.
class GoogleCloudAiplatformV1BigQuerySource {
  /// BigQuery URI to a table, up to 2000 characters long.
  ///
  /// Accepted forms: * BigQuery path. For example:
  /// `bq://projectId.bqDatasetId.bqTableId`.
  ///
  /// Required.
  core.String? inputUri;

  GoogleCloudAiplatformV1BigQuerySource({
    this.inputUri,
  });

  GoogleCloudAiplatformV1BigQuerySource.fromJson(core.Map json_)
      : this(
          inputUri: json_['inputUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputUri != null) 'inputUri': inputUri!,
      };
}

/// Input for bleu metric.
class GoogleCloudAiplatformV1BleuInput {
  /// Repeated bleu instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1BleuInstance>? instances;

  /// Spec for bleu score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1BleuSpec? metricSpec;

  GoogleCloudAiplatformV1BleuInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1BleuInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1BleuInstance.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1BleuSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for bleu instance.
typedef GoogleCloudAiplatformV1BleuInstance = $Instance00;

/// Bleu metric value for an instance.
class GoogleCloudAiplatformV1BleuMetricValue {
  /// Bleu score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1BleuMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1BleuMetricValue.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for bleu metric.
class GoogleCloudAiplatformV1BleuResults {
  /// Bleu metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1BleuMetricValue>? bleuMetricValues;

  GoogleCloudAiplatformV1BleuResults({
    this.bleuMetricValues,
  });

  GoogleCloudAiplatformV1BleuResults.fromJson(core.Map json_)
      : this(
          bleuMetricValues: (json_['bleuMetricValues'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1BleuMetricValue.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bleuMetricValues != null) 'bleuMetricValues': bleuMetricValues!,
      };
}

/// Spec for bleu score metric - calculates the precision of n-grams in the
/// prediction as compared to reference - returns a score ranging between 0 to
/// 1.
class GoogleCloudAiplatformV1BleuSpec {
  /// Whether to use_effective_order to compute bleu score.
  ///
  /// Optional.
  core.bool? useEffectiveOrder;

  GoogleCloudAiplatformV1BleuSpec({
    this.useEffectiveOrder,
  });

  GoogleCloudAiplatformV1BleuSpec.fromJson(core.Map json_)
      : this(
          useEffectiveOrder: json_['useEffectiveOrder'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useEffectiveOrder != null) 'useEffectiveOrder': useEffectiveOrder!,
      };
}

/// Content blob.
class GoogleCloudAiplatformV1Blob {
  /// Raw bytes.
  ///
  /// Required.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Display name of the blob.
  ///
  /// Used to provide a label or filename to distinguish blobs. This field is
  /// only returned in PromptMessage for prompt management. It is not currently
  /// used in the Gemini GenerateContent calls.
  ///
  /// Optional.
  core.String? displayName;

  /// The IANA standard MIME type of the source data.
  ///
  /// Required.
  core.String? mimeType;

  GoogleCloudAiplatformV1Blob({
    this.data,
    this.displayName,
    this.mimeType,
  });

  GoogleCloudAiplatformV1Blob.fromJson(core.Map json_)
      : this(
          data: json_['data'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          mimeType: json_['mimeType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (data != null) 'data': data!,
        if (displayName != null) 'displayName': displayName!,
        if (mimeType != null) 'mimeType': mimeType!,
      };
}

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// https://arxiv.org/abs/2004.03383
class GoogleCloudAiplatformV1BlurBaselineConfig {
  /// The standard deviation of the blur kernel for the blurred baseline.
  ///
  /// The same blurring parameter is used for both the height and the width
  /// dimension. If not set, the method defaults to the zero (i.e. black for
  /// images) baseline.
  core.double? maxBlurSigma;

  GoogleCloudAiplatformV1BlurBaselineConfig({
    this.maxBlurSigma,
  });

  GoogleCloudAiplatformV1BlurBaselineConfig.fromJson(core.Map json_)
      : this(
          maxBlurSigma: (json_['maxBlurSigma'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxBlurSigma != null) 'maxBlurSigma': maxBlurSigma!,
      };
}

/// A list of boolean values.
class GoogleCloudAiplatformV1BoolArray {
  /// A list of bool values.
  core.List<core.bool>? values;

  GoogleCloudAiplatformV1BoolArray({
    this.values,
  });

  GoogleCloudAiplatformV1BoolArray.fromJson(core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => value as core.bool)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Config of GenAI caching features.
///
/// This is a singleton resource.
class GoogleCloudAiplatformV1CacheConfig {
  /// If set to true, disables GenAI caching.
  ///
  /// Otherwise caching is enabled.
  core.bool? disableCache;

  /// Identifier.
  ///
  /// Name of the cache config. Format: - `projects/{project}/cacheConfig`.
  core.String? name;

  GoogleCloudAiplatformV1CacheConfig({
    this.disableCache,
    this.name,
  });

  GoogleCloudAiplatformV1CacheConfig.fromJson(core.Map json_)
      : this(
          disableCache: json_['disableCache'] as core.bool?,
          name: json_['name'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disableCache != null) 'disableCache': disableCache!,
        if (name != null) 'name': name!,
      };
}

/// A resource used in LLM queries for users to explicitly specify what to cache
/// and how to cache.
class GoogleCloudAiplatformV1CachedContent {
  /// Input only.
  ///
  /// Immutable. The content to cache
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Content>? contents;

  /// Creation time of the cache entry.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-generated meaningful display name of the cached content.
  ///
  /// Optional. Immutable.
  core.String? displayName;

  /// Timestamp of when this resource is considered expired.
  ///
  /// This is *always* provided on output, regardless of what was sent on input.
  core.String? expireTime;

  /// The name of the `Model` to use for cached content.
  ///
  /// Currently, only the published Gemini base models are supported, in form of
  /// projects/{PROJECT}/locations/{LOCATION}/publishers/google/models/{MODEL}
  ///
  /// Immutable.
  core.String? model;

  /// Identifier.
  ///
  /// The server-generated resource name of the cached content Format:
  /// projects/{project}/locations/{location}/cachedContents/{cached_content}
  ///
  /// Immutable.
  core.String? name;

  /// Input only.
  ///
  /// Immutable. Developer set system instruction. Currently, text only
  ///
  /// Optional.
  GoogleCloudAiplatformV1Content? systemInstruction;

  /// Input only.
  ///
  /// Immutable. Tool config. This config is shared for all tools
  ///
  /// Optional.
  GoogleCloudAiplatformV1ToolConfig? toolConfig;

  /// Input only.
  ///
  /// Immutable. A list of `Tools` the model may use to generate the next
  /// response
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Tool>? tools;

  /// Input only.
  ///
  /// The TTL for this resource. The expiration time is computed: now + TTL.
  core.String? ttl;

  /// When the cache entry was last updated in UTC time.
  ///
  /// Output only.
  core.String? updateTime;

  /// Metadata on the usage of the cached content.
  ///
  /// Output only.
  GoogleCloudAiplatformV1CachedContentUsageMetadata? usageMetadata;

  GoogleCloudAiplatformV1CachedContent({
    this.contents,
    this.createTime,
    this.displayName,
    this.expireTime,
    this.model,
    this.name,
    this.systemInstruction,
    this.toolConfig,
    this.tools,
    this.ttl,
    this.updateTime,
    this.usageMetadata,
  });

  GoogleCloudAiplatformV1CachedContent.fromJson(core.Map json_)
      : this(
          contents: (json_['contents'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Content.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          expireTime: json_['expireTime'] as core.String?,
          model: json_['model'] as core.String?,
          name: json_['name'] as core.String?,
          systemInstruction: json_.containsKey('systemInstruction')
              ? GoogleCloudAiplatformV1Content.fromJson(
                  json_['systemInstruction']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolConfig: json_.containsKey('toolConfig')
              ? GoogleCloudAiplatformV1ToolConfig.fromJson(
                  json_['toolConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          tools: (json_['tools'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tool.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          ttl: json_['ttl'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
          usageMetadata: json_.containsKey('usageMetadata')
              ? GoogleCloudAiplatformV1CachedContentUsageMetadata.fromJson(
                  json_['usageMetadata'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (expireTime != null) 'expireTime': expireTime!,
        if (model != null) 'model': model!,
        if (name != null) 'name': name!,
        if (systemInstruction != null) 'systemInstruction': systemInstruction!,
        if (toolConfig != null) 'toolConfig': toolConfig!,
        if (tools != null) 'tools': tools!,
        if (ttl != null) 'ttl': ttl!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (usageMetadata != null) 'usageMetadata': usageMetadata!,
      };
}

/// Metadata on the usage of the cached content.
class GoogleCloudAiplatformV1CachedContentUsageMetadata {
  /// Duration of audio in seconds.
  core.int? audioDurationSeconds;

  /// Number of images.
  core.int? imageCount;

  /// Number of text characters.
  core.int? textCount;

  /// Total number of tokens that the cached content consumes.
  core.int? totalTokenCount;

  /// Duration of video in seconds.
  core.int? videoDurationSeconds;

  GoogleCloudAiplatformV1CachedContentUsageMetadata({
    this.audioDurationSeconds,
    this.imageCount,
    this.textCount,
    this.totalTokenCount,
    this.videoDurationSeconds,
  });

  GoogleCloudAiplatformV1CachedContentUsageMetadata.fromJson(core.Map json_)
      : this(
          audioDurationSeconds: json_['audioDurationSeconds'] as core.int?,
          imageCount: json_['imageCount'] as core.int?,
          textCount: json_['textCount'] as core.int?,
          totalTokenCount: json_['totalTokenCount'] as core.int?,
          videoDurationSeconds: json_['videoDurationSeconds'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (audioDurationSeconds != null)
          'audioDurationSeconds': audioDurationSeconds!,
        if (imageCount != null) 'imageCount': imageCount!,
        if (textCount != null) 'textCount': textCount!,
        if (totalTokenCount != null) 'totalTokenCount': totalTokenCount!,
        if (videoDurationSeconds != null)
          'videoDurationSeconds': videoDurationSeconds!,
      };
}

/// Request message for JobService.CancelBatchPredictionJob.
typedef GoogleCloudAiplatformV1CancelBatchPredictionJobRequest = $Empty;

/// Request message for JobService.CancelCustomJob.
typedef GoogleCloudAiplatformV1CancelCustomJobRequest = $Empty;

/// Request message for JobService.CancelDataLabelingJob.
typedef GoogleCloudAiplatformV1CancelDataLabelingJobRequest = $Empty;

/// Request message for JobService.CancelHyperparameterTuningJob.
typedef GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest = $Empty;

/// Request message for JobService.CancelNasJob.
typedef GoogleCloudAiplatformV1CancelNasJobRequest = $Empty;

/// Request message for PipelineService.CancelPipelineJob.
typedef GoogleCloudAiplatformV1CancelPipelineJobRequest = $Empty;

/// Request message for PipelineService.CancelTrainingPipeline.
typedef GoogleCloudAiplatformV1CancelTrainingPipelineRequest = $Empty;

/// Request message for GenAiTuningService.CancelTuningJob.
typedef GoogleCloudAiplatformV1CancelTuningJobRequest = $Empty;

/// A response candidate generated from the model.
class GoogleCloudAiplatformV1Candidate {
  /// Average log probability score of the candidate.
  ///
  /// Output only.
  core.double? avgLogprobs;

  /// Source attribution of the generated content.
  ///
  /// Output only.
  GoogleCloudAiplatformV1CitationMetadata? citationMetadata;

  /// Content parts of the candidate.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Content? content;

  /// Describes the reason the mode stopped generating tokens in more detail.
  ///
  /// This is only filled when `finish_reason` is set.
  ///
  /// Output only.
  core.String? finishMessage;

  /// The reason why the model stopped generating tokens.
  ///
  /// If empty, the model has not stopped generating the tokens.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "FINISH_REASON_UNSPECIFIED" : The finish reason is unspecified.
  /// - "STOP" : Token generation reached a natural stopping point or a
  /// configured stop sequence.
  /// - "MAX_TOKENS" : Token generation reached the configured maximum output
  /// tokens.
  /// - "SAFETY" : Token generation stopped because the content potentially
  /// contains safety violations. NOTE: When streaming, content is empty if
  /// content filters blocks the output.
  /// - "RECITATION" : The token generation stopped because of potential
  /// recitation.
  /// - "OTHER" : All other reasons that stopped the token generation.
  /// - "BLOCKLIST" : Token generation stopped because the content contains
  /// forbidden terms.
  /// - "PROHIBITED_CONTENT" : Token generation stopped for potentially
  /// containing prohibited content.
  /// - "SPII" : Token generation stopped because the content potentially
  /// contains Sensitive Personally Identifiable Information (SPII).
  /// - "MALFORMED_FUNCTION_CALL" : The function call generated by the model is
  /// invalid.
  core.String? finishReason;

  /// Metadata specifies sources used to ground generated content.
  ///
  /// Output only.
  GoogleCloudAiplatformV1GroundingMetadata? groundingMetadata;

  /// Index of the candidate.
  ///
  /// Output only.
  core.int? index;

  /// Log-likelihood scores for the response tokens and top tokens
  ///
  /// Output only.
  GoogleCloudAiplatformV1LogprobsResult? logprobsResult;

  /// List of ratings for the safety of a response candidate.
  ///
  /// There is at most one rating per category.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1SafetyRating>? safetyRatings;

  GoogleCloudAiplatformV1Candidate({
    this.avgLogprobs,
    this.citationMetadata,
    this.content,
    this.finishMessage,
    this.finishReason,
    this.groundingMetadata,
    this.index,
    this.logprobsResult,
    this.safetyRatings,
  });

  GoogleCloudAiplatformV1Candidate.fromJson(core.Map json_)
      : this(
          avgLogprobs: (json_['avgLogprobs'] as core.num?)?.toDouble(),
          citationMetadata: json_.containsKey('citationMetadata')
              ? GoogleCloudAiplatformV1CitationMetadata.fromJson(
                  json_['citationMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          content: json_.containsKey('content')
              ? GoogleCloudAiplatformV1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>)
              : null,
          finishMessage: json_['finishMessage'] as core.String?,
          finishReason: json_['finishReason'] as core.String?,
          groundingMetadata: json_.containsKey('groundingMetadata')
              ? GoogleCloudAiplatformV1GroundingMetadata.fromJson(
                  json_['groundingMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          index: json_['index'] as core.int?,
          logprobsResult: json_.containsKey('logprobsResult')
              ? GoogleCloudAiplatformV1LogprobsResult.fromJson(
                  json_['logprobsResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          safetyRatings: (json_['safetyRatings'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1SafetyRating.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (avgLogprobs != null) 'avgLogprobs': avgLogprobs!,
        if (citationMetadata != null) 'citationMetadata': citationMetadata!,
        if (content != null) 'content': content!,
        if (finishMessage != null) 'finishMessage': finishMessage!,
        if (finishReason != null) 'finishReason': finishReason!,
        if (groundingMetadata != null) 'groundingMetadata': groundingMetadata!,
        if (index != null) 'index': index!,
        if (logprobsResult != null) 'logprobsResult': logprobsResult!,
        if (safetyRatings != null) 'safetyRatings': safetyRatings!,
      };
}

/// Request message for VizierService.CheckTrialEarlyStoppingState.
typedef GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest = $Empty;

/// Source attributions for content.
class GoogleCloudAiplatformV1Citation {
  /// End index into the content.
  ///
  /// Output only.
  core.int? endIndex;

  /// License of the attribution.
  ///
  /// Output only.
  core.String? license;

  /// Publication date of the attribution.
  ///
  /// Output only.
  GoogleTypeDate? publicationDate;

  /// Start index into the content.
  ///
  /// Output only.
  core.int? startIndex;

  /// Title of the attribution.
  ///
  /// Output only.
  core.String? title;

  /// Url reference of the attribution.
  ///
  /// Output only.
  core.String? uri;

  GoogleCloudAiplatformV1Citation({
    this.endIndex,
    this.license,
    this.publicationDate,
    this.startIndex,
    this.title,
    this.uri,
  });

  GoogleCloudAiplatformV1Citation.fromJson(core.Map json_)
      : this(
          endIndex: json_['endIndex'] as core.int?,
          license: json_['license'] as core.String?,
          publicationDate: json_.containsKey('publicationDate')
              ? GoogleTypeDate.fromJson(json_['publicationDate']
                  as core.Map<core.String, core.dynamic>)
              : null,
          startIndex: json_['startIndex'] as core.int?,
          title: json_['title'] as core.String?,
          uri: json_['uri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endIndex != null) 'endIndex': endIndex!,
        if (license != null) 'license': license!,
        if (publicationDate != null) 'publicationDate': publicationDate!,
        if (startIndex != null) 'startIndex': startIndex!,
        if (title != null) 'title': title!,
        if (uri != null) 'uri': uri!,
      };
}

/// A collection of source attributions for a piece of content.
class GoogleCloudAiplatformV1CitationMetadata {
  /// List of citations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Citation>? citations;

  GoogleCloudAiplatformV1CitationMetadata({
    this.citations,
  });

  GoogleCloudAiplatformV1CitationMetadata.fromJson(core.Map json_)
      : this(
          citations: (json_['citations'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Citation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (citations != null) 'citations': citations!,
      };
}

/// Claim that is extracted from the input text and facts that support it.
class GoogleCloudAiplatformV1Claim {
  /// Index in the input text where the claim ends (exclusive).
  core.int? endIndex;

  /// Indexes of the facts supporting this claim.
  core.List<core.int>? factIndexes;

  /// Confidence score of this corroboration.
  core.double? score;

  /// Index in the input text where the claim starts (inclusive).
  core.int? startIndex;

  GoogleCloudAiplatformV1Claim({
    this.endIndex,
    this.factIndexes,
    this.score,
    this.startIndex,
  });

  GoogleCloudAiplatformV1Claim.fromJson(core.Map json_)
      : this(
          endIndex: json_['endIndex'] as core.int?,
          factIndexes: (json_['factIndexes'] as core.List?)
              ?.map((value) => value as core.int)
              .toList(),
          score: (json_['score'] as core.num?)?.toDouble(),
          startIndex: json_['startIndex'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endIndex != null) 'endIndex': endIndex!,
        if (factIndexes != null) 'factIndexes': factIndexes!,
        if (score != null) 'score': score!,
        if (startIndex != null) 'startIndex': startIndex!,
      };
}

/// Configurations (e.g. inference timeout) that are applied on your endpoints.
class GoogleCloudAiplatformV1ClientConnectionConfig {
  /// Customizable online prediction request timeout.
  core.String? inferenceTimeout;

  GoogleCloudAiplatformV1ClientConnectionConfig({
    this.inferenceTimeout,
  });

  GoogleCloudAiplatformV1ClientConnectionConfig.fromJson(core.Map json_)
      : this(
          inferenceTimeout: json_['inferenceTimeout'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inferenceTimeout != null) 'inferenceTimeout': inferenceTimeout!,
      };
}

/// Result of executing the \[ExecutableCode\].
///
/// Always follows a `part` containing the \[ExecutableCode\].
class GoogleCloudAiplatformV1CodeExecutionResult {
  /// Outcome of the code execution.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OUTCOME_UNSPECIFIED" : Unspecified status. This value should not be
  /// used.
  /// - "OUTCOME_OK" : Code execution completed successfully.
  /// - "OUTCOME_FAILED" : Code execution finished but with a failure. `stderr`
  /// should contain the reason.
  /// - "OUTCOME_DEADLINE_EXCEEDED" : Code execution ran for too long, and was
  /// cancelled. There may or may not be a partial output present.
  core.String? outcome;

  /// Contains stdout when code execution is successful, stderr or other
  /// description otherwise.
  ///
  /// Optional.
  core.String? output;

  GoogleCloudAiplatformV1CodeExecutionResult({
    this.outcome,
    this.output,
  });

  GoogleCloudAiplatformV1CodeExecutionResult.fromJson(core.Map json_)
      : this(
          outcome: json_['outcome'] as core.String?,
          output: json_['output'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outcome != null) 'outcome': outcome!,
        if (output != null) 'output': output!,
      };
}

/// Input for coherence metric.
class GoogleCloudAiplatformV1CoherenceInput {
  /// Coherence instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1CoherenceInstance? instance;

  /// Spec for coherence score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1CoherenceSpec? metricSpec;

  GoogleCloudAiplatformV1CoherenceInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1CoherenceInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1CoherenceInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1CoherenceSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for coherence instance.
typedef GoogleCloudAiplatformV1CoherenceInstance = $Instance01;

/// Spec for coherence result.
class GoogleCloudAiplatformV1CoherenceResult {
  /// Confidence for coherence score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for coherence score.
  ///
  /// Output only.
  core.String? explanation;

  /// Coherence score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1CoherenceResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1CoherenceResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for coherence score metric.
typedef GoogleCloudAiplatformV1CoherenceSpec = $Spec;

/// Input for Comet metric.
class GoogleCloudAiplatformV1CometInput {
  /// Comet instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1CometInstance? instance;

  /// Spec for comet metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1CometSpec? metricSpec;

  GoogleCloudAiplatformV1CometInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1CometInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1CometInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1CometSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for Comet instance - The fields used for evaluation are dependent on
/// the comet version.
typedef GoogleCloudAiplatformV1CometInstance = $Instance03;

/// Spec for Comet result - calculates the comet score for the given instance
/// using the version specified in the spec.
class GoogleCloudAiplatformV1CometResult {
  /// Comet score.
  ///
  /// Range depends on version.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1CometResult({
    this.score,
  });

  GoogleCloudAiplatformV1CometResult.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Spec for Comet metric.
class GoogleCloudAiplatformV1CometSpec {
  /// Source language in BCP-47 format.
  ///
  /// Optional.
  core.String? sourceLanguage;

  /// Target language in BCP-47 format.
  ///
  /// Covers both prediction and reference.
  ///
  /// Optional.
  core.String? targetLanguage;

  /// Which version to use for evaluation.
  ///
  /// Required.
  /// Possible string values are:
  /// - "COMET_VERSION_UNSPECIFIED" : Comet version unspecified.
  /// - "COMET_22_SRC_REF" : Comet 22 for translation + source + reference
  /// (source-reference-combined).
  core.String? version;

  GoogleCloudAiplatformV1CometSpec({
    this.sourceLanguage,
    this.targetLanguage,
    this.version,
  });

  GoogleCloudAiplatformV1CometSpec.fromJson(core.Map json_)
      : this(
          sourceLanguage: json_['sourceLanguage'] as core.String?,
          targetLanguage: json_['targetLanguage'] as core.String?,
          version: json_['version'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sourceLanguage != null) 'sourceLanguage': sourceLanguage!,
        if (targetLanguage != null) 'targetLanguage': targetLanguage!,
        if (version != null) 'version': version!,
      };
}

/// Request message for VizierService.CompleteTrial.
class GoogleCloudAiplatformV1CompleteTrialRequest {
  /// If provided, it will be used as the completed Trial's final_measurement;
  /// Otherwise, the service will auto-select a previously reported measurement
  /// as the final-measurement
  ///
  /// Optional.
  GoogleCloudAiplatformV1Measurement? finalMeasurement;

  /// A human readable reason why the trial was infeasible.
  ///
  /// This should only be provided if `trial_infeasible` is true.
  ///
  /// Optional.
  core.String? infeasibleReason;

  /// True if the Trial cannot be run with the given Parameter, and
  /// final_measurement will be ignored.
  ///
  /// Optional.
  core.bool? trialInfeasible;

  GoogleCloudAiplatformV1CompleteTrialRequest({
    this.finalMeasurement,
    this.infeasibleReason,
    this.trialInfeasible,
  });

  GoogleCloudAiplatformV1CompleteTrialRequest.fromJson(core.Map json_)
      : this(
          finalMeasurement: json_.containsKey('finalMeasurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>)
              : null,
          infeasibleReason: json_['infeasibleReason'] as core.String?,
          trialInfeasible: json_['trialInfeasible'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
        if (infeasibleReason != null) 'infeasibleReason': infeasibleReason!,
        if (trialInfeasible != null) 'trialInfeasible': trialInfeasible!,
      };
}

/// Success and error statistics of processing multiple entities (for example,
/// DataItems or structured data rows) in batch.
class GoogleCloudAiplatformV1CompletionStats {
  /// The number of entities for which any error was encountered.
  ///
  /// Output only.
  core.String? failedCount;

  /// In cases when enough errors are encountered a job, pipeline, or operation
  /// may be failed as a whole.
  ///
  /// Below is the number of entities for which the processing had not been
  /// finished (either in successful or failed state). Set to -1 if the number
  /// is unknown (for example, the operation failed before the total entity
  /// number could be collected).
  ///
  /// Output only.
  core.String? incompleteCount;

  /// The number of entities that had been processed successfully.
  ///
  /// Output only.
  core.String? successfulCount;

  /// The number of the successful forecast points that are generated by the
  /// forecasting model.
  ///
  /// This is ONLY used by the forecasting batch prediction.
  ///
  /// Output only.
  core.String? successfulForecastPointCount;

  GoogleCloudAiplatformV1CompletionStats({
    this.failedCount,
    this.incompleteCount,
    this.successfulCount,
    this.successfulForecastPointCount,
  });

  GoogleCloudAiplatformV1CompletionStats.fromJson(core.Map json_)
      : this(
          failedCount: json_['failedCount'] as core.String?,
          incompleteCount: json_['incompleteCount'] as core.String?,
          successfulCount: json_['successfulCount'] as core.String?,
          successfulForecastPointCount:
              json_['successfulForecastPointCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failedCount != null) 'failedCount': failedCount!,
        if (incompleteCount != null) 'incompleteCount': incompleteCount!,
        if (successfulCount != null) 'successfulCount': successfulCount!,
        if (successfulForecastPointCount != null)
          'successfulForecastPointCount': successfulForecastPointCount!,
      };
}

/// Request message for ComputeTokens RPC call.
class GoogleCloudAiplatformV1ComputeTokensRequest {
  /// Input content.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Content>? contents;

  /// The instances that are the input to token computing API call.
  ///
  /// Schema is identical to the prediction schema of the text model, even for
  /// the non-text models, like chat models, or Codey models.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The name of the publisher model requested to serve the prediction.
  ///
  /// Format: projects/{project}/locations/{location}/publishers / * /models / *
  ///
  /// Optional.
  core.String? model;

  GoogleCloudAiplatformV1ComputeTokensRequest({
    this.contents,
    this.instances,
    this.model,
  });

  GoogleCloudAiplatformV1ComputeTokensRequest.fromJson(core.Map json_)
      : this(
          contents: (json_['contents'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Content.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          instances: json_.containsKey('instances')
              ? json_['instances'] as core.List
              : null,
          model: json_['model'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (instances != null) 'instances': instances!,
        if (model != null) 'model': model!,
      };
}

/// Response message for ComputeTokens RPC call.
class GoogleCloudAiplatformV1ComputeTokensResponse {
  /// Lists of tokens info from the input.
  ///
  /// A ComputeTokensRequest could have multiple instances with a prompt in each
  /// instance. We also need to return lists of tokens info for the request with
  /// multiple instances.
  core.List<GoogleCloudAiplatformV1TokensInfo>? tokensInfo;

  GoogleCloudAiplatformV1ComputeTokensResponse({
    this.tokensInfo,
  });

  GoogleCloudAiplatformV1ComputeTokensResponse.fromJson(core.Map json_)
      : this(
          tokensInfo: (json_['tokensInfo'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TokensInfo.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tokensInfo != null) 'tokensInfo': tokensInfo!,
      };
}

/// The Container Registry location for the container image.
class GoogleCloudAiplatformV1ContainerRegistryDestination {
  /// Container Registry URI of a container image.
  ///
  /// Only Google Container Registry and Artifact Registry are supported now.
  /// Accepted forms: * Google Container Registry path. For example:
  /// `gcr.io/projectId/imageName:tag`. * Artifact Registry path. For example:
  /// `us-central1-docker.pkg.dev/projectId/repoName/imageName:tag`. If a tag is
  /// not specified, "latest" will be used as the default tag.
  ///
  /// Required.
  core.String? outputUri;

  GoogleCloudAiplatformV1ContainerRegistryDestination({
    this.outputUri,
  });

  GoogleCloudAiplatformV1ContainerRegistryDestination.fromJson(core.Map json_)
      : this(
          outputUri: json_['outputUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputUri != null) 'outputUri': outputUri!,
      };
}

/// The spec of a Container.
class GoogleCloudAiplatformV1ContainerSpec {
  /// The arguments to be passed when starting the container.
  core.List<core.String>? args;

  /// The command to be invoked when the container is started.
  ///
  /// It overrides the entrypoint instruction in Dockerfile when provided.
  core.List<core.String>? command;

  /// Environment variables to be passed to the container.
  ///
  /// Maximum limit is 100.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// The URI of a container image in the Container Registry that is to be run
  /// on each worker replica.
  ///
  /// Required.
  core.String? imageUri;

  GoogleCloudAiplatformV1ContainerSpec({
    this.args,
    this.command,
    this.env,
    this.imageUri,
  });

  GoogleCloudAiplatformV1ContainerSpec.fromJson(core.Map json_)
      : this(
          args: (json_['args'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          command: (json_['command'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          env: (json_['env'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          imageUri: json_['imageUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (args != null) 'args': args!,
        if (command != null) 'command': command!,
        if (env != null) 'env': env!,
        if (imageUri != null) 'imageUri': imageUri!,
      };
}

/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the
/// `Content` and a `parts` field containing multi-part data that contains the
/// content of the message turn.
class GoogleCloudAiplatformV1Content {
  /// Ordered `Parts` that constitute a single message.
  ///
  /// Parts may have different IANA MIME types.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1Part>? parts;

  /// The producer of the content.
  ///
  /// Must be either 'user' or 'model'. Useful to set for multi-turn
  /// conversations, otherwise can be left blank or unset.
  ///
  /// Optional.
  core.String? role;

  GoogleCloudAiplatformV1Content({
    this.parts,
    this.role,
  });

  GoogleCloudAiplatformV1Content.fromJson(core.Map json_)
      : this(
          parts: (json_['parts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Part.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          role: json_['role'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parts != null) 'parts': parts!,
        if (role != null) 'role': role!,
      };
}

/// Instance of a general context.
class GoogleCloudAiplatformV1Context {
  /// Timestamp when this Context was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Context
  core.String? description;

  /// User provided display name of the Context.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Contexts.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Context (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Context.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Context.
  ///
  /// Immutable.
  core.String? name;

  /// A list of resource names of Contexts that are parents of this Context.
  ///
  /// A Context may have at most 10 parent_contexts.
  ///
  /// Output only.
  core.List<core.String>? parentContexts;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// Timestamp when this Context was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Context({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.parentContexts,
    this.schemaTitle,
    this.schemaVersion,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Context.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_['name'] as core.String?,
          parentContexts: (json_['parentContexts'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          schemaTitle: json_['schemaTitle'] as core.String?,
          schemaVersion: json_['schemaVersion'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (parentContexts != null) 'parentContexts': parentContexts!,
        if (schemaTitle != null) 'schemaTitle': schemaTitle!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Request message for ModelService.CopyModel.
class GoogleCloudAiplatformV1CopyModelRequest {
  /// Customer-managed encryption key options.
  ///
  /// If this is set, then the Model copy will be encrypted with the provided
  /// encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Copy source_model into a new Model with this ID.
  ///
  /// The ID will become the final component of the model resource name. This
  /// value may be up to 63 characters, and valid characters are `[a-z0-9_-]`.
  /// The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// Specify this field to copy source_model into this existing Model as a new
  /// version.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Optional.
  core.String? parentModel;

  /// The resource name of the Model to copy.
  ///
  /// That Model must be in the same Project. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Required.
  core.String? sourceModel;

  GoogleCloudAiplatformV1CopyModelRequest({
    this.encryptionSpec,
    this.modelId,
    this.parentModel,
    this.sourceModel,
  });

  GoogleCloudAiplatformV1CopyModelRequest.fromJson(core.Map json_)
      : this(
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelId: json_['modelId'] as core.String?,
          parentModel: json_['parentModel'] as core.String?,
          sourceModel: json_['sourceModel'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (modelId != null) 'modelId': modelId!,
        if (parentModel != null) 'parentModel': parentModel!,
        if (sourceModel != null) 'sourceModel': sourceModel!,
      };
}

/// RagCorpus status.
class GoogleCloudAiplatformV1CorpusStatus {
  /// Only when the `state` field is ERROR.
  ///
  /// Output only.
  core.String? errorStatus;

  /// RagCorpus life state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "UNKNOWN" : This state is not supposed to happen.
  /// - "INITIALIZED" : RagCorpus resource entry is initialized, but hasn't done
  /// validation.
  /// - "ACTIVE" : RagCorpus is provisioned successfully and is ready to serve.
  /// - "ERROR" : RagCorpus is in a problematic situation. See `error_message`
  /// field for details.
  core.String? state;

  GoogleCloudAiplatformV1CorpusStatus({
    this.errorStatus,
    this.state,
  });

  GoogleCloudAiplatformV1CorpusStatus.fromJson(core.Map json_)
      : this(
          errorStatus: json_['errorStatus'] as core.String?,
          state: json_['state'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (errorStatus != null) 'errorStatus': errorStatus!,
        if (state != null) 'state': state!,
      };
}

/// Request message for CorroborateContent.
class GoogleCloudAiplatformV1CorroborateContentRequest {
  /// Input content to corroborate, only text format is supported for now.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Content? content;

  /// Facts used to generate the text can also be used to corroborate the text.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Fact>? facts;

  /// Parameters that can be set to override default settings per request.
  ///
  /// Optional.
  GoogleCloudAiplatformV1CorroborateContentRequestParameters? parameters;

  GoogleCloudAiplatformV1CorroborateContentRequest({
    this.content,
    this.facts,
    this.parameters,
  });

  GoogleCloudAiplatformV1CorroborateContentRequest.fromJson(core.Map json_)
      : this(
          content: json_.containsKey('content')
              ? GoogleCloudAiplatformV1Content.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>)
              : null,
          facts: (json_['facts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Fact.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1CorroborateContentRequestParameters
                  .fromJson(json_['parameters']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (content != null) 'content': content!,
        if (facts != null) 'facts': facts!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Parameters that can be overrided per request.
class GoogleCloudAiplatformV1CorroborateContentRequestParameters {
  /// Only return claims with citation score larger than the threshold.
  ///
  /// Optional.
  core.double? citationThreshold;

  GoogleCloudAiplatformV1CorroborateContentRequestParameters({
    this.citationThreshold,
  });

  GoogleCloudAiplatformV1CorroborateContentRequestParameters.fromJson(
      core.Map json_)
      : this(
          citationThreshold:
              (json_['citationThreshold'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (citationThreshold != null) 'citationThreshold': citationThreshold!,
      };
}

/// Response message for CorroborateContent.
class GoogleCloudAiplatformV1CorroborateContentResponse {
  /// Claims that are extracted from the input content and facts that support
  /// the claims.
  core.List<GoogleCloudAiplatformV1Claim>? claims;

  /// Confidence score of corroborating content.
  ///
  /// Value is \[0,1\] with 1 is the most confidence.
  core.double? corroborationScore;

  GoogleCloudAiplatformV1CorroborateContentResponse({
    this.claims,
    this.corroborationScore,
  });

  GoogleCloudAiplatformV1CorroborateContentResponse.fromJson(core.Map json_)
      : this(
          claims: (json_['claims'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Claim.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          corroborationScore:
              (json_['corroborationScore'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (claims != null) 'claims': claims!,
        if (corroborationScore != null)
          'corroborationScore': corroborationScore!,
      };
}

/// Request message for PredictionService.CountTokens.
class GoogleCloudAiplatformV1CountTokensRequest {
  /// Input content.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Content>? contents;

  /// Generation config that the model will use to generate the response.
  ///
  /// Optional.
  GoogleCloudAiplatformV1GenerationConfig? generationConfig;

  /// The instances that are the input to token counting call.
  ///
  /// Schema is identical to the prediction schema of the underlying model.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The name of the publisher model requested to serve the prediction.
  ///
  /// Format: `projects/{project}/locations/{location}/publishers / * /models /
  /// * `
  ///
  /// Optional.
  core.String? model;

  /// The user provided system instructions for the model.
  ///
  /// Note: only text should be used in parts and content in each part will be
  /// in a separate paragraph.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Content? systemInstruction;

  /// A list of `Tools` the model may use to generate the next response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Tool>? tools;

  GoogleCloudAiplatformV1CountTokensRequest({
    this.contents,
    this.generationConfig,
    this.instances,
    this.model,
    this.systemInstruction,
    this.tools,
  });

  GoogleCloudAiplatformV1CountTokensRequest.fromJson(core.Map json_)
      : this(
          contents: (json_['contents'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Content.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          generationConfig: json_.containsKey('generationConfig')
              ? GoogleCloudAiplatformV1GenerationConfig.fromJson(
                  json_['generationConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          instances: json_.containsKey('instances')
              ? json_['instances'] as core.List
              : null,
          model: json_['model'] as core.String?,
          systemInstruction: json_.containsKey('systemInstruction')
              ? GoogleCloudAiplatformV1Content.fromJson(
                  json_['systemInstruction']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tools: (json_['tools'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tool.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contents != null) 'contents': contents!,
        if (generationConfig != null) 'generationConfig': generationConfig!,
        if (instances != null) 'instances': instances!,
        if (model != null) 'model': model!,
        if (systemInstruction != null) 'systemInstruction': systemInstruction!,
        if (tools != null) 'tools': tools!,
      };
}

/// Response message for PredictionService.CountTokens.
class GoogleCloudAiplatformV1CountTokensResponse {
  /// List of modalities that were processed in the request input.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModalityTokenCount>? promptTokensDetails;

  /// The total number of billable characters counted across all instances from
  /// the request.
  core.int? totalBillableCharacters;

  /// The total number of tokens counted across all instances from the request.
  core.int? totalTokens;

  GoogleCloudAiplatformV1CountTokensResponse({
    this.promptTokensDetails,
    this.totalBillableCharacters,
    this.totalTokens,
  });

  GoogleCloudAiplatformV1CountTokensResponse.fromJson(core.Map json_)
      : this(
          promptTokensDetails: (json_['promptTokensDetails'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModalityTokenCount.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          totalBillableCharacters:
              json_['totalBillableCharacters'] as core.int?,
          totalTokens: json_['totalTokens'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (promptTokensDetails != null)
          'promptTokensDetails': promptTokensDetails!,
        if (totalBillableCharacters != null)
          'totalBillableCharacters': totalBillableCharacters!,
        if (totalTokens != null) 'totalTokens': totalTokens!,
      };
}

/// Request message for CreateDeploymentResourcePool method.
class GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest {
  /// The DeploymentResourcePool to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1DeploymentResourcePool? deploymentResourcePool;

  /// The ID to use for the DeploymentResourcePool, which will become the final
  /// component of the DeploymentResourcePool's resource name.
  ///
  /// The maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  ///
  /// Required.
  core.String? deploymentResourcePoolId;

  GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest({
    this.deploymentResourcePool,
    this.deploymentResourcePoolId,
  });

  GoogleCloudAiplatformV1CreateDeploymentResourcePoolRequest.fromJson(
      core.Map json_)
      : this(
          deploymentResourcePool: json_.containsKey('deploymentResourcePool')
              ? GoogleCloudAiplatformV1DeploymentResourcePool.fromJson(
                  json_['deploymentResourcePool']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deploymentResourcePoolId:
              json_['deploymentResourcePoolId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deploymentResourcePool != null)
          'deploymentResourcePool': deploymentResourcePool!,
        if (deploymentResourcePoolId != null)
          'deploymentResourcePoolId': deploymentResourcePoolId!,
      };
}

/// Request message for FeaturestoreService.CreateFeature.
///
/// Request message for FeatureRegistryService.CreateFeature.
class GoogleCloudAiplatformV1CreateFeatureRequest {
  /// The Feature to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1Feature? feature;

  /// The ID to use for the Feature, which will become the final component of
  /// the Feature's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number. The value must be
  /// unique within an EntityType/FeatureGroup.
  ///
  /// Required.
  core.String? featureId;

  /// The resource name of the EntityType or FeatureGroup to create a Feature.
  ///
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  ///
  /// Required.
  core.String? parent;

  GoogleCloudAiplatformV1CreateFeatureRequest({
    this.feature,
    this.featureId,
    this.parent,
  });

  GoogleCloudAiplatformV1CreateFeatureRequest.fromJson(core.Map json_)
      : this(
          feature: json_.containsKey('feature')
              ? GoogleCloudAiplatformV1Feature.fromJson(
                  json_['feature'] as core.Map<core.String, core.dynamic>)
              : null,
          featureId: json_['featureId'] as core.String?,
          parent: json_['parent'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (feature != null) 'feature': feature!,
        if (featureId != null) 'featureId': featureId!,
        if (parent != null) 'parent': parent!,
      };
}

/// Request message for \[NotebookService.CreateNotebookExecutionJob\]
class GoogleCloudAiplatformV1CreateNotebookExecutionJobRequest {
  /// The NotebookExecutionJob to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1NotebookExecutionJob? notebookExecutionJob;

  /// User specified ID for the NotebookExecutionJob.
  ///
  /// Optional.
  core.String? notebookExecutionJobId;

  /// The resource name of the Location to create the NotebookExecutionJob.
  ///
  /// Format: `projects/{project}/locations/{location}`
  ///
  /// Required.
  core.String? parent;

  GoogleCloudAiplatformV1CreateNotebookExecutionJobRequest({
    this.notebookExecutionJob,
    this.notebookExecutionJobId,
    this.parent,
  });

  GoogleCloudAiplatformV1CreateNotebookExecutionJobRequest.fromJson(
      core.Map json_)
      : this(
          notebookExecutionJob: json_.containsKey('notebookExecutionJob')
              ? GoogleCloudAiplatformV1NotebookExecutionJob.fromJson(
                  json_['notebookExecutionJob']
                      as core.Map<core.String, core.dynamic>)
              : null,
          notebookExecutionJobId:
              json_['notebookExecutionJobId'] as core.String?,
          parent: json_['parent'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (notebookExecutionJob != null)
          'notebookExecutionJob': notebookExecutionJob!,
        if (notebookExecutionJobId != null)
          'notebookExecutionJobId': notebookExecutionJobId!,
        if (parent != null) 'parent': parent!,
      };
}

/// Request message for PipelineService.CreatePipelineJob.
class GoogleCloudAiplatformV1CreatePipelineJobRequest {
  /// The resource name of the Location to create the PipelineJob in.
  ///
  /// Format: `projects/{project}/locations/{location}`
  ///
  /// Required.
  core.String? parent;

  /// The PipelineJob to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1PipelineJob? pipelineJob;

  /// The ID to use for the PipelineJob, which will become the final component
  /// of the PipelineJob name.
  ///
  /// If not provided, an ID will be automatically generated. This value should
  /// be less than 128 characters, and valid characters are `/a-z-/`.
  core.String? pipelineJobId;

  GoogleCloudAiplatformV1CreatePipelineJobRequest({
    this.parent,
    this.pipelineJob,
    this.pipelineJobId,
  });

  GoogleCloudAiplatformV1CreatePipelineJobRequest.fromJson(core.Map json_)
      : this(
          parent: json_['parent'] as core.String?,
          pipelineJob: json_.containsKey('pipelineJob')
              ? GoogleCloudAiplatformV1PipelineJob.fromJson(
                  json_['pipelineJob'] as core.Map<core.String, core.dynamic>)
              : null,
          pipelineJobId: json_['pipelineJobId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parent != null) 'parent': parent!,
        if (pipelineJob != null) 'pipelineJob': pipelineJob!,
        if (pipelineJobId != null) 'pipelineJobId': pipelineJobId!,
      };
}

/// Request message for TensorboardService.CreateTensorboardRun.
class GoogleCloudAiplatformV1CreateTensorboardRunRequest {
  /// The resource name of the TensorboardExperiment to create the
  /// TensorboardRun in.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  ///
  /// Required.
  core.String? parent;

  /// The TensorboardRun to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1TensorboardRun? tensorboardRun;

  /// The ID to use for the Tensorboard run, which becomes the final component
  /// of the Tensorboard run's resource name.
  ///
  /// This value should be 1-128 characters, and valid characters are `/a-z-/`.
  ///
  /// Required.
  core.String? tensorboardRunId;

  GoogleCloudAiplatformV1CreateTensorboardRunRequest({
    this.parent,
    this.tensorboardRun,
    this.tensorboardRunId,
  });

  GoogleCloudAiplatformV1CreateTensorboardRunRequest.fromJson(core.Map json_)
      : this(
          parent: json_['parent'] as core.String?,
          tensorboardRun: json_.containsKey('tensorboardRun')
              ? GoogleCloudAiplatformV1TensorboardRun.fromJson(
                  json_['tensorboardRun']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tensorboardRunId: json_['tensorboardRunId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parent != null) 'parent': parent!,
        if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!,
        if (tensorboardRunId != null) 'tensorboardRunId': tensorboardRunId!,
      };
}

/// Request message for TensorboardService.CreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest {
  /// The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Required.
  core.String? parent;

  /// The TensorboardTimeSeries to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1TensorboardTimeSeries? tensorboardTimeSeries;

  /// The user specified unique ID to use for the TensorboardTimeSeries, which
  /// becomes the final component of the TensorboardTimeSeries's resource name.
  ///
  /// This value should match "a-z0-9{0, 127}"
  ///
  /// Optional.
  core.String? tensorboardTimeSeriesId;

  GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest({
    this.parent,
    this.tensorboardTimeSeries,
    this.tensorboardTimeSeriesId,
  });

  GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest.fromJson(
      core.Map json_)
      : this(
          parent: json_['parent'] as core.String?,
          tensorboardTimeSeries: json_.containsKey('tensorboardTimeSeries')
              ? GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
                  json_['tensorboardTimeSeries']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tensorboardTimeSeriesId:
              json_['tensorboardTimeSeriesId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parent != null) 'parent': parent!,
        if (tensorboardTimeSeries != null)
          'tensorboardTimeSeries': tensorboardTimeSeries!,
        if (tensorboardTimeSeriesId != null)
          'tensorboardTimeSeriesId': tensorboardTimeSeriesId!,
      };
}

/// The storage details for CSV output content.
class GoogleCloudAiplatformV1CsvDestination {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1CsvDestination({
    this.gcsDestination,
  });

  GoogleCloudAiplatformV1CsvDestination.fromJson(core.Map json_)
      : this(
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
      };
}

/// The storage details for CSV input content.
class GoogleCloudAiplatformV1CsvSource {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  GoogleCloudAiplatformV1CsvSource({
    this.gcsSource,
  });

  GoogleCloudAiplatformV1CsvSource.fromJson(core.Map json_)
      : this(
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsSource != null) 'gcsSource': gcsSource!,
      };
}

/// Represents a job that runs custom workloads such as a Docker container or a
/// Python package.
///
/// A CustomJob can have multiple worker pools and each worker pool can have its
/// own machine and input spec. A CustomJob will be cleaned up once the job
/// enters terminal state (failed or succeeded).
class GoogleCloudAiplatformV1CustomJob {
  /// Time when the CustomJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the CustomJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a CustomJob.
  ///
  /// If this is set, then all resources created by the CustomJob will be
  /// encrypted with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the CustomJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Job spec.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? jobSpec;

  /// The labels with user-defined metadata to organize CustomJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of a CustomJob.
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the CustomJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Time when the CustomJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// URIs for accessing
  /// [interactive shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node).
  ///
  /// Only available if job_spec.enable_web_access is `true`. The keys are names
  /// of each node in the training job; for example, `workerpool0-0` for the
  /// primary node, `workerpool1-0` for the first node in the second worker
  /// pool, and `workerpool1-1` for the second node in the second worker pool.
  /// The values are the URIs for each node's interactive shell.
  ///
  /// Output only.
  core.Map<core.String, core.String>? webAccessUris;

  GoogleCloudAiplatformV1CustomJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.jobSpec,
    this.labels,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.updateTime,
    this.webAccessUris,
  });

  GoogleCloudAiplatformV1CustomJob.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          jobSpec: json_.containsKey('jobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['jobSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
          webAccessUris:
              (json_['webAccessUris'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (jobSpec != null) 'jobSpec': jobSpec!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (webAccessUris != null) 'webAccessUris': webAccessUris!,
      };
}

/// Represents the spec of a CustomJob.
class GoogleCloudAiplatformV1CustomJobSpec {
  /// The Cloud Storage location to store the output of this CustomJob or
  /// HyperparameterTuningJob.
  ///
  /// For HyperparameterTuningJob, the baseOutputDirectory of each child
  /// CustomJob backing a Trial is set to a subdirectory of name id under its
  /// parent HyperparameterTuningJob's baseOutputDirectory. The following Vertex
  /// AI environment variables will be passed to containers or python modules
  /// when this field is set: For CustomJob: * AIP_MODEL_DIR = `/model/` *
  /// AIP_CHECKPOINT_DIR = `/checkpoints/` * AIP_TENSORBOARD_LOG_DIR = `/logs/`
  /// For CustomJob backing a Trial of HyperparameterTuningJob: * AIP_MODEL_DIR
  /// = `//model/` * AIP_CHECKPOINT_DIR = `//checkpoints/` *
  /// AIP_TENSORBOARD_LOG_DIR = `//logs/`
  GoogleCloudAiplatformV1GcsDestination? baseOutputDirectory;

  /// Whether you want Vertex AI to enable access to the customized dashboard in
  /// training chief container.
  ///
  /// If set to `true`, you can access the dashboard at the URIs given by
  /// CustomJob.web_access_uris or Trial.web_access_uris (within
  /// HyperparameterTuningJob.trials).
  ///
  /// Optional.
  core.bool? enableDashboardAccess;

  /// Whether you want Vertex AI to enable
  /// [interactive shell access](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// to training containers.
  ///
  /// If set to `true`, you can access interactive shells at the URIs given by
  /// CustomJob.web_access_uris or Trial.web_access_uris (within
  /// HyperparameterTuningJob.trials).
  ///
  /// Optional.
  core.bool? enableWebAccess;

  /// The Experiment associated with this job.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}`
  ///
  /// Optional.
  core.String? experiment;

  /// The Experiment Run associated with this job.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}-{experiment-run-name}`
  ///
  /// Optional.
  core.String? experimentRun;

  /// The name of the Model resources for which to generate a mapping to
  /// artifact URIs.
  ///
  /// Applicable only to some of the Google-provided custom jobs. Format:
  /// `projects/{project}/locations/{location}/models/{model}` In order to
  /// retrieve a specific version of the model, also provide the version ID or
  /// version alias. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` If no
  /// version ID or alias is specified, the "default" version will be returned.
  /// The "default" version alias is created for the first version of the model,
  /// and can be moved to other versions later on. There will be exactly one
  /// default version.
  ///
  /// Optional.
  core.List<core.String>? models;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to which the
  /// Job should be peered.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. To specify
  /// this field, you must have already
  /// [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  /// If this field is left unspecified, the job is not peered with any network.
  ///
  /// Optional.
  core.String? network;

  /// The ID of the PersistentResource in the same Project and Location which to
  /// run If this is specified, the job will be run on existing machines held by
  /// the PersistentResource instead of on-demand short-live machines.
  ///
  /// The network and CMEK configs on the job should be consistent with those on
  /// the PersistentResource, otherwise, the job will be rejected.
  ///
  /// Optional.
  core.String? persistentResourceId;

  /// The ID of the location to store protected artifacts.
  ///
  /// e.g. us-central1. Populate only when the location is different than
  /// CustomJob location. List of supported locations:
  /// https://cloud.google.com/vertex-ai/docs/general/locations
  core.String? protectedArtifactLocationId;

  /// A list of names for the reserved ip ranges under the VPC network that can
  /// be used for this job.
  ///
  /// If set, we will deploy the job within the provided ip ranges. Otherwise,
  /// the job will be deployed to any ip ranges under the provided VPC network.
  /// Example: \['vertex-ai-ip-range'\].
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  /// Scheduling options for a CustomJob.
  GoogleCloudAiplatformV1Scheduling? scheduling;

  /// Specifies the service account for workload run-as account.
  ///
  /// Users submitting jobs must have act-as permission on this run-as account.
  /// If unspecified, the
  /// [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// for the CustomJob's project is used.
  core.String? serviceAccount;

  /// The name of a Vertex AI Tensorboard resource to which this CustomJob will
  /// upload Tensorboard logs.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  ///
  /// Optional.
  core.String? tensorboard;

  /// The spec of the worker pools including machine type and Docker image.
  ///
  /// All worker pools except the first one are optional and can be skipped by
  /// providing an empty value.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1WorkerPoolSpec>? workerPoolSpecs;

  GoogleCloudAiplatformV1CustomJobSpec({
    this.baseOutputDirectory,
    this.enableDashboardAccess,
    this.enableWebAccess,
    this.experiment,
    this.experimentRun,
    this.models,
    this.network,
    this.persistentResourceId,
    this.protectedArtifactLocationId,
    this.reservedIpRanges,
    this.scheduling,
    this.serviceAccount,
    this.tensorboard,
    this.workerPoolSpecs,
  });

  GoogleCloudAiplatformV1CustomJobSpec.fromJson(core.Map json_)
      : this(
          baseOutputDirectory: json_.containsKey('baseOutputDirectory')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['baseOutputDirectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
          enableDashboardAccess: json_['enableDashboardAccess'] as core.bool?,
          enableWebAccess: json_['enableWebAccess'] as core.bool?,
          experiment: json_['experiment'] as core.String?,
          experimentRun: json_['experimentRun'] as core.String?,
          models: (json_['models'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          network: json_['network'] as core.String?,
          persistentResourceId: json_['persistentResourceId'] as core.String?,
          protectedArtifactLocationId:
              json_['protectedArtifactLocationId'] as core.String?,
          reservedIpRanges: (json_['reservedIpRanges'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          scheduling: json_.containsKey('scheduling')
              ? GoogleCloudAiplatformV1Scheduling.fromJson(
                  json_['scheduling'] as core.Map<core.String, core.dynamic>)
              : null,
          serviceAccount: json_['serviceAccount'] as core.String?,
          tensorboard: json_['tensorboard'] as core.String?,
          workerPoolSpecs: (json_['workerPoolSpecs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1WorkerPoolSpec.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baseOutputDirectory != null)
          'baseOutputDirectory': baseOutputDirectory!,
        if (enableDashboardAccess != null)
          'enableDashboardAccess': enableDashboardAccess!,
        if (enableWebAccess != null) 'enableWebAccess': enableWebAccess!,
        if (experiment != null) 'experiment': experiment!,
        if (experimentRun != null) 'experimentRun': experimentRun!,
        if (models != null) 'models': models!,
        if (network != null) 'network': network!,
        if (persistentResourceId != null)
          'persistentResourceId': persistentResourceId!,
        if (protectedArtifactLocationId != null)
          'protectedArtifactLocationId': protectedArtifactLocationId!,
        if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
        if (scheduling != null) 'scheduling': scheduling!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (tensorboard != null) 'tensorboard': tensorboard!,
        if (workerPoolSpecs != null) 'workerPoolSpecs': workerPoolSpecs!,
      };
}

/// A piece of data in a Dataset.
///
/// Could be an image, a video, a document or plain text.
class GoogleCloudAiplatformV1DataItem {
  /// Timestamp when this DataItem was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your DataItems.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one DataItem(System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the DataItem.
  ///
  /// Output only.
  core.String? name;

  /// The data that the DataItem represents (for example, an image or a text
  /// snippet).
  ///
  /// The schema of the payload is stored in the parent Dataset's metadata
  /// schema's dataItemSchemaUri field.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? payload;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this DataItem was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1DataItem({
    this.createTime,
    this.etag,
    this.labels,
    this.name,
    this.payload,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1DataItem.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          payload: json_['payload'],
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (payload != null) 'payload': payload!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A container for a single DataItem and Annotations on it.
class GoogleCloudAiplatformV1DataItemView {
  /// The Annotations on the DataItem.
  ///
  /// If too many Annotations should be returned for the DataItem, this field
  /// will be truncated per annotations_limit in request. If it was, then the
  /// has_truncated_annotations will be set to true.
  core.List<GoogleCloudAiplatformV1Annotation>? annotations;

  /// The DataItem.
  GoogleCloudAiplatformV1DataItem? dataItem;

  /// True if and only if the Annotations field has been truncated.
  ///
  /// It happens if more Annotations for this DataItem met the request's
  /// annotation_filter than are allowed to be returned by annotations_limit.
  /// Note that if Annotations field is not being returned due to field mask,
  /// then this field will not be set to true no matter how many Annotations are
  /// there.
  core.bool? hasTruncatedAnnotations;

  GoogleCloudAiplatformV1DataItemView({
    this.annotations,
    this.dataItem,
    this.hasTruncatedAnnotations,
  });

  GoogleCloudAiplatformV1DataItemView.fromJson(core.Map json_)
      : this(
          annotations: (json_['annotations'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Annotation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          dataItem: json_.containsKey('dataItem')
              ? GoogleCloudAiplatformV1DataItem.fromJson(
                  json_['dataItem'] as core.Map<core.String, core.dynamic>)
              : null,
          hasTruncatedAnnotations:
              json_['hasTruncatedAnnotations'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (dataItem != null) 'dataItem': dataItem!,
        if (hasTruncatedAnnotations != null)
          'hasTruncatedAnnotations': hasTruncatedAnnotations!,
      };
}

/// DataLabelingJob is used to trigger a human labeling job on unlabeled data
/// from the following Dataset:
class GoogleCloudAiplatformV1DataLabelingJob {
  /// Parameters that configure the active learning pipeline.
  ///
  /// Active learning will label the data incrementally via several iterations.
  /// For every iteration, it will select a batch of data based on the sampling
  /// strategy.
  GoogleCloudAiplatformV1ActiveLearningConfig? activeLearningConfig;

  /// Labels to assign to annotations generated by this DataLabelingJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? annotationLabels;

  /// Timestamp when this DataLabelingJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Estimated cost(in US dollars) that the DataLabelingJob has incurred to
  /// date.
  ///
  /// Output only.
  GoogleTypeMoney? currentSpend;

  /// Dataset resource names.
  ///
  /// Right now we only support labeling from a single Dataset. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  ///
  /// Required.
  core.List<core.String>? datasets;

  /// The user-defined name of the DataLabelingJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. Display name of a DataLabelingJob.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a DataLabelingJob.
  ///
  /// If set, this DataLabelingJob will be secured by this key. Note:
  /// Annotations created in the DataLabelingJob are associated with the
  /// EncryptionSpec of the Dataset they are exported to.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// DataLabelingJob errors.
  ///
  /// It is only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Input config parameters for the DataLabelingJob.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? inputs;

  /// Points to a YAML file stored on Google Cloud Storage describing the config
  /// for a specific type of DataLabelingJob.
  ///
  /// The schema files that can be used here are found in the
  /// https://storage.googleapis.com/google-cloud-aiplatform bucket in the
  /// /schema/datalabelingjob/inputs/ folder.
  ///
  /// Required.
  core.String? inputsSchemaUri;

  /// The Google Cloud Storage location of the instruction pdf.
  ///
  /// This pdf is shared with labelers, and provides detailed description on how
  /// to label DataItems in Datasets.
  ///
  /// Required.
  core.String? instructionUri;

  /// Number of labelers to work on each DataItem.
  ///
  /// Required.
  core.int? labelerCount;

  /// Current labeling job progress percentage scaled in interval \[0, 100\],
  /// indicating the percentage of DataItems that has been finished.
  ///
  /// Output only.
  core.int? labelingProgress;

  /// The labels with user-defined metadata to organize your DataLabelingJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable. Following system labels exist for each DataLabelingJob: *
  /// "aiplatform.googleapis.com/schema": output only, its value is the
  /// inputs_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the DataLabelingJob.
  ///
  /// Output only.
  core.String? name;

  /// The SpecialistPools' resource names associated with this job.
  core.List<core.String>? specialistPools;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Timestamp when this DataLabelingJob was updated most recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1DataLabelingJob({
    this.activeLearningConfig,
    this.annotationLabels,
    this.createTime,
    this.currentSpend,
    this.datasets,
    this.displayName,
    this.encryptionSpec,
    this.error,
    this.inputs,
    this.inputsSchemaUri,
    this.instructionUri,
    this.labelerCount,
    this.labelingProgress,
    this.labels,
    this.name,
    this.specialistPools,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1DataLabelingJob.fromJson(core.Map json_)
      : this(
          activeLearningConfig: json_.containsKey('activeLearningConfig')
              ? GoogleCloudAiplatformV1ActiveLearningConfig.fromJson(
                  json_['activeLearningConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          annotationLabels: (json_['annotationLabels']
                  as core.Map<core.String, core.dynamic>?)
              ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          createTime: json_['createTime'] as core.String?,
          currentSpend: json_.containsKey('currentSpend')
              ? GoogleTypeMoney.fromJson(
                  json_['currentSpend'] as core.Map<core.String, core.dynamic>)
              : null,
          datasets: (json_['datasets'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          inputs: json_['inputs'],
          inputsSchemaUri: json_['inputsSchemaUri'] as core.String?,
          instructionUri: json_['instructionUri'] as core.String?,
          labelerCount: json_['labelerCount'] as core.int?,
          labelingProgress: json_['labelingProgress'] as core.int?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          specialistPools: (json_['specialistPools'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (activeLearningConfig != null)
          'activeLearningConfig': activeLearningConfig!,
        if (annotationLabels != null) 'annotationLabels': annotationLabels!,
        if (createTime != null) 'createTime': createTime!,
        if (currentSpend != null) 'currentSpend': currentSpend!,
        if (datasets != null) 'datasets': datasets!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (error != null) 'error': error!,
        if (inputs != null) 'inputs': inputs!,
        if (inputsSchemaUri != null) 'inputsSchemaUri': inputsSchemaUri!,
        if (instructionUri != null) 'instructionUri': instructionUri!,
        if (labelerCount != null) 'labelerCount': labelerCount!,
        if (labelingProgress != null) 'labelingProgress': labelingProgress!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (specialistPools != null) 'specialistPools': specialistPools!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A collection of DataItems and Annotations on them.
class GoogleCloudAiplatformV1Dataset {
  /// Timestamp when this Dataset was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The number of DataItems in this Dataset.
  ///
  /// Only apply for non-structured Dataset.
  ///
  /// Output only.
  core.String? dataItemCount;

  /// The description of the Dataset.
  core.String? description;

  /// The user-defined name of the Dataset.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Dataset.
  ///
  /// If set, this Dataset and all sub-resources of this Dataset will be secured
  /// by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Datasets.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Dataset (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for each Dataset: *
  /// "aiplatform.googleapis.com/dataset_metadata_schema": output only, its
  /// value is the metadata_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Additional information about the Dataset.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Artifact that was created in MetadataStore when
  /// creating the Dataset.
  ///
  /// The Artifact resource name pattern is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  ///
  /// Output only.
  core.String? metadataArtifact;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Dataset.
  ///
  /// The schema is defined as an OpenAPI 3.0.2 Schema Object. The schema files
  /// that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/metadata/.
  ///
  /// Required.
  core.String? metadataSchemaUri;

  /// Reference to the public base model last used by the dataset.
  ///
  /// Only set for prompt datasets.
  ///
  /// Optional.
  core.String? modelReference;

  /// Identifier.
  ///
  /// The resource name of the Dataset. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// All SavedQueries belong to the Dataset will be returned in List/Get
  /// Dataset response.
  ///
  /// The annotation_specs field will not be populated except for UI cases which
  /// will only use annotation_spec_count. In CreateDataset request, a
  /// SavedQuery is created together if this field is set, up to one SavedQuery
  /// can be set in CreateDatasetRequest. The SavedQuery should not contain any
  /// AnnotationSpec.
  core.List<GoogleCloudAiplatformV1SavedQuery>? savedQueries;

  /// Timestamp when this Dataset was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Dataset({
    this.createTime,
    this.dataItemCount,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.metadata,
    this.metadataArtifact,
    this.metadataSchemaUri,
    this.modelReference,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.savedQueries,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Dataset.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          dataItemCount: json_['dataItemCount'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          metadata: json_['metadata'],
          metadataArtifact: json_['metadataArtifact'] as core.String?,
          metadataSchemaUri: json_['metadataSchemaUri'] as core.String?,
          modelReference: json_['modelReference'] as core.String?,
          name: json_['name'] as core.String?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          savedQueries: (json_['savedQueries'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1SavedQuery.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (dataItemCount != null) 'dataItemCount': dataItemCount!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataArtifact != null) 'metadataArtifact': metadataArtifact!,
        if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
        if (modelReference != null) 'modelReference': modelReference!,
        if (name != null) 'name': name!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (savedQueries != null) 'savedQueries': savedQueries!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Describes the dataset version.
class GoogleCloudAiplatformV1DatasetVersion {
  /// Name of the associated BigQuery dataset.
  ///
  /// Output only.
  core.String? bigQueryDatasetName;

  /// Timestamp when this DatasetVersion was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the DatasetVersion.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Additional information about the DatasetVersion.
  ///
  /// Required. Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Reference to the public base model last used by the dataset version.
  ///
  /// Only set for prompt dataset versions.
  ///
  /// Output only.
  core.String? modelReference;

  /// Identifier.
  ///
  /// The resource name of the DatasetVersion. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this DatasetVersion was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1DatasetVersion({
    this.bigQueryDatasetName,
    this.createTime,
    this.displayName,
    this.etag,
    this.metadata,
    this.modelReference,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1DatasetVersion.fromJson(core.Map json_)
      : this(
          bigQueryDatasetName: json_['bigQueryDatasetName'] as core.String?,
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          metadata: json_['metadata'],
          modelReference: json_['modelReference'] as core.String?,
          name: json_['name'] as core.String?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigQueryDatasetName != null)
          'bigQueryDatasetName': bigQueryDatasetName!,
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (metadata != null) 'metadata': metadata!,
        if (modelReference != null) 'modelReference': modelReference!,
        if (name != null) 'name': name!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A description of resources that are dedicated to a DeployedModel or
/// DeployedIndex, and that need a higher degree of manual configuration.
class GoogleCloudAiplatformV1DedicatedResources {
  /// The metric specifications that overrides a resource utilization metric
  /// (CPU utilization, accelerator's duty cycle, and so on) target value
  /// (default to 60 if not set).
  ///
  /// At most one entry is allowed per metric. If machine_spec.accelerator_count
  /// is above 0, the autoscaling will be based on both CPU utilization and
  /// accelerator's duty cycle metrics and scale up when either metrics exceeds
  /// its target value while scale down if both metrics are under their target
  /// value. The default target value is 60 for both metrics. If
  /// machine_spec.accelerator_count is 0, the autoscaling will be based on CPU
  /// utilization metric only with default target value 60 if not explicitly
  /// set. For example, in the case of Online Prediction, if you want to
  /// override target CPU utilization to 80, you should set
  /// autoscaling_metric_specs.metric_name to
  /// `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
  /// autoscaling_metric_specs.target to `80`.
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1AutoscalingMetricSpec>?
      autoscalingMetricSpecs;

  /// The specification of a single machine being used.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The maximum number of replicas that may be deployed on when the traffic
  /// against it increases.
  ///
  /// If the requested value is too large, the deployment will error, but if
  /// deployment succeeds then the ability to scale to that many replicas is
  /// guaranteed (barring service outages). If traffic increases beyond what its
  /// replicas at maximum may handle, a portion of the traffic will be dropped.
  /// If this value is not provided, will use min_replica_count as the default
  /// value. The value of this field impacts the charge against Vertex CPU and
  /// GPU quotas. Specifically, you will be charged for (max_replica_count *
  /// number of cores in the selected machine type) and (max_replica_count *
  /// number of GPUs per replica in the selected machine type).
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The minimum number of machine replicas that will be always deployed on.
  ///
  /// This value must be greater than or equal to 1. If traffic increases, it
  /// may dynamically be deployed onto more replicas, and as traffic decreases,
  /// some of these extra replicas may be freed.
  ///
  /// Required. Immutable.
  core.int? minReplicaCount;

  /// Number of required available replicas for the deployment to succeed.
  ///
  /// This field is only needed when partial deployment/mutation is desired. If
  /// set, the deploy/mutate operation will succeed once available_replica_count
  /// reaches required_replica_count, and the rest of the replicas will be
  /// retried. If not set, the default required_replica_count will be
  /// min_replica_count.
  ///
  /// Optional.
  core.int? requiredReplicaCount;

  /// If true, schedule the deployment workload on
  /// [spot VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
  ///
  /// Optional.
  core.bool? spot;

  GoogleCloudAiplatformV1DedicatedResources({
    this.autoscalingMetricSpecs,
    this.machineSpec,
    this.maxReplicaCount,
    this.minReplicaCount,
    this.requiredReplicaCount,
    this.spot,
  });

  GoogleCloudAiplatformV1DedicatedResources.fromJson(core.Map json_)
      : this(
          autoscalingMetricSpecs:
              (json_['autoscalingMetricSpecs'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1AutoscalingMetricSpec.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          maxReplicaCount: json_['maxReplicaCount'] as core.int?,
          minReplicaCount: json_['minReplicaCount'] as core.int?,
          requiredReplicaCount: json_['requiredReplicaCount'] as core.int?,
          spot: json_['spot'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalingMetricSpecs != null)
          'autoscalingMetricSpecs': autoscalingMetricSpecs!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
        if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
        if (requiredReplicaCount != null)
          'requiredReplicaCount': requiredReplicaCount!,
        if (spot != null) 'spot': spot!,
      };
}

/// Request message for FeaturestoreService.DeleteFeatureValues.
class GoogleCloudAiplatformV1DeleteFeatureValuesRequest {
  /// Select feature values to be deleted by specifying entities.
  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity? selectEntity;

  /// Select feature values to be deleted by specifying time range and features.
  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature?
      selectTimeRangeAndFeature;

  GoogleCloudAiplatformV1DeleteFeatureValuesRequest({
    this.selectEntity,
    this.selectTimeRangeAndFeature,
  });

  GoogleCloudAiplatformV1DeleteFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          selectEntity: json_.containsKey('selectEntity')
              ? GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity
                  .fromJson(json_['selectEntity']
                      as core.Map<core.String, core.dynamic>)
              : null,
          selectTimeRangeAndFeature: json_
                  .containsKey('selectTimeRangeAndFeature')
              ? GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature
                  .fromJson(json_['selectTimeRangeAndFeature']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (selectEntity != null) 'selectEntity': selectEntity!,
        if (selectTimeRangeAndFeature != null)
          'selectTimeRangeAndFeature': selectTimeRangeAndFeature!,
      };
}

/// Message to select entity.
///
/// If an entity id is selected, all the feature values corresponding to the
/// entity id will be deleted, including the entityId.
class GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity {
  /// Selectors choosing feature values of which entity id to be deleted from
  /// the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1EntityIdSelector? entityIdSelector;

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity({
    this.entityIdSelector,
  });

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity.fromJson(
      core.Map json_)
      : this(
          entityIdSelector: json_.containsKey('entityIdSelector')
              ? GoogleCloudAiplatformV1EntityIdSelector.fromJson(
                  json_['entityIdSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityIdSelector != null) 'entityIdSelector': entityIdSelector!,
      };
}

/// Message to select time range and feature.
///
/// Values of the selected feature generated within an inclusive time range will
/// be deleted. Using this option permanently deletes the feature values from
/// the specified feature IDs within the specified time range. This might
/// include data from the online storage. If you want to retain any deleted
/// historical data in the online storage, you must re-ingest it.
class GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature {
  /// Selectors choosing which feature values to be deleted from the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  /// If set, data will not be deleted from online storage.
  ///
  /// When time range is older than the data in online storage, setting this to
  /// be true will make the deletion have no impact on online serving.
  core.bool? skipOnlineStorageDelete;

  /// Select feature generated within a half-inclusive time range.
  ///
  /// The time range is lower inclusive and upper exclusive.
  ///
  /// Required.
  GoogleTypeInterval? timeRange;

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature({
    this.featureSelector,
    this.skipOnlineStorageDelete,
    this.timeRange,
  });

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature.fromJson(
      core.Map json_)
      : this(
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
          skipOnlineStorageDelete:
              json_['skipOnlineStorageDelete'] as core.bool?,
          timeRange: json_.containsKey('timeRange')
              ? GoogleTypeInterval.fromJson(
                  json_['timeRange'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureSelector != null) 'featureSelector': featureSelector!,
        if (skipOnlineStorageDelete != null)
          'skipOnlineStorageDelete': skipOnlineStorageDelete!,
        if (timeRange != null) 'timeRange': timeRange!,
      };
}

/// Request message for IndexEndpointService.DeployIndex.
class GoogleCloudAiplatformV1DeployIndexRequest {
  /// The DeployedIndex to be created within the IndexEndpoint.
  ///
  /// Required.
  GoogleCloudAiplatformV1DeployedIndex? deployedIndex;

  GoogleCloudAiplatformV1DeployIndexRequest({
    this.deployedIndex,
  });

  GoogleCloudAiplatformV1DeployIndexRequest.fromJson(core.Map json_)
      : this(
          deployedIndex: json_.containsKey('deployedIndex')
              ? GoogleCloudAiplatformV1DeployedIndex.fromJson(
                  json_['deployedIndex'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndex != null) 'deployedIndex': deployedIndex!,
      };
}

/// Request message for EndpointService.DeployModel.
class GoogleCloudAiplatformV1DeployModelRequest {
  /// The DeployedModel to be created within the Endpoint.
  ///
  /// Note that Endpoint.traffic_split must be updated for the DeployedModel to
  /// start receiving traffic, either as part of this call, or via
  /// EndpointService.UpdateEndpoint.
  ///
  /// Required.
  GoogleCloudAiplatformV1DeployedModel? deployedModel;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If this field is non-empty, then the Endpoint's traffic_split will be
  /// overwritten with it. To refer to the ID of the just being deployed Model,
  /// a "0" should be used, and the actual ID of the new DeployedModel will be
  /// filled in its place by this method. The traffic percentage values must add
  /// up to 100. If this field is empty, then the Endpoint's traffic_split is
  /// not updated.
  core.Map<core.String, core.int>? trafficSplit;

  GoogleCloudAiplatformV1DeployModelRequest({
    this.deployedModel,
    this.trafficSplit,
  });

  GoogleCloudAiplatformV1DeployModelRequest.fromJson(core.Map json_)
      : this(
          deployedModel: json_.containsKey('deployedModel')
              ? GoogleCloudAiplatformV1DeployedModel.fromJson(
                  json_['deployedModel'] as core.Map<core.String, core.dynamic>)
              : null,
          trafficSplit:
              (json_['trafficSplit'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.int,
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModel != null) 'deployedModel': deployedModel!,
        if (trafficSplit != null) 'trafficSplit': trafficSplit!,
      };
}

/// A deployment of an Index.
///
/// IndexEndpoints contain one or more DeployedIndexes.
class GoogleCloudAiplatformV1DeployedIndex {
  /// A description of resources that the DeployedIndex uses, which to large
  /// degree are decided by Vertex AI, and optionally allows only a modest
  /// additional configuration.
  ///
  /// If min_replica_count is not set, the default value is 2 (we don't provide
  /// SLA when min_replica_count=1). If max_replica_count is not set, the
  /// default value is min_replica_count. The max allowed replica count is 1000.
  ///
  /// Optional.
  GoogleCloudAiplatformV1AutomaticResources? automaticResources;

  /// Timestamp when the DeployedIndex was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of resources that are dedicated to the DeployedIndex, and
  /// that need a higher degree of manual configuration.
  ///
  /// The field min_replica_count must be set to a value strictly greater than
  /// 0, or else validation will fail. We don't provide SLA when
  /// min_replica_count=1. If max_replica_count is not set, the default value is
  /// min_replica_count. The max allowed replica count is 1000. Available
  /// machine types for SMALL shard: e2-standard-2 and all machine types
  /// available for MEDIUM and LARGE shard. Available machine types for MEDIUM
  /// shard: e2-standard-16 and all machine types available for LARGE shard.
  /// Available machine types for LARGE shard: e2-highmem-16, n2d-standard-32.
  /// n1-standard-16 and n1-standard-32 are still available, but we recommend
  /// e2-standard-16 and e2-highmem-16 for cost efficiency.
  ///
  /// Optional.
  GoogleCloudAiplatformV1DedicatedResources? dedicatedResources;

  /// If set, the authentication is enabled for the private endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1DeployedIndexAuthConfig? deployedIndexAuthConfig;

  /// The deployment group can be no longer than 64 characters (eg: 'test',
  /// 'prod').
  ///
  /// If not set, we will use the 'default' deployment group. Creating
  /// `deployment_groups` with `reserved_ip_ranges` is a recommended practice
  /// when the peered network has multiple peering ranges. This creates your
  /// deployments from predictable IP spaces for easier traffic administration.
  /// Also, one deployment_group (except 'default') can only be used with the
  /// same reserved_ip_ranges which means if the deployment_group has been used
  /// with reserved_ip_ranges: \[a, b, c\], using it with \[a, b\] or \[d, e\]
  /// is disallowed. Note: we only support up to 5 deployment groups(not
  /// including 'default').
  ///
  /// Optional.
  core.String? deploymentGroup;

  /// The display name of the DeployedIndex.
  ///
  /// If not provided upon creation, the Index's display_name is used.
  core.String? displayName;

  /// If true, private endpoint's access logs are sent to Cloud Logging.
  ///
  /// These logs are like standard server access logs, containing information
  /// like timestamp and latency for each MatchRequest. Note that logs may incur
  /// a cost, especially if the deployed index receives a high queries per
  /// second rate (QPS). Estimate your costs before enabling this option.
  ///
  /// Optional.
  core.bool? enableAccessLogging;

  /// The user specified ID of the DeployedIndex.
  ///
  /// The ID can be up to 128 characters long and must start with a letter and
  /// only contain letters, numbers, and underscores. The ID must be unique
  /// within the project it is created in.
  ///
  /// Required.
  core.String? id;

  /// The name of the Index this is the deployment of.
  ///
  /// We may refer to this Index as the DeployedIndex's "original" Index.
  ///
  /// Required.
  core.String? index;

  /// The DeployedIndex may depend on various data on its original Index.
  ///
  /// Additionally when certain changes to the original Index are being done
  /// (e.g. when what the Index contains is being changed) the DeployedIndex may
  /// be asynchronously updated in the background to reflect these changes. If
  /// this timestamp's value is at least the Index.update_time of the original
  /// Index, it means that this DeployedIndex and the original Index are in
  /// sync. If this timestamp is older, then to see which updates this
  /// DeployedIndex already contains (and which it does not), one must list the
  /// operations that are running on the original Index. Only the successfully
  /// completed Operations with update_time equal or before this sync time are
  /// contained in this DeployedIndex.
  ///
  /// Output only.
  core.String? indexSyncTime;

  /// Provides paths for users to send requests directly to the deployed index
  /// services running on Cloud via private services access.
  ///
  /// This field is populated if network is configured.
  ///
  /// Output only.
  GoogleCloudAiplatformV1IndexPrivateEndpoints? privateEndpoints;

  /// If set for PSC deployed index, PSC connection will be automatically
  /// created after deployment is done and the endpoint information is populated
  /// in private_endpoints.psc_automated_endpoints.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1PSCAutomationConfig>? pscAutomationConfigs;

  /// A list of reserved ip ranges under the VPC network that can be used for
  /// this DeployedIndex.
  ///
  /// If set, we will deploy the index within the provided ip ranges. Otherwise,
  /// the index might be deployed to any ip ranges under the provided VPC
  /// network. The value should be the name of the address
  /// (https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
  /// Example: \['vertex-ai-ip-range'\]. For more information about subnets and
  /// network IP ranges, please see
  /// https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  GoogleCloudAiplatformV1DeployedIndex({
    this.automaticResources,
    this.createTime,
    this.dedicatedResources,
    this.deployedIndexAuthConfig,
    this.deploymentGroup,
    this.displayName,
    this.enableAccessLogging,
    this.id,
    this.index,
    this.indexSyncTime,
    this.privateEndpoints,
    this.pscAutomationConfigs,
    this.reservedIpRanges,
  });

  GoogleCloudAiplatformV1DeployedIndex.fromJson(core.Map json_)
      : this(
          automaticResources: json_.containsKey('automaticResources')
              ? GoogleCloudAiplatformV1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deployedIndexAuthConfig: json_.containsKey('deployedIndexAuthConfig')
              ? GoogleCloudAiplatformV1DeployedIndexAuthConfig.fromJson(
                  json_['deployedIndexAuthConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deploymentGroup: json_['deploymentGroup'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          enableAccessLogging: json_['enableAccessLogging'] as core.bool?,
          id: json_['id'] as core.String?,
          index: json_['index'] as core.String?,
          indexSyncTime: json_['indexSyncTime'] as core.String?,
          privateEndpoints: json_.containsKey('privateEndpoints')
              ? GoogleCloudAiplatformV1IndexPrivateEndpoints.fromJson(
                  json_['privateEndpoints']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pscAutomationConfigs: (json_['pscAutomationConfigs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PSCAutomationConfig.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          reservedIpRanges: (json_['reservedIpRanges'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automaticResources != null)
          'automaticResources': automaticResources!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (deployedIndexAuthConfig != null)
          'deployedIndexAuthConfig': deployedIndexAuthConfig!,
        if (deploymentGroup != null) 'deploymentGroup': deploymentGroup!,
        if (displayName != null) 'displayName': displayName!,
        if (enableAccessLogging != null)
          'enableAccessLogging': enableAccessLogging!,
        if (id != null) 'id': id!,
        if (index != null) 'index': index!,
        if (indexSyncTime != null) 'indexSyncTime': indexSyncTime!,
        if (privateEndpoints != null) 'privateEndpoints': privateEndpoints!,
        if (pscAutomationConfigs != null)
          'pscAutomationConfigs': pscAutomationConfigs!,
        if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
      };
}

/// Used to set up the auth on the DeployedIndex's private endpoint.
class GoogleCloudAiplatformV1DeployedIndexAuthConfig {
  /// Defines the authentication provider that the DeployedIndex uses.
  GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider? authProvider;

  GoogleCloudAiplatformV1DeployedIndexAuthConfig({
    this.authProvider,
  });

  GoogleCloudAiplatformV1DeployedIndexAuthConfig.fromJson(core.Map json_)
      : this(
          authProvider: json_.containsKey('authProvider')
              ? GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider
                  .fromJson(json_['authProvider']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (authProvider != null) 'authProvider': authProvider!,
      };
}

/// Configuration for an authentication provider, including support for \[JSON
/// Web Token
/// (JWT)\](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
class GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider {
  /// A list of allowed JWT issuers.
  ///
  /// Each entry must be a valid Google service account, in the following
  /// format: `service-account-name@project-id.iam.gserviceaccount.com`
  core.List<core.String>? allowedIssuers;

  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  ///
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted.
  core.List<core.String>? audiences;

  GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider({
    this.allowedIssuers,
    this.audiences,
  });

  GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider.fromJson(
      core.Map json_)
      : this(
          allowedIssuers: (json_['allowedIssuers'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          audiences: (json_['audiences'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowedIssuers != null) 'allowedIssuers': allowedIssuers!,
        if (audiences != null) 'audiences': audiences!,
      };
}

/// Points to a DeployedIndex.
class GoogleCloudAiplatformV1DeployedIndexRef {
  /// The ID of the DeployedIndex in the above IndexEndpoint.
  ///
  /// Immutable.
  core.String? deployedIndexId;

  /// The display name of the DeployedIndex.
  ///
  /// Output only.
  core.String? displayName;

  /// A resource name of the IndexEndpoint.
  ///
  /// Immutable.
  core.String? indexEndpoint;

  GoogleCloudAiplatformV1DeployedIndexRef({
    this.deployedIndexId,
    this.displayName,
    this.indexEndpoint,
  });

  GoogleCloudAiplatformV1DeployedIndexRef.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_['deployedIndexId'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          indexEndpoint: json_['indexEndpoint'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
        if (displayName != null) 'displayName': displayName!,
        if (indexEndpoint != null) 'indexEndpoint': indexEndpoint!,
      };
}

/// A deployment of a Model.
///
/// Endpoints contain one or more DeployedModels.
class GoogleCloudAiplatformV1DeployedModel {
  /// A description of resources that to large degree are decided by Vertex AI,
  /// and require only a modest additional configuration.
  GoogleCloudAiplatformV1AutomaticResources? automaticResources;

  /// Timestamp when the DeployedModel was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  GoogleCloudAiplatformV1DedicatedResources? dedicatedResources;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to Cloud
  /// Logging by default.
  ///
  /// Please note that the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging/pricing). User
  /// can disable container logging by setting this flag to true.
  core.bool? disableContainerLogging;

  /// If true, deploy the model without explainable feature, regardless the
  /// existence of Model.explanation_spec or explanation_spec.
  core.bool? disableExplanations;

  /// The display name of the DeployedModel.
  ///
  /// If not provided upon creation, the Model's display_name is used.
  core.String? displayName;

  /// If true, online prediction access logs are sent to Cloud Logging.
  ///
  /// These logs are like standard server access logs, containing information
  /// like timestamp and latency for each prediction request. Note that logs may
  /// incur a cost, especially if your project receives prediction requests at a
  /// high queries per second rate (QPS). Estimate your costs before enabling
  /// this option.
  core.bool? enableAccessLogging;

  /// Explanation configuration for this DeployedModel.
  ///
  /// When deploying a Model using EndpointService.DeployModel, this value
  /// overrides the value of Model.explanation_spec. All fields of
  /// explanation_spec are optional in the request. If a field of
  /// explanation_spec is not populated, the value of the same field of
  /// Model.explanation_spec is inherited. If the corresponding
  /// Model.explanation_spec is not populated, all fields of the
  /// explanation_spec will be used for the explanation configuration.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// Configuration for faster model deployment.
  GoogleCloudAiplatformV1FasterDeploymentConfig? fasterDeploymentConfig;

  /// The ID of the DeployedModel.
  ///
  /// If not provided upon deployment, Vertex AI will generate a value for this
  /// ID. This value should be 1-10 characters, and valid characters are
  /// `/[0-9]/`.
  ///
  /// Immutable.
  core.String? id;

  /// The resource name of the Model that this is the deployment of.
  ///
  /// Note that the Model may be in a different location than the
  /// DeployedModel's Endpoint. The resource name may contain version id or
  /// version alias to specify the version. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` if no
  /// version is specified, the default version will be deployed.
  ///
  /// Required.
  core.String? model;

  /// The version ID of the model that is deployed.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// Provide paths for users to send predict/explain/health requests directly
  /// to the deployed model services running on Cloud via private services
  /// access.
  ///
  /// This field is populated if network is configured.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PrivateEndpoints? privateEndpoints;

  /// The service account that the DeployedModel's container runs as.
  ///
  /// Specify the email address of the service account. If this service account
  /// is not specified, the container runs as a service account that doesn't
  /// have access to the resource project. Users deploying the Model must have
  /// the `iam.serviceAccounts.actAs` permission on this service account.
  core.String? serviceAccount;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  core.String? sharedResources;

  /// Spec for configuring speculative decoding.
  ///
  /// Optional.
  GoogleCloudAiplatformV1SpeculativeDecodingSpec? speculativeDecodingSpec;

  /// Runtime status of the deployed model.
  ///
  /// Output only.
  GoogleCloudAiplatformV1DeployedModelStatus? status;

  /// System labels to apply to Model Garden deployments.
  ///
  /// System labels are managed by Google for internal use only.
  core.Map<core.String, core.String>? systemLabels;

  GoogleCloudAiplatformV1DeployedModel({
    this.automaticResources,
    this.createTime,
    this.dedicatedResources,
    this.disableContainerLogging,
    this.disableExplanations,
    this.displayName,
    this.enableAccessLogging,
    this.explanationSpec,
    this.fasterDeploymentConfig,
    this.id,
    this.model,
    this.modelVersionId,
    this.privateEndpoints,
    this.serviceAccount,
    this.sharedResources,
    this.speculativeDecodingSpec,
    this.status,
    this.systemLabels,
  });

  GoogleCloudAiplatformV1DeployedModel.fromJson(core.Map json_)
      : this(
          automaticResources: json_.containsKey('automaticResources')
              ? GoogleCloudAiplatformV1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          disableContainerLogging:
              json_['disableContainerLogging'] as core.bool?,
          disableExplanations: json_['disableExplanations'] as core.bool?,
          displayName: json_['displayName'] as core.String?,
          enableAccessLogging: json_['enableAccessLogging'] as core.bool?,
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          fasterDeploymentConfig: json_.containsKey('fasterDeploymentConfig')
              ? GoogleCloudAiplatformV1FasterDeploymentConfig.fromJson(
                  json_['fasterDeploymentConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          id: json_['id'] as core.String?,
          model: json_['model'] as core.String?,
          modelVersionId: json_['modelVersionId'] as core.String?,
          privateEndpoints: json_.containsKey('privateEndpoints')
              ? GoogleCloudAiplatformV1PrivateEndpoints.fromJson(
                  json_['privateEndpoints']
                      as core.Map<core.String, core.dynamic>)
              : null,
          serviceAccount: json_['serviceAccount'] as core.String?,
          sharedResources: json_['sharedResources'] as core.String?,
          speculativeDecodingSpec: json_.containsKey('speculativeDecodingSpec')
              ? GoogleCloudAiplatformV1SpeculativeDecodingSpec.fromJson(
                  json_['speculativeDecodingSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          status: json_.containsKey('status')
              ? GoogleCloudAiplatformV1DeployedModelStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>)
              : null,
          systemLabels:
              (json_['systemLabels'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automaticResources != null)
          'automaticResources': automaticResources!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (disableContainerLogging != null)
          'disableContainerLogging': disableContainerLogging!,
        if (disableExplanations != null)
          'disableExplanations': disableExplanations!,
        if (displayName != null) 'displayName': displayName!,
        if (enableAccessLogging != null)
          'enableAccessLogging': enableAccessLogging!,
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (fasterDeploymentConfig != null)
          'fasterDeploymentConfig': fasterDeploymentConfig!,
        if (id != null) 'id': id!,
        if (model != null) 'model': model!,
        if (modelVersionId != null) 'modelVersionId': modelVersionId!,
        if (privateEndpoints != null) 'privateEndpoints': privateEndpoints!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (sharedResources != null) 'sharedResources': sharedResources!,
        if (speculativeDecodingSpec != null)
          'speculativeDecodingSpec': speculativeDecodingSpec!,
        if (status != null) 'status': status!,
        if (systemLabels != null) 'systemLabels': systemLabels!,
      };
}

/// Points to a DeployedModel.
class GoogleCloudAiplatformV1DeployedModelRef {
  /// An ID of a DeployedModel in the above Endpoint.
  ///
  /// Immutable.
  core.String? deployedModelId;

  /// A resource name of an Endpoint.
  ///
  /// Immutable.
  core.String? endpoint;

  GoogleCloudAiplatformV1DeployedModelRef({
    this.deployedModelId,
    this.endpoint,
  });

  GoogleCloudAiplatformV1DeployedModelRef.fromJson(core.Map json_)
      : this(
          deployedModelId: json_['deployedModelId'] as core.String?,
          endpoint: json_['endpoint'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (endpoint != null) 'endpoint': endpoint!,
      };
}

/// Runtime status of the deployed model.
class GoogleCloudAiplatformV1DeployedModelStatus {
  /// The number of available replicas of the deployed model.
  ///
  /// Output only.
  core.int? availableReplicaCount;

  /// The time at which the status was last updated.
  ///
  /// Output only.
  core.String? lastUpdateTime;

  /// The latest deployed model's status message (if any).
  ///
  /// Output only.
  core.String? message;

  GoogleCloudAiplatformV1DeployedModelStatus({
    this.availableReplicaCount,
    this.lastUpdateTime,
    this.message,
  });

  GoogleCloudAiplatformV1DeployedModelStatus.fromJson(core.Map json_)
      : this(
          availableReplicaCount: json_['availableReplicaCount'] as core.int?,
          lastUpdateTime: json_['lastUpdateTime'] as core.String?,
          message: json_['message'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (availableReplicaCount != null)
          'availableReplicaCount': availableReplicaCount!,
        if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!,
        if (message != null) 'message': message!,
      };
}

/// A description of resources that can be shared by multiple DeployedModels,
/// whose underlying specification consists of a DedicatedResources.
class GoogleCloudAiplatformV1DeploymentResourcePool {
  /// Timestamp when this DeploymentResourcePool was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The underlying DedicatedResources that the DeploymentResourcePool uses.
  ///
  /// Required.
  GoogleCloudAiplatformV1DedicatedResources? dedicatedResources;

  /// If the DeploymentResourcePool is deployed with custom-trained Models or
  /// AutoML Tabular Models, the container(s) of the DeploymentResourcePool will
  /// send `stderr` and `stdout` streams to Cloud Logging by default.
  ///
  /// Please note that the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging/pricing). User
  /// can disable container logging by setting this flag to true.
  core.bool? disableContainerLogging;

  /// Customer-managed encryption key spec for a DeploymentResourcePool.
  ///
  /// If set, this DeploymentResourcePool will be secured by this key. Endpoints
  /// and the DeploymentResourcePool they deploy in need to have the same
  /// EncryptionSpec.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// The resource name of the DeploymentResourcePool.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  ///
  /// Immutable.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// The service account that the DeploymentResourcePool's container(s) run as.
  ///
  /// Specify the email address of the service account. If this service account
  /// is not specified, the container(s) run as a service account that doesn't
  /// have access to the resource project. Users deploying the Models to this
  /// DeploymentResourcePool must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1DeploymentResourcePool({
    this.createTime,
    this.dedicatedResources,
    this.disableContainerLogging,
    this.encryptionSpec,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1DeploymentResourcePool.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          disableContainerLogging:
              json_['disableContainerLogging'] as core.bool?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          serviceAccount: json_['serviceAccount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (disableContainerLogging != null)
          'disableContainerLogging': disableContainerLogging!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (name != null) 'name': name!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
      };
}

class GoogleCloudAiplatformV1DestinationFeatureSetting {
  /// Specify the field name in the export destination.
  ///
  /// If not specified, Feature ID is used.
  core.String? destinationField;

  /// The ID of the Feature to apply the setting to.
  ///
  /// Required.
  core.String? featureId;

  GoogleCloudAiplatformV1DestinationFeatureSetting({
    this.destinationField,
    this.featureId,
  });

  GoogleCloudAiplatformV1DestinationFeatureSetting.fromJson(core.Map json_)
      : this(
          destinationField: json_['destinationField'] as core.String?,
          featureId: json_['featureId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destinationField != null) 'destinationField': destinationField!,
        if (featureId != null) 'featureId': featureId!,
      };
}

/// Request message for PredictionService.DirectPredict.
class GoogleCloudAiplatformV1DirectPredictRequest {
  /// The prediction input.
  core.List<GoogleCloudAiplatformV1Tensor>? inputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1Tensor? parameters;

  GoogleCloudAiplatformV1DirectPredictRequest({
    this.inputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1DirectPredictRequest.fromJson(core.Map json_)
      : this(
          inputs: (json_['inputs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputs != null) 'inputs': inputs!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Response message for PredictionService.DirectPredict.
class GoogleCloudAiplatformV1DirectPredictResponse {
  /// The prediction output.
  core.List<GoogleCloudAiplatformV1Tensor>? outputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1Tensor? parameters;

  GoogleCloudAiplatformV1DirectPredictResponse({
    this.outputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1DirectPredictResponse.fromJson(core.Map json_)
      : this(
          outputs: (json_['outputs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputs != null) 'outputs': outputs!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Request message for PredictionService.DirectRawPredict.
class GoogleCloudAiplatformV1DirectRawPredictRequest {
  /// The prediction input.
  core.String? input;
  core.List<core.int> get inputAsBytes => convert.base64.decode(input!);

  set inputAsBytes(core.List<core.int> bytes_) {
    input =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format: `/namespace.Service/Method/` Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  core.String? methodName;

  GoogleCloudAiplatformV1DirectRawPredictRequest({
    this.input,
    this.methodName,
  });

  GoogleCloudAiplatformV1DirectRawPredictRequest.fromJson(core.Map json_)
      : this(
          input: json_['input'] as core.String?,
          methodName: json_['methodName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (input != null) 'input': input!,
        if (methodName != null) 'methodName': methodName!,
      };
}

/// Response message for PredictionService.DirectRawPredict.
class GoogleCloudAiplatformV1DirectRawPredictResponse {
  /// The prediction output.
  core.String? output;
  core.List<core.int> get outputAsBytes => convert.base64.decode(output!);

  set outputAsBytes(core.List<core.int> bytes_) {
    output =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  GoogleCloudAiplatformV1DirectRawPredictResponse({
    this.output,
  });

  GoogleCloudAiplatformV1DirectRawPredictResponse.fromJson(core.Map json_)
      : this(
          output: json_['output'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (output != null) 'output': output!,
      };
}

/// The input content is encapsulated and uploaded in the request.
typedef GoogleCloudAiplatformV1DirectUploadSource = $Empty;

/// Represents the spec of disk options.
typedef GoogleCloudAiplatformV1DiskSpec = $Shared04;

/// A list of double values.
class GoogleCloudAiplatformV1DoubleArray {
  /// A list of double values.
  core.List<core.double>? values;

  GoogleCloudAiplatformV1DoubleArray({
    this.values,
  });

  GoogleCloudAiplatformV1DoubleArray.fromJson(core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Describes the options to customize dynamic retrieval.
class GoogleCloudAiplatformV1DynamicRetrievalConfig {
  /// The threshold to be used in dynamic retrieval.
  ///
  /// If not set, a system default value is used.
  ///
  /// Optional.
  core.double? dynamicThreshold;

  /// The mode of the predictor to be used in dynamic retrieval.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Always trigger retrieval.
  /// - "MODE_DYNAMIC" : Run retrieval only when system decides it is necessary.
  core.String? mode;

  GoogleCloudAiplatformV1DynamicRetrievalConfig({
    this.dynamicThreshold,
    this.mode,
  });

  GoogleCloudAiplatformV1DynamicRetrievalConfig.fromJson(core.Map json_)
      : this(
          dynamicThreshold:
              (json_['dynamicThreshold'] as core.num?)?.toDouble(),
          mode: json_['mode'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dynamicThreshold != null) 'dynamicThreshold': dynamicThreshold!,
        if (mode != null) 'mode': mode!,
      };
}

/// Represents a customer-managed encryption key spec that can be applied to a
/// top-level resource.
class GoogleCloudAiplatformV1EncryptionSpec {
  /// The Cloud KMS resource identifier of the customer managed encryption key
  /// used to protect a resource.
  ///
  /// Has the form:
  /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
  /// The key needs to be in the same region as where the compute resource is
  /// created.
  ///
  /// Required.
  core.String? kmsKeyName;

  GoogleCloudAiplatformV1EncryptionSpec({
    this.kmsKeyName,
  });

  GoogleCloudAiplatformV1EncryptionSpec.fromJson(core.Map json_)
      : this(
          kmsKeyName: json_['kmsKeyName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
      };
}

/// Models are deployed into it, and afterwards Endpoint is called to obtain
/// predictions and explanations.
class GoogleCloudAiplatformV1Endpoint {
  /// Configurations that are applied to the endpoint for online prediction.
  GoogleCloudAiplatformV1ClientConnectionConfig? clientConnectionConfig;

  /// Timestamp when this Endpoint was created.
  ///
  /// Output only.
  core.String? createTime;

  /// DNS of the dedicated endpoint.
  ///
  /// Will only be populated if dedicated_endpoint_enabled is true. Format:
  /// `https://{endpoint_id}.{region}-{project_number}.prediction.vertexai.goog`.
  ///
  /// Output only.
  core.String? dedicatedEndpointDns;

  /// If true, the endpoint will be exposed through a dedicated DNS
  /// \[Endpoint.dedicated_endpoint_dns\].
  ///
  /// Your request to the dedicated DNS will be isolated from other users'
  /// traffic and will have better performance and reliability. Note: Once you
  /// enabled dedicated endpoint, you won't be able to send request to the
  /// shared DNS {region}-aiplatform.googleapis.com. The limitation will be
  /// removed soon.
  core.bool? dedicatedEndpointEnabled;

  /// The models deployed in this Endpoint.
  ///
  /// To add or remove DeployedModels use EndpointService.DeployModel and
  /// EndpointService.UndeployModel respectively.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedModel>? deployedModels;

  /// The description of the Endpoint.
  core.String? description;

  /// The display name of the Endpoint.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Deprecated: If true, expose the Endpoint via private service connect.
  ///
  /// Only one of the fields, network or enable_private_service_connect, can be
  /// set.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enablePrivateServiceConnect;

  /// Customer-managed encryption key spec for an Endpoint.
  ///
  /// If set, this Endpoint and all sub-resources of this Endpoint will be
  /// secured by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Configuration for GenAiAdvancedFeatures.
  ///
  /// If the endpoint is serving GenAI models, advanced features like native RAG
  /// integration can be configured. Currently, only Model Garden models are
  /// supported.
  ///
  /// Optional.
  GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfig?
      genAiAdvancedFeaturesConfig;

  /// The labels with user-defined metadata to organize your Endpoints.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the Model Monitoring job associated with this Endpoint if
  /// monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  ///
  /// Output only.
  core.String? modelDeploymentMonitoringJob;

  /// The resource name of the Endpoint.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  /// to which the Endpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If
  /// left unspecified, the Endpoint is not peered with any network. Only one of
  /// the fields, network or enable_private_service_connect, can be set.
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`. Where `{project}` is a
  /// project number, as in `12345`, and `{network}` is network name.
  ///
  /// Optional.
  core.String? network;

  /// Configures the request-response logging for online prediction.
  GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig?
      predictRequestResponseLoggingConfig;

  /// Configuration for private service connect.
  ///
  /// network and private_service_connect_config are mutually exclusive.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PrivateServiceConnectConfig?
      privateServiceConnectConfig;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If a DeployedModel's ID is not listed in this map, then it receives no
  /// traffic. The traffic percentage values must add up to 100, or map must be
  /// empty if the Endpoint is to not accept any traffic at a moment.
  core.Map<core.String, core.int>? trafficSplit;

  /// Timestamp when this Endpoint was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Endpoint({
    this.clientConnectionConfig,
    this.createTime,
    this.dedicatedEndpointDns,
    this.dedicatedEndpointEnabled,
    this.deployedModels,
    this.description,
    this.displayName,
    this.enablePrivateServiceConnect,
    this.encryptionSpec,
    this.etag,
    this.genAiAdvancedFeaturesConfig,
    this.labels,
    this.modelDeploymentMonitoringJob,
    this.name,
    this.network,
    this.predictRequestResponseLoggingConfig,
    this.privateServiceConnectConfig,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.trafficSplit,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Endpoint.fromJson(core.Map json_)
      : this(
          clientConnectionConfig: json_.containsKey('clientConnectionConfig')
              ? GoogleCloudAiplatformV1ClientConnectionConfig.fromJson(
                  json_['clientConnectionConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          dedicatedEndpointDns: json_['dedicatedEndpointDns'] as core.String?,
          dedicatedEndpointEnabled:
              json_['dedicatedEndpointEnabled'] as core.bool?,
          deployedModels: (json_['deployedModels'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DeployedModel.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          enablePrivateServiceConnect:
              json_['enablePrivateServiceConnect'] as core.bool?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          genAiAdvancedFeaturesConfig:
              json_.containsKey('genAiAdvancedFeaturesConfig')
                  ? GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfig.fromJson(
                      json_['genAiAdvancedFeaturesConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          modelDeploymentMonitoringJob:
              json_['modelDeploymentMonitoringJob'] as core.String?,
          name: json_['name'] as core.String?,
          network: json_['network'] as core.String?,
          predictRequestResponseLoggingConfig:
              json_.containsKey('predictRequestResponseLoggingConfig')
                  ? GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig
                      .fromJson(json_['predictRequestResponseLoggingConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          privateServiceConnectConfig:
              json_.containsKey('privateServiceConnectConfig')
                  ? GoogleCloudAiplatformV1PrivateServiceConnectConfig.fromJson(
                      json_['privateServiceConnectConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          trafficSplit:
              (json_['trafficSplit'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.int,
            ),
          ),
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientConnectionConfig != null)
          'clientConnectionConfig': clientConnectionConfig!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedEndpointDns != null)
          'dedicatedEndpointDns': dedicatedEndpointDns!,
        if (dedicatedEndpointEnabled != null)
          'dedicatedEndpointEnabled': dedicatedEndpointEnabled!,
        if (deployedModels != null) 'deployedModels': deployedModels!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (enablePrivateServiceConnect != null)
          'enablePrivateServiceConnect': enablePrivateServiceConnect!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (genAiAdvancedFeaturesConfig != null)
          'genAiAdvancedFeaturesConfig': genAiAdvancedFeaturesConfig!,
        if (labels != null) 'labels': labels!,
        if (modelDeploymentMonitoringJob != null)
          'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (predictRequestResponseLoggingConfig != null)
          'predictRequestResponseLoggingConfig':
              predictRequestResponseLoggingConfig!,
        if (privateServiceConnectConfig != null)
          'privateServiceConnectConfig': privateServiceConnectConfig!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (trafficSplit != null) 'trafficSplit': trafficSplit!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Tool to search public web data, powered by Vertex AI Search and Sec4
/// compliance.
typedef GoogleCloudAiplatformV1EnterpriseWebSearch = $Empty;

/// Selector for entityId.
///
/// Getting ids from the given source.
class GoogleCloudAiplatformV1EntityIdSelector {
  /// Source of Csv
  GoogleCloudAiplatformV1CsvSource? csvSource;

  /// Source column that holds entity IDs.
  ///
  /// If not provided, entity IDs are extracted from the column named entity_id.
  core.String? entityIdField;

  GoogleCloudAiplatformV1EntityIdSelector({
    this.csvSource,
    this.entityIdField,
  });

  GoogleCloudAiplatformV1EntityIdSelector.fromJson(core.Map json_)
      : this(
          csvSource: json_.containsKey('csvSource')
              ? GoogleCloudAiplatformV1CsvSource.fromJson(
                  json_['csvSource'] as core.Map<core.String, core.dynamic>)
              : null,
          entityIdField: json_['entityIdField'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (csvSource != null) 'csvSource': csvSource!,
        if (entityIdField != null) 'entityIdField': entityIdField!,
      };
}

/// An entity type is a type of object in a system that needs to be modeled and
/// have stored information about.
///
/// For example, driver is an entity type, and driver0 is an instance of an
/// entity type driver.
class GoogleCloudAiplatformV1EntityType {
  /// Timestamp when this EntityType was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the EntityType.
  ///
  /// Optional.
  core.String? description;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your EntityTypes.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one EntityType (System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The default monitoring configuration for all Features with value type
  /// (Feature.ValueType) BOOL, STRING, DOUBLE or INT64 under this EntityType.
  ///
  /// If this is populated with
  /// \[FeaturestoreMonitoringConfig.monitoring_interval\] specified, snapshot
  /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is
  /// disabled.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfig? monitoringConfig;

  /// Name of the EntityType.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// The last part entity_type is assigned by the client. The entity_type can
  /// be up to 64 characters long and can consist only of ASCII Latin letters
  /// A-Z and a-z and underscore(_), and ASCII digits 0-9 starting with a
  /// letter. The value will be unique given a featurestore.
  ///
  /// Immutable.
  core.String? name;

  /// Config for data retention policy in offline storage.
  ///
  /// TTL in days for feature values that will be stored in offline storage. The
  /// Feature Store offline storage periodically removes obsolete feature values
  /// older than `offline_storage_ttl_days` since the feature generation time.
  /// If unset (or explicitly set to 0), default to 4000 days TTL.
  ///
  /// Optional.
  core.int? offlineStorageTtlDays;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this EntityType was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1EntityType({
    this.createTime,
    this.description,
    this.etag,
    this.labels,
    this.monitoringConfig,
    this.name,
    this.offlineStorageTtlDays,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1EntityType.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          monitoringConfig: json_.containsKey('monitoringConfig')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfig.fromJson(
                  json_['monitoringConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          offlineStorageTtlDays: json_['offlineStorageTtlDays'] as core.int?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (monitoringConfig != null) 'monitoringConfig': monitoringConfig!,
        if (name != null) 'name': name!,
        if (offlineStorageTtlDays != null)
          'offlineStorageTtlDays': offlineStorageTtlDays!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Represents an environment variable present in a Container or Python Module.
class GoogleCloudAiplatformV1EnvVar {
  /// Name of the environment variable.
  ///
  /// Must be a valid C identifier.
  ///
  /// Required.
  core.String? name;

  /// Variables that reference a $(VAR_NAME) are expanded using the previous
  /// defined environment variables in the container and any service environment
  /// variables.
  ///
  /// If a variable cannot be resolved, the reference in the input string will
  /// be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie:
  /// $$(VAR_NAME). Escaped references will never be expanded, regardless of
  /// whether the variable exists or not.
  ///
  /// Required.
  core.String? value;

  GoogleCloudAiplatformV1EnvVar({
    this.name,
    this.value,
  });

  GoogleCloudAiplatformV1EnvVar.fromJson(core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          value: json_['value'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// Model error analysis for each annotation.
class GoogleCloudAiplatformV1ErrorAnalysisAnnotation {
  /// Attributed items for a given annotation, typically representing neighbors
  /// from the training sets constrained by the query type.
  core.List<GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem>?
      attributedItems;

  /// The outlier score of this annotated item.
  ///
  /// Usually defined as the min of all distances from attributed items.
  core.double? outlierScore;

  /// The threshold used to determine if this annotation is an outlier or not.
  core.double? outlierThreshold;

  /// The query type used for finding the attributed items.
  /// Possible string values are:
  /// - "QUERY_TYPE_UNSPECIFIED" : Unspecified query type for model error
  /// analysis.
  /// - "ALL_SIMILAR" : Query similar samples across all classes in the dataset.
  /// - "SAME_CLASS_SIMILAR" : Query similar samples from the same class of the
  /// input sample.
  /// - "SAME_CLASS_DISSIMILAR" : Query dissimilar samples from the same class
  /// of the input sample.
  core.String? queryType;

  GoogleCloudAiplatformV1ErrorAnalysisAnnotation({
    this.attributedItems,
    this.outlierScore,
    this.outlierThreshold,
    this.queryType,
  });

  GoogleCloudAiplatformV1ErrorAnalysisAnnotation.fromJson(core.Map json_)
      : this(
          attributedItems: (json_['attributedItems'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          outlierScore: (json_['outlierScore'] as core.num?)?.toDouble(),
          outlierThreshold:
              (json_['outlierThreshold'] as core.num?)?.toDouble(),
          queryType: json_['queryType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributedItems != null) 'attributedItems': attributedItems!,
        if (outlierScore != null) 'outlierScore': outlierScore!,
        if (outlierThreshold != null) 'outlierThreshold': outlierThreshold!,
        if (queryType != null) 'queryType': queryType!,
      };
}

/// Attributed items for a given annotation, typically representing neighbors
/// from the training sets constrained by the query type.
class GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem {
  /// The unique ID for each annotation.
  ///
  /// Used by FE to allocate the annotation in DB.
  core.String? annotationResourceName;

  /// The distance of this item to the annotation.
  core.double? distance;

  GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem({
    this.annotationResourceName,
    this.distance,
  });

  GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem.fromJson(
      core.Map json_)
      : this(
          annotationResourceName:
              json_['annotationResourceName'] as core.String?,
          distance: (json_['distance'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationResourceName != null)
          'annotationResourceName': annotationResourceName!,
        if (distance != null) 'distance': distance!,
      };
}

/// Request message for EvaluationService.EvaluateDataset.
class GoogleCloudAiplatformV1EvaluateDatasetRequest {
  /// Autorater config used for evaluation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1AutoraterConfig? autoraterConfig;

  /// The dataset used for evaluation.
  ///
  /// Required.
  GoogleCloudAiplatformV1EvaluationDataset? dataset;

  /// The metrics used for evaluation.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1Metric>? metrics;

  /// Config for evaluation output.
  ///
  /// Required.
  GoogleCloudAiplatformV1OutputConfig? outputConfig;

  GoogleCloudAiplatformV1EvaluateDatasetRequest({
    this.autoraterConfig,
    this.dataset,
    this.metrics,
    this.outputConfig,
  });

  GoogleCloudAiplatformV1EvaluateDatasetRequest.fromJson(core.Map json_)
      : this(
          autoraterConfig: json_.containsKey('autoraterConfig')
              ? GoogleCloudAiplatformV1AutoraterConfig.fromJson(
                  json_['autoraterConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          dataset: json_.containsKey('dataset')
              ? GoogleCloudAiplatformV1EvaluationDataset.fromJson(
                  json_['dataset'] as core.Map<core.String, core.dynamic>)
              : null,
          metrics: (json_['metrics'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Metric.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          outputConfig: json_.containsKey('outputConfig')
              ? GoogleCloudAiplatformV1OutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!,
        if (dataset != null) 'dataset': dataset!,
        if (metrics != null) 'metrics': metrics!,
        if (outputConfig != null) 'outputConfig': outputConfig!,
      };
}

/// Request message for EvaluationService.EvaluateInstances.
class GoogleCloudAiplatformV1EvaluateInstancesRequest {
  /// Autorater config used for evaluation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1AutoraterConfig? autoraterConfig;

  /// Instances and metric spec for bleu metric.
  GoogleCloudAiplatformV1BleuInput? bleuInput;

  /// Input for coherence metric.
  GoogleCloudAiplatformV1CoherenceInput? coherenceInput;

  /// Translation metrics.
  ///
  /// Input for Comet metric.
  GoogleCloudAiplatformV1CometInput? cometInput;

  /// Auto metric instances.
  ///
  /// Instances and metric spec for exact match metric.
  GoogleCloudAiplatformV1ExactMatchInput? exactMatchInput;

  /// LLM-based metric instance.
  ///
  /// General text generation metrics, applicable to other categories. Input for
  /// fluency metric.
  GoogleCloudAiplatformV1FluencyInput? fluencyInput;

  /// Input for fulfillment metric.
  GoogleCloudAiplatformV1FulfillmentInput? fulfillmentInput;

  /// Input for groundedness metric.
  GoogleCloudAiplatformV1GroundednessInput? groundednessInput;

  /// Input for Metricx metric.
  GoogleCloudAiplatformV1MetricxInput? metricxInput;

  /// Input for pairwise metric.
  GoogleCloudAiplatformV1PairwiseMetricInput? pairwiseMetricInput;

  /// Input for pairwise question answering quality metric.
  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInput?
      pairwiseQuestionAnsweringQualityInput;

  /// Input for pairwise summarization quality metric.
  GoogleCloudAiplatformV1PairwiseSummarizationQualityInput?
      pairwiseSummarizationQualityInput;

  /// Input for pointwise metric.
  GoogleCloudAiplatformV1PointwiseMetricInput? pointwiseMetricInput;

  /// Input for question answering correctness metric.
  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInput?
      questionAnsweringCorrectnessInput;

  /// Input for question answering helpfulness metric.
  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInput?
      questionAnsweringHelpfulnessInput;

  /// Input for question answering quality metric.
  GoogleCloudAiplatformV1QuestionAnsweringQualityInput?
      questionAnsweringQualityInput;

  /// Input for question answering relevance metric.
  GoogleCloudAiplatformV1QuestionAnsweringRelevanceInput?
      questionAnsweringRelevanceInput;

  /// Instances and metric spec for rouge metric.
  GoogleCloudAiplatformV1RougeInput? rougeInput;

  /// Input for safety metric.
  GoogleCloudAiplatformV1SafetyInput? safetyInput;

  /// Input for summarization helpfulness metric.
  GoogleCloudAiplatformV1SummarizationHelpfulnessInput?
      summarizationHelpfulnessInput;

  /// Input for summarization quality metric.
  GoogleCloudAiplatformV1SummarizationQualityInput? summarizationQualityInput;

  /// Input for summarization verbosity metric.
  GoogleCloudAiplatformV1SummarizationVerbosityInput?
      summarizationVerbosityInput;

  /// Tool call metric instances.
  ///
  /// Input for tool call valid metric.
  GoogleCloudAiplatformV1ToolCallValidInput? toolCallValidInput;

  /// Input for tool name match metric.
  GoogleCloudAiplatformV1ToolNameMatchInput? toolNameMatchInput;

  /// Input for tool parameter key match metric.
  GoogleCloudAiplatformV1ToolParameterKeyMatchInput? toolParameterKeyMatchInput;

  /// Input for tool parameter key value match metric.
  GoogleCloudAiplatformV1ToolParameterKVMatchInput? toolParameterKvMatchInput;

  /// Input for trajectory match any order metric.
  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInput?
      trajectoryAnyOrderMatchInput;

  /// Input for trajectory exact match metric.
  GoogleCloudAiplatformV1TrajectoryExactMatchInput? trajectoryExactMatchInput;

  /// Input for trajectory in order match metric.
  GoogleCloudAiplatformV1TrajectoryInOrderMatchInput?
      trajectoryInOrderMatchInput;

  /// Input for trajectory precision metric.
  GoogleCloudAiplatformV1TrajectoryPrecisionInput? trajectoryPrecisionInput;

  /// Input for trajectory recall metric.
  GoogleCloudAiplatformV1TrajectoryRecallInput? trajectoryRecallInput;

  /// Input for trajectory single tool use metric.
  GoogleCloudAiplatformV1TrajectorySingleToolUseInput?
      trajectorySingleToolUseInput;

  GoogleCloudAiplatformV1EvaluateInstancesRequest({
    this.autoraterConfig,
    this.bleuInput,
    this.coherenceInput,
    this.cometInput,
    this.exactMatchInput,
    this.fluencyInput,
    this.fulfillmentInput,
    this.groundednessInput,
    this.metricxInput,
    this.pairwiseMetricInput,
    this.pairwiseQuestionAnsweringQualityInput,
    this.pairwiseSummarizationQualityInput,
    this.pointwiseMetricInput,
    this.questionAnsweringCorrectnessInput,
    this.questionAnsweringHelpfulnessInput,
    this.questionAnsweringQualityInput,
    this.questionAnsweringRelevanceInput,
    this.rougeInput,
    this.safetyInput,
    this.summarizationHelpfulnessInput,
    this.summarizationQualityInput,
    this.summarizationVerbosityInput,
    this.toolCallValidInput,
    this.toolNameMatchInput,
    this.toolParameterKeyMatchInput,
    this.toolParameterKvMatchInput,
    this.trajectoryAnyOrderMatchInput,
    this.trajectoryExactMatchInput,
    this.trajectoryInOrderMatchInput,
    this.trajectoryPrecisionInput,
    this.trajectoryRecallInput,
    this.trajectorySingleToolUseInput,
  });

  GoogleCloudAiplatformV1EvaluateInstancesRequest.fromJson(core.Map json_)
      : this(
          autoraterConfig: json_.containsKey('autoraterConfig')
              ? GoogleCloudAiplatformV1AutoraterConfig.fromJson(
                  json_['autoraterConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          bleuInput: json_.containsKey('bleuInput')
              ? GoogleCloudAiplatformV1BleuInput.fromJson(
                  json_['bleuInput'] as core.Map<core.String, core.dynamic>)
              : null,
          coherenceInput: json_.containsKey('coherenceInput')
              ? GoogleCloudAiplatformV1CoherenceInput.fromJson(
                  json_['coherenceInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          cometInput: json_.containsKey('cometInput')
              ? GoogleCloudAiplatformV1CometInput.fromJson(
                  json_['cometInput'] as core.Map<core.String, core.dynamic>)
              : null,
          exactMatchInput: json_.containsKey('exactMatchInput')
              ? GoogleCloudAiplatformV1ExactMatchInput.fromJson(
                  json_['exactMatchInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          fluencyInput: json_.containsKey('fluencyInput')
              ? GoogleCloudAiplatformV1FluencyInput.fromJson(
                  json_['fluencyInput'] as core.Map<core.String, core.dynamic>)
              : null,
          fulfillmentInput: json_.containsKey('fulfillmentInput')
              ? GoogleCloudAiplatformV1FulfillmentInput.fromJson(
                  json_['fulfillmentInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          groundednessInput: json_.containsKey('groundednessInput')
              ? GoogleCloudAiplatformV1GroundednessInput.fromJson(
                  json_['groundednessInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          metricxInput: json_.containsKey('metricxInput')
              ? GoogleCloudAiplatformV1MetricxInput.fromJson(
                  json_['metricxInput'] as core.Map<core.String, core.dynamic>)
              : null,
          pairwiseMetricInput: json_.containsKey('pairwiseMetricInput')
              ? GoogleCloudAiplatformV1PairwiseMetricInput.fromJson(
                  json_['pairwiseMetricInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pairwiseQuestionAnsweringQualityInput:
              json_.containsKey('pairwiseQuestionAnsweringQualityInput')
                  ? GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInput
                      .fromJson(json_['pairwiseQuestionAnsweringQualityInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          pairwiseSummarizationQualityInput:
              json_.containsKey('pairwiseSummarizationQualityInput')
                  ? GoogleCloudAiplatformV1PairwiseSummarizationQualityInput
                      .fromJson(json_['pairwiseSummarizationQualityInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          pointwiseMetricInput: json_.containsKey('pointwiseMetricInput')
              ? GoogleCloudAiplatformV1PointwiseMetricInput.fromJson(
                  json_['pointwiseMetricInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          questionAnsweringCorrectnessInput:
              json_.containsKey('questionAnsweringCorrectnessInput')
                  ? GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInput
                      .fromJson(json_['questionAnsweringCorrectnessInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          questionAnsweringHelpfulnessInput:
              json_.containsKey('questionAnsweringHelpfulnessInput')
                  ? GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInput
                      .fromJson(json_['questionAnsweringHelpfulnessInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          questionAnsweringQualityInput: json_
                  .containsKey('questionAnsweringQualityInput')
              ? GoogleCloudAiplatformV1QuestionAnsweringQualityInput.fromJson(
                  json_['questionAnsweringQualityInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          questionAnsweringRelevanceInput: json_
                  .containsKey('questionAnsweringRelevanceInput')
              ? GoogleCloudAiplatformV1QuestionAnsweringRelevanceInput.fromJson(
                  json_['questionAnsweringRelevanceInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          rougeInput: json_.containsKey('rougeInput')
              ? GoogleCloudAiplatformV1RougeInput.fromJson(
                  json_['rougeInput'] as core.Map<core.String, core.dynamic>)
              : null,
          safetyInput: json_.containsKey('safetyInput')
              ? GoogleCloudAiplatformV1SafetyInput.fromJson(
                  json_['safetyInput'] as core.Map<core.String, core.dynamic>)
              : null,
          summarizationHelpfulnessInput: json_
                  .containsKey('summarizationHelpfulnessInput')
              ? GoogleCloudAiplatformV1SummarizationHelpfulnessInput.fromJson(
                  json_['summarizationHelpfulnessInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          summarizationQualityInput:
              json_.containsKey('summarizationQualityInput')
                  ? GoogleCloudAiplatformV1SummarizationQualityInput.fromJson(
                      json_['summarizationQualityInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          summarizationVerbosityInput:
              json_.containsKey('summarizationVerbosityInput')
                  ? GoogleCloudAiplatformV1SummarizationVerbosityInput.fromJson(
                      json_['summarizationVerbosityInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          toolCallValidInput: json_.containsKey('toolCallValidInput')
              ? GoogleCloudAiplatformV1ToolCallValidInput.fromJson(
                  json_['toolCallValidInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolNameMatchInput: json_.containsKey('toolNameMatchInput')
              ? GoogleCloudAiplatformV1ToolNameMatchInput.fromJson(
                  json_['toolNameMatchInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolParameterKeyMatchInput:
              json_.containsKey('toolParameterKeyMatchInput')
                  ? GoogleCloudAiplatformV1ToolParameterKeyMatchInput.fromJson(
                      json_['toolParameterKeyMatchInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          toolParameterKvMatchInput:
              json_.containsKey('toolParameterKvMatchInput')
                  ? GoogleCloudAiplatformV1ToolParameterKVMatchInput.fromJson(
                      json_['toolParameterKvMatchInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trajectoryAnyOrderMatchInput: json_
                  .containsKey('trajectoryAnyOrderMatchInput')
              ? GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInput.fromJson(
                  json_['trajectoryAnyOrderMatchInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trajectoryExactMatchInput:
              json_.containsKey('trajectoryExactMatchInput')
                  ? GoogleCloudAiplatformV1TrajectoryExactMatchInput.fromJson(
                      json_['trajectoryExactMatchInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trajectoryInOrderMatchInput:
              json_.containsKey('trajectoryInOrderMatchInput')
                  ? GoogleCloudAiplatformV1TrajectoryInOrderMatchInput.fromJson(
                      json_['trajectoryInOrderMatchInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trajectoryPrecisionInput:
              json_.containsKey('trajectoryPrecisionInput')
                  ? GoogleCloudAiplatformV1TrajectoryPrecisionInput.fromJson(
                      json_['trajectoryPrecisionInput']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trajectoryRecallInput: json_.containsKey('trajectoryRecallInput')
              ? GoogleCloudAiplatformV1TrajectoryRecallInput.fromJson(
                  json_['trajectoryRecallInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trajectorySingleToolUseInput: json_
                  .containsKey('trajectorySingleToolUseInput')
              ? GoogleCloudAiplatformV1TrajectorySingleToolUseInput.fromJson(
                  json_['trajectorySingleToolUseInput']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!,
        if (bleuInput != null) 'bleuInput': bleuInput!,
        if (coherenceInput != null) 'coherenceInput': coherenceInput!,
        if (cometInput != null) 'cometInput': cometInput!,
        if (exactMatchInput != null) 'exactMatchInput': exactMatchInput!,
        if (fluencyInput != null) 'fluencyInput': fluencyInput!,
        if (fulfillmentInput != null) 'fulfillmentInput': fulfillmentInput!,
        if (groundednessInput != null) 'groundednessInput': groundednessInput!,
        if (metricxInput != null) 'metricxInput': metricxInput!,
        if (pairwiseMetricInput != null)
          'pairwiseMetricInput': pairwiseMetricInput!,
        if (pairwiseQuestionAnsweringQualityInput != null)
          'pairwiseQuestionAnsweringQualityInput':
              pairwiseQuestionAnsweringQualityInput!,
        if (pairwiseSummarizationQualityInput != null)
          'pairwiseSummarizationQualityInput':
              pairwiseSummarizationQualityInput!,
        if (pointwiseMetricInput != null)
          'pointwiseMetricInput': pointwiseMetricInput!,
        if (questionAnsweringCorrectnessInput != null)
          'questionAnsweringCorrectnessInput':
              questionAnsweringCorrectnessInput!,
        if (questionAnsweringHelpfulnessInput != null)
          'questionAnsweringHelpfulnessInput':
              questionAnsweringHelpfulnessInput!,
        if (questionAnsweringQualityInput != null)
          'questionAnsweringQualityInput': questionAnsweringQualityInput!,
        if (questionAnsweringRelevanceInput != null)
          'questionAnsweringRelevanceInput': questionAnsweringRelevanceInput!,
        if (rougeInput != null) 'rougeInput': rougeInput!,
        if (safetyInput != null) 'safetyInput': safetyInput!,
        if (summarizationHelpfulnessInput != null)
          'summarizationHelpfulnessInput': summarizationHelpfulnessInput!,
        if (summarizationQualityInput != null)
          'summarizationQualityInput': summarizationQualityInput!,
        if (summarizationVerbosityInput != null)
          'summarizationVerbosityInput': summarizationVerbosityInput!,
        if (toolCallValidInput != null)
          'toolCallValidInput': toolCallValidInput!,
        if (toolNameMatchInput != null)
          'toolNameMatchInput': toolNameMatchInput!,
        if (toolParameterKeyMatchInput != null)
          'toolParameterKeyMatchInput': toolParameterKeyMatchInput!,
        if (toolParameterKvMatchInput != null)
          'toolParameterKvMatchInput': toolParameterKvMatchInput!,
        if (trajectoryAnyOrderMatchInput != null)
          'trajectoryAnyOrderMatchInput': trajectoryAnyOrderMatchInput!,
        if (trajectoryExactMatchInput != null)
          'trajectoryExactMatchInput': trajectoryExactMatchInput!,
        if (trajectoryInOrderMatchInput != null)
          'trajectoryInOrderMatchInput': trajectoryInOrderMatchInput!,
        if (trajectoryPrecisionInput != null)
          'trajectoryPrecisionInput': trajectoryPrecisionInput!,
        if (trajectoryRecallInput != null)
          'trajectoryRecallInput': trajectoryRecallInput!,
        if (trajectorySingleToolUseInput != null)
          'trajectorySingleToolUseInput': trajectorySingleToolUseInput!,
      };
}

/// Response message for EvaluationService.EvaluateInstances.
class GoogleCloudAiplatformV1EvaluateInstancesResponse {
  /// Results for bleu metric.
  GoogleCloudAiplatformV1BleuResults? bleuResults;

  /// Result for coherence metric.
  GoogleCloudAiplatformV1CoherenceResult? coherenceResult;

  /// Translation metrics.
  ///
  /// Result for Comet metric.
  GoogleCloudAiplatformV1CometResult? cometResult;

  /// Auto metric evaluation results.
  ///
  /// Results for exact match metric.
  GoogleCloudAiplatformV1ExactMatchResults? exactMatchResults;

  /// LLM-based metric evaluation result.
  ///
  /// General text generation metrics, applicable to other categories. Result
  /// for fluency metric.
  GoogleCloudAiplatformV1FluencyResult? fluencyResult;

  /// Result for fulfillment metric.
  GoogleCloudAiplatformV1FulfillmentResult? fulfillmentResult;

  /// Result for groundedness metric.
  GoogleCloudAiplatformV1GroundednessResult? groundednessResult;

  /// Result for Metricx metric.
  GoogleCloudAiplatformV1MetricxResult? metricxResult;

  /// Result for pairwise metric.
  GoogleCloudAiplatformV1PairwiseMetricResult? pairwiseMetricResult;

  /// Result for pairwise question answering quality metric.
  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityResult?
      pairwiseQuestionAnsweringQualityResult;

  /// Result for pairwise summarization quality metric.
  GoogleCloudAiplatformV1PairwiseSummarizationQualityResult?
      pairwiseSummarizationQualityResult;

  /// Generic metrics.
  ///
  /// Result for pointwise metric.
  GoogleCloudAiplatformV1PointwiseMetricResult? pointwiseMetricResult;

  /// Result for question answering correctness metric.
  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessResult?
      questionAnsweringCorrectnessResult;

  /// Result for question answering helpfulness metric.
  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessResult?
      questionAnsweringHelpfulnessResult;

  /// Question answering only metrics.
  ///
  /// Result for question answering quality metric.
  GoogleCloudAiplatformV1QuestionAnsweringQualityResult?
      questionAnsweringQualityResult;

  /// Result for question answering relevance metric.
  GoogleCloudAiplatformV1QuestionAnsweringRelevanceResult?
      questionAnsweringRelevanceResult;

  /// Results for rouge metric.
  GoogleCloudAiplatformV1RougeResults? rougeResults;

  /// Result for safety metric.
  GoogleCloudAiplatformV1SafetyResult? safetyResult;

  /// Result for summarization helpfulness metric.
  GoogleCloudAiplatformV1SummarizationHelpfulnessResult?
      summarizationHelpfulnessResult;

  /// Summarization only metrics.
  ///
  /// Result for summarization quality metric.
  GoogleCloudAiplatformV1SummarizationQualityResult? summarizationQualityResult;

  /// Result for summarization verbosity metric.
  GoogleCloudAiplatformV1SummarizationVerbosityResult?
      summarizationVerbosityResult;

  /// Tool call metrics.
  ///
  /// Results for tool call valid metric.
  GoogleCloudAiplatformV1ToolCallValidResults? toolCallValidResults;

  /// Results for tool name match metric.
  GoogleCloudAiplatformV1ToolNameMatchResults? toolNameMatchResults;

  /// Results for tool parameter key match metric.
  GoogleCloudAiplatformV1ToolParameterKeyMatchResults?
      toolParameterKeyMatchResults;

  /// Results for tool parameter key value match metric.
  GoogleCloudAiplatformV1ToolParameterKVMatchResults?
      toolParameterKvMatchResults;

  /// Result for trajectory any order match metric.
  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchResults?
      trajectoryAnyOrderMatchResults;

  /// Result for trajectory exact match metric.
  GoogleCloudAiplatformV1TrajectoryExactMatchResults?
      trajectoryExactMatchResults;

  /// Result for trajectory in order match metric.
  GoogleCloudAiplatformV1TrajectoryInOrderMatchResults?
      trajectoryInOrderMatchResults;

  /// Result for trajectory precision metric.
  GoogleCloudAiplatformV1TrajectoryPrecisionResults? trajectoryPrecisionResults;

  /// Results for trajectory recall metric.
  GoogleCloudAiplatformV1TrajectoryRecallResults? trajectoryRecallResults;

  /// Results for trajectory single tool use metric.
  GoogleCloudAiplatformV1TrajectorySingleToolUseResults?
      trajectorySingleToolUseResults;

  GoogleCloudAiplatformV1EvaluateInstancesResponse({
    this.bleuResults,
    this.coherenceResult,
    this.cometResult,
    this.exactMatchResults,
    this.fluencyResult,
    this.fulfillmentResult,
    this.groundednessResult,
    this.metricxResult,
    this.pairwiseMetricResult,
    this.pairwiseQuestionAnsweringQualityResult,
    this.pairwiseSummarizationQualityResult,
    this.pointwiseMetricResult,
    this.questionAnsweringCorrectnessResult,
    this.questionAnsweringHelpfulnessResult,
    this.questionAnsweringQualityResult,
    this.questionAnsweringRelevanceResult,
    this.rougeResults,
    this.safetyResult,
    this.summarizationHelpfulnessResult,
    this.summarizationQualityResult,
    this.summarizationVerbosityResult,
    this.toolCallValidResults,
    this.toolNameMatchResults,
    this.toolParameterKeyMatchResults,
    this.toolParameterKvMatchResults,
    this.trajectoryAnyOrderMatchResults,
    this.trajectoryExactMatchResults,
    this.trajectoryInOrderMatchResults,
    this.trajectoryPrecisionResults,
    this.trajectoryRecallResults,
    this.trajectorySingleToolUseResults,
  });

  GoogleCloudAiplatformV1EvaluateInstancesResponse.fromJson(core.Map json_)
      : this(
          bleuResults: json_.containsKey('bleuResults')
              ? GoogleCloudAiplatformV1BleuResults.fromJson(
                  json_['bleuResults'] as core.Map<core.String, core.dynamic>)
              : null,
          coherenceResult: json_.containsKey('coherenceResult')
              ? GoogleCloudAiplatformV1CoherenceResult.fromJson(
                  json_['coherenceResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          cometResult: json_.containsKey('cometResult')
              ? GoogleCloudAiplatformV1CometResult.fromJson(
                  json_['cometResult'] as core.Map<core.String, core.dynamic>)
              : null,
          exactMatchResults: json_.containsKey('exactMatchResults')
              ? GoogleCloudAiplatformV1ExactMatchResults.fromJson(
                  json_['exactMatchResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
          fluencyResult: json_.containsKey('fluencyResult')
              ? GoogleCloudAiplatformV1FluencyResult.fromJson(
                  json_['fluencyResult'] as core.Map<core.String, core.dynamic>)
              : null,
          fulfillmentResult: json_.containsKey('fulfillmentResult')
              ? GoogleCloudAiplatformV1FulfillmentResult.fromJson(
                  json_['fulfillmentResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          groundednessResult: json_.containsKey('groundednessResult')
              ? GoogleCloudAiplatformV1GroundednessResult.fromJson(
                  json_['groundednessResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          metricxResult: json_.containsKey('metricxResult')
              ? GoogleCloudAiplatformV1MetricxResult.fromJson(
                  json_['metricxResult'] as core.Map<core.String, core.dynamic>)
              : null,
          pairwiseMetricResult: json_.containsKey('pairwiseMetricResult')
              ? GoogleCloudAiplatformV1PairwiseMetricResult.fromJson(
                  json_['pairwiseMetricResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pairwiseQuestionAnsweringQualityResult: json_
                  .containsKey('pairwiseQuestionAnsweringQualityResult')
              ? GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityResult
                  .fromJson(json_['pairwiseQuestionAnsweringQualityResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pairwiseSummarizationQualityResult:
              json_.containsKey('pairwiseSummarizationQualityResult')
                  ? GoogleCloudAiplatformV1PairwiseSummarizationQualityResult
                      .fromJson(json_['pairwiseSummarizationQualityResult']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          pointwiseMetricResult: json_.containsKey('pointwiseMetricResult')
              ? GoogleCloudAiplatformV1PointwiseMetricResult.fromJson(
                  json_['pointwiseMetricResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          questionAnsweringCorrectnessResult:
              json_.containsKey('questionAnsweringCorrectnessResult')
                  ? GoogleCloudAiplatformV1QuestionAnsweringCorrectnessResult
                      .fromJson(json_['questionAnsweringCorrectnessResult']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          questionAnsweringHelpfulnessResult:
              json_.containsKey('questionAnsweringHelpfulnessResult')
                  ? GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessResult
                      .fromJson(json_['questionAnsweringHelpfulnessResult']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          questionAnsweringQualityResult: json_
                  .containsKey('questionAnsweringQualityResult')
              ? GoogleCloudAiplatformV1QuestionAnsweringQualityResult.fromJson(
                  json_['questionAnsweringQualityResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          questionAnsweringRelevanceResult:
              json_.containsKey('questionAnsweringRelevanceResult')
                  ? GoogleCloudAiplatformV1QuestionAnsweringRelevanceResult
                      .fromJson(json_['questionAnsweringRelevanceResult']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          rougeResults: json_.containsKey('rougeResults')
              ? GoogleCloudAiplatformV1RougeResults.fromJson(
                  json_['rougeResults'] as core.Map<core.String, core.dynamic>)
              : null,
          safetyResult: json_.containsKey('safetyResult')
              ? GoogleCloudAiplatformV1SafetyResult.fromJson(
                  json_['safetyResult'] as core.Map<core.String, core.dynamic>)
              : null,
          summarizationHelpfulnessResult: json_
                  .containsKey('summarizationHelpfulnessResult')
              ? GoogleCloudAiplatformV1SummarizationHelpfulnessResult.fromJson(
                  json_['summarizationHelpfulnessResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          summarizationQualityResult:
              json_.containsKey('summarizationQualityResult')
                  ? GoogleCloudAiplatformV1SummarizationQualityResult.fromJson(
                      json_['summarizationQualityResult']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          summarizationVerbosityResult: json_
                  .containsKey('summarizationVerbosityResult')
              ? GoogleCloudAiplatformV1SummarizationVerbosityResult.fromJson(
                  json_['summarizationVerbosityResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolCallValidResults: json_.containsKey('toolCallValidResults')
              ? GoogleCloudAiplatformV1ToolCallValidResults.fromJson(
                  json_['toolCallValidResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolNameMatchResults: json_.containsKey('toolNameMatchResults')
              ? GoogleCloudAiplatformV1ToolNameMatchResults.fromJson(
                  json_['toolNameMatchResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolParameterKeyMatchResults: json_
                  .containsKey('toolParameterKeyMatchResults')
              ? GoogleCloudAiplatformV1ToolParameterKeyMatchResults.fromJson(
                  json_['toolParameterKeyMatchResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolParameterKvMatchResults:
              json_.containsKey('toolParameterKvMatchResults')
                  ? GoogleCloudAiplatformV1ToolParameterKVMatchResults.fromJson(
                      json_['toolParameterKvMatchResults']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trajectoryAnyOrderMatchResults: json_
                  .containsKey('trajectoryAnyOrderMatchResults')
              ? GoogleCloudAiplatformV1TrajectoryAnyOrderMatchResults.fromJson(
                  json_['trajectoryAnyOrderMatchResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trajectoryExactMatchResults:
              json_.containsKey('trajectoryExactMatchResults')
                  ? GoogleCloudAiplatformV1TrajectoryExactMatchResults.fromJson(
                      json_['trajectoryExactMatchResults']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trajectoryInOrderMatchResults: json_
                  .containsKey('trajectoryInOrderMatchResults')
              ? GoogleCloudAiplatformV1TrajectoryInOrderMatchResults.fromJson(
                  json_['trajectoryInOrderMatchResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trajectoryPrecisionResults:
              json_.containsKey('trajectoryPrecisionResults')
                  ? GoogleCloudAiplatformV1TrajectoryPrecisionResults.fromJson(
                      json_['trajectoryPrecisionResults']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trajectoryRecallResults: json_.containsKey('trajectoryRecallResults')
              ? GoogleCloudAiplatformV1TrajectoryRecallResults.fromJson(
                  json_['trajectoryRecallResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trajectorySingleToolUseResults: json_
                  .containsKey('trajectorySingleToolUseResults')
              ? GoogleCloudAiplatformV1TrajectorySingleToolUseResults.fromJson(
                  json_['trajectorySingleToolUseResults']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bleuResults != null) 'bleuResults': bleuResults!,
        if (coherenceResult != null) 'coherenceResult': coherenceResult!,
        if (cometResult != null) 'cometResult': cometResult!,
        if (exactMatchResults != null) 'exactMatchResults': exactMatchResults!,
        if (fluencyResult != null) 'fluencyResult': fluencyResult!,
        if (fulfillmentResult != null) 'fulfillmentResult': fulfillmentResult!,
        if (groundednessResult != null)
          'groundednessResult': groundednessResult!,
        if (metricxResult != null) 'metricxResult': metricxResult!,
        if (pairwiseMetricResult != null)
          'pairwiseMetricResult': pairwiseMetricResult!,
        if (pairwiseQuestionAnsweringQualityResult != null)
          'pairwiseQuestionAnsweringQualityResult':
              pairwiseQuestionAnsweringQualityResult!,
        if (pairwiseSummarizationQualityResult != null)
          'pairwiseSummarizationQualityResult':
              pairwiseSummarizationQualityResult!,
        if (pointwiseMetricResult != null)
          'pointwiseMetricResult': pointwiseMetricResult!,
        if (questionAnsweringCorrectnessResult != null)
          'questionAnsweringCorrectnessResult':
              questionAnsweringCorrectnessResult!,
        if (questionAnsweringHelpfulnessResult != null)
          'questionAnsweringHelpfulnessResult':
              questionAnsweringHelpfulnessResult!,
        if (questionAnsweringQualityResult != null)
          'questionAnsweringQualityResult': questionAnsweringQualityResult!,
        if (questionAnsweringRelevanceResult != null)
          'questionAnsweringRelevanceResult': questionAnsweringRelevanceResult!,
        if (rougeResults != null) 'rougeResults': rougeResults!,
        if (safetyResult != null) 'safetyResult': safetyResult!,
        if (summarizationHelpfulnessResult != null)
          'summarizationHelpfulnessResult': summarizationHelpfulnessResult!,
        if (summarizationQualityResult != null)
          'summarizationQualityResult': summarizationQualityResult!,
        if (summarizationVerbosityResult != null)
          'summarizationVerbosityResult': summarizationVerbosityResult!,
        if (toolCallValidResults != null)
          'toolCallValidResults': toolCallValidResults!,
        if (toolNameMatchResults != null)
          'toolNameMatchResults': toolNameMatchResults!,
        if (toolParameterKeyMatchResults != null)
          'toolParameterKeyMatchResults': toolParameterKeyMatchResults!,
        if (toolParameterKvMatchResults != null)
          'toolParameterKvMatchResults': toolParameterKvMatchResults!,
        if (trajectoryAnyOrderMatchResults != null)
          'trajectoryAnyOrderMatchResults': trajectoryAnyOrderMatchResults!,
        if (trajectoryExactMatchResults != null)
          'trajectoryExactMatchResults': trajectoryExactMatchResults!,
        if (trajectoryInOrderMatchResults != null)
          'trajectoryInOrderMatchResults': trajectoryInOrderMatchResults!,
        if (trajectoryPrecisionResults != null)
          'trajectoryPrecisionResults': trajectoryPrecisionResults!,
        if (trajectoryRecallResults != null)
          'trajectoryRecallResults': trajectoryRecallResults!,
        if (trajectorySingleToolUseResults != null)
          'trajectorySingleToolUseResults': trajectorySingleToolUseResults!,
      };
}

/// True positive, false positive, or false negative.
///
/// EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
/// of `annotationSpec` dimension.
class GoogleCloudAiplatformV1EvaluatedAnnotation {
  /// The data item payload that the Model predicted this EvaluatedAnnotation
  /// on.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? dataItemPayload;

  /// Annotations of model error analysis results.
  core.List<GoogleCloudAiplatformV1ErrorAnalysisAnnotation>?
      errorAnalysisAnnotations;

  /// ID of the EvaluatedDataItemView under the same ancestor ModelEvaluation.
  ///
  /// The EvaluatedDataItemView consists of all ground truths and predictions on
  /// data_item_payload.
  ///
  /// Output only.
  core.String? evaluatedDataItemViewId;

  /// Explanations of predictions.
  ///
  /// Each element of the explanations indicates the explanation for one
  /// explanation Method. The attributions list in the
  /// EvaluatedAnnotationExplanation.explanation object corresponds to the
  /// predictions list. For example, the second element in the attributions list
  /// explains the second element in the predictions list.
  core.List<GoogleCloudAiplatformV1EvaluatedAnnotationExplanation>?
      explanations;

  /// The ground truth Annotations, i.e. the Annotations that exist in the test
  /// data the Model is evaluated on.
  ///
  /// For true positive, there is one and only one ground truth annotation,
  /// which matches the only prediction in predictions. For false positive,
  /// there are zero or more ground truth annotations that are similar to the
  /// only prediction in predictions, but not enough for a match. For false
  /// negative, there is one and only one ground truth annotation, which doesn't
  /// match any predictions created by the model. The schema of the ground truth
  /// is stored in ModelEvaluation.annotation_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? groundTruths;

  /// The model predicted annotations.
  ///
  /// For true positive, there is one and only one prediction, which matches the
  /// only one ground truth annotation in ground_truths. For false positive,
  /// there is one and only one prediction, which doesn't match any ground truth
  /// annotation of the corresponding data_item_view_id. For false negative,
  /// there are zero or more predictions which are similar to the only ground
  /// truth annotation in ground_truths but not enough for a match. The schema
  /// of the prediction is stored in ModelEvaluation.annotation_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  /// Type of the EvaluatedAnnotation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED" : Invalid value.
  /// - "TRUE_POSITIVE" : The EvaluatedAnnotation is a true positive. It has a
  /// prediction created by the Model and a ground truth Annotation which the
  /// prediction matches.
  /// - "FALSE_POSITIVE" : The EvaluatedAnnotation is false positive. It has a
  /// prediction created by the Model which does not match any ground truth
  /// annotation.
  /// - "FALSE_NEGATIVE" : The EvaluatedAnnotation is false negative. It has a
  /// ground truth annotation which is not matched by any of the model created
  /// predictions.
  core.String? type;

  GoogleCloudAiplatformV1EvaluatedAnnotation({
    this.dataItemPayload,
    this.errorAnalysisAnnotations,
    this.evaluatedDataItemViewId,
    this.explanations,
    this.groundTruths,
    this.predictions,
    this.type,
  });

  GoogleCloudAiplatformV1EvaluatedAnnotation.fromJson(core.Map json_)
      : this(
          dataItemPayload: json_['dataItemPayload'],
          errorAnalysisAnnotations:
              (json_['errorAnalysisAnnotations'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ErrorAnalysisAnnotation.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
          evaluatedDataItemViewId:
              json_['evaluatedDataItemViewId'] as core.String?,
          explanations: (json_['explanations'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1EvaluatedAnnotationExplanation
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          groundTruths: json_.containsKey('groundTruths')
              ? json_['groundTruths'] as core.List
              : null,
          predictions: json_.containsKey('predictions')
              ? json_['predictions'] as core.List
              : null,
          type: json_['type'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataItemPayload != null) 'dataItemPayload': dataItemPayload!,
        if (errorAnalysisAnnotations != null)
          'errorAnalysisAnnotations': errorAnalysisAnnotations!,
        if (evaluatedDataItemViewId != null)
          'evaluatedDataItemViewId': evaluatedDataItemViewId!,
        if (explanations != null) 'explanations': explanations!,
        if (groundTruths != null) 'groundTruths': groundTruths!,
        if (predictions != null) 'predictions': predictions!,
        if (type != null) 'type': type!,
      };
}

/// Explanation result of the prediction produced by the Model.
class GoogleCloudAiplatformV1EvaluatedAnnotationExplanation {
  /// Explanation attribution response details.
  GoogleCloudAiplatformV1Explanation? explanation;

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are: *
  /// `image-integrated-gradients` * `image-xrai`
  core.String? explanationType;

  GoogleCloudAiplatformV1EvaluatedAnnotationExplanation({
    this.explanation,
    this.explanationType,
  });

  GoogleCloudAiplatformV1EvaluatedAnnotationExplanation.fromJson(core.Map json_)
      : this(
          explanation: json_.containsKey('explanation')
              ? GoogleCloudAiplatformV1Explanation.fromJson(
                  json_['explanation'] as core.Map<core.String, core.dynamic>)
              : null,
          explanationType: json_['explanationType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanation != null) 'explanation': explanation!,
        if (explanationType != null) 'explanationType': explanationType!,
      };
}

/// The dataset used for evaluation.
class GoogleCloudAiplatformV1EvaluationDataset {
  /// BigQuery source holds the dataset.
  GoogleCloudAiplatformV1BigQuerySource? bigquerySource;

  /// Cloud storage source holds the dataset.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  GoogleCloudAiplatformV1EvaluationDataset({
    this.bigquerySource,
    this.gcsSource,
  });

  GoogleCloudAiplatformV1EvaluationDataset.fromJson(core.Map json_)
      : this(
          bigquerySource: json_.containsKey('bigquerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigquerySource != null) 'bigquerySource': bigquerySource!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
      };
}

/// An edge describing the relationship between an Artifact and an Execution in
/// a lineage graph.
class GoogleCloudAiplatformV1Event {
  /// The relative resource name of the Artifact in the Event.
  ///
  /// Required.
  core.String? artifact;

  /// Time the Event occurred.
  ///
  /// Output only.
  core.String? eventTime;

  /// The relative resource name of the Execution in the Event.
  ///
  /// Output only.
  core.String? execution;

  /// The labels with user-defined metadata to annotate Events.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Event (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  core.Map<core.String, core.String>? labels;

  /// The type of the Event.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified whether input or output of the
  /// Execution.
  /// - "INPUT" : An input of the Execution.
  /// - "OUTPUT" : An output of the Execution.
  core.String? type;

  GoogleCloudAiplatformV1Event({
    this.artifact,
    this.eventTime,
    this.execution,
    this.labels,
    this.type,
  });

  GoogleCloudAiplatformV1Event.fromJson(core.Map json_)
      : this(
          artifact: json_['artifact'] as core.String?,
          eventTime: json_['eventTime'] as core.String?,
          execution: json_['execution'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          type: json_['type'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifact != null) 'artifact': artifact!,
        if (eventTime != null) 'eventTime': eventTime!,
        if (execution != null) 'execution': execution!,
        if (labels != null) 'labels': labels!,
        if (type != null) 'type': type!,
      };
}

/// Input for exact match metric.
class GoogleCloudAiplatformV1ExactMatchInput {
  /// Repeated exact match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ExactMatchInstance>? instances;

  /// Spec for exact match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1ExactMatchSpec? metricSpec;

  GoogleCloudAiplatformV1ExactMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1ExactMatchInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ExactMatchInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1ExactMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for exact match instance.
typedef GoogleCloudAiplatformV1ExactMatchInstance = $Instance00;

/// Exact match metric value for an instance.
class GoogleCloudAiplatformV1ExactMatchMetricValue {
  /// Exact match score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1ExactMatchMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1ExactMatchMetricValue.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for exact match metric.
class GoogleCloudAiplatformV1ExactMatchResults {
  /// Exact match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ExactMatchMetricValue>?
      exactMatchMetricValues;

  GoogleCloudAiplatformV1ExactMatchResults({
    this.exactMatchMetricValues,
  });

  GoogleCloudAiplatformV1ExactMatchResults.fromJson(core.Map json_)
      : this(
          exactMatchMetricValues:
              (json_['exactMatchMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ExactMatchMetricValue.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exactMatchMetricValues != null)
          'exactMatchMetricValues': exactMatchMetricValues!,
      };
}

/// Spec for exact match metric - returns 1 if prediction and reference exactly
/// matches, otherwise 0.
typedef GoogleCloudAiplatformV1ExactMatchSpec = $Empty;

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
class GoogleCloudAiplatformV1Examples {
  /// The Cloud Storage input instances.
  GoogleCloudAiplatformV1ExamplesExampleGcsSource? exampleGcsSource;

  /// The full configuration for the generated index, the semantics are the same
  /// as metadata and should match
  /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? nearestNeighborSearchConfig;

  /// The number of neighbors to return when querying for examples.
  core.int? neighborCount;

  /// Simplified preset configuration, which automatically sets configuration
  /// values based on the desired query speed-precision trade-off and modality.
  GoogleCloudAiplatformV1Presets? presets;

  GoogleCloudAiplatformV1Examples({
    this.exampleGcsSource,
    this.nearestNeighborSearchConfig,
    this.neighborCount,
    this.presets,
  });

  GoogleCloudAiplatformV1Examples.fromJson(core.Map json_)
      : this(
          exampleGcsSource: json_.containsKey('exampleGcsSource')
              ? GoogleCloudAiplatformV1ExamplesExampleGcsSource.fromJson(
                  json_['exampleGcsSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          nearestNeighborSearchConfig: json_['nearestNeighborSearchConfig'],
          neighborCount: json_['neighborCount'] as core.int?,
          presets: json_.containsKey('presets')
              ? GoogleCloudAiplatformV1Presets.fromJson(
                  json_['presets'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exampleGcsSource != null) 'exampleGcsSource': exampleGcsSource!,
        if (nearestNeighborSearchConfig != null)
          'nearestNeighborSearchConfig': nearestNeighborSearchConfig!,
        if (neighborCount != null) 'neighborCount': neighborCount!,
        if (presets != null) 'presets': presets!,
      };
}

/// The Cloud Storage input instances.
class GoogleCloudAiplatformV1ExamplesExampleGcsSource {
  /// The format in which instances are given, if not specified, assume it's
  /// JSONL format.
  ///
  /// Currently only JSONL format is supported.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Format unspecified, used when unset.
  /// - "JSONL" : Examples are stored in JSONL files.
  core.String? dataFormat;

  /// The Cloud Storage location for the input instances.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  GoogleCloudAiplatformV1ExamplesExampleGcsSource({
    this.dataFormat,
    this.gcsSource,
  });

  GoogleCloudAiplatformV1ExamplesExampleGcsSource.fromJson(core.Map json_)
      : this(
          dataFormat: json_['dataFormat'] as core.String?,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataFormat != null) 'dataFormat': dataFormat!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
      };
}

/// Overrides for example-based explanations.
class GoogleCloudAiplatformV1ExamplesOverride {
  /// The number of neighbors to return that have the same crowding tag.
  core.int? crowdingCount;

  /// The format of the data being provided with each call.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Unspecified format. Must not be used.
  /// - "INSTANCES" : Provided data is a set of model inputs.
  /// - "EMBEDDINGS" : Provided data is a set of embeddings.
  core.String? dataFormat;

  /// The number of neighbors to return.
  core.int? neighborCount;

  /// Restrict the resulting nearest neighbors to respect these constraints.
  core.List<GoogleCloudAiplatformV1ExamplesRestrictionsNamespace>? restrictions;

  /// If true, return the embeddings instead of neighbors.
  core.bool? returnEmbeddings;

  GoogleCloudAiplatformV1ExamplesOverride({
    this.crowdingCount,
    this.dataFormat,
    this.neighborCount,
    this.restrictions,
    this.returnEmbeddings,
  });

  GoogleCloudAiplatformV1ExamplesOverride.fromJson(core.Map json_)
      : this(
          crowdingCount: json_['crowdingCount'] as core.int?,
          dataFormat: json_['dataFormat'] as core.String?,
          neighborCount: json_['neighborCount'] as core.int?,
          restrictions: (json_['restrictions'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ExamplesRestrictionsNamespace.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          returnEmbeddings: json_['returnEmbeddings'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (crowdingCount != null) 'crowdingCount': crowdingCount!,
        if (dataFormat != null) 'dataFormat': dataFormat!,
        if (neighborCount != null) 'neighborCount': neighborCount!,
        if (restrictions != null) 'restrictions': restrictions!,
        if (returnEmbeddings != null) 'returnEmbeddings': returnEmbeddings!,
      };
}

/// Restrictions namespace for example-based explanations overrides.
class GoogleCloudAiplatformV1ExamplesRestrictionsNamespace {
  /// The list of allowed tags.
  core.List<core.String>? allow;

  /// The list of deny tags.
  core.List<core.String>? deny;

  /// The namespace name.
  core.String? namespaceName;

  GoogleCloudAiplatformV1ExamplesRestrictionsNamespace({
    this.allow,
    this.deny,
    this.namespaceName,
  });

  GoogleCloudAiplatformV1ExamplesRestrictionsNamespace.fromJson(core.Map json_)
      : this(
          allow: (json_['allow'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          deny: (json_['deny'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          namespaceName: json_['namespaceName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allow != null) 'allow': allow!,
        if (deny != null) 'deny': deny!,
        if (namespaceName != null) 'namespaceName': namespaceName!,
      };
}

/// Code generated by the model that is meant to be executed, and the result
/// returned to the model.
///
/// Generated when using the \[FunctionDeclaration\] tool and
/// \[FunctionCallingConfig\] mode is set to \[Mode.CODE\].
class GoogleCloudAiplatformV1ExecutableCode {
  /// The code to be executed.
  ///
  /// Required.
  core.String? code;

  /// Programming language of the `code`.
  ///
  /// Required.
  /// Possible string values are:
  /// - "LANGUAGE_UNSPECIFIED" : Unspecified language. This value should not be
  /// used.
  /// - "PYTHON" : Python \>= 3.10, with numpy and simpy available.
  core.String? language;

  GoogleCloudAiplatformV1ExecutableCode({
    this.code,
    this.language,
  });

  GoogleCloudAiplatformV1ExecutableCode.fromJson(core.Map json_)
      : this(
          code: json_['code'] as core.String?,
          language: json_['language'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (code != null) 'code': code!,
        if (language != null) 'language': language!,
      };
}

/// Instance of a general execution.
class GoogleCloudAiplatformV1Execution {
  /// Timestamp when this Execution was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Execution
  core.String? description;

  /// User provided display name of the Execution.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Executions.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Execution (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Execution.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Execution.
  ///
  /// Output only.
  core.String? name;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in `schema_title` to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// The state of this Execution.
  ///
  /// This is a property of the Execution, and does not imply or capture any
  /// ongoing process. This property is managed by clients (such as Vertex AI
  /// Pipelines) and the system does not prescribe or check the validity of
  /// state transitions.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified Execution state
  /// - "NEW" : The Execution is new
  /// - "RUNNING" : The Execution is running
  /// - "COMPLETE" : The Execution has finished running
  /// - "FAILED" : The Execution has failed
  /// - "CACHED" : The Execution completed through Cache hit.
  /// - "CANCELLED" : The Execution was cancelled.
  core.String? state;

  /// Timestamp when this Execution was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Execution({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.schemaTitle,
    this.schemaVersion,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Execution.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_['name'] as core.String?,
          schemaTitle: json_['schemaTitle'] as core.String?,
          schemaVersion: json_['schemaVersion'] as core.String?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (schemaTitle != null) 'schemaTitle': schemaTitle!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Request message for PredictionService.Explain.
class GoogleCloudAiplatformV1ExplainRequest {
  /// If specified, this ExplainRequest will be served by the chosen
  /// DeployedModel, overriding Endpoint.traffic_split.
  core.String? deployedModelId;

  /// If specified, overrides the explanation_spec of the DeployedModel.
  ///
  /// Can be used for explaining prediction results with different
  /// configurations, such as: - Explaining top-5 predictions results as opposed
  /// to top-1; - Increasing path count or step count of the attribution methods
  /// to reduce approximate errors; - Using different baselines for explaining
  /// the prediction results.
  GoogleCloudAiplatformV1ExplanationSpecOverride? explanationSpecOverride;

  /// The instances that are the input to the explanation call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the explanation call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  GoogleCloudAiplatformV1ExplainRequest({
    this.deployedModelId,
    this.explanationSpecOverride,
    this.instances,
    this.parameters,
  });

  GoogleCloudAiplatformV1ExplainRequest.fromJson(core.Map json_)
      : this(
          deployedModelId: json_['deployedModelId'] as core.String?,
          explanationSpecOverride: json_.containsKey('explanationSpecOverride')
              ? GoogleCloudAiplatformV1ExplanationSpecOverride.fromJson(
                  json_['explanationSpecOverride']
                      as core.Map<core.String, core.dynamic>)
              : null,
          instances: json_.containsKey('instances')
              ? json_['instances'] as core.List
              : null,
          parameters: json_['parameters'],
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (explanationSpecOverride != null)
          'explanationSpecOverride': explanationSpecOverride!,
        if (instances != null) 'instances': instances!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Response message for PredictionService.Explain.
class GoogleCloudAiplatformV1ExplainResponse {
  /// ID of the Endpoint's DeployedModel that served this explanation.
  core.String? deployedModelId;

  /// The explanations of the Model's PredictResponse.predictions.
  ///
  /// It has the same number of elements as instances to be explained.
  core.List<GoogleCloudAiplatformV1Explanation>? explanations;

  /// The predictions that are the output of the predictions call.
  ///
  /// Same as PredictResponse.predictions.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  GoogleCloudAiplatformV1ExplainResponse({
    this.deployedModelId,
    this.explanations,
    this.predictions,
  });

  GoogleCloudAiplatformV1ExplainResponse.fromJson(core.Map json_)
      : this(
          deployedModelId: json_['deployedModelId'] as core.String?,
          explanations: (json_['explanations'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Explanation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          predictions: json_.containsKey('predictions')
              ? json_['predictions'] as core.List
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (explanations != null) 'explanations': explanations!,
        if (predictions != null) 'predictions': predictions!,
      };
}

/// Explanation of a prediction (provided in PredictResponse.predictions)
/// produced by the Model on a given instance.
class GoogleCloudAiplatformV1Explanation {
  /// Feature attributions grouped by predicted outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item. Attribution.output_index can be used to identify which
  /// output this attribution is explaining. By default, we provide Shapley
  /// values for the predicted class. However, you can configure the explanation
  /// request to generate Shapley values for any other classes too. For example,
  /// if a model predicts a probability of `0.4` for approving a loan
  /// application, the model's decision is to reject the application since
  /// `p(reject) = 0.6 > p(approve) = 0.4`, and the default Shapley values would
  /// be computed for rejection decision and not approval, even though the
  /// latter might be the positive class. If users set
  /// ExplanationParameters.top_k, the attributions are sorted by
  /// instance_output_value in descending order. If
  /// ExplanationParameters.output_indices is specified, the attributions are
  /// stored by Attribution.output_index in the same order as they appear in the
  /// output_indices.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Attribution>? attributions;

  /// List of the nearest neighbors for example-based explanations.
  ///
  /// For models deployed with the examples explanations feature enabled, the
  /// attributions field is empty and instead the neighbors field is populated.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Neighbor>? neighbors;

  GoogleCloudAiplatformV1Explanation({
    this.attributions,
    this.neighbors,
  });

  GoogleCloudAiplatformV1Explanation.fromJson(core.Map json_)
      : this(
          attributions: (json_['attributions'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Attribution.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          neighbors: (json_['neighbors'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Neighbor.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributions != null) 'attributions': attributions!,
        if (neighbors != null) 'neighbors': neighbors!,
      };
}

/// Metadata describing the Model's input and output for explanation.
class GoogleCloudAiplatformV1ExplanationMetadata {
  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of the feature attributions.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML tabular Models always have this field populated by Vertex AI. Note:
  /// The URI given on output may be different, including the URI scheme, than
  /// the one given on input. The output URI will point to a location where the
  /// user only has a read access.
  core.String? featureAttributionsSchemaUri;

  /// Map from feature names to feature input metadata.
  ///
  /// Keys are the name of the features. Values are the specification of the
  /// feature. An empty InputMetadata is valid. It describes a text feature
  /// which has the name specified as the key in ExplanationMetadata.inputs. The
  /// baseline of the empty feature is chosen by Vertex AI. For Vertex
  /// AI-provided Tensorflow images, the key can be any friendly name of the
  /// feature. Once specified, featureAttributions are keyed by this key (if not
  /// grouped with another feature). For custom images, the key must match with
  /// the key in instance.
  ///
  /// Required.
  core.Map<core.String,
      GoogleCloudAiplatformV1ExplanationMetadataInputMetadata>? inputs;

  /// Name of the source to generate embeddings for example based explanations.
  core.String? latentSpaceSource;

  /// Map from output names to output metadata.
  ///
  /// For Vertex AI-provided Tensorflow images, keys can be any user defined
  /// string that consists of any UTF-8 characters. For custom images, keys are
  /// the name of the output field in the prediction to be explained. Currently
  /// only one key is allowed.
  ///
  /// Required.
  core.Map<core.String,
      GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata>? outputs;

  GoogleCloudAiplatformV1ExplanationMetadata({
    this.featureAttributionsSchemaUri,
    this.inputs,
    this.latentSpaceSource,
    this.outputs,
  });

  GoogleCloudAiplatformV1ExplanationMetadata.fromJson(core.Map json_)
      : this(
          featureAttributionsSchemaUri:
              json_['featureAttributionsSchemaUri'] as core.String?,
          inputs:
              (json_['inputs'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          latentSpaceSource: json_['latentSpaceSource'] as core.String?,
          outputs:
              (json_['outputs'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureAttributionsSchemaUri != null)
          'featureAttributionsSchemaUri': featureAttributionsSchemaUri!,
        if (inputs != null) 'inputs': inputs!,
        if (latentSpaceSource != null) 'latentSpaceSource': latentSpaceSource!,
        if (outputs != null) 'outputs': outputs!,
      };
}

/// Metadata of the input of a feature.
///
/// Fields other than InputMetadata.input_baselines are applicable only for
/// Models that are using Vertex AI-provided images for Tensorflow.
class GoogleCloudAiplatformV1ExplanationMetadataInputMetadata {
  /// Specifies the shape of the values of the input if the input is a sparse
  /// representation.
  ///
  /// Refer to Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  core.String? denseShapeTensorName;

  /// A list of baselines for the encoded tensor.
  ///
  /// The shape of each baseline should match the shape of the encoded tensor.
  /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
  /// encoded tensor.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? encodedBaselines;

  /// Encoded tensor is a transformation of the input tensor.
  ///
  /// Must be provided if choosing Integrated Gradients attribution or XRAI
  /// attribution and the input tensor is not differentiable. An encoded tensor
  /// is generated if the input tensor is encoded by a lookup table.
  core.String? encodedTensorName;

  /// Defines how the feature is encoded into the input tensor.
  ///
  /// Defaults to IDENTITY.
  /// Possible string values are:
  /// - "ENCODING_UNSPECIFIED" : Default value. This is the same as IDENTITY.
  /// - "IDENTITY" : The tensor represents one feature.
  /// - "BAG_OF_FEATURES" : The tensor represents a bag of features where each
  /// index maps to a feature. InputMetadata.index_feature_mapping must be
  /// provided for this encoding. For example: ``` input = [27, 6.0, 150]
  /// index_feature_mapping = ["age", "height", "weight"] ```
  /// - "BAG_OF_FEATURES_SPARSE" : The tensor represents a bag of features where
  /// each index maps to a feature. Zero values in the tensor indicates feature
  /// being non-existent. InputMetadata.index_feature_mapping must be provided
  /// for this encoding. For example: ``` input = [2, 0, 5, 0, 1]
  /// index_feature_mapping = ["a", "b", "c", "d", "e"] ```
  /// - "INDICATOR" : The tensor is a list of binaries representing whether a
  /// feature exists or not (1 indicates existence).
  /// InputMetadata.index_feature_mapping must be provided for this encoding.
  /// For example: ``` input = [1, 0, 1, 0, 1] index_feature_mapping = ["a",
  /// "b", "c", "d", "e"] ```
  /// - "COMBINED_EMBEDDING" : The tensor is encoded into a 1-dimensional array
  /// represented by an encoded tensor. InputMetadata.encoded_tensor_name must
  /// be provided for this encoding. For example: ``` input = ["This", "is",
  /// "a", "test", "."] encoded = [0.1, 0.2, 0.3, 0.4, 0.5] ```
  /// - "CONCAT_EMBEDDING" : Select this encoding when the input tensor is
  /// encoded into a 2-dimensional array represented by an encoded tensor.
  /// InputMetadata.encoded_tensor_name must be provided for this encoding. The
  /// first dimension of the encoded tensor's shape is the same as the input
  /// tensor's shape. For example: ``` input = ["This", "is", "a", "test", "."]
  /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5], [0.2, 0.1, 0.4, 0.3, 0.5], [0.5,
  /// 0.1, 0.3, 0.5, 0.4], [0.5, 0.3, 0.1, 0.2, 0.4], [0.4, 0.3, 0.2, 0.5, 0.1]]
  /// ```
  core.String? encoding;

  /// The domain details of the input feature value.
  ///
  /// Like min/max, original mean or standard deviation if normalized.
  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain?
      featureValueDomain;

  /// Name of the group that the input belongs to.
  ///
  /// Features with the same group name will be treated as one feature when
  /// computing attributions. Features grouped together can have different
  /// shapes in value. If provided, there will be one single attribution
  /// generated in Attribution.feature_attributions, keyed by the group name.
  core.String? groupName;

  /// A list of feature names for each index in the input tensor.
  ///
  /// Required when the input InputMetadata.encoding is BAG_OF_FEATURES,
  /// BAG_OF_FEATURES_SPARSE, INDICATOR.
  core.List<core.String>? indexFeatureMapping;

  /// Specifies the index of the values of the input tensor.
  ///
  /// Required when the input tensor is a sparse representation. Refer to
  /// Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  core.String? indicesTensorName;

  /// Baseline inputs for this feature.
  ///
  /// If no baseline is specified, Vertex AI chooses the baseline for this
  /// feature. If multiple baselines are specified, Vertex AI returns the
  /// average attributions across them in Attribution.feature_attributions. For
  /// Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each
  /// baseline must match the shape of the input tensor. If a scalar is
  /// provided, we broadcast to the same shape as the input tensor. For custom
  /// images, the element of the baselines must be in the same format as the
  /// feature's input in the instance\[\]. The schema of any single instance may
  /// be specified via Endpoint's DeployedModels' Model's PredictSchemata's
  /// instance_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? inputBaselines;

  /// Name of the input tensor for this feature.
  ///
  /// Required and is only applicable to Vertex AI-provided images for
  /// Tensorflow.
  core.String? inputTensorName;

  /// Modality of the feature.
  ///
  /// Valid values are: numeric, image. Defaults to numeric.
  core.String? modality;

  /// Visualization configurations for image explanation.
  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization?
      visualization;

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadata({
    this.denseShapeTensorName,
    this.encodedBaselines,
    this.encodedTensorName,
    this.encoding,
    this.featureValueDomain,
    this.groupName,
    this.indexFeatureMapping,
    this.indicesTensorName,
    this.inputBaselines,
    this.inputTensorName,
    this.modality,
    this.visualization,
  });

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.fromJson(
      core.Map json_)
      : this(
          denseShapeTensorName: json_['denseShapeTensorName'] as core.String?,
          encodedBaselines: json_.containsKey('encodedBaselines')
              ? json_['encodedBaselines'] as core.List
              : null,
          encodedTensorName: json_['encodedTensorName'] as core.String?,
          encoding: json_['encoding'] as core.String?,
          featureValueDomain: json_.containsKey('featureValueDomain')
              ? GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain
                  .fromJson(json_['featureValueDomain']
                      as core.Map<core.String, core.dynamic>)
              : null,
          groupName: json_['groupName'] as core.String?,
          indexFeatureMapping: (json_['indexFeatureMapping'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          indicesTensorName: json_['indicesTensorName'] as core.String?,
          inputBaselines: json_.containsKey('inputBaselines')
              ? json_['inputBaselines'] as core.List
              : null,
          inputTensorName: json_['inputTensorName'] as core.String?,
          modality: json_['modality'] as core.String?,
          visualization: json_.containsKey('visualization')
              ? GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization
                  .fromJson(json_['visualization']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (denseShapeTensorName != null)
          'denseShapeTensorName': denseShapeTensorName!,
        if (encodedBaselines != null) 'encodedBaselines': encodedBaselines!,
        if (encodedTensorName != null) 'encodedTensorName': encodedTensorName!,
        if (encoding != null) 'encoding': encoding!,
        if (featureValueDomain != null)
          'featureValueDomain': featureValueDomain!,
        if (groupName != null) 'groupName': groupName!,
        if (indexFeatureMapping != null)
          'indexFeatureMapping': indexFeatureMapping!,
        if (indicesTensorName != null) 'indicesTensorName': indicesTensorName!,
        if (inputBaselines != null) 'inputBaselines': inputBaselines!,
        if (inputTensorName != null) 'inputTensorName': inputTensorName!,
        if (modality != null) 'modality': modality!,
        if (visualization != null) 'visualization': visualization!,
      };
}

/// Domain details of the input feature value.
///
/// Provides numeric information about the feature, such as its range (min,
/// max). If the feature has been pre-processed, for example with z-scoring,
/// then it provides information about how to recover the original feature. For
/// example, if the input feature is an image and it has been pre-processed to
/// obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev
/// refer to the mean and stddev of the original feature (e.g. image tensor)
/// from which input feature (with mean = 0 and stddev = 1) was obtained.
class GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain {
  /// The maximum permissible value for this feature.
  core.double? maxValue;

  /// The minimum permissible value for this feature.
  core.double? minValue;

  /// If this input feature has been normalized to a mean value of 0, the
  /// original_mean specifies the mean value of the domain prior to
  /// normalization.
  core.double? originalMean;

  /// If this input feature has been normalized to a standard deviation of 1.0,
  /// the original_stddev specifies the standard deviation of the domain prior
  /// to normalization.
  core.double? originalStddev;

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain({
    this.maxValue,
    this.minValue,
    this.originalMean,
    this.originalStddev,
  });

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain.fromJson(
      core.Map json_)
      : this(
          maxValue: (json_['maxValue'] as core.num?)?.toDouble(),
          minValue: (json_['minValue'] as core.num?)?.toDouble(),
          originalMean: (json_['originalMean'] as core.num?)?.toDouble(),
          originalStddev: (json_['originalStddev'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxValue != null) 'maxValue': maxValue!,
        if (minValue != null) 'minValue': minValue!,
        if (originalMean != null) 'originalMean': originalMean!,
        if (originalStddev != null) 'originalStddev': originalStddev!,
      };
}

/// Visualization configurations for image explanation.
class GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization {
  /// Excludes attributions below the specified percentile, from the highlighted
  /// areas.
  ///
  /// Defaults to 62.
  core.double? clipPercentLowerbound;

  /// Excludes attributions above the specified percentile from the highlighted
  /// areas.
  ///
  /// Using the clip_percent_upperbound and clip_percent_lowerbound together can
  /// be useful for filtering out noise and making it easier to see areas of
  /// strong attribution. Defaults to 99.9.
  core.double? clipPercentUpperbound;

  /// The color scheme used for the highlighted areas.
  ///
  /// Defaults to PINK_GREEN for Integrated Gradients attribution, which shows
  /// positive attributions in green and negative in pink. Defaults to VIRIDIS
  /// for XRAI attribution, which highlights the most influential regions in
  /// yellow and the least influential in blue.
  /// Possible string values are:
  /// - "COLOR_MAP_UNSPECIFIED" : Should not be used.
  /// - "PINK_GREEN" : Positive: green. Negative: pink.
  /// - "VIRIDIS" : Viridis color map: A perceptually uniform color mapping
  /// which is easier to see by those with colorblindness and progresses from
  /// yellow to green to blue. Positive: yellow. Negative: blue.
  /// - "RED" : Positive: red. Negative: red.
  /// - "GREEN" : Positive: green. Negative: green.
  /// - "RED_GREEN" : Positive: green. Negative: red.
  /// - "PINK_WHITE_GREEN" : PiYG palette.
  core.String? colorMap;

  /// How the original image is displayed in the visualization.
  ///
  /// Adjusting the overlay can help increase visual clarity if the original
  /// image makes it difficult to view the visualization. Defaults to NONE.
  /// Possible string values are:
  /// - "OVERLAY_TYPE_UNSPECIFIED" : Default value. This is the same as NONE.
  /// - "NONE" : No overlay.
  /// - "ORIGINAL" : The attributions are shown on top of the original image.
  /// - "GRAYSCALE" : The attributions are shown on top of grayscaled version of
  /// the original image.
  /// - "MASK_BLACK" : The attributions are used as a mask to reveal predictive
  /// parts of the image and hide the un-predictive parts.
  core.String? overlayType;

  /// Whether to only highlight pixels with positive contributions, negative or
  /// both.
  ///
  /// Defaults to POSITIVE.
  /// Possible string values are:
  /// - "POLARITY_UNSPECIFIED" : Default value. This is the same as POSITIVE.
  /// - "POSITIVE" : Highlights the pixels/outlines that were most influential
  /// to the model's prediction.
  /// - "NEGATIVE" : Setting polarity to negative highlights areas that does not
  /// lead to the models's current prediction.
  /// - "BOTH" : Shows both positive and negative attributions.
  core.String? polarity;

  /// Type of the image visualization.
  ///
  /// Only applicable to Integrated Gradients attribution. OUTLINES shows
  /// regions of attribution, while PIXELS shows per-pixel attribution. Defaults
  /// to OUTLINES.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Should not be used.
  /// - "PIXELS" : Shows which pixel contributed to the image prediction.
  /// - "OUTLINES" : Shows which region contributed to the image prediction by
  /// outlining the region.
  core.String? type;

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization({
    this.clipPercentLowerbound,
    this.clipPercentUpperbound,
    this.colorMap,
    this.overlayType,
    this.polarity,
    this.type,
  });

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization.fromJson(
      core.Map json_)
      : this(
          clipPercentLowerbound:
              (json_['clipPercentLowerbound'] as core.num?)?.toDouble(),
          clipPercentUpperbound:
              (json_['clipPercentUpperbound'] as core.num?)?.toDouble(),
          colorMap: json_['colorMap'] as core.String?,
          overlayType: json_['overlayType'] as core.String?,
          polarity: json_['polarity'] as core.String?,
          type: json_['type'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clipPercentLowerbound != null)
          'clipPercentLowerbound': clipPercentLowerbound!,
        if (clipPercentUpperbound != null)
          'clipPercentUpperbound': clipPercentUpperbound!,
        if (colorMap != null) 'colorMap': colorMap!,
        if (overlayType != null) 'overlayType': overlayType!,
        if (polarity != null) 'polarity': polarity!,
        if (type != null) 'type': type!,
      };
}

/// Metadata of the prediction output to be explained.
class GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata {
  /// Specify a field name in the prediction to look for the display name.
  ///
  /// Use this if the prediction contains the display names for the outputs. The
  /// display names in the prediction must have the same shape of the outputs,
  /// so that it can be located by Attribution.output_index for a specific
  /// output.
  core.String? displayNameMappingKey;

  /// Static mapping between the index and display name.
  ///
  /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
  /// list of scores of all the classes in a pre-defined order for a
  /// multi-classification Model. It's not feasible if the outputs are
  /// non-deterministic, e.g. the Model produces top-k classes or sort the
  /// outputs by their values. The shape of the value must be an n-dimensional
  /// array of strings. The number of dimensions must match that of the outputs
  /// to be explained. The Attribution.output_display_name is populated by
  /// locating in the mapping with Attribution.output_index.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? indexDisplayNameMapping;

  /// Name of the output tensor.
  ///
  /// Required and is only applicable to Vertex AI provided images for
  /// Tensorflow.
  core.String? outputTensorName;

  GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata({
    this.displayNameMappingKey,
    this.indexDisplayNameMapping,
    this.outputTensorName,
  });

  GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata.fromJson(
      core.Map json_)
      : this(
          displayNameMappingKey: json_['displayNameMappingKey'] as core.String?,
          indexDisplayNameMapping: json_['indexDisplayNameMapping'],
          outputTensorName: json_['outputTensorName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayNameMappingKey != null)
          'displayNameMappingKey': displayNameMappingKey!,
        if (indexDisplayNameMapping != null)
          'indexDisplayNameMapping': indexDisplayNameMapping!,
        if (outputTensorName != null) 'outputTensorName': outputTensorName!,
      };
}

/// The ExplanationMetadata entries that can be overridden at online explanation
/// time.
class GoogleCloudAiplatformV1ExplanationMetadataOverride {
  /// Overrides the input metadata of the features.
  ///
  /// The key is the name of the feature to be overridden. The keys specified
  /// here must exist in the input metadata to be overridden. If a feature is
  /// not specified here, the corresponding feature's input metadata is not
  /// overridden.
  ///
  /// Required.
  core.Map<core.String,
          GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride>?
      inputs;

  GoogleCloudAiplatformV1ExplanationMetadataOverride({
    this.inputs,
  });

  GoogleCloudAiplatformV1ExplanationMetadataOverride.fromJson(core.Map json_)
      : this(
          inputs:
              (json_['inputs'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride
                  .fromJson(value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputs != null) 'inputs': inputs!,
      };
}

/// The input metadata entries to be overridden.
class GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride {
  /// Baseline inputs for this feature.
  ///
  /// This overrides the `input_baseline` field of the
  /// ExplanationMetadata.InputMetadata object of the corresponding feature's
  /// input metadata. If it's not specified, the original baselines are not
  /// overridden.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? inputBaselines;

  GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride({
    this.inputBaselines,
  });

  GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride.fromJson(
      core.Map json_)
      : this(
          inputBaselines: json_.containsKey('inputBaselines')
              ? json_['inputBaselines'] as core.List
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputBaselines != null) 'inputBaselines': inputBaselines!,
      };
}

/// Parameters to configure explaining for Model's predictions.
class GoogleCloudAiplatformV1ExplanationParameters {
  /// Example-based explanations that returns the nearest neighbors from the
  /// provided dataset.
  GoogleCloudAiplatformV1Examples? examples;

  /// An attribution method that computes Aumann-Shapley values taking advantage
  /// of the model's fully differentiable structure.
  ///
  /// Refer to this paper for more details: https://arxiv.org/abs/1703.01365
  GoogleCloudAiplatformV1IntegratedGradientsAttribution?
      integratedGradientsAttribution;

  /// If populated, only returns attributions that have output_index contained
  /// in output_indices.
  ///
  /// It must be an ndarray of integers, with the same shape of the output it's
  /// explaining. If not populated, returns attributions for top_k indices of
  /// outputs. If neither top_k nor output_indices is populated, returns the
  /// argmax index of the outputs. Only applicable to Models that predict
  /// multiple outputs (e,g, multi-class Models that predict multiple classes).
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? outputIndices;

  /// An attribution method that approximates Shapley values for features that
  /// contribute to the label being predicted.
  ///
  /// A sampling strategy is used to approximate the value rather than
  /// considering all subsets of features. Refer to this paper for model
  /// details: https://arxiv.org/abs/1306.4265.
  GoogleCloudAiplatformV1SampledShapleyAttribution? sampledShapleyAttribution;

  /// If populated, returns attributions for top K indices of outputs (defaults
  /// to 1).
  ///
  /// Only applies to Models that predicts more than one outputs (e,g,
  /// multi-class Models). When set to -1, returns explanations for all outputs.
  core.int? topK;

  /// An attribution method that redistributes Integrated Gradients attribution
  /// to segmented regions, taking advantage of the model's fully differentiable
  /// structure.
  ///
  /// Refer to this paper for more details: https://arxiv.org/abs/1906.02825
  /// XRAI currently performs better on natural images, like a picture of a
  /// house or an animal. If the images are taken in artificial environments,
  /// like a lab or manufacturing line, or from diagnostic equipment, like
  /// x-rays or quality-control cameras, use Integrated Gradients instead.
  GoogleCloudAiplatformV1XraiAttribution? xraiAttribution;

  GoogleCloudAiplatformV1ExplanationParameters({
    this.examples,
    this.integratedGradientsAttribution,
    this.outputIndices,
    this.sampledShapleyAttribution,
    this.topK,
    this.xraiAttribution,
  });

  GoogleCloudAiplatformV1ExplanationParameters.fromJson(core.Map json_)
      : this(
          examples: json_.containsKey('examples')
              ? GoogleCloudAiplatformV1Examples.fromJson(
                  json_['examples'] as core.Map<core.String, core.dynamic>)
              : null,
          integratedGradientsAttribution: json_
                  .containsKey('integratedGradientsAttribution')
              ? GoogleCloudAiplatformV1IntegratedGradientsAttribution.fromJson(
                  json_['integratedGradientsAttribution']
                      as core.Map<core.String, core.dynamic>)
              : null,
          outputIndices: json_.containsKey('outputIndices')
              ? json_['outputIndices'] as core.List
              : null,
          sampledShapleyAttribution:
              json_.containsKey('sampledShapleyAttribution')
                  ? GoogleCloudAiplatformV1SampledShapleyAttribution.fromJson(
                      json_['sampledShapleyAttribution']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          topK: json_['topK'] as core.int?,
          xraiAttribution: json_.containsKey('xraiAttribution')
              ? GoogleCloudAiplatformV1XraiAttribution.fromJson(
                  json_['xraiAttribution']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (examples != null) 'examples': examples!,
        if (integratedGradientsAttribution != null)
          'integratedGradientsAttribution': integratedGradientsAttribution!,
        if (outputIndices != null) 'outputIndices': outputIndices!,
        if (sampledShapleyAttribution != null)
          'sampledShapleyAttribution': sampledShapleyAttribution!,
        if (topK != null) 'topK': topK!,
        if (xraiAttribution != null) 'xraiAttribution': xraiAttribution!,
      };
}

/// Specification of Model explanation.
class GoogleCloudAiplatformV1ExplanationSpec {
  /// Metadata describing the Model's input and output for explanation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ExplanationMetadata? metadata;

  /// Parameters that configure explaining of the Model's predictions.
  ///
  /// Required.
  GoogleCloudAiplatformV1ExplanationParameters? parameters;

  GoogleCloudAiplatformV1ExplanationSpec({
    this.metadata,
    this.parameters,
  });

  GoogleCloudAiplatformV1ExplanationSpec.fromJson(core.Map json_)
      : this(
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1ExplanationMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1ExplanationParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metadata != null) 'metadata': metadata!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// The ExplanationSpec entries that can be overridden at online explanation
/// time.
class GoogleCloudAiplatformV1ExplanationSpecOverride {
  /// The example-based explanations parameter overrides.
  GoogleCloudAiplatformV1ExamplesOverride? examplesOverride;

  /// The metadata to be overridden.
  ///
  /// If not specified, no metadata is overridden.
  GoogleCloudAiplatformV1ExplanationMetadataOverride? metadata;

  /// The parameters to be overridden.
  ///
  /// Note that the attribution method cannot be changed. If not specified, no
  /// parameter is overridden.
  GoogleCloudAiplatformV1ExplanationParameters? parameters;

  GoogleCloudAiplatformV1ExplanationSpecOverride({
    this.examplesOverride,
    this.metadata,
    this.parameters,
  });

  GoogleCloudAiplatformV1ExplanationSpecOverride.fromJson(core.Map json_)
      : this(
          examplesOverride: json_.containsKey('examplesOverride')
              ? GoogleCloudAiplatformV1ExamplesOverride.fromJson(
                  json_['examplesOverride']
                      as core.Map<core.String, core.dynamic>)
              : null,
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1ExplanationMetadataOverride.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1ExplanationParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (examplesOverride != null) 'examplesOverride': examplesOverride!,
        if (metadata != null) 'metadata': metadata!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Describes what part of the Dataset is to be exported, the destination of the
/// export and how to export.
class GoogleCloudAiplatformV1ExportDataConfig {
  /// The Cloud Storage URI that points to a YAML file describing the annotation
  /// schema.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
  /// chosen schema must be consistent with metadata of the Dataset specified by
  /// ExportDataRequest.name. Only used for custom training data export use
  /// cases. Only applicable to Datasets that have DataItems and Annotations.
  /// Only Annotations that both match this schema and belong to DataItems not
  /// ignored by the split method are used in respectively training, validation
  /// or test role, depending on the role of the DataItem they are on. When used
  /// in conjunction with annotations_filter, the Annotations used for training
  /// are filtered by both annotations_filter and annotation_schema_uri.
  core.String? annotationSchemaUri;

  /// An expression for filtering what part of the Dataset is to be exported.
  ///
  /// Only Annotations that match this filter will be exported. The filter
  /// syntax is the same as in ListAnnotations.
  core.String? annotationsFilter;

  /// Indicates the usage of the exported files.
  /// Possible string values are:
  /// - "EXPORT_USE_UNSPECIFIED" : Regular user export.
  /// - "CUSTOM_CODE_TRAINING" : Export for custom code training.
  core.String? exportUse;

  /// Split based on the provided filters for each set.
  GoogleCloudAiplatformV1ExportFilterSplit? filterSplit;

  /// Split based on fractions defining the size of each set.
  GoogleCloudAiplatformV1ExportFractionSplit? fractionSplit;

  /// The Google Cloud Storage location where the output is to be written to.
  ///
  /// In the given directory a new directory will be created with name:
  /// `export-data--` where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601
  /// format. All export output will be written into that directory. Inside that
  /// directory, annotations with the same schema will be grouped into sub
  /// directories which are named with the corresponding annotations' schema
  /// title. Inside these sub directories, a schema.yaml will be created to
  /// describe the output format.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  /// The ID of a SavedQuery (annotation set) under the Dataset specified by
  /// ExportDataRequest.name used for filtering Annotations for training.
  ///
  /// Only used for custom training data export use cases. Only applicable to
  /// Datasets that have SavedQueries. Only Annotations that are associated with
  /// this SavedQuery are used in respectively training. When used in
  /// conjunction with annotations_filter, the Annotations used for training are
  /// filtered by both saved_query_id and annotations_filter. Only one of
  /// saved_query_id and annotation_schema_uri should be specified as both of
  /// them represent the same thing: problem type.
  core.String? savedQueryId;

  GoogleCloudAiplatformV1ExportDataConfig({
    this.annotationSchemaUri,
    this.annotationsFilter,
    this.exportUse,
    this.filterSplit,
    this.fractionSplit,
    this.gcsDestination,
    this.savedQueryId,
  });

  GoogleCloudAiplatformV1ExportDataConfig.fromJson(core.Map json_)
      : this(
          annotationSchemaUri: json_['annotationSchemaUri'] as core.String?,
          annotationsFilter: json_['annotationsFilter'] as core.String?,
          exportUse: json_['exportUse'] as core.String?,
          filterSplit: json_.containsKey('filterSplit')
              ? GoogleCloudAiplatformV1ExportFilterSplit.fromJson(
                  json_['filterSplit'] as core.Map<core.String, core.dynamic>)
              : null,
          fractionSplit: json_.containsKey('fractionSplit')
              ? GoogleCloudAiplatformV1ExportFractionSplit.fromJson(
                  json_['fractionSplit'] as core.Map<core.String, core.dynamic>)
              : null,
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          savedQueryId: json_['savedQueryId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationSchemaUri != null)
          'annotationSchemaUri': annotationSchemaUri!,
        if (annotationsFilter != null) 'annotationsFilter': annotationsFilter!,
        if (exportUse != null) 'exportUse': exportUse!,
        if (filterSplit != null) 'filterSplit': filterSplit!,
        if (fractionSplit != null) 'fractionSplit': fractionSplit!,
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
        if (savedQueryId != null) 'savedQueryId': savedQueryId!,
      };
}

/// Request message for DatasetService.ExportData.
class GoogleCloudAiplatformV1ExportDataRequest {
  /// The desired output location.
  ///
  /// Required.
  GoogleCloudAiplatformV1ExportDataConfig? exportConfig;

  GoogleCloudAiplatformV1ExportDataRequest({
    this.exportConfig,
  });

  GoogleCloudAiplatformV1ExportDataRequest.fromJson(core.Map json_)
      : this(
          exportConfig: json_.containsKey('exportConfig')
              ? GoogleCloudAiplatformV1ExportDataConfig.fromJson(
                  json_['exportConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exportConfig != null) 'exportConfig': exportConfig!,
      };
}

/// Request message for FeaturestoreService.ExportFeatureValues.
class GoogleCloudAiplatformV1ExportFeatureValuesRequest {
  /// Specifies destination location and format.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureValueDestination? destination;

  /// Selects Features to export values of.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  /// Exports all historical values of all entities of the EntityType within a
  /// time range
  GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport? fullExport;

  /// Per-Feature export settings.
  core.List<GoogleCloudAiplatformV1DestinationFeatureSetting>? settings;

  /// Exports the latest Feature values of all entities of the EntityType within
  /// a time range.
  GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport?
      snapshotExport;

  GoogleCloudAiplatformV1ExportFeatureValuesRequest({
    this.destination,
    this.featureSelector,
    this.fullExport,
    this.settings,
    this.snapshotExport,
  });

  GoogleCloudAiplatformV1ExportFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          destination: json_.containsKey('destination')
              ? GoogleCloudAiplatformV1FeatureValueDestination.fromJson(
                  json_['destination'] as core.Map<core.String, core.dynamic>)
              : null,
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
          fullExport: json_.containsKey('fullExport')
              ? GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport
                  .fromJson(json_['fullExport']
                      as core.Map<core.String, core.dynamic>)
              : null,
          settings: (json_['settings'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1DestinationFeatureSetting.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          snapshotExport: json_.containsKey('snapshotExport')
              ? GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport
                  .fromJson(json_['snapshotExport']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destination != null) 'destination': destination!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
        if (fullExport != null) 'fullExport': fullExport!,
        if (settings != null) 'settings': settings!,
        if (snapshotExport != null) 'snapshotExport': snapshotExport!,
      };
}

/// Describes exporting all historical Feature values of all entities of the
/// EntityType between \[start_time, end_time\].
class GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport {
  /// Exports Feature values as of this timestamp.
  ///
  /// If not set, retrieve values as of now. Timestamp, if present, must not
  /// have higher than millisecond precision.
  core.String? endTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  core.String? startTime;

  GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport({
    this.endTime,
    this.startTime,
  });

  GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport.fromJson(
      core.Map json_)
      : this(
          endTime: json_['endTime'] as core.String?,
          startTime: json_['startTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endTime != null) 'endTime': endTime!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Describes exporting the latest Feature values of all entities of the
/// EntityType between \[start_time, snapshot_time\].
class GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport {
  /// Exports Feature values as of this timestamp.
  ///
  /// If not set, retrieve values as of now. Timestamp, if present, must not
  /// have higher than millisecond precision.
  core.String? snapshotTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  core.String? startTime;

  GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport({
    this.snapshotTime,
    this.startTime,
  });

  GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport.fromJson(
      core.Map json_)
      : this(
          snapshotTime: json_['snapshotTime'] as core.String?,
          startTime: json_['startTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (snapshotTime != null) 'snapshotTime': snapshotTime!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored.
///
/// Currently only supported for Datasets containing DataItems. If any of the
/// filters in this message are to match nothing, then they can be set as '-'
/// (the minus sign). Supported only for unstructured Datasets.
typedef GoogleCloudAiplatformV1ExportFilterSplit = $FilterSplit;

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions.
///
/// Any of `training_fraction`, `validation_fraction` and `test_fraction` may
/// optionally be provided, they must sum to up to 1. If the provided ones sum
/// to less than 1, the remainder is assigned to sets as decided by Vertex AI.
/// If none of the fractions are set, by default roughly 80% of data is used for
/// training, 10% for validation, and 10% for test.
typedef GoogleCloudAiplatformV1ExportFractionSplit = $FractionSplit;

/// Request message for ModelService.ExportModel.
class GoogleCloudAiplatformV1ExportModelRequest {
  /// The desired output location and configuration.
  ///
  /// Required.
  GoogleCloudAiplatformV1ExportModelRequestOutputConfig? outputConfig;

  GoogleCloudAiplatformV1ExportModelRequest({
    this.outputConfig,
  });

  GoogleCloudAiplatformV1ExportModelRequest.fromJson(core.Map json_)
      : this(
          outputConfig: json_.containsKey('outputConfig')
              ? GoogleCloudAiplatformV1ExportModelRequestOutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputConfig != null) 'outputConfig': outputConfig!,
      };
}

/// Output configuration for the Model export.
class GoogleCloudAiplatformV1ExportModelRequestOutputConfig {
  /// The Cloud Storage location where the Model artifact is to be written to.
  ///
  /// Under the directory given as the destination a new one with name
  /// "`model-export--`", where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ
  /// ISO-8601 format, will be created. Inside, the Model and any of its
  /// supporting files will be written. This field should only be set when the
  /// `exportableContent` field of the \[Model.supported_export_formats\] object
  /// contains `ARTIFACT`.
  GoogleCloudAiplatformV1GcsDestination? artifactDestination;

  /// The ID of the format in which the Model must be exported.
  ///
  /// Each Model lists the export formats it supports. If no value is provided
  /// here, then the first from the list of the Model's supported formats is
  /// used by default.
  core.String? exportFormatId;

  /// The Google Container Registry or Artifact Registry uri where the Model
  /// container image will be copied to.
  ///
  /// This field should only be set when the `exportableContent` field of the
  /// \[Model.supported_export_formats\] object contains `IMAGE`.
  GoogleCloudAiplatformV1ContainerRegistryDestination? imageDestination;

  GoogleCloudAiplatformV1ExportModelRequestOutputConfig({
    this.artifactDestination,
    this.exportFormatId,
    this.imageDestination,
  });

  GoogleCloudAiplatformV1ExportModelRequestOutputConfig.fromJson(core.Map json_)
      : this(
          artifactDestination: json_.containsKey('artifactDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['artifactDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          exportFormatId: json_['exportFormatId'] as core.String?,
          imageDestination: json_.containsKey('imageDestination')
              ? GoogleCloudAiplatformV1ContainerRegistryDestination.fromJson(
                  json_['imageDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactDestination != null)
          'artifactDestination': artifactDestination!,
        if (exportFormatId != null) 'exportFormatId': exportFormatId!,
        if (imageDestination != null) 'imageDestination': imageDestination!,
      };
}

/// Request message for TensorboardService.ExportTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest {
  /// Exports the TensorboardTimeSeries' data that match the filter expression.
  core.String? filter;

  /// Field to use to sort the TensorboardTimeSeries' data.
  ///
  /// By default, TensorboardTimeSeries' data is returned in a pseudo random
  /// order.
  core.String? orderBy;

  /// The maximum number of data points to return per page.
  ///
  /// The default page_size is 1000. Values must be between 1 and 10000. Values
  /// above 10000 are coerced to 10000.
  core.int? pageSize;

  /// A page token, received from a previous ExportTensorboardTimeSeriesData
  /// call.
  ///
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to ExportTensorboardTimeSeriesData must match the call
  /// that provided the page token.
  core.String? pageToken;

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest({
    this.filter,
    this.orderBy,
    this.pageSize,
    this.pageToken,
  });

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest.fromJson(
      core.Map json_)
      : this(
          filter: json_['filter'] as core.String?,
          orderBy: json_['orderBy'] as core.String?,
          pageSize: json_['pageSize'] as core.int?,
          pageToken: json_['pageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (orderBy != null) 'orderBy': orderBy!,
        if (pageSize != null) 'pageSize': pageSize!,
        if (pageToken != null) 'pageToken': pageToken!,
      };
}

/// Response message for TensorboardService.ExportTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse {
  /// A token, which can be sent as page_token to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The returned time series data points.
  core.List<GoogleCloudAiplatformV1TimeSeriesDataPoint>? timeSeriesDataPoints;

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse({
    this.nextPageToken,
    this.timeSeriesDataPoints,
  });

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          timeSeriesDataPoints: (json_['timeSeriesDataPoints'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TimeSeriesDataPoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (timeSeriesDataPoints != null)
          'timeSeriesDataPoints': timeSeriesDataPoints!,
      };
}

/// The fact used in grounding.
class GoogleCloudAiplatformV1Fact {
  /// Query that is used to retrieve this fact.
  core.String? query;

  /// If present, according to the underlying Vector DB and the selected metric
  /// type, the score can be either the distance or the similarity between the
  /// query and the fact and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the fact. The larger the distance, the less
  /// relevant the fact is to the query. The range is \[0, 2\], while 0 means
  /// the most relevant and 2 means the least relevant.
  core.double? score;

  /// If present, the summary/snippet of the fact.
  core.String? summary;

  /// If present, it refers to the title of this fact.
  core.String? title;

  /// If present, this uri links to the source of the fact.
  core.String? uri;

  /// If present, the distance between the query vector and this fact vector.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? vectorDistance;

  GoogleCloudAiplatformV1Fact({
    this.query,
    this.score,
    this.summary,
    this.title,
    this.uri,
    this.vectorDistance,
  });

  GoogleCloudAiplatformV1Fact.fromJson(core.Map json_)
      : this(
          query: json_['query'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
          summary: json_['summary'] as core.String?,
          title: json_['title'] as core.String?,
          uri: json_['uri'] as core.String?,
          vectorDistance: (json_['vectorDistance'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (query != null) 'query': query!,
        if (score != null) 'score': score!,
        if (summary != null) 'summary': summary!,
        if (title != null) 'title': title!,
        if (uri != null) 'uri': uri!,
        if (vectorDistance != null) 'vectorDistance': vectorDistance!,
      };
}

/// Configuration for faster model deployment.
class GoogleCloudAiplatformV1FasterDeploymentConfig {
  /// If true, enable fast tryout feature for this deployed model.
  core.bool? fastTryoutEnabled;

  GoogleCloudAiplatformV1FasterDeploymentConfig({
    this.fastTryoutEnabled,
  });

  GoogleCloudAiplatformV1FasterDeploymentConfig.fromJson(core.Map json_)
      : this(
          fastTryoutEnabled: json_['fastTryoutEnabled'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fastTryoutEnabled != null) 'fastTryoutEnabled': fastTryoutEnabled!,
      };
}

/// Feature Metadata information.
///
/// For example, color is a feature that describes an apple.
class GoogleCloudAiplatformV1Feature {
  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Timestamp when this EntityType was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Feature.
  core.String? description;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// If not set, use the monitoring_config defined for the EntityType this
  /// Feature belongs to. Only Features with type (Feature.ValueType) BOOL,
  /// STRING, DOUBLE or INT64 can enable monitoring. If set to true, all types
  /// of data monitoring are disabled despite the config on EntityType.
  ///
  /// Optional.
  core.bool? disableMonitoring;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Features.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one Feature (System labels
  /// are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// The list of historical stats and anomalies with specified objectives.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly>?
      monitoringStatsAnomalies;

  /// Name of the Feature.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  ///
  /// Immutable.
  core.String? name;

  /// Entity responsible for maintaining this feature.
  ///
  /// Can be comma separated list of email addresses or URIs.
  core.String? pointOfContact;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Timestamp when this EntityType was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Type of Feature value.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "BOOL" : Used for Feature that is a boolean.
  /// - "BOOL_ARRAY" : Used for Feature that is a list of boolean.
  /// - "DOUBLE" : Used for Feature that is double.
  /// - "DOUBLE_ARRAY" : Used for Feature that is a list of double.
  /// - "INT64" : Used for Feature that is INT64.
  /// - "INT64_ARRAY" : Used for Feature that is a list of INT64.
  /// - "STRING" : Used for Feature that is string.
  /// - "STRING_ARRAY" : Used for Feature that is a list of String.
  /// - "BYTES" : Used for Feature that is bytes.
  /// - "STRUCT" : Used for Feature that is struct.
  core.String? valueType;

  /// Only applicable for Vertex AI Feature Store.
  ///
  /// The name of the BigQuery Table/View column hosting data for this version.
  /// If no value is provided, will use feature_id.
  core.String? versionColumnName;

  GoogleCloudAiplatformV1Feature({
    this.createTime,
    this.description,
    this.disableMonitoring,
    this.etag,
    this.labels,
    this.monitoringStatsAnomalies,
    this.name,
    this.pointOfContact,
    this.updateTime,
    this.valueType,
    this.versionColumnName,
  });

  GoogleCloudAiplatformV1Feature.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          disableMonitoring: json_['disableMonitoring'] as core.bool?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          monitoringStatsAnomalies: (json_['monitoringStatsAnomalies']
                  as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          name: json_['name'] as core.String?,
          pointOfContact: json_['pointOfContact'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
          valueType: json_['valueType'] as core.String?,
          versionColumnName: json_['versionColumnName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (disableMonitoring != null) 'disableMonitoring': disableMonitoring!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (monitoringStatsAnomalies != null)
          'monitoringStatsAnomalies': monitoringStatsAnomalies!,
        if (name != null) 'name': name!,
        if (pointOfContact != null) 'pointOfContact': pointOfContact!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (valueType != null) 'valueType': valueType!,
        if (versionColumnName != null) 'versionColumnName': versionColumnName!,
      };
}

/// Vertex AI Feature Group.
class GoogleCloudAiplatformV1FeatureGroup {
  /// Indicates that features for this group come from BigQuery Table/View.
  ///
  /// By default treats the source as a sparse time series source. The BigQuery
  /// source table or view must have at least one entity ID column and a column
  /// named `feature_timestamp`.
  GoogleCloudAiplatformV1FeatureGroupBigQuery? bigQuery;

  /// Timestamp when this FeatureGroup was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the FeatureGroup.
  ///
  /// Optional.
  core.String? description;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your FeatureGroup.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one FeatureGroup(System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureGroup. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  core.String? name;

  /// Timestamp when this FeatureGroup was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1FeatureGroup({
    this.bigQuery,
    this.createTime,
    this.description,
    this.etag,
    this.labels,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1FeatureGroup.fromJson(core.Map json_)
      : this(
          bigQuery: json_.containsKey('bigQuery')
              ? GoogleCloudAiplatformV1FeatureGroupBigQuery.fromJson(
                  json_['bigQuery'] as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigQuery != null) 'bigQuery': bigQuery!,
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Input source type for BigQuery Tables and Views.
class GoogleCloudAiplatformV1FeatureGroupBigQuery {
  /// The BigQuery source URI that points to either a BigQuery Table or View.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1BigQuerySource? bigQuerySource;

  /// If set, all feature values will be fetched from a single row per unique
  /// entityId including nulls.
  ///
  /// If not set, will collapse all rows for each unique entityId into a singe
  /// row with any non-null values if present, if no non-null values are present
  /// will sync null. ex: If source has schema `(entity_id, feature_timestamp,
  /// f0, f1)` and the following rows: `(e1, 2020-01-01T10:00:00.123Z, 10, 15)`
  /// `(e1, 2020-02-01T10:00:00.123Z, 20, null)` If dense is set, `(e1, 20,
  /// null)` is synced to online stores. If dense is not set, `(e1, 20, 15)` is
  /// synced to online stores.
  ///
  /// Optional.
  core.bool? dense;

  /// Columns to construct entity_id / row keys.
  ///
  /// If not provided defaults to `entity_id`.
  ///
  /// Optional.
  core.List<core.String>? entityIdColumns;

  /// Set if the data source is not a time-series.
  ///
  /// Optional.
  core.bool? staticDataSource;

  /// If the source is a time-series source, this can be set to control how
  /// downstream sources (ex: FeatureView ) will treat time-series sources.
  ///
  /// If not set, will treat the source as a time-series source with
  /// `feature_timestamp` as timestamp column and no scan boundary.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureGroupBigQueryTimeSeries? timeSeries;

  GoogleCloudAiplatformV1FeatureGroupBigQuery({
    this.bigQuerySource,
    this.dense,
    this.entityIdColumns,
    this.staticDataSource,
    this.timeSeries,
  });

  GoogleCloudAiplatformV1FeatureGroupBigQuery.fromJson(core.Map json_)
      : this(
          bigQuerySource: json_.containsKey('bigQuerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigQuerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          dense: json_['dense'] as core.bool?,
          entityIdColumns: (json_['entityIdColumns'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          staticDataSource: json_['staticDataSource'] as core.bool?,
          timeSeries: json_.containsKey('timeSeries')
              ? GoogleCloudAiplatformV1FeatureGroupBigQueryTimeSeries.fromJson(
                  json_['timeSeries'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!,
        if (dense != null) 'dense': dense!,
        if (entityIdColumns != null) 'entityIdColumns': entityIdColumns!,
        if (staticDataSource != null) 'staticDataSource': staticDataSource!,
        if (timeSeries != null) 'timeSeries': timeSeries!,
      };
}

class GoogleCloudAiplatformV1FeatureGroupBigQueryTimeSeries {
  /// Column hosting timestamp values for a time-series source.
  ///
  /// Will be used to determine the latest `feature_values` for each entity.
  /// Optional. If not provided, column named `feature_timestamp` of type
  /// `TIMESTAMP` will be used.
  ///
  /// Optional.
  core.String? timestampColumn;

  GoogleCloudAiplatformV1FeatureGroupBigQueryTimeSeries({
    this.timestampColumn,
  });

  GoogleCloudAiplatformV1FeatureGroupBigQueryTimeSeries.fromJson(core.Map json_)
      : this(
          timestampColumn: json_['timestampColumn'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (timestampColumn != null) 'timestampColumn': timestampColumn!,
      };
}

/// A list of historical SnapshotAnalysis or ImportFeaturesAnalysis stats
/// requested by user, sorted by FeatureStatsAnomaly.start_time descending.
class GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly {
  /// The stats and anomalies generated at specific timestamp.
  ///
  /// Output only.
  GoogleCloudAiplatformV1FeatureStatsAnomaly? featureStatsAnomaly;

  /// The objective for each stats.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OBJECTIVE_UNSPECIFIED" : If it's OBJECTIVE_UNSPECIFIED,
  /// monitoring_stats will be empty.
  /// - "IMPORT_FEATURE_ANALYSIS" : Stats are generated by Import Feature
  /// Analysis.
  /// - "SNAPSHOT_ANALYSIS" : Stats are generated by Snapshot Analysis.
  core.String? objective;

  GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly({
    this.featureStatsAnomaly,
    this.objective,
  });

  GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly.fromJson(core.Map json_)
      : this(
          featureStatsAnomaly: json_.containsKey('featureStatsAnomaly')
              ? GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(
                  json_['featureStatsAnomaly']
                      as core.Map<core.String, core.dynamic>)
              : null,
          objective: json_['objective'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureStatsAnomaly != null)
          'featureStatsAnomaly': featureStatsAnomaly!,
        if (objective != null) 'objective': objective!,
      };
}

/// Noise sigma by features.
///
/// Noise sigma represents the standard deviation of the gaussian kernel that
/// will be used to add noise to interpolated inputs prior to computing
/// gradients.
class GoogleCloudAiplatformV1FeatureNoiseSigma {
  /// Noise sigma per feature.
  ///
  /// No noise is added to features that are not set.
  core.List<GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature>?
      noiseSigma;

  GoogleCloudAiplatformV1FeatureNoiseSigma({
    this.noiseSigma,
  });

  GoogleCloudAiplatformV1FeatureNoiseSigma.fromJson(core.Map json_)
      : this(
          noiseSigma: (json_['noiseSigma'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (noiseSigma != null) 'noiseSigma': noiseSigma!,
      };
}

/// Noise sigma for a single feature.
class GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature {
  /// The name of the input feature for which noise sigma is provided.
  ///
  /// The features are defined in explanation metadata inputs.
  core.String? name;

  /// This represents the standard deviation of the Gaussian kernel that will be
  /// used to add noise to the feature prior to computing gradients.
  ///
  /// Similar to noise_sigma but represents the noise added to the current
  /// feature. Defaults to 0.1.
  core.double? sigma;

  GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature({
    this.name,
    this.sigma,
  });

  GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature.fromJson(
      core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          sigma: (json_['sigma'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (sigma != null) 'sigma': sigma!,
      };
}

/// Vertex AI Feature Online Store provides a centralized repository for serving
/// ML features and embedding indexes at low latency.
///
/// The Feature Online Store is a top-level container.
class GoogleCloudAiplatformV1FeatureOnlineStore {
  /// Contains settings for the Cloud Bigtable instance that will be created to
  /// serve featureValues for all FeatureViews under this FeatureOnlineStore.
  GoogleCloudAiplatformV1FeatureOnlineStoreBigtable? bigtable;

  /// Timestamp when this FeatureOnlineStore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The dedicated serving endpoint for this FeatureOnlineStore, which is
  /// different from common Vertex service endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureOnlineStoreDedicatedServingEndpoint?
      dedicatedServingEndpoint;

  /// Customer-managed encryption key spec for data storage.
  ///
  /// If set, online store will be secured by this key.
  ///
  /// Optional.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your FeatureOnlineStore.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label
  /// keys are prefixed with "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureOnlineStore. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
  core.String? name;

  /// Contains settings for the Optimized store that will be created to serve
  /// featureValues for all FeatureViews under this FeatureOnlineStore.
  ///
  /// When choose Optimized storage type, need to set
  /// PrivateServiceConnectConfig.enable_private_service_connect to use private
  /// endpoint. Otherwise will use public endpoint by default.
  GoogleCloudAiplatformV1FeatureOnlineStoreOptimized? optimized;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// State of the featureOnlineStore.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value. This value is unused.
  /// - "STABLE" : State when the featureOnlineStore configuration is not being
  /// updated and the fields reflect the current configuration of the
  /// featureOnlineStore. The featureOnlineStore is usable in this state.
  /// - "UPDATING" : The state of the featureOnlineStore configuration when it
  /// is being updated. During an update, the fields reflect either the original
  /// configuration or the updated configuration of the featureOnlineStore. The
  /// featureOnlineStore is still usable in this state.
  core.String? state;

  /// Timestamp when this FeatureOnlineStore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1FeatureOnlineStore({
    this.bigtable,
    this.createTime,
    this.dedicatedServingEndpoint,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.optimized,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1FeatureOnlineStore.fromJson(core.Map json_)
      : this(
          bigtable: json_.containsKey('bigtable')
              ? GoogleCloudAiplatformV1FeatureOnlineStoreBigtable.fromJson(
                  json_['bigtable'] as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          dedicatedServingEndpoint: json_
                  .containsKey('dedicatedServingEndpoint')
              ? GoogleCloudAiplatformV1FeatureOnlineStoreDedicatedServingEndpoint
                  .fromJson(json_['dedicatedServingEndpoint']
                      as core.Map<core.String, core.dynamic>)
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          optimized: json_.containsKey('optimized')
              ? GoogleCloudAiplatformV1FeatureOnlineStoreOptimized.fromJson(
                  json_['optimized'] as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigtable != null) 'bigtable': bigtable!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedServingEndpoint != null)
          'dedicatedServingEndpoint': dedicatedServingEndpoint!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (optimized != null) 'optimized': optimized!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

class GoogleCloudAiplatformV1FeatureOnlineStoreBigtable {
  /// Autoscaling config applied to Bigtable Instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling? autoScaling;

  GoogleCloudAiplatformV1FeatureOnlineStoreBigtable({
    this.autoScaling,
  });

  GoogleCloudAiplatformV1FeatureOnlineStoreBigtable.fromJson(core.Map json_)
      : this(
          autoScaling: json_.containsKey('autoScaling')
              ? GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling
                  .fromJson(json_['autoScaling']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoScaling != null) 'autoScaling': autoScaling!,
      };
}

class GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling {
  /// A percentage of the cluster's CPU capacity.
  ///
  /// Can be from 10% to 80%. When a cluster's CPU utilization exceeds the
  /// target that you have set, Bigtable immediately adds nodes to the cluster.
  /// When CPU utilization is substantially lower than the target, Bigtable
  /// removes nodes. If not set will default to 50%.
  ///
  /// Optional.
  core.int? cpuUtilizationTarget;

  /// The maximum number of nodes to scale up to.
  ///
  /// Must be greater than or equal to min_node_count, and less than or equal to
  /// 10 times of 'min_node_count'.
  ///
  /// Required.
  core.int? maxNodeCount;

  /// The minimum number of nodes to scale down to.
  ///
  /// Must be greater than or equal to 1.
  ///
  /// Required.
  core.int? minNodeCount;

  GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling({
    this.cpuUtilizationTarget,
    this.maxNodeCount,
    this.minNodeCount,
  });

  GoogleCloudAiplatformV1FeatureOnlineStoreBigtableAutoScaling.fromJson(
      core.Map json_)
      : this(
          cpuUtilizationTarget: json_['cpuUtilizationTarget'] as core.int?,
          maxNodeCount: json_['maxNodeCount'] as core.int?,
          minNodeCount: json_['minNodeCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cpuUtilizationTarget != null)
          'cpuUtilizationTarget': cpuUtilizationTarget!,
        if (maxNodeCount != null) 'maxNodeCount': maxNodeCount!,
        if (minNodeCount != null) 'minNodeCount': minNodeCount!,
      };
}

/// The dedicated serving endpoint for this FeatureOnlineStore.
///
/// Only need to set when you choose Optimized storage type. Public endpoint is
/// provisioned by default.
class GoogleCloudAiplatformV1FeatureOnlineStoreDedicatedServingEndpoint {
  /// Private service connect config.
  ///
  /// The private service connection is available only for Optimized storage
  /// type, not for embedding management now. If
  /// PrivateServiceConnectConfig.enable_private_service_connect set to true,
  /// customers will use private service connection to send request. Otherwise,
  /// the connection will set to public endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PrivateServiceConnectConfig?
      privateServiceConnectConfig;

  /// This field will be populated with the domain name to use for this
  /// FeatureOnlineStore
  ///
  /// Output only.
  core.String? publicEndpointDomainName;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled and after FeatureViewSync
  /// is created.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1FeatureOnlineStoreDedicatedServingEndpoint({
    this.privateServiceConnectConfig,
    this.publicEndpointDomainName,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1FeatureOnlineStoreDedicatedServingEndpoint.fromJson(
      core.Map json_)
      : this(
          privateServiceConnectConfig:
              json_.containsKey('privateServiceConnectConfig')
                  ? GoogleCloudAiplatformV1PrivateServiceConnectConfig.fromJson(
                      json_['privateServiceConnectConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          publicEndpointDomainName:
              json_['publicEndpointDomainName'] as core.String?,
          serviceAttachment: json_['serviceAttachment'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (privateServiceConnectConfig != null)
          'privateServiceConnectConfig': privateServiceConnectConfig!,
        if (publicEndpointDomainName != null)
          'publicEndpointDomainName': publicEndpointDomainName!,
        if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
      };
}

/// Optimized storage type
typedef GoogleCloudAiplatformV1FeatureOnlineStoreOptimized = $Empty;

/// Selector for Features of an EntityType.
class GoogleCloudAiplatformV1FeatureSelector {
  /// Matches Features based on ID.
  ///
  /// Required.
  GoogleCloudAiplatformV1IdMatcher? idMatcher;

  GoogleCloudAiplatformV1FeatureSelector({
    this.idMatcher,
  });

  GoogleCloudAiplatformV1FeatureSelector.fromJson(core.Map json_)
      : this(
          idMatcher: json_.containsKey('idMatcher')
              ? GoogleCloudAiplatformV1IdMatcher.fromJson(
                  json_['idMatcher'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (idMatcher != null) 'idMatcher': idMatcher!,
      };
}

/// Stats and Anomaly generated at specific timestamp for specific Feature.
///
/// The start_time and end_time are used to define the time range of the dataset
/// that current stats belongs to, e.g. prediction traffic is bucketed into
/// prediction datasets by time window. If the Dataset is not defined by time
/// window, start_time = end_time. Timestamp of the stats and anomalies always
/// refers to end_time. Raw stats and anomalies are stored in stats_uri or
/// anomaly_uri in the tensorflow defined protos. Field data_stats contains
/// almost identical information with the raw stats in Vertex AI defined proto,
/// for UI to display.
class GoogleCloudAiplatformV1FeatureStatsAnomaly {
  /// This is the threshold used when detecting anomalies.
  ///
  /// The threshold can be changed by user, so this one might be different from
  /// ThresholdConfig.value.
  core.double? anomalyDetectionThreshold;

  /// Path of the anomaly file for current feature values in Cloud Storage
  /// bucket.
  ///
  /// Format: gs:////anomalies. Example:
  /// gs://monitoring_bucket/feature_name/anomalies. Stats are stored as binary
  /// format with Protobuf message Anoamlies are stored as binary format with
  /// Protobuf message
  /// [tensorflow.metadata.v0.AnomalyInfo](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto).
  core.String? anomalyUri;

  /// Deviation from the current stats to baseline stats.
  ///
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by JensenShannon divergence.
  core.double? distributionDeviation;

  /// The end timestamp of window where stats were generated.
  ///
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), end_time indicates the timestamp of the data used to
  /// generate stats (e.g. timestamp we take snapshots for feature values).
  core.String? endTime;

  /// Feature importance score, only populated when cross-feature monitoring is
  /// enabled.
  ///
  /// For now only used to represent feature attribution score within range \[0,
  /// 1\] for ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW
  /// and ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT.
  core.double? score;

  /// The start timestamp of window where stats were generated.
  ///
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), start_time is only used to indicate the monitoring
  /// intervals, so it always equals to (end_time - monitoring_interval).
  core.String? startTime;

  /// Path of the stats file for current feature values in Cloud Storage bucket.
  ///
  /// Format: gs:////stats. Example: gs://monitoring_bucket/feature_name/stats.
  /// Stats are stored as binary format with Protobuf message
  /// [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
  core.String? statsUri;

  GoogleCloudAiplatformV1FeatureStatsAnomaly({
    this.anomalyDetectionThreshold,
    this.anomalyUri,
    this.distributionDeviation,
    this.endTime,
    this.score,
    this.startTime,
    this.statsUri,
  });

  GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(core.Map json_)
      : this(
          anomalyDetectionThreshold:
              (json_['anomalyDetectionThreshold'] as core.num?)?.toDouble(),
          anomalyUri: json_['anomalyUri'] as core.String?,
          distributionDeviation:
              (json_['distributionDeviation'] as core.num?)?.toDouble(),
          endTime: json_['endTime'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
          startTime: json_['startTime'] as core.String?,
          statsUri: json_['statsUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (anomalyDetectionThreshold != null)
          'anomalyDetectionThreshold': anomalyDetectionThreshold!,
        if (anomalyUri != null) 'anomalyUri': anomalyUri!,
        if (distributionDeviation != null)
          'distributionDeviation': distributionDeviation!,
        if (endTime != null) 'endTime': endTime!,
        if (score != null) 'score': score!,
        if (startTime != null) 'startTime': startTime!,
        if (statsUri != null) 'statsUri': statsUri!,
      };
}

/// Value for a feature.
class GoogleCloudAiplatformV1FeatureValue {
  /// A list of bool type feature value.
  GoogleCloudAiplatformV1BoolArray? boolArrayValue;

  /// Bool type feature value.
  core.bool? boolValue;

  /// Bytes feature value.
  core.String? bytesValue;
  core.List<core.int> get bytesValueAsBytes =>
      convert.base64.decode(bytesValue!);

  set bytesValueAsBytes(core.List<core.int> bytes_) {
    bytesValue =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of double type feature value.
  GoogleCloudAiplatformV1DoubleArray? doubleArrayValue;

  /// Double type feature value.
  core.double? doubleValue;

  /// A list of int64 type feature value.
  GoogleCloudAiplatformV1Int64Array? int64ArrayValue;

  /// Int64 feature value.
  core.String? int64Value;

  /// Metadata of feature value.
  GoogleCloudAiplatformV1FeatureValueMetadata? metadata;

  /// A list of string type feature value.
  GoogleCloudAiplatformV1StringArray? stringArrayValue;

  /// String feature value.
  core.String? stringValue;

  /// A struct type feature value.
  GoogleCloudAiplatformV1StructValue? structValue;

  GoogleCloudAiplatformV1FeatureValue({
    this.boolArrayValue,
    this.boolValue,
    this.bytesValue,
    this.doubleArrayValue,
    this.doubleValue,
    this.int64ArrayValue,
    this.int64Value,
    this.metadata,
    this.stringArrayValue,
    this.stringValue,
    this.structValue,
  });

  GoogleCloudAiplatformV1FeatureValue.fromJson(core.Map json_)
      : this(
          boolArrayValue: json_.containsKey('boolArrayValue')
              ? GoogleCloudAiplatformV1BoolArray.fromJson(
                  json_['boolArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          boolValue: json_['boolValue'] as core.bool?,
          bytesValue: json_['bytesValue'] as core.String?,
          doubleArrayValue: json_.containsKey('doubleArrayValue')
              ? GoogleCloudAiplatformV1DoubleArray.fromJson(
                  json_['doubleArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
          int64ArrayValue: json_.containsKey('int64ArrayValue')
              ? GoogleCloudAiplatformV1Int64Array.fromJson(
                  json_['int64ArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          int64Value: json_['int64Value'] as core.String?,
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1FeatureValueMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          stringArrayValue: json_.containsKey('stringArrayValue')
              ? GoogleCloudAiplatformV1StringArray.fromJson(
                  json_['stringArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          stringValue: json_['stringValue'] as core.String?,
          structValue: json_.containsKey('structValue')
              ? GoogleCloudAiplatformV1StructValue.fromJson(
                  json_['structValue'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (boolArrayValue != null) 'boolArrayValue': boolArrayValue!,
        if (boolValue != null) 'boolValue': boolValue!,
        if (bytesValue != null) 'bytesValue': bytesValue!,
        if (doubleArrayValue != null) 'doubleArrayValue': doubleArrayValue!,
        if (doubleValue != null) 'doubleValue': doubleValue!,
        if (int64ArrayValue != null) 'int64ArrayValue': int64ArrayValue!,
        if (int64Value != null) 'int64Value': int64Value!,
        if (metadata != null) 'metadata': metadata!,
        if (stringArrayValue != null) 'stringArrayValue': stringArrayValue!,
        if (stringValue != null) 'stringValue': stringValue!,
        if (structValue != null) 'structValue': structValue!,
      };
}

/// A destination location for Feature values and format.
class GoogleCloudAiplatformV1FeatureValueDestination {
  /// Output in BigQuery format.
  ///
  /// BigQueryDestination.output_uri in
  /// FeatureValueDestination.bigquery_destination must refer to a table.
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// Output in CSV format.
  ///
  /// Array Feature value types are not allowed in CSV format.
  GoogleCloudAiplatformV1CsvDestination? csvDestination;

  /// Output in TFRecord format.
  ///
  /// Below are the mapping from Feature value type in Featurestore to Feature
  /// value type in TFRecord: Value type in Featurestore | Value type in
  /// TFRecord DOUBLE, DOUBLE_ARRAY | FLOAT_LIST INT64, INT64_ARRAY | INT64_LIST
  /// STRING, STRING_ARRAY, BYTES | BYTES_LIST true -\> byte_string("true"),
  /// false -\> byte_string("false") BOOL, BOOL_ARRAY (true, false) | BYTES_LIST
  GoogleCloudAiplatformV1TFRecordDestination? tfrecordDestination;

  GoogleCloudAiplatformV1FeatureValueDestination({
    this.bigqueryDestination,
    this.csvDestination,
    this.tfrecordDestination,
  });

  GoogleCloudAiplatformV1FeatureValueDestination.fromJson(core.Map json_)
      : this(
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          csvDestination: json_.containsKey('csvDestination')
              ? GoogleCloudAiplatformV1CsvDestination.fromJson(
                  json_['csvDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tfrecordDestination: json_.containsKey('tfrecordDestination')
              ? GoogleCloudAiplatformV1TFRecordDestination.fromJson(
                  json_['tfrecordDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (csvDestination != null) 'csvDestination': csvDestination!,
        if (tfrecordDestination != null)
          'tfrecordDestination': tfrecordDestination!,
      };
}

/// Container for list of values.
class GoogleCloudAiplatformV1FeatureValueList {
  /// A list of feature values.
  ///
  /// All of them should be the same data type.
  core.List<GoogleCloudAiplatformV1FeatureValue>? values;

  GoogleCloudAiplatformV1FeatureValueList({
    this.values,
  });

  GoogleCloudAiplatformV1FeatureValueList.fromJson(core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1FeatureValue.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Metadata of feature value.
class GoogleCloudAiplatformV1FeatureValueMetadata {
  /// Feature generation timestamp.
  ///
  /// Typically, it is provided by user at feature ingestion time. If not,
  /// feature store will use the system timestamp when the data is ingested into
  /// feature store. For streaming ingestion, the time, aligned by days, must be
  /// no older than five years (1825 days) and no later than one year (366 days)
  /// in the future.
  core.String? generateTime;

  GoogleCloudAiplatformV1FeatureValueMetadata({
    this.generateTime,
  });

  GoogleCloudAiplatformV1FeatureValueMetadata.fromJson(core.Map json_)
      : this(
          generateTime: json_['generateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (generateTime != null) 'generateTime': generateTime!,
      };
}

/// FeatureView is representation of values that the FeatureOnlineStore will
/// serve based on its syncConfig.
class GoogleCloudAiplatformV1FeatureView {
  /// Configures how data is supposed to be extracted from a BigQuery source to
  /// be loaded onto the FeatureOnlineStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewBigQuerySource? bigQuerySource;

  /// Timestamp when this FeatureView was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Configures the features from a Feature Registry source that need to be
  /// loaded onto the FeatureOnlineStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource?
      featureRegistrySource;

  /// Configuration for index preparation for vector search.
  ///
  /// It contains the required configurations to create an index from source
  /// data, so that approximate nearest neighbor (a.k.a ANN) algorithms search
  /// can be performed during online serving.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewIndexConfig? indexConfig;

  /// The labels with user-defined metadata to organize your FeatureViews.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label
  /// keys are prefixed with "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Name of the FeatureView. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  core.String? name;

  /// Configuration for FeatureView created under Optimized FeatureOnlineStore.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewOptimizedConfig? optimizedConfig;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// A Service Account unique to this FeatureView.
  ///
  /// The role bigquery.dataViewer should be granted to this service account to
  /// allow Vertex AI Feature Store to sync data to the online store.
  ///
  /// Output only.
  core.String? serviceAccountEmail;

  /// Service agent type used during data sync.
  ///
  /// By default, the Vertex AI Service Agent is used. When using an IAM Policy
  /// to isolate this FeatureView within a project, a separate service account
  /// should be provisioned by setting this field to
  /// `SERVICE_AGENT_TYPE_FEATURE_VIEW`. This will generate a separate service
  /// account to access the BigQuery source table.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "SERVICE_AGENT_TYPE_UNSPECIFIED" : By default, the project-level Vertex
  /// AI Service Agent is enabled.
  /// - "SERVICE_AGENT_TYPE_PROJECT" : Indicates the project-level Vertex AI
  /// Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used during sync jobs.
  /// - "SERVICE_AGENT_TYPE_FEATURE_VIEW" : Enable a FeatureView service account
  /// to be created by Vertex AI and output in the field
  /// `service_account_email`. This service account will be used to read from
  /// the source BigQuery table during sync.
  core.String? serviceAgentType;

  /// Configures when data is to be synced/updated for this FeatureView.
  ///
  /// At the end of the sync the latest featureValues for each entityId of this
  /// FeatureView are made ready for online serving.
  GoogleCloudAiplatformV1FeatureViewSyncConfig? syncConfig;

  /// Timestamp when this FeatureView was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The Vertex RAG Source that the FeatureView is linked to.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewVertexRagSource? vertexRagSource;

  GoogleCloudAiplatformV1FeatureView({
    this.bigQuerySource,
    this.createTime,
    this.etag,
    this.featureRegistrySource,
    this.indexConfig,
    this.labels,
    this.name,
    this.optimizedConfig,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccountEmail,
    this.serviceAgentType,
    this.syncConfig,
    this.updateTime,
    this.vertexRagSource,
  });

  GoogleCloudAiplatformV1FeatureView.fromJson(core.Map json_)
      : this(
          bigQuerySource: json_.containsKey('bigQuerySource')
              ? GoogleCloudAiplatformV1FeatureViewBigQuerySource.fromJson(
                  json_['bigQuerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          etag: json_['etag'] as core.String?,
          featureRegistrySource: json_.containsKey('featureRegistrySource')
              ? GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource
                  .fromJson(json_['featureRegistrySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          indexConfig: json_.containsKey('indexConfig')
              ? GoogleCloudAiplatformV1FeatureViewIndexConfig.fromJson(
                  json_['indexConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          optimizedConfig: json_.containsKey('optimizedConfig')
              ? GoogleCloudAiplatformV1FeatureViewOptimizedConfig.fromJson(
                  json_['optimizedConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          serviceAccountEmail: json_['serviceAccountEmail'] as core.String?,
          serviceAgentType: json_['serviceAgentType'] as core.String?,
          syncConfig: json_.containsKey('syncConfig')
              ? GoogleCloudAiplatformV1FeatureViewSyncConfig.fromJson(
                  json_['syncConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
          vertexRagSource: json_.containsKey('vertexRagSource')
              ? GoogleCloudAiplatformV1FeatureViewVertexRagSource.fromJson(
                  json_['vertexRagSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!,
        if (createTime != null) 'createTime': createTime!,
        if (etag != null) 'etag': etag!,
        if (featureRegistrySource != null)
          'featureRegistrySource': featureRegistrySource!,
        if (indexConfig != null) 'indexConfig': indexConfig!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (optimizedConfig != null) 'optimizedConfig': optimizedConfig!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (serviceAccountEmail != null)
          'serviceAccountEmail': serviceAccountEmail!,
        if (serviceAgentType != null) 'serviceAgentType': serviceAgentType!,
        if (syncConfig != null) 'syncConfig': syncConfig!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (vertexRagSource != null) 'vertexRagSource': vertexRagSource!,
      };
}

class GoogleCloudAiplatformV1FeatureViewBigQuerySource {
  /// Columns to construct entity_id / row keys.
  ///
  /// Required.
  core.List<core.String>? entityIdColumns;

  /// The BigQuery view URI that will be materialized on each sync trigger based
  /// on FeatureView.SyncConfig.
  ///
  /// Required.
  core.String? uri;

  GoogleCloudAiplatformV1FeatureViewBigQuerySource({
    this.entityIdColumns,
    this.uri,
  });

  GoogleCloudAiplatformV1FeatureViewBigQuerySource.fromJson(core.Map json_)
      : this(
          entityIdColumns: (json_['entityIdColumns'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          uri: json_['uri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityIdColumns != null) 'entityIdColumns': entityIdColumns!,
        if (uri != null) 'uri': uri!,
      };
}

/// Lookup key for a feature view.
class GoogleCloudAiplatformV1FeatureViewDataKey {
  /// The actual Entity ID will be composed from this struct.
  ///
  /// This should match with the way ID is defined in the FeatureView spec.
  GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey? compositeKey;

  /// String key to use for lookup.
  core.String? key;

  GoogleCloudAiplatformV1FeatureViewDataKey({
    this.compositeKey,
    this.key,
  });

  GoogleCloudAiplatformV1FeatureViewDataKey.fromJson(core.Map json_)
      : this(
          compositeKey: json_.containsKey('compositeKey')
              ? GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey.fromJson(
                  json_['compositeKey'] as core.Map<core.String, core.dynamic>)
              : null,
          key: json_['key'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (compositeKey != null) 'compositeKey': compositeKey!,
        if (key != null) 'key': key!,
      };
}

/// ID that is comprised from several parts (columns).
class GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey {
  /// Parts to construct Entity ID.
  ///
  /// Should match with the same ID columns as defined in FeatureView in the
  /// same order.
  core.List<core.String>? parts;

  GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey({
    this.parts,
  });

  GoogleCloudAiplatformV1FeatureViewDataKeyCompositeKey.fromJson(core.Map json_)
      : this(
          parts: (json_['parts'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parts != null) 'parts': parts!,
      };
}

/// A Feature Registry source for features that need to be synced to Online
/// Store.
class GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource {
  /// List of features that need to be synced to Online Store.
  ///
  /// Required.
  core.List<
          GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup>?
      featureGroups;

  /// The project number of the parent project of the Feature Groups.
  ///
  /// Optional.
  core.String? projectNumber;

  GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource({
    this.featureGroups,
    this.projectNumber,
  });

  GoogleCloudAiplatformV1FeatureViewFeatureRegistrySource.fromJson(
      core.Map json_)
      : this(
          featureGroups: (json_['featureGroups'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          projectNumber: json_['projectNumber'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureGroups != null) 'featureGroups': featureGroups!,
        if (projectNumber != null) 'projectNumber': projectNumber!,
      };
}

/// Features belonging to a single feature group that will be synced to Online
/// Store.
class GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup {
  /// Identifier of the feature group.
  ///
  /// Required.
  core.String? featureGroupId;

  /// Identifiers of features under the feature group.
  ///
  /// Required.
  core.List<core.String>? featureIds;

  GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup({
    this.featureGroupId,
    this.featureIds,
  });

  GoogleCloudAiplatformV1FeatureViewFeatureRegistrySourceFeatureGroup.fromJson(
      core.Map json_)
      : this(
          featureGroupId: json_['featureGroupId'] as core.String?,
          featureIds: (json_['featureIds'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureGroupId != null) 'featureGroupId': featureGroupId!,
        if (featureIds != null) 'featureIds': featureIds!,
      };
}

/// Configuration for vector indexing.
class GoogleCloudAiplatformV1FeatureViewIndexConfig {
  /// Configuration options for using brute force search, which simply
  /// implements the standard linear search in the database for each query.
  ///
  /// It is primarily meant for benchmarking and to generate the ground truth
  /// for approximate search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewIndexConfigBruteForceConfig?
      bruteForceConfig;

  /// Column of crowding.
  ///
  /// This column contains crowding attribute which is a constraint on a
  /// neighbor list produced by FeatureOnlineStoreService.SearchNearestEntities
  /// to diversify search results. If
  /// NearestNeighborQuery.per_crowding_attribute_neighbor_count is set to K in
  /// SearchNearestEntitiesRequest, it's guaranteed that no more than K entities
  /// of the same crowding attribute are returned in the response.
  ///
  /// Optional.
  core.String? crowdingColumn;

  /// The distance measure used in nearest neighbor search.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "DISTANCE_MEASURE_TYPE_UNSPECIFIED" : Should not be set.
  /// - "SQUARED_L2_DISTANCE" : Euclidean (L_2) Distance.
  /// - "COSINE_DISTANCE" : Cosine Distance. Defined as 1 - cosine similarity.
  /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead of
  /// COSINE distance. Our algorithms have been more optimized for DOT_PRODUCT
  /// distance which, when combined with UNIT_L2_NORM, is mathematically
  /// equivalent to COSINE distance and results in the same ranking.
  /// - "DOT_PRODUCT_DISTANCE" : Dot Product Distance. Defined as a negative of
  /// the dot product.
  core.String? distanceMeasureType;

  /// Column of embedding.
  ///
  /// This column contains the source data to create index for vector search.
  /// embedding_column must be set when using vector search.
  ///
  /// Optional.
  core.String? embeddingColumn;

  /// The number of dimensions of the input embedding.
  ///
  /// Optional.
  core.int? embeddingDimension;

  /// Columns of features that're used to filter vector search results.
  ///
  /// Optional.
  core.List<core.String>? filterColumns;

  /// Configuration options for the tree-AH algorithm (Shallow tree + Asymmetric
  /// Hashing).
  ///
  /// Please refer to this paper for more details:
  /// https://arxiv.org/abs/1908.10396
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewIndexConfigTreeAHConfig? treeAhConfig;

  GoogleCloudAiplatformV1FeatureViewIndexConfig({
    this.bruteForceConfig,
    this.crowdingColumn,
    this.distanceMeasureType,
    this.embeddingColumn,
    this.embeddingDimension,
    this.filterColumns,
    this.treeAhConfig,
  });

  GoogleCloudAiplatformV1FeatureViewIndexConfig.fromJson(core.Map json_)
      : this(
          bruteForceConfig: json_.containsKey('bruteForceConfig')
              ? GoogleCloudAiplatformV1FeatureViewIndexConfigBruteForceConfig
                  .fromJson(json_['bruteForceConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          crowdingColumn: json_['crowdingColumn'] as core.String?,
          distanceMeasureType: json_['distanceMeasureType'] as core.String?,
          embeddingColumn: json_['embeddingColumn'] as core.String?,
          embeddingDimension: json_['embeddingDimension'] as core.int?,
          filterColumns: (json_['filterColumns'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          treeAhConfig: json_.containsKey('treeAhConfig')
              ? GoogleCloudAiplatformV1FeatureViewIndexConfigTreeAHConfig
                  .fromJson(json_['treeAhConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bruteForceConfig != null) 'bruteForceConfig': bruteForceConfig!,
        if (crowdingColumn != null) 'crowdingColumn': crowdingColumn!,
        if (distanceMeasureType != null)
          'distanceMeasureType': distanceMeasureType!,
        if (embeddingColumn != null) 'embeddingColumn': embeddingColumn!,
        if (embeddingDimension != null)
          'embeddingDimension': embeddingDimension!,
        if (filterColumns != null) 'filterColumns': filterColumns!,
        if (treeAhConfig != null) 'treeAhConfig': treeAhConfig!,
      };
}

/// Configuration options for using brute force search.
typedef GoogleCloudAiplatformV1FeatureViewIndexConfigBruteForceConfig = $Empty;

/// Configuration options for the tree-AH algorithm.
class GoogleCloudAiplatformV1FeatureViewIndexConfigTreeAHConfig {
  /// Number of embeddings on each leaf node.
  ///
  /// The default value is 1000 if not set.
  ///
  /// Optional.
  core.String? leafNodeEmbeddingCount;

  GoogleCloudAiplatformV1FeatureViewIndexConfigTreeAHConfig({
    this.leafNodeEmbeddingCount,
  });

  GoogleCloudAiplatformV1FeatureViewIndexConfigTreeAHConfig.fromJson(
      core.Map json_)
      : this(
          leafNodeEmbeddingCount:
              json_['leafNodeEmbeddingCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (leafNodeEmbeddingCount != null)
          'leafNodeEmbeddingCount': leafNodeEmbeddingCount!,
      };
}

/// Configuration for FeatureViews created in Optimized FeatureOnlineStore.
class GoogleCloudAiplatformV1FeatureViewOptimizedConfig {
  /// A description of resources that the FeatureView uses, which to large
  /// degree are decided by Vertex AI, and optionally allows only a modest
  /// additional configuration.
  ///
  /// If min_replica_count is not set, the default value is 2. If
  /// max_replica_count is not set, the default value is 6. The max allowed
  /// replica count is 1000.
  ///
  /// Optional.
  GoogleCloudAiplatformV1AutomaticResources? automaticResources;

  GoogleCloudAiplatformV1FeatureViewOptimizedConfig({
    this.automaticResources,
  });

  GoogleCloudAiplatformV1FeatureViewOptimizedConfig.fromJson(core.Map json_)
      : this(
          automaticResources: json_.containsKey('automaticResources')
              ? GoogleCloudAiplatformV1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automaticResources != null)
          'automaticResources': automaticResources!,
      };
}

/// FeatureViewSync is a representation of sync operation which copies data from
/// data source to Feature View in Online Store.
class GoogleCloudAiplatformV1FeatureViewSync {
  /// Time when this FeatureViewSync is created.
  ///
  /// Creation of a FeatureViewSync means that the job is pending / waiting for
  /// sufficient resources but may not have started the actual data transfer
  /// yet.
  ///
  /// Output only.
  core.String? createTime;

  /// Final status of the FeatureViewSync.
  ///
  /// Output only.
  GoogleRpcStatus? finalStatus;

  /// Identifier.
  ///
  /// Name of the FeatureViewSync. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  core.String? name;

  /// Time when this FeatureViewSync is finished.
  ///
  /// Output only.
  GoogleTypeInterval? runTime;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Summary of the sync job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1FeatureViewSyncSyncSummary? syncSummary;

  GoogleCloudAiplatformV1FeatureViewSync({
    this.createTime,
    this.finalStatus,
    this.name,
    this.runTime,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.syncSummary,
  });

  GoogleCloudAiplatformV1FeatureViewSync.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          finalStatus: json_.containsKey('finalStatus')
              ? GoogleRpcStatus.fromJson(
                  json_['finalStatus'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          runTime: json_.containsKey('runTime')
              ? GoogleTypeInterval.fromJson(
                  json_['runTime'] as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          syncSummary: json_.containsKey('syncSummary')
              ? GoogleCloudAiplatformV1FeatureViewSyncSyncSummary.fromJson(
                  json_['syncSummary'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (finalStatus != null) 'finalStatus': finalStatus!,
        if (name != null) 'name': name!,
        if (runTime != null) 'runTime': runTime!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (syncSummary != null) 'syncSummary': syncSummary!,
      };
}

/// Configuration for Sync.
///
/// Only one option is set.
class GoogleCloudAiplatformV1FeatureViewSyncConfig {
  /// If true, syncs the FeatureView in a continuous manner to Online Store.
  ///
  /// Optional.
  core.bool? continuous;

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs.
  ///
  /// To explicitly set a timezone to the cron tab, apply a prefix in the cron
  /// tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The
  /// ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database.
  /// For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York
  /// 1 * * * *".
  core.String? cron;

  GoogleCloudAiplatformV1FeatureViewSyncConfig({
    this.continuous,
    this.cron,
  });

  GoogleCloudAiplatformV1FeatureViewSyncConfig.fromJson(core.Map json_)
      : this(
          continuous: json_['continuous'] as core.bool?,
          cron: json_['cron'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (continuous != null) 'continuous': continuous!,
        if (cron != null) 'cron': cron!,
      };
}

/// Summary from the Sync job.
///
/// For continuous syncs, the summary is updated periodically. For batch syncs,
/// it gets updated on completion of the sync.
class GoogleCloudAiplatformV1FeatureViewSyncSyncSummary {
  /// Total number of rows synced.
  ///
  /// Output only.
  core.String? rowSynced;

  /// Lower bound of the system time watermark for the sync job.
  ///
  /// This is only set for continuously syncing feature views.
  core.String? systemWatermarkTime;

  /// BigQuery slot milliseconds consumed for the sync job.
  ///
  /// Output only.
  core.String? totalSlot;

  GoogleCloudAiplatformV1FeatureViewSyncSyncSummary({
    this.rowSynced,
    this.systemWatermarkTime,
    this.totalSlot,
  });

  GoogleCloudAiplatformV1FeatureViewSyncSyncSummary.fromJson(core.Map json_)
      : this(
          rowSynced: json_['rowSynced'] as core.String?,
          systemWatermarkTime: json_['systemWatermarkTime'] as core.String?,
          totalSlot: json_['totalSlot'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (rowSynced != null) 'rowSynced': rowSynced!,
        if (systemWatermarkTime != null)
          'systemWatermarkTime': systemWatermarkTime!,
        if (totalSlot != null) 'totalSlot': totalSlot!,
      };
}

/// A Vertex Rag source for features that need to be synced to Online Store.
class GoogleCloudAiplatformV1FeatureViewVertexRagSource {
  /// The RAG corpus id corresponding to this FeatureView.
  ///
  /// Optional.
  core.String? ragCorpusId;

  /// The BigQuery view/table URI that will be materialized on each manual sync
  /// trigger.
  ///
  /// The table/view is expected to have the following columns and types at
  /// least: - `corpus_id` (STRING, NULLABLE/REQUIRED) - `file_id` (STRING,
  /// NULLABLE/REQUIRED) - `chunk_id` (STRING, NULLABLE/REQUIRED) -
  /// `chunk_data_type` (STRING, NULLABLE/REQUIRED) - `chunk_data` (STRING,
  /// NULLABLE/REQUIRED) - `embeddings` (FLOAT, REPEATED) - `file_original_uri`
  /// (STRING, NULLABLE/REQUIRED)
  ///
  /// Required.
  core.String? uri;

  GoogleCloudAiplatformV1FeatureViewVertexRagSource({
    this.ragCorpusId,
    this.uri,
  });

  GoogleCloudAiplatformV1FeatureViewVertexRagSource.fromJson(core.Map json_)
      : this(
          ragCorpusId: json_['ragCorpusId'] as core.String?,
          uri: json_['uri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragCorpusId != null) 'ragCorpusId': ragCorpusId!,
        if (uri != null) 'uri': uri!,
      };
}

/// Vertex AI Feature Store provides a centralized repository for organizing,
/// storing, and serving ML features.
///
/// The Featurestore is a top-level container for your features and their
/// values.
class GoogleCloudAiplatformV1Featurestore {
  /// Timestamp when this Featurestore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Customer-managed encryption key spec for data storage.
  ///
  /// If set, both of the online and offline data storage will be secured by
  /// this key.
  ///
  /// Optional.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Featurestore.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one Featurestore(System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Name of the Featurestore.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  ///
  /// Output only.
  core.String? name;

  /// Config for online storage resources.
  ///
  /// The field should not co-exist with the field of
  /// `OnlineStoreReplicationConfig`. If both of it and
  /// OnlineStoreReplicationConfig are unset, the feature store will not have an
  /// online store and cannot be used for online serving.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig? onlineServingConfig;

  /// TTL in days for feature values that will be stored in online serving
  /// storage.
  ///
  /// The Feature Store online storage periodically removes obsolete feature
  /// values older than `online_storage_ttl_days` since the feature generation
  /// time. Note that `online_storage_ttl_days` should be less than or equal to
  /// `offline_storage_ttl_days` for each EntityType under a featurestore. If
  /// not set, default to 4000 days
  ///
  /// Optional.
  core.int? onlineStorageTtlDays;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// State of the featurestore.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value. This value is unused.
  /// - "STABLE" : State when the featurestore configuration is not being
  /// updated and the fields reflect the current configuration of the
  /// featurestore. The featurestore is usable in this state.
  /// - "UPDATING" : The state of the featurestore configuration when it is
  /// being updated. During an update, the fields reflect either the original
  /// configuration or the updated configuration of the featurestore. For
  /// example, `online_serving_config.fixed_node_count` can take minutes to
  /// update. While the update is in progress, the featurestore is in the
  /// UPDATING state, and the value of `fixed_node_count` can be the original
  /// value or the updated value, depending on the progress of the operation.
  /// Until the update completes, the actual number of nodes can still be the
  /// original value of `fixed_node_count`. The featurestore is still usable in
  /// this state.
  core.String? state;

  /// Timestamp when this Featurestore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Featurestore({
    this.createTime,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.onlineServingConfig,
    this.onlineStorageTtlDays,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Featurestore.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          onlineServingConfig: json_.containsKey('onlineServingConfig')
              ? GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig.fromJson(
                  json_['onlineServingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          onlineStorageTtlDays: json_['onlineStorageTtlDays'] as core.int?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (onlineServingConfig != null)
          'onlineServingConfig': onlineServingConfig!,
        if (onlineStorageTtlDays != null)
          'onlineStorageTtlDays': onlineStorageTtlDays!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Configuration of how features in Featurestore are monitored.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfig {
  /// Threshold for categorical features of anomaly detection.
  ///
  /// This is shared by all types of Featurestore Monitoring for categorical
  /// features (i.e. Features with type (Feature.ValueType) BOOL or STRING).
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig?
      categoricalThresholdConfig;

  /// The config for ImportFeatures Analysis Based Feature Monitoring.
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis?
      importFeaturesAnalysis;

  /// Threshold for numerical features of anomaly detection.
  ///
  /// This is shared by all objectives of Featurestore Monitoring for numerical
  /// features (i.e. Features with type (Feature.ValueType) DOUBLE or INT64).
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig?
      numericalThresholdConfig;

  /// The config for Snapshot Analysis Based Feature Monitoring.
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis?
      snapshotAnalysis;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfig({
    this.categoricalThresholdConfig,
    this.importFeaturesAnalysis,
    this.numericalThresholdConfig,
    this.snapshotAnalysis,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfig.fromJson(core.Map json_)
      : this(
          categoricalThresholdConfig: json_
                  .containsKey('categoricalThresholdConfig')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig
                  .fromJson(json_['categoricalThresholdConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          importFeaturesAnalysis: json_.containsKey('importFeaturesAnalysis')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis
                  .fromJson(json_['importFeaturesAnalysis']
                      as core.Map<core.String, core.dynamic>)
              : null,
          numericalThresholdConfig: json_
                  .containsKey('numericalThresholdConfig')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig
                  .fromJson(json_['numericalThresholdConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          snapshotAnalysis: json_.containsKey('snapshotAnalysis')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis
                  .fromJson(json_['snapshotAnalysis']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (categoricalThresholdConfig != null)
          'categoricalThresholdConfig': categoricalThresholdConfig!,
        if (importFeaturesAnalysis != null)
          'importFeaturesAnalysis': importFeaturesAnalysis!,
        if (numericalThresholdConfig != null)
          'numericalThresholdConfig': numericalThresholdConfig!,
        if (snapshotAnalysis != null) 'snapshotAnalysis': snapshotAnalysis!,
      };
}

/// Configuration of the Featurestore's ImportFeature Analysis Based Monitoring.
///
/// This type of analysis generates statistics for values of each Feature
/// imported by every ImportFeatureValues operation.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis {
  /// The baseline used to do anomaly detection for the statistics generated by
  /// import features analysis.
  /// Possible string values are:
  /// - "BASELINE_UNSPECIFIED" : Should not be used.
  /// - "LATEST_STATS" : Choose the later one statistics generated by either
  /// most recent snapshot analysis or previous import features analysis. If non
  /// of them exists, skip anomaly detection and only generate a statistics.
  /// - "MOST_RECENT_SNAPSHOT_STATS" : Use the statistics generated by the most
  /// recent snapshot analysis if exists.
  /// - "PREVIOUS_IMPORT_FEATURES_STATS" : Use the statistics generated by the
  /// previous import features analysis if exists.
  core.String? anomalyDetectionBaseline;

  /// Whether to enable / disable / inherite default hebavior for import
  /// features analysis.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Should not be used.
  /// - "DEFAULT" : The default behavior of whether to enable the monitoring.
  /// EntityType-level config: disabled. Feature-level config: inherited from
  /// the configuration of EntityType this Feature belongs to.
  /// - "ENABLED" : Explicitly enables import features analysis.
  /// EntityType-level config: by default enables import features analysis for
  /// all Features under it. Feature-level config: enables import features
  /// analysis regardless of the EntityType-level config.
  /// - "DISABLED" : Explicitly disables import features analysis.
  /// EntityType-level config: by default disables import features analysis for
  /// all Features under it. Feature-level config: disables import features
  /// analysis regardless of the EntityType-level config.
  core.String? state;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis({
    this.anomalyDetectionBaseline,
    this.state,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis.fromJson(
      core.Map json_)
      : this(
          anomalyDetectionBaseline:
              json_['anomalyDetectionBaseline'] as core.String?,
          state: json_['state'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (anomalyDetectionBaseline != null)
          'anomalyDetectionBaseline': anomalyDetectionBaseline!,
        if (state != null) 'state': state!,
      };
}

/// Configuration of the Featurestore's Snapshot Analysis Based Monitoring.
///
/// This type of analysis generates statistics for each Feature based on a
/// snapshot of the latest feature value of each entities every
/// monitoring_interval.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis {
  /// The monitoring schedule for snapshot analysis.
  ///
  /// For EntityType-level config: unset / disabled = true indicates disabled by
  /// default for Features under it; otherwise by default enable snapshot
  /// analysis monitoring with monitoring_interval for Features under it.
  /// Feature-level config: disabled = true indicates disabled regardless of the
  /// EntityType-level config; unset monitoring_interval indicates going with
  /// EntityType-level config; otherwise run snapshot analysis monitoring with
  /// monitoring_interval regardless of the EntityType-level config. Explicitly
  /// Disable the snapshot analysis based monitoring.
  core.bool? disabled;

  /// Configuration of the snapshot analysis based monitoring pipeline running
  /// interval.
  ///
  /// The value indicates number of days.
  core.int? monitoringIntervalDays;

  /// Customized export features time window for snapshot analysis.
  ///
  /// Unit is one day. Default value is 3 weeks. Minimum value is 1 day. Maximum
  /// value is 4000 days.
  core.int? stalenessDays;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis({
    this.disabled,
    this.monitoringIntervalDays,
    this.stalenessDays,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis.fromJson(
      core.Map json_)
      : this(
          disabled: json_['disabled'] as core.bool?,
          monitoringIntervalDays: json_['monitoringIntervalDays'] as core.int?,
          stalenessDays: json_['stalenessDays'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disabled != null) 'disabled': disabled!,
        if (monitoringIntervalDays != null)
          'monitoringIntervalDays': monitoringIntervalDays!,
        if (stalenessDays != null) 'stalenessDays': stalenessDays!,
      };
}

/// The config for Featurestore Monitoring threshold.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig {
  /// Specify a threshold value that can trigger the alert.
  ///
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by JensenShannon divergence. Each feature must have a non-zero
  /// threshold if they need to be monitored. Otherwise no alert will be
  /// triggered for that feature.
  core.double? value;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig({
    this.value,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig.fromJson(
      core.Map json_)
      : this(
          value: (json_['value'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
      };
}

/// OnlineServingConfig specifies the details for provisioning online serving
/// resources.
class GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig {
  /// The number of nodes for the online store.
  ///
  /// The number of nodes doesn't scale automatically, but you can manually
  /// update the number of nodes. If set to 0, the featurestore will not have an
  /// online store and cannot be used for online serving.
  core.int? fixedNodeCount;

  /// Online serving scaling configuration.
  ///
  /// Only one of `fixed_node_count` and `scaling` can be set. Setting one will
  /// reset the other.
  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling? scaling;

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig({
    this.fixedNodeCount,
    this.scaling,
  });

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig.fromJson(
      core.Map json_)
      : this(
          fixedNodeCount: json_['fixedNodeCount'] as core.int?,
          scaling: json_.containsKey('scaling')
              ? GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling
                  .fromJson(
                      json_['scaling'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fixedNodeCount != null) 'fixedNodeCount': fixedNodeCount!,
        if (scaling != null) 'scaling': scaling!,
      };
}

/// Online serving scaling configuration.
///
/// If min_node_count and max_node_count are set to the same value, the cluster
/// will be configured with the fixed number of node (no auto-scaling).
class GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling {
  /// The cpu utilization that the Autoscaler should be trying to achieve.
  ///
  /// This number is on a scale from 0 (no utilization) to 100 (total
  /// utilization), and is limited between 10 and 80. When a cluster's CPU
  /// utilization exceeds the target that you have set, Bigtable immediately
  /// adds nodes to the cluster. When CPU utilization is substantially lower
  /// than the target, Bigtable removes nodes. If not set or set to 0, default
  /// to 50.
  ///
  /// Optional.
  core.int? cpuUtilizationTarget;

  /// The maximum number of nodes to scale up to.
  ///
  /// Must be greater than min_node_count, and less than or equal to 10 times of
  /// 'min_node_count'.
  core.int? maxNodeCount;

  /// The minimum number of nodes to scale down to.
  ///
  /// Must be greater than or equal to 1.
  ///
  /// Required.
  core.int? minNodeCount;

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling({
    this.cpuUtilizationTarget,
    this.maxNodeCount,
    this.minNodeCount,
  });

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling.fromJson(
      core.Map json_)
      : this(
          cpuUtilizationTarget: json_['cpuUtilizationTarget'] as core.int?,
          maxNodeCount: json_['maxNodeCount'] as core.int?,
          minNodeCount: json_['minNodeCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cpuUtilizationTarget != null)
          'cpuUtilizationTarget': cpuUtilizationTarget!,
        if (maxNodeCount != null) 'maxNodeCount': maxNodeCount!,
        if (minNodeCount != null) 'minNodeCount': minNodeCount!,
      };
}

/// Request message for FeatureOnlineStoreService.FetchFeatureValues.
///
/// All the features under the requested feature view will be returned.
class GoogleCloudAiplatformV1FetchFeatureValuesRequest {
  /// Response data format.
  ///
  /// If not set, FeatureViewDataFormat.KEY_VALUE will be used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED" : Not set. Will be treated as the
  /// KeyValue format.
  /// - "KEY_VALUE" : Return response data in key-value format.
  /// - "PROTO_STRUCT" : Return response data in proto Struct format.
  core.String? dataFormat;

  /// The request key to fetch feature values for.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeatureViewDataKey? dataKey;

  GoogleCloudAiplatformV1FetchFeatureValuesRequest({
    this.dataFormat,
    this.dataKey,
  });

  GoogleCloudAiplatformV1FetchFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          dataFormat: json_['dataFormat'] as core.String?,
          dataKey: json_.containsKey('dataKey')
              ? GoogleCloudAiplatformV1FeatureViewDataKey.fromJson(
                  json_['dataKey'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataFormat != null) 'dataFormat': dataFormat!,
        if (dataKey != null) 'dataKey': dataKey!,
      };
}

/// Response message for FeatureOnlineStoreService.FetchFeatureValues
class GoogleCloudAiplatformV1FetchFeatureValuesResponse {
  /// The data key associated with this response.
  ///
  /// Will only be populated for
  /// FeatureOnlineStoreService.StreamingFetchFeatureValues RPCs.
  GoogleCloudAiplatformV1FeatureViewDataKey? dataKey;

  /// Feature values in KeyValue format.
  GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList?
      keyValues;

  /// Feature values in proto Struct format.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? protoStruct;

  GoogleCloudAiplatformV1FetchFeatureValuesResponse({
    this.dataKey,
    this.keyValues,
    this.protoStruct,
  });

  GoogleCloudAiplatformV1FetchFeatureValuesResponse.fromJson(core.Map json_)
      : this(
          dataKey: json_.containsKey('dataKey')
              ? GoogleCloudAiplatformV1FeatureViewDataKey.fromJson(
                  json_['dataKey'] as core.Map<core.String, core.dynamic>)
              : null,
          keyValues: json_.containsKey('keyValues')
              ? GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList
                  .fromJson(
                      json_['keyValues'] as core.Map<core.String, core.dynamic>)
              : null,
          protoStruct: json_.containsKey('protoStruct')
              ? json_['protoStruct'] as core.Map<core.String, core.dynamic>
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataKey != null) 'dataKey': dataKey!,
        if (keyValues != null) 'keyValues': keyValues!,
        if (protoStruct != null) 'protoStruct': protoStruct!,
      };
}

/// Response structure in the format of key (feature name) and (feature) value
/// pair.
class GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList {
  /// List of feature names and values.
  core.List<
          GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair>?
      features;

  GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList({
    this.features,
  });

  GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairList.fromJson(
      core.Map json_)
      : this(
          features: (json_['features'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (features != null) 'features': features!,
      };
}

/// Feature name & value pair.
class GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair {
  /// Feature short name.
  core.String? name;

  /// Feature value.
  GoogleCloudAiplatformV1FeatureValue? value;

  GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair({
    this.name,
    this.value,
  });

  GoogleCloudAiplatformV1FetchFeatureValuesResponseFeatureNameValuePairListFeatureNameValuePair.fromJson(
      core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          value: json_.containsKey('value')
              ? GoogleCloudAiplatformV1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// Request message for PredictionService.FetchPredictOperation.
class GoogleCloudAiplatformV1FetchPredictOperationRequest {
  /// The server-assigned name for the operation.
  ///
  /// Required.
  core.String? operationName;

  GoogleCloudAiplatformV1FetchPredictOperationRequest({
    this.operationName,
  });

  GoogleCloudAiplatformV1FetchPredictOperationRequest.fromJson(core.Map json_)
      : this(
          operationName: json_['operationName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (operationName != null) 'operationName': operationName!,
      };
}

/// URI based data.
class GoogleCloudAiplatformV1FileData {
  /// Display name of the file data.
  ///
  /// Used to provide a label or filename to distinguish file datas. This field
  /// is only returned in PromptMessage for prompt management. It is not
  /// currently used in the Gemini GenerateContent calls.
  ///
  /// Optional.
  core.String? displayName;

  /// URI.
  ///
  /// Required.
  core.String? fileUri;

  /// The IANA standard MIME type of the source data.
  ///
  /// Required.
  core.String? mimeType;

  GoogleCloudAiplatformV1FileData({
    this.displayName,
    this.fileUri,
    this.mimeType,
  });

  GoogleCloudAiplatformV1FileData.fromJson(core.Map json_)
      : this(
          displayName: json_['displayName'] as core.String?,
          fileUri: json_['fileUri'] as core.String?,
          mimeType: json_['mimeType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
        if (fileUri != null) 'fileUri': fileUri!,
        if (mimeType != null) 'mimeType': mimeType!,
      };
}

/// RagFile status.
class GoogleCloudAiplatformV1FileStatus {
  /// Only when the `state` field is ERROR.
  ///
  /// Output only.
  core.String? errorStatus;

  /// RagFile state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : RagFile state is unspecified.
  /// - "ACTIVE" : RagFile resource has been created and indexed successfully.
  /// - "ERROR" : RagFile resource is in a problematic state. See
  /// `error_message` field for details.
  core.String? state;

  GoogleCloudAiplatformV1FileStatus({
    this.errorStatus,
    this.state,
  });

  GoogleCloudAiplatformV1FileStatus.fromJson(core.Map json_)
      : this(
          errorStatus: json_['errorStatus'] as core.String?,
          state: json_['state'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (errorStatus != null) 'errorStatus': errorStatus!,
        if (state != null) 'state': state!,
      };
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored.
///
/// Currently only supported for Datasets containing DataItems. If any of the
/// filters in this message are to match nothing, then they can be set as '-'
/// (the minus sign). Supported only for unstructured Datasets.
typedef GoogleCloudAiplatformV1FilterSplit = $FilterSplit;

/// The request message for MatchService.FindNeighbors.
class GoogleCloudAiplatformV1FindNeighborsRequest {
  /// The ID of the DeployedIndex that will serve the request.
  ///
  /// This request is sent to a specific IndexEndpoint, as per the
  /// IndexEndpoint.network. That IndexEndpoint also has
  /// IndexEndpoint.deployed_indexes, and each such index has a DeployedIndex.id
  /// field. The value of the field below must equal one of the DeployedIndex.id
  /// fields of the IndexEndpoint that is being called for this request.
  core.String? deployedIndexId;

  /// The list of queries.
  core.List<GoogleCloudAiplatformV1FindNeighborsRequestQuery>? queries;

  /// If set to true, the full datapoints (including all vector values and
  /// restricts) of the nearest neighbors are returned.
  ///
  /// Note that returning full datapoint will significantly increase the latency
  /// and cost of the query.
  core.bool? returnFullDatapoint;

  GoogleCloudAiplatformV1FindNeighborsRequest({
    this.deployedIndexId,
    this.queries,
    this.returnFullDatapoint,
  });

  GoogleCloudAiplatformV1FindNeighborsRequest.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_['deployedIndexId'] as core.String?,
          queries: (json_['queries'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FindNeighborsRequestQuery.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          returnFullDatapoint: json_['returnFullDatapoint'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
        if (queries != null) 'queries': queries!,
        if (returnFullDatapoint != null)
          'returnFullDatapoint': returnFullDatapoint!,
      };
}

/// A query to find a number of the nearest neighbors (most similar vectors) of
/// a vector.
class GoogleCloudAiplatformV1FindNeighborsRequestQuery {
  /// The number of neighbors to find via approximate search before exact
  /// reordering is performed.
  ///
  /// If not set, the default value from scam config is used; if set, this value
  /// must be \> 0.
  core.int? approximateNeighborCount;

  /// The datapoint/vector whose nearest neighbors should be searched for.
  ///
  /// Required.
  GoogleCloudAiplatformV1IndexDatapoint? datapoint;

  /// The fraction of the number of leaves to search, set at query time allows
  /// user to tune search performance.
  ///
  /// This value increase result in both search accuracy and latency increase.
  /// The value should be between 0.0 and 1.0. If not set or set to 0.0, query
  /// uses the default value specified in
  /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
  core.double? fractionLeafNodesToSearchOverride;

  /// The number of nearest neighbors to be retrieved from database for each
  /// query.
  ///
  /// If not set, will use the default from the service configuration
  /// (https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config).
  core.int? neighborCount;

  /// Crowding is a constraint on a neighbor list produced by nearest neighbor
  /// search requiring that no more than some value k' of the k neighbors
  /// returned have the same value of crowding_attribute.
  ///
  /// It's used for improving result diversity. This field is the maximum number
  /// of matches with the same crowding tag.
  core.int? perCrowdingAttributeNeighborCount;

  /// Represents RRF algorithm that combines search results.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FindNeighborsRequestQueryRRF? rrf;

  GoogleCloudAiplatformV1FindNeighborsRequestQuery({
    this.approximateNeighborCount,
    this.datapoint,
    this.fractionLeafNodesToSearchOverride,
    this.neighborCount,
    this.perCrowdingAttributeNeighborCount,
    this.rrf,
  });

  GoogleCloudAiplatformV1FindNeighborsRequestQuery.fromJson(core.Map json_)
      : this(
          approximateNeighborCount:
              json_['approximateNeighborCount'] as core.int?,
          datapoint: json_.containsKey('datapoint')
              ? GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                  json_['datapoint'] as core.Map<core.String, core.dynamic>)
              : null,
          fractionLeafNodesToSearchOverride:
              (json_['fractionLeafNodesToSearchOverride'] as core.num?)
                  ?.toDouble(),
          neighborCount: json_['neighborCount'] as core.int?,
          perCrowdingAttributeNeighborCount:
              json_['perCrowdingAttributeNeighborCount'] as core.int?,
          rrf: json_.containsKey('rrf')
              ? GoogleCloudAiplatformV1FindNeighborsRequestQueryRRF.fromJson(
                  json_['rrf'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (approximateNeighborCount != null)
          'approximateNeighborCount': approximateNeighborCount!,
        if (datapoint != null) 'datapoint': datapoint!,
        if (fractionLeafNodesToSearchOverride != null)
          'fractionLeafNodesToSearchOverride':
              fractionLeafNodesToSearchOverride!,
        if (neighborCount != null) 'neighborCount': neighborCount!,
        if (perCrowdingAttributeNeighborCount != null)
          'perCrowdingAttributeNeighborCount':
              perCrowdingAttributeNeighborCount!,
        if (rrf != null) 'rrf': rrf!,
      };
}

/// Parameters for RRF algorithm that combines search results.
class GoogleCloudAiplatformV1FindNeighborsRequestQueryRRF {
  /// Users can provide an alpha value to give more weight to dense vs sparse
  /// results.
  ///
  /// For example, if the alpha is 0, we only return sparse and if the alpha is
  /// 1, we only return dense.
  ///
  /// Required.
  core.double? alpha;

  GoogleCloudAiplatformV1FindNeighborsRequestQueryRRF({
    this.alpha,
  });

  GoogleCloudAiplatformV1FindNeighborsRequestQueryRRF.fromJson(core.Map json_)
      : this(
          alpha: (json_['alpha'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (alpha != null) 'alpha': alpha!,
      };
}

/// The response message for MatchService.FindNeighbors.
class GoogleCloudAiplatformV1FindNeighborsResponse {
  /// The nearest neighbors of the query datapoints.
  core.List<GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors>?
      nearestNeighbors;

  GoogleCloudAiplatformV1FindNeighborsResponse({
    this.nearestNeighbors,
  });

  GoogleCloudAiplatformV1FindNeighborsResponse.fromJson(core.Map json_)
      : this(
          nearestNeighbors: (json_['nearestNeighbors'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nearestNeighbors != null) 'nearestNeighbors': nearestNeighbors!,
      };
}

/// Nearest neighbors for one query.
class GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors {
  /// The ID of the query datapoint.
  core.String? id;

  /// All its neighbors.
  core.List<GoogleCloudAiplatformV1FindNeighborsResponseNeighbor>? neighbors;

  GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors({
    this.id,
    this.neighbors,
  });

  GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors.fromJson(
      core.Map json_)
      : this(
          id: json_['id'] as core.String?,
          neighbors: (json_['neighbors'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FindNeighborsResponseNeighbor.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (neighbors != null) 'neighbors': neighbors!,
      };
}

/// A neighbor of the query vector.
class GoogleCloudAiplatformV1FindNeighborsResponseNeighbor {
  /// The datapoint of the neighbor.
  ///
  /// Note that full datapoints are returned only when "return_full_datapoint"
  /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
  /// fields are populated.
  GoogleCloudAiplatformV1IndexDatapoint? datapoint;

  /// The distance between the neighbor and the dense embedding query.
  core.double? distance;

  /// The distance between the neighbor and the query sparse_embedding.
  core.double? sparseDistance;

  GoogleCloudAiplatformV1FindNeighborsResponseNeighbor({
    this.datapoint,
    this.distance,
    this.sparseDistance,
  });

  GoogleCloudAiplatformV1FindNeighborsResponseNeighbor.fromJson(core.Map json_)
      : this(
          datapoint: json_.containsKey('datapoint')
              ? GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                  json_['datapoint'] as core.Map<core.String, core.dynamic>)
              : null,
          distance: (json_['distance'] as core.num?)?.toDouble(),
          sparseDistance: (json_['sparseDistance'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapoint != null) 'datapoint': datapoint!,
        if (distance != null) 'distance': distance!,
        if (sparseDistance != null) 'sparseDistance': sparseDistance!,
      };
}

/// Input for fluency metric.
class GoogleCloudAiplatformV1FluencyInput {
  /// Fluency instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1FluencyInstance? instance;

  /// Spec for fluency score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1FluencySpec? metricSpec;

  GoogleCloudAiplatformV1FluencyInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1FluencyInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1FluencyInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1FluencySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for fluency instance.
typedef GoogleCloudAiplatformV1FluencyInstance = $Instance01;

/// Spec for fluency result.
class GoogleCloudAiplatformV1FluencyResult {
  /// Confidence for fluency score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for fluency score.
  ///
  /// Output only.
  core.String? explanation;

  /// Fluency score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1FluencyResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1FluencyResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for fluency score metric.
typedef GoogleCloudAiplatformV1FluencySpec = $Spec;

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions.
///
/// Any of `training_fraction`, `validation_fraction` and `test_fraction` may
/// optionally be provided, they must sum to up to 1. If the provided ones sum
/// to less than 1, the remainder is assigned to sets as decided by Vertex AI.
/// If none of the fractions are set, by default roughly 80% of data is used for
/// training, 10% for validation, and 10% for test.
typedef GoogleCloudAiplatformV1FractionSplit = $FractionSplit;

/// Input for fulfillment metric.
class GoogleCloudAiplatformV1FulfillmentInput {
  /// Fulfillment instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1FulfillmentInstance? instance;

  /// Spec for fulfillment score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1FulfillmentSpec? metricSpec;

  GoogleCloudAiplatformV1FulfillmentInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1FulfillmentInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1FulfillmentInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1FulfillmentSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for fulfillment instance.
class GoogleCloudAiplatformV1FulfillmentInstance {
  /// Inference instruction prompt to compare prediction with.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  GoogleCloudAiplatformV1FulfillmentInstance({
    this.instruction,
    this.prediction,
  });

  GoogleCloudAiplatformV1FulfillmentInstance.fromJson(core.Map json_)
      : this(
          instruction: json_['instruction'] as core.String?,
          prediction: json_['prediction'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instruction != null) 'instruction': instruction!,
        if (prediction != null) 'prediction': prediction!,
      };
}

/// Spec for fulfillment result.
class GoogleCloudAiplatformV1FulfillmentResult {
  /// Confidence for fulfillment score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for fulfillment score.
  ///
  /// Output only.
  core.String? explanation;

  /// Fulfillment score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1FulfillmentResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1FulfillmentResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for fulfillment metric.
typedef GoogleCloudAiplatformV1FulfillmentSpec = $Spec;

/// A predicted \[FunctionCall\] returned from the model that contains a string
/// representing the \[FunctionDeclaration.name\] and a structured JSON object
/// containing the parameters and their values.
class GoogleCloudAiplatformV1FunctionCall {
  /// The function parameters and values in JSON object format.
  ///
  /// See \[FunctionDeclaration.parameters\] for parameter details.
  ///
  /// Optional. Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? args;

  /// The name of the function to call.
  ///
  /// Matches \[FunctionDeclaration.name\].
  ///
  /// Required.
  core.String? name;

  GoogleCloudAiplatformV1FunctionCall({
    this.args,
    this.name,
  });

  GoogleCloudAiplatformV1FunctionCall.fromJson(core.Map json_)
      : this(
          args: json_.containsKey('args')
              ? json_['args'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_['name'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (args != null) 'args': args!,
        if (name != null) 'name': name!,
      };
}

/// Function calling config.
class GoogleCloudAiplatformV1FunctionCallingConfig {
  /// Function names to call.
  ///
  /// Only set when the Mode is ANY. Function names should match
  /// \[FunctionDeclaration.name\]. With mode set to ANY, model will predict a
  /// function call from the set of function names provided.
  ///
  /// Optional.
  core.List<core.String>? allowedFunctionNames;

  /// Function calling mode.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MODE_UNSPECIFIED" : Unspecified function calling mode. This value
  /// should not be used.
  /// - "AUTO" : Default model behavior, model decides to predict either
  /// function calls or natural language response.
  /// - "ANY" : Model is constrained to always predicting function calls only.
  /// If "allowed_function_names" are set, the predicted function calls will be
  /// limited to any one of "allowed_function_names", else the predicted
  /// function calls will be any one of the provided "function_declarations".
  /// - "NONE" : Model will not predict any function calls. Model behavior is
  /// same as when not passing any function declarations.
  core.String? mode;

  GoogleCloudAiplatformV1FunctionCallingConfig({
    this.allowedFunctionNames,
    this.mode,
  });

  GoogleCloudAiplatformV1FunctionCallingConfig.fromJson(core.Map json_)
      : this(
          allowedFunctionNames: (json_['allowedFunctionNames'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          mode: json_['mode'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowedFunctionNames != null)
          'allowedFunctionNames': allowedFunctionNames!,
        if (mode != null) 'mode': mode!,
      };
}

/// Structured representation of a function declaration as defined by the
/// [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3).
///
/// Included in this declaration are the function name, description, parameters
/// and response type. This FunctionDeclaration is a representation of a block
/// of code that can be used as a `Tool` by the model and executed by the
/// client.
class GoogleCloudAiplatformV1FunctionDeclaration {
  /// Description and purpose of the function.
  ///
  /// Model uses it to decide how and whether to call the function.
  ///
  /// Optional.
  core.String? description;

  /// The name of the function to call.
  ///
  /// Must start with a letter or an underscore. Must be a-z, A-Z, 0-9, or
  /// contain underscores, dots and dashes, with a maximum length of 64.
  ///
  /// Required.
  core.String? name;

  /// Describes the parameters to this function in JSON Schema Object format.
  ///
  /// Reflects the Open API 3.03 Parameter Object. string Key: the name of the
  /// parameter. Parameter names are case sensitive. Schema Value: the Schema
  /// defining the type used for the parameter. For function with no parameters,
  /// this can be left unset. Parameter names must start with a letter or an
  /// underscore and must only contain chars a-z, A-Z, 0-9, or underscores with
  /// a maximum length of 64. Example with 1 required and 1 optional parameter:
  /// type: OBJECT properties: param1: type: STRING param2: type: INTEGER
  /// required: - param1
  ///
  /// Optional.
  GoogleCloudAiplatformV1Schema? parameters;

  /// Describes the output from this function in JSON Schema format.
  ///
  /// Reflects the Open API 3.03 Response Object. The Schema defines the type
  /// used for the response value of the function.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Schema? response;

  GoogleCloudAiplatformV1FunctionDeclaration({
    this.description,
    this.name,
    this.parameters,
    this.response,
  });

  GoogleCloudAiplatformV1FunctionDeclaration.fromJson(core.Map json_)
      : this(
          description: json_['description'] as core.String?,
          name: json_['name'] as core.String?,
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1Schema.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
          response: json_.containsKey('response')
              ? GoogleCloudAiplatformV1Schema.fromJson(
                  json_['response'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (name != null) 'name': name!,
        if (parameters != null) 'parameters': parameters!,
        if (response != null) 'response': response!,
      };
}

/// The result output from a \[FunctionCall\] that contains a string
/// representing the \[FunctionDeclaration.name\] and a structured JSON object
/// containing any output from the function is used as context to the model.
///
/// This should contain the result of a \[FunctionCall\] made based on model
/// prediction.
class GoogleCloudAiplatformV1FunctionResponse {
  /// The name of the function to call.
  ///
  /// Matches \[FunctionDeclaration.name\] and \[FunctionCall.name\].
  ///
  /// Required.
  core.String? name;

  /// The function response in JSON object format.
  ///
  /// Use "output" key to specify function output and "error" key to specify
  /// error details (if any). If "output" and "error" keys are not specified,
  /// then whole "response" is treated as function output.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? response;

  GoogleCloudAiplatformV1FunctionResponse({
    this.name,
    this.response,
  });

  GoogleCloudAiplatformV1FunctionResponse.fromJson(core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          response: json_.containsKey('response')
              ? json_['response'] as core.Map<core.String, core.dynamic>
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (response != null) 'response': response!,
      };
}

/// The Google Cloud Storage location where the output is to be written to.
class GoogleCloudAiplatformV1GcsDestination {
  /// Google Cloud Storage URI to output directory.
  ///
  /// If the uri doesn't end with '/', a '/' will be automatically appended. The
  /// directory is created if it doesn't exist.
  ///
  /// Required.
  core.String? outputUriPrefix;

  GoogleCloudAiplatformV1GcsDestination({
    this.outputUriPrefix,
  });

  GoogleCloudAiplatformV1GcsDestination.fromJson(core.Map json_)
      : this(
          outputUriPrefix: json_['outputUriPrefix'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputUriPrefix != null) 'outputUriPrefix': outputUriPrefix!,
      };
}

/// The Google Cloud Storage location for the input content.
class GoogleCloudAiplatformV1GcsSource {
  /// Google Cloud Storage URI(-s) to the input file(s).
  ///
  /// May contain wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
  ///
  /// Required.
  core.List<core.String>? uris;

  GoogleCloudAiplatformV1GcsSource({
    this.uris,
  });

  GoogleCloudAiplatformV1GcsSource.fromJson(core.Map json_)
      : this(
          uris: (json_['uris'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (uris != null) 'uris': uris!,
      };
}

/// Configuration for GenAiAdvancedFeatures.
class GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfig {
  /// Configuration for Retrieval Augmented Generation feature.
  GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfigRagConfig? ragConfig;

  GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfig({
    this.ragConfig,
  });

  GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfig.fromJson(core.Map json_)
      : this(
          ragConfig: json_.containsKey('ragConfig')
              ? GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfigRagConfig
                  .fromJson(
                      json_['ragConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragConfig != null) 'ragConfig': ragConfig!,
      };
}

/// Configuration for Retrieval Augmented Generation feature.
class GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfigRagConfig {
  /// If true, enable Retrieval Augmented Generation in ChatCompletion request.
  ///
  /// Once enabled, the endpoint will be identified as GenAI endpoint and
  /// Arthedain router will be used.
  core.bool? enableRag;

  GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfigRagConfig({
    this.enableRag,
  });

  GoogleCloudAiplatformV1GenAiAdvancedFeaturesConfigRagConfig.fromJson(
      core.Map json_)
      : this(
          enableRag: json_['enableRag'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableRag != null) 'enableRag': enableRag!,
      };
}

/// Request message for \[PredictionService.GenerateContent\].
class GoogleCloudAiplatformV1GenerateContentRequest {
  /// The name of the cached content used as context to serve the prediction.
  ///
  /// Note: only used in explicit caching, where users can have control over
  /// caching (e.g. what content to cache) and enjoy guaranteed cost savings.
  /// Format:
  /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
  ///
  /// Optional.
  core.String? cachedContent;

  /// The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn
  /// queries, this is a repeated field that contains conversation history +
  /// latest request.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1Content>? contents;

  /// Generation config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1GenerationConfig? generationConfig;

  /// The labels with user-defined metadata for the request.
  ///
  /// It is used for billing and reporting only. Label keys and values can be no
  /// longer than 63 characters (Unicode codepoints) and can only contain
  /// lowercase letters, numeric characters, underscores, and dashes.
  /// International characters are allowed. Label values are optional. Label
  /// keys must start with a letter.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Per request settings for blocking unsafe content.
  ///
  /// Enforced on GenerateContentResponse.candidates.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1SafetySetting>? safetySettings;

  /// The user provided system instructions for the model.
  ///
  /// Note: only text should be used in parts and content in each part will be
  /// in a separate paragraph.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Content? systemInstruction;

  /// Tool config.
  ///
  /// This config is shared for all tools provided in the request.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ToolConfig? toolConfig;

  /// A list of `Tools` the model may use to generate the next response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Tool>? tools;

  GoogleCloudAiplatformV1GenerateContentRequest({
    this.cachedContent,
    this.contents,
    this.generationConfig,
    this.labels,
    this.safetySettings,
    this.systemInstruction,
    this.toolConfig,
    this.tools,
  });

  GoogleCloudAiplatformV1GenerateContentRequest.fromJson(core.Map json_)
      : this(
          cachedContent: json_['cachedContent'] as core.String?,
          contents: (json_['contents'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Content.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          generationConfig: json_.containsKey('generationConfig')
              ? GoogleCloudAiplatformV1GenerationConfig.fromJson(
                  json_['generationConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          safetySettings: (json_['safetySettings'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1SafetySetting.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          systemInstruction: json_.containsKey('systemInstruction')
              ? GoogleCloudAiplatformV1Content.fromJson(
                  json_['systemInstruction']
                      as core.Map<core.String, core.dynamic>)
              : null,
          toolConfig: json_.containsKey('toolConfig')
              ? GoogleCloudAiplatformV1ToolConfig.fromJson(
                  json_['toolConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          tools: (json_['tools'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tool.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cachedContent != null) 'cachedContent': cachedContent!,
        if (contents != null) 'contents': contents!,
        if (generationConfig != null) 'generationConfig': generationConfig!,
        if (labels != null) 'labels': labels!,
        if (safetySettings != null) 'safetySettings': safetySettings!,
        if (systemInstruction != null) 'systemInstruction': systemInstruction!,
        if (toolConfig != null) 'toolConfig': toolConfig!,
        if (tools != null) 'tools': tools!,
      };
}

/// Response message for \[PredictionService.GenerateContent\].
class GoogleCloudAiplatformV1GenerateContentResponse {
  /// Generated candidates.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Candidate>? candidates;

  /// Timestamp when the request is made to the server.
  ///
  /// Output only.
  core.String? createTime;

  /// The model version used to generate the response.
  ///
  /// Output only.
  core.String? modelVersion;

  /// Content filter results for a prompt sent in the request.
  ///
  /// Note: Sent only in the first stream chunk. Only happens when no candidates
  /// were generated due to content violations.
  ///
  /// Output only.
  GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback? promptFeedback;

  /// response_id is used to identify each response.
  ///
  /// It is the encoding of the event_id.
  ///
  /// Output only.
  core.String? responseId;

  /// Usage metadata about the response(s).
  GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata? usageMetadata;

  GoogleCloudAiplatformV1GenerateContentResponse({
    this.candidates,
    this.createTime,
    this.modelVersion,
    this.promptFeedback,
    this.responseId,
    this.usageMetadata,
  });

  GoogleCloudAiplatformV1GenerateContentResponse.fromJson(core.Map json_)
      : this(
          candidates: (json_['candidates'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Candidate.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          createTime: json_['createTime'] as core.String?,
          modelVersion: json_['modelVersion'] as core.String?,
          promptFeedback: json_.containsKey('promptFeedback')
              ? GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback
                  .fromJson(json_['promptFeedback']
                      as core.Map<core.String, core.dynamic>)
              : null,
          responseId: json_['responseId'] as core.String?,
          usageMetadata: json_.containsKey('usageMetadata')
              ? GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata
                  .fromJson(json_['usageMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (candidates != null) 'candidates': candidates!,
        if (createTime != null) 'createTime': createTime!,
        if (modelVersion != null) 'modelVersion': modelVersion!,
        if (promptFeedback != null) 'promptFeedback': promptFeedback!,
        if (responseId != null) 'responseId': responseId!,
        if (usageMetadata != null) 'usageMetadata': usageMetadata!,
      };
}

/// Content filter results for a prompt sent in the request.
class GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback {
  /// Blocked reason.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "BLOCKED_REASON_UNSPECIFIED" : Unspecified blocked reason.
  /// - "SAFETY" : Candidates blocked due to safety.
  /// - "OTHER" : Candidates blocked due to other reason.
  /// - "BLOCKLIST" : Candidates blocked due to the terms which are included
  /// from the terminology blocklist.
  /// - "PROHIBITED_CONTENT" : Candidates blocked due to prohibited content.
  core.String? blockReason;

  /// A readable block reason message.
  ///
  /// Output only.
  core.String? blockReasonMessage;

  /// Safety ratings.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1SafetyRating>? safetyRatings;

  GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback({
    this.blockReason,
    this.blockReasonMessage,
    this.safetyRatings,
  });

  GoogleCloudAiplatformV1GenerateContentResponsePromptFeedback.fromJson(
      core.Map json_)
      : this(
          blockReason: json_['blockReason'] as core.String?,
          blockReasonMessage: json_['blockReasonMessage'] as core.String?,
          safetyRatings: (json_['safetyRatings'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1SafetyRating.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blockReason != null) 'blockReason': blockReason!,
        if (blockReasonMessage != null)
          'blockReasonMessage': blockReasonMessage!,
        if (safetyRatings != null) 'safetyRatings': safetyRatings!,
      };
}

/// Usage metadata about response(s).
class GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata {
  /// List of modalities of the cached content in the request input.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModalityTokenCount>? cacheTokensDetails;

  /// Number of tokens in the cached part in the input (the cached content).
  ///
  /// Output only.
  core.int? cachedContentTokenCount;

  /// Number of tokens in the response(s).
  core.int? candidatesTokenCount;

  /// List of modalities that were returned in the response.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModalityTokenCount>? candidatesTokensDetails;

  /// Number of tokens in the request.
  ///
  /// When `cached_content` is set, this is still the total effective prompt
  /// size meaning this includes the number of tokens in the cached content.
  core.int? promptTokenCount;

  /// List of modalities that were processed in the request input.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModalityTokenCount>? promptTokensDetails;

  /// Number of tokens present in tool-use prompt(s).
  ///
  /// Output only.
  core.int? toolUsePromptTokenCount;

  /// List of modalities that were processed for tool-use request inputs.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModalityTokenCount>?
      toolUsePromptTokensDetails;

  /// Total token count for prompt, response candidates, and tool-use prompts
  /// (if present).
  core.int? totalTokenCount;

  GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata({
    this.cacheTokensDetails,
    this.cachedContentTokenCount,
    this.candidatesTokenCount,
    this.candidatesTokensDetails,
    this.promptTokenCount,
    this.promptTokensDetails,
    this.toolUsePromptTokenCount,
    this.toolUsePromptTokensDetails,
    this.totalTokenCount,
  });

  GoogleCloudAiplatformV1GenerateContentResponseUsageMetadata.fromJson(
      core.Map json_)
      : this(
          cacheTokensDetails: (json_['cacheTokensDetails'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModalityTokenCount.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          cachedContentTokenCount:
              json_['cachedContentTokenCount'] as core.int?,
          candidatesTokenCount: json_['candidatesTokenCount'] as core.int?,
          candidatesTokensDetails:
              (json_['candidatesTokensDetails'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ModalityTokenCount.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
          promptTokenCount: json_['promptTokenCount'] as core.int?,
          promptTokensDetails: (json_['promptTokensDetails'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModalityTokenCount.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          toolUsePromptTokenCount:
              json_['toolUsePromptTokenCount'] as core.int?,
          toolUsePromptTokensDetails:
              (json_['toolUsePromptTokensDetails'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ModalityTokenCount.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
          totalTokenCount: json_['totalTokenCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cacheTokensDetails != null)
          'cacheTokensDetails': cacheTokensDetails!,
        if (cachedContentTokenCount != null)
          'cachedContentTokenCount': cachedContentTokenCount!,
        if (candidatesTokenCount != null)
          'candidatesTokenCount': candidatesTokenCount!,
        if (candidatesTokensDetails != null)
          'candidatesTokensDetails': candidatesTokensDetails!,
        if (promptTokenCount != null) 'promptTokenCount': promptTokenCount!,
        if (promptTokensDetails != null)
          'promptTokensDetails': promptTokensDetails!,
        if (toolUsePromptTokenCount != null)
          'toolUsePromptTokenCount': toolUsePromptTokenCount!,
        if (toolUsePromptTokensDetails != null)
          'toolUsePromptTokensDetails': toolUsePromptTokensDetails!,
        if (totalTokenCount != null) 'totalTokenCount': totalTokenCount!,
      };
}

/// Generation config.
class GoogleCloudAiplatformV1GenerationConfig {
  /// If enabled, audio timestamp will be included in the request to the model.
  ///
  /// Optional.
  core.bool? audioTimestamp;

  /// Number of candidates to generate.
  ///
  /// Optional.
  core.int? candidateCount;

  /// Frequency penalties.
  ///
  /// Optional.
  core.double? frequencyPenalty;

  /// Logit probabilities.
  ///
  /// Optional.
  core.int? logprobs;

  /// The maximum number of output tokens to generate per message.
  ///
  /// Optional.
  core.int? maxOutputTokens;

  /// If specified, the media resolution specified will be used.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "MEDIA_RESOLUTION_UNSPECIFIED" : Media resolution has not been set.
  /// - "MEDIA_RESOLUTION_LOW" : Media resolution set to low (64 tokens).
  /// - "MEDIA_RESOLUTION_MEDIUM" : Media resolution set to medium (256 tokens).
  /// - "MEDIA_RESOLUTION_HIGH" : Media resolution set to high (zoomed reframing
  /// with 256 tokens).
  core.String? mediaResolution;

  /// Positive penalties.
  ///
  /// Optional.
  core.double? presencePenalty;

  /// If true, export the logprobs results in response.
  ///
  /// Optional.
  core.bool? responseLogprobs;

  /// Output response mimetype of the generated candidate text.
  ///
  /// Supported mimetype: - `text/plain`: (default) Text output. -
  /// `application/json`: JSON response in the candidates. The model needs to be
  /// prompted to output the appropriate response type, otherwise the behavior
  /// is undefined. This is a preview feature.
  ///
  /// Optional.
  core.String? responseMimeType;

  /// The modalities of the response.
  ///
  /// Optional.
  core.List<core.String>? responseModalities;

  /// The `Schema` object allows the definition of input and output data types.
  ///
  /// These types can be objects, but also primitives and arrays. Represents a
  /// select subset of an
  /// [OpenAPI 3.0 schema object](https://spec.openapis.org/oas/v3.0.3#schema).
  /// If set, a compatible response_mime_type must also be set. Compatible
  /// mimetypes: `application/json`: Schema for JSON response.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Schema? responseSchema;

  /// Routing configuration.
  ///
  /// Optional.
  GoogleCloudAiplatformV1GenerationConfigRoutingConfig? routingConfig;

  /// Seed.
  ///
  /// Optional.
  core.int? seed;

  /// The speech generation config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1SpeechConfig? speechConfig;

  /// Stop sequences.
  ///
  /// Optional.
  core.List<core.String>? stopSequences;

  /// Controls the randomness of predictions.
  ///
  /// Optional.
  core.double? temperature;

  /// If specified, top-k sampling will be used.
  ///
  /// Optional.
  core.double? topK;

  /// If specified, nucleus sampling will be used.
  ///
  /// Optional.
  core.double? topP;

  GoogleCloudAiplatformV1GenerationConfig({
    this.audioTimestamp,
    this.candidateCount,
    this.frequencyPenalty,
    this.logprobs,
    this.maxOutputTokens,
    this.mediaResolution,
    this.presencePenalty,
    this.responseLogprobs,
    this.responseMimeType,
    this.responseModalities,
    this.responseSchema,
    this.routingConfig,
    this.seed,
    this.speechConfig,
    this.stopSequences,
    this.temperature,
    this.topK,
    this.topP,
  });

  GoogleCloudAiplatformV1GenerationConfig.fromJson(core.Map json_)
      : this(
          audioTimestamp: json_['audioTimestamp'] as core.bool?,
          candidateCount: json_['candidateCount'] as core.int?,
          frequencyPenalty:
              (json_['frequencyPenalty'] as core.num?)?.toDouble(),
          logprobs: json_['logprobs'] as core.int?,
          maxOutputTokens: json_['maxOutputTokens'] as core.int?,
          mediaResolution: json_['mediaResolution'] as core.String?,
          presencePenalty: (json_['presencePenalty'] as core.num?)?.toDouble(),
          responseLogprobs: json_['responseLogprobs'] as core.bool?,
          responseMimeType: json_['responseMimeType'] as core.String?,
          responseModalities: (json_['responseModalities'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          responseSchema: json_.containsKey('responseSchema')
              ? GoogleCloudAiplatformV1Schema.fromJson(json_['responseSchema']
                  as core.Map<core.String, core.dynamic>)
              : null,
          routingConfig: json_.containsKey('routingConfig')
              ? GoogleCloudAiplatformV1GenerationConfigRoutingConfig.fromJson(
                  json_['routingConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          seed: json_['seed'] as core.int?,
          speechConfig: json_.containsKey('speechConfig')
              ? GoogleCloudAiplatformV1SpeechConfig.fromJson(
                  json_['speechConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          stopSequences: (json_['stopSequences'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          temperature: (json_['temperature'] as core.num?)?.toDouble(),
          topK: (json_['topK'] as core.num?)?.toDouble(),
          topP: (json_['topP'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (audioTimestamp != null) 'audioTimestamp': audioTimestamp!,
        if (candidateCount != null) 'candidateCount': candidateCount!,
        if (frequencyPenalty != null) 'frequencyPenalty': frequencyPenalty!,
        if (logprobs != null) 'logprobs': logprobs!,
        if (maxOutputTokens != null) 'maxOutputTokens': maxOutputTokens!,
        if (mediaResolution != null) 'mediaResolution': mediaResolution!,
        if (presencePenalty != null) 'presencePenalty': presencePenalty!,
        if (responseLogprobs != null) 'responseLogprobs': responseLogprobs!,
        if (responseMimeType != null) 'responseMimeType': responseMimeType!,
        if (responseModalities != null)
          'responseModalities': responseModalities!,
        if (responseSchema != null) 'responseSchema': responseSchema!,
        if (routingConfig != null) 'routingConfig': routingConfig!,
        if (seed != null) 'seed': seed!,
        if (speechConfig != null) 'speechConfig': speechConfig!,
        if (stopSequences != null) 'stopSequences': stopSequences!,
        if (temperature != null) 'temperature': temperature!,
        if (topK != null) 'topK': topK!,
        if (topP != null) 'topP': topP!,
      };
}

/// The configuration for routing the request to a specific model.
class GoogleCloudAiplatformV1GenerationConfigRoutingConfig {
  /// Automated routing.
  GoogleCloudAiplatformV1GenerationConfigRoutingConfigAutoRoutingMode? autoMode;

  /// Manual routing.
  GoogleCloudAiplatformV1GenerationConfigRoutingConfigManualRoutingMode?
      manualMode;

  GoogleCloudAiplatformV1GenerationConfigRoutingConfig({
    this.autoMode,
    this.manualMode,
  });

  GoogleCloudAiplatformV1GenerationConfigRoutingConfig.fromJson(core.Map json_)
      : this(
          autoMode: json_.containsKey('autoMode')
              ? GoogleCloudAiplatformV1GenerationConfigRoutingConfigAutoRoutingMode
                  .fromJson(
                      json_['autoMode'] as core.Map<core.String, core.dynamic>)
              : null,
          manualMode: json_.containsKey('manualMode')
              ? GoogleCloudAiplatformV1GenerationConfigRoutingConfigManualRoutingMode
                  .fromJson(json_['manualMode']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoMode != null) 'autoMode': autoMode!,
        if (manualMode != null) 'manualMode': manualMode!,
      };
}

/// When automated routing is specified, the routing will be determined by the
/// pretrained routing model and customer provided model routing preference.
class GoogleCloudAiplatformV1GenerationConfigRoutingConfigAutoRoutingMode {
  /// The model routing preference.
  /// Possible string values are:
  /// - "UNKNOWN" : Unspecified model routing preference.
  /// - "PRIORITIZE_QUALITY" : Prefer higher quality over low cost.
  /// - "BALANCED" : Balanced model routing preference.
  /// - "PRIORITIZE_COST" : Prefer lower cost over higher quality.
  core.String? modelRoutingPreference;

  GoogleCloudAiplatformV1GenerationConfigRoutingConfigAutoRoutingMode({
    this.modelRoutingPreference,
  });

  GoogleCloudAiplatformV1GenerationConfigRoutingConfigAutoRoutingMode.fromJson(
      core.Map json_)
      : this(
          modelRoutingPreference:
              json_['modelRoutingPreference'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelRoutingPreference != null)
          'modelRoutingPreference': modelRoutingPreference!,
      };
}

/// When manual routing is set, the specified model will be used directly.
class GoogleCloudAiplatformV1GenerationConfigRoutingConfigManualRoutingMode {
  /// The model name to use.
  ///
  /// Only the public LLM models are accepted. e.g. 'gemini-1.5-pro-001'.
  core.String? modelName;

  GoogleCloudAiplatformV1GenerationConfigRoutingConfigManualRoutingMode({
    this.modelName,
  });

  GoogleCloudAiplatformV1GenerationConfigRoutingConfigManualRoutingMode.fromJson(
      core.Map json_)
      : this(
          modelName: json_['modelName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelName != null) 'modelName': modelName!,
      };
}

/// Contains information about the source of the models generated from
/// Generative AI Studio.
class GoogleCloudAiplatformV1GenieSource {
  /// The public base model URI.
  ///
  /// Required.
  core.String? baseModelUri;

  GoogleCloudAiplatformV1GenieSource({
    this.baseModelUri,
  });

  GoogleCloudAiplatformV1GenieSource.fromJson(core.Map json_)
      : this(
          baseModelUri: json_['baseModelUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baseModelUri != null) 'baseModelUri': baseModelUri!,
      };
}

/// The Google Drive location for the input content.
class GoogleCloudAiplatformV1GoogleDriveSource {
  /// Google Drive resource IDs.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1GoogleDriveSourceResourceId>? resourceIds;

  GoogleCloudAiplatformV1GoogleDriveSource({
    this.resourceIds,
  });

  GoogleCloudAiplatformV1GoogleDriveSource.fromJson(core.Map json_)
      : this(
          resourceIds: (json_['resourceIds'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1GoogleDriveSourceResourceId.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourceIds != null) 'resourceIds': resourceIds!,
      };
}

/// The type and ID of the Google Drive resource.
class GoogleCloudAiplatformV1GoogleDriveSourceResourceId {
  /// The ID of the Google Drive resource.
  ///
  /// Required.
  core.String? resourceId;

  /// The type of the Google Drive resource.
  ///
  /// Required.
  /// Possible string values are:
  /// - "RESOURCE_TYPE_UNSPECIFIED" : Unspecified resource type.
  /// - "RESOURCE_TYPE_FILE" : File resource type.
  /// - "RESOURCE_TYPE_FOLDER" : Folder resource type.
  core.String? resourceType;

  GoogleCloudAiplatformV1GoogleDriveSourceResourceId({
    this.resourceId,
    this.resourceType,
  });

  GoogleCloudAiplatformV1GoogleDriveSourceResourceId.fromJson(core.Map json_)
      : this(
          resourceId: json_['resourceId'] as core.String?,
          resourceType: json_['resourceType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourceId != null) 'resourceId': resourceId!,
        if (resourceType != null) 'resourceType': resourceType!,
      };
}

/// Tool to retrieve public web data for grounding, powered by Google.
class GoogleCloudAiplatformV1GoogleSearchRetrieval {
  /// Specifies the dynamic retrieval configuration for the given source.
  GoogleCloudAiplatformV1DynamicRetrievalConfig? dynamicRetrievalConfig;

  GoogleCloudAiplatformV1GoogleSearchRetrieval({
    this.dynamicRetrievalConfig,
  });

  GoogleCloudAiplatformV1GoogleSearchRetrieval.fromJson(core.Map json_)
      : this(
          dynamicRetrievalConfig: json_.containsKey('dynamicRetrievalConfig')
              ? GoogleCloudAiplatformV1DynamicRetrievalConfig.fromJson(
                  json_['dynamicRetrievalConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dynamicRetrievalConfig != null)
          'dynamicRetrievalConfig': dynamicRetrievalConfig!,
      };
}

/// Input for groundedness metric.
class GoogleCloudAiplatformV1GroundednessInput {
  /// Groundedness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1GroundednessInstance? instance;

  /// Spec for groundedness metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1GroundednessSpec? metricSpec;

  GoogleCloudAiplatformV1GroundednessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1GroundednessInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1GroundednessInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1GroundednessSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for groundedness instance.
class GoogleCloudAiplatformV1GroundednessInstance {
  /// Background information provided in context used to compare against the
  /// prediction.
  ///
  /// Required.
  core.String? context;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  GoogleCloudAiplatformV1GroundednessInstance({
    this.context,
    this.prediction,
  });

  GoogleCloudAiplatformV1GroundednessInstance.fromJson(core.Map json_)
      : this(
          context: json_['context'] as core.String?,
          prediction: json_['prediction'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (context != null) 'context': context!,
        if (prediction != null) 'prediction': prediction!,
      };
}

/// Spec for groundedness result.
class GoogleCloudAiplatformV1GroundednessResult {
  /// Confidence for groundedness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for groundedness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Groundedness score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1GroundednessResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1GroundednessResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for groundedness metric.
typedef GoogleCloudAiplatformV1GroundednessSpec = $Spec;

/// Grounding chunk.
class GoogleCloudAiplatformV1GroundingChunk {
  /// Grounding chunk from context retrieved by the retrieval tools.
  GoogleCloudAiplatformV1GroundingChunkRetrievedContext? retrievedContext;

  /// Grounding chunk from the web.
  GoogleCloudAiplatformV1GroundingChunkWeb? web;

  GoogleCloudAiplatformV1GroundingChunk({
    this.retrievedContext,
    this.web,
  });

  GoogleCloudAiplatformV1GroundingChunk.fromJson(core.Map json_)
      : this(
          retrievedContext: json_.containsKey('retrievedContext')
              ? GoogleCloudAiplatformV1GroundingChunkRetrievedContext.fromJson(
                  json_['retrievedContext']
                      as core.Map<core.String, core.dynamic>)
              : null,
          web: json_.containsKey('web')
              ? GoogleCloudAiplatformV1GroundingChunkWeb.fromJson(
                  json_['web'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (retrievedContext != null) 'retrievedContext': retrievedContext!,
        if (web != null) 'web': web!,
      };
}

/// Chunk from context retrieved by the retrieval tools.
class GoogleCloudAiplatformV1GroundingChunkRetrievedContext {
  /// Text of the attribution.
  core.String? text;

  /// Title of the attribution.
  core.String? title;

  /// URI reference of the attribution.
  core.String? uri;

  GoogleCloudAiplatformV1GroundingChunkRetrievedContext({
    this.text,
    this.title,
    this.uri,
  });

  GoogleCloudAiplatformV1GroundingChunkRetrievedContext.fromJson(core.Map json_)
      : this(
          text: json_['text'] as core.String?,
          title: json_['title'] as core.String?,
          uri: json_['uri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (text != null) 'text': text!,
        if (title != null) 'title': title!,
        if (uri != null) 'uri': uri!,
      };
}

/// Chunk from the web.
class GoogleCloudAiplatformV1GroundingChunkWeb {
  /// Title of the chunk.
  core.String? title;

  /// URI reference of the chunk.
  core.String? uri;

  GoogleCloudAiplatformV1GroundingChunkWeb({
    this.title,
    this.uri,
  });

  GoogleCloudAiplatformV1GroundingChunkWeb.fromJson(core.Map json_)
      : this(
          title: json_['title'] as core.String?,
          uri: json_['uri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (title != null) 'title': title!,
        if (uri != null) 'uri': uri!,
      };
}

/// Metadata returned to client when grounding is enabled.
class GoogleCloudAiplatformV1GroundingMetadata {
  /// List of supporting references retrieved from specified grounding source.
  core.List<GoogleCloudAiplatformV1GroundingChunk>? groundingChunks;

  /// List of grounding support.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1GroundingSupport>? groundingSupports;

  /// Retrieval metadata.
  ///
  /// Optional. Output only.
  GoogleCloudAiplatformV1RetrievalMetadata? retrievalMetadata;

  /// Google search entry for the following-up web searches.
  ///
  /// Optional.
  GoogleCloudAiplatformV1SearchEntryPoint? searchEntryPoint;

  /// Web search queries for the following-up web search.
  ///
  /// Optional.
  core.List<core.String>? webSearchQueries;

  GoogleCloudAiplatformV1GroundingMetadata({
    this.groundingChunks,
    this.groundingSupports,
    this.retrievalMetadata,
    this.searchEntryPoint,
    this.webSearchQueries,
  });

  GoogleCloudAiplatformV1GroundingMetadata.fromJson(core.Map json_)
      : this(
          groundingChunks: (json_['groundingChunks'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1GroundingChunk.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          groundingSupports: (json_['groundingSupports'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1GroundingSupport.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          retrievalMetadata: json_.containsKey('retrievalMetadata')
              ? GoogleCloudAiplatformV1RetrievalMetadata.fromJson(
                  json_['retrievalMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          searchEntryPoint: json_.containsKey('searchEntryPoint')
              ? GoogleCloudAiplatformV1SearchEntryPoint.fromJson(
                  json_['searchEntryPoint']
                      as core.Map<core.String, core.dynamic>)
              : null,
          webSearchQueries: (json_['webSearchQueries'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (groundingChunks != null) 'groundingChunks': groundingChunks!,
        if (groundingSupports != null) 'groundingSupports': groundingSupports!,
        if (retrievalMetadata != null) 'retrievalMetadata': retrievalMetadata!,
        if (searchEntryPoint != null) 'searchEntryPoint': searchEntryPoint!,
        if (webSearchQueries != null) 'webSearchQueries': webSearchQueries!,
      };
}

/// Grounding support.
class GoogleCloudAiplatformV1GroundingSupport {
  /// Confidence score of the support references.
  ///
  /// Ranges from 0 to 1. 1 is the most confident. This list must have the same
  /// size as the grounding_chunk_indices.
  core.List<core.double>? confidenceScores;

  /// A list of indices (into 'grounding_chunk') specifying the citations
  /// associated with the claim.
  ///
  /// For instance \[1,3,4\] means that grounding_chunk\[1\],
  /// grounding_chunk\[3\], grounding_chunk\[4\] are the retrieved content
  /// attributed to the claim.
  core.List<core.int>? groundingChunkIndices;

  /// Segment of the content this support belongs to.
  GoogleCloudAiplatformV1Segment? segment;

  GoogleCloudAiplatformV1GroundingSupport({
    this.confidenceScores,
    this.groundingChunkIndices,
    this.segment,
  });

  GoogleCloudAiplatformV1GroundingSupport.fromJson(core.Map json_)
      : this(
          confidenceScores: (json_['confidenceScores'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
          groundingChunkIndices: (json_['groundingChunkIndices'] as core.List?)
              ?.map((value) => value as core.int)
              .toList(),
          segment: json_.containsKey('segment')
              ? GoogleCloudAiplatformV1Segment.fromJson(
                  json_['segment'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidenceScores != null) 'confidenceScores': confidenceScores!,
        if (groundingChunkIndices != null)
          'groundingChunkIndices': groundingChunkIndices!,
        if (segment != null) 'segment': segment!,
      };
}

/// Represents a HyperparameterTuningJob.
///
/// A HyperparameterTuningJob has a Study specification and multiple CustomJobs
/// with identical CustomJob specification.
class GoogleCloudAiplatformV1HyperparameterTuningJob {
  /// Time when the HyperparameterTuningJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the HyperparameterTuningJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a HyperparameterTuningJob.
  ///
  /// If this is set, then all resources created by the HyperparameterTuningJob
  /// will be encrypted with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the HyperparameterTuningJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize
  /// HyperparameterTuningJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The number of failed Trials that need to be seen before failing the
  /// HyperparameterTuningJob.
  ///
  /// If set to 0, Vertex AI decides how many Trials must fail before the whole
  /// job fails.
  core.int? maxFailedTrialCount;

  /// The desired total number of Trials.
  ///
  /// Required.
  core.int? maxTrialCount;

  /// Resource name of the HyperparameterTuningJob.
  ///
  /// Output only.
  core.String? name;

  /// The desired number of Trials to run in parallel.
  ///
  /// Required.
  core.int? parallelTrialCount;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the HyperparameterTuningJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Study configuration of the HyperparameterTuningJob.
  ///
  /// Required.
  GoogleCloudAiplatformV1StudySpec? studySpec;

  /// The spec of a trial job.
  ///
  /// The same spec applies to the CustomJobs created in all the trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? trialJobSpec;

  /// Trials of the HyperparameterTuningJob.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Trial>? trials;

  /// Time when the HyperparameterTuningJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1HyperparameterTuningJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.labels,
    this.maxFailedTrialCount,
    this.maxTrialCount,
    this.name,
    this.parallelTrialCount,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.studySpec,
    this.trialJobSpec,
    this.trials,
    this.updateTime,
  });

  GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          maxFailedTrialCount: json_['maxFailedTrialCount'] as core.int?,
          maxTrialCount: json_['maxTrialCount'] as core.int?,
          name: json_['name'] as core.String?,
          parallelTrialCount: json_['parallelTrialCount'] as core.int?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          studySpec: json_.containsKey('studySpec')
              ? GoogleCloudAiplatformV1StudySpec.fromJson(
                  json_['studySpec'] as core.Map<core.String, core.dynamic>)
              : null,
          trialJobSpec: json_.containsKey('trialJobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['trialJobSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          trials: (json_['trials'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Trial.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (labels != null) 'labels': labels!,
        if (maxFailedTrialCount != null)
          'maxFailedTrialCount': maxFailedTrialCount!,
        if (maxTrialCount != null) 'maxTrialCount': maxTrialCount!,
        if (name != null) 'name': name!,
        if (parallelTrialCount != null)
          'parallelTrialCount': parallelTrialCount!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (studySpec != null) 'studySpec': studySpec!,
        if (trialJobSpec != null) 'trialJobSpec': trialJobSpec!,
        if (trials != null) 'trials': trials!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Matcher for Features of an EntityType by Feature ID.
class GoogleCloudAiplatformV1IdMatcher {
  /// The following are accepted as `ids`: * A single-element list containing
  /// only `*`, which selects all Features in the target EntityType, or * A list
  /// containing only Feature IDs, which selects only Features with those IDs in
  /// the target EntityType.
  ///
  /// Required.
  core.List<core.String>? ids;

  GoogleCloudAiplatformV1IdMatcher({
    this.ids,
  });

  GoogleCloudAiplatformV1IdMatcher.fromJson(core.Map json_)
      : this(
          ids: (json_['ids'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ids != null) 'ids': ids!,
      };
}

/// Describes the location from where we import data into a Dataset, together
/// with the labels that will be applied to the DataItems and the Annotations.
class GoogleCloudAiplatformV1ImportDataConfig {
  /// Labels that will be applied to newly imported Annotations.
  ///
  /// If two Annotations are identical, one of them will be deduped. Two
  /// Annotations are considered identical if their payload, payload_schema_uri
  /// and all of their labels are the same. These labels will be overridden by
  /// Annotation labels specified inside index file referenced by
  /// import_schema_uri, e.g. jsonl file.
  core.Map<core.String, core.String>? annotationLabels;

  /// Labels that will be applied to newly imported DataItems.
  ///
  /// If an identical DataItem as one being imported already exists in the
  /// Dataset, then these labels will be appended to these of the already
  /// existing one, and if labels with identical key is imported before, the old
  /// label value will be overwritten. If two DataItems are identical in the
  /// same import data operation, the labels will be combined and if key
  /// collision happens in this case, one of the values will be picked randomly.
  /// Two DataItems are considered identical if their content bytes are
  /// identical (e.g. image bytes or pdf bytes). These labels will be overridden
  /// by Annotation labels specified inside index file referenced by
  /// import_schema_uri, e.g. jsonl file.
  core.Map<core.String, core.String>? dataItemLabels;

  /// The Google Cloud Storage location for the input content.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// Points to a YAML file stored on Google Cloud Storage describing the import
  /// format.
  ///
  /// Validation will be done against the schema. The schema is defined as an
  /// [OpenAPI 3.0.2 Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  ///
  /// Required.
  core.String? importSchemaUri;

  GoogleCloudAiplatformV1ImportDataConfig({
    this.annotationLabels,
    this.dataItemLabels,
    this.gcsSource,
    this.importSchemaUri,
  });

  GoogleCloudAiplatformV1ImportDataConfig.fromJson(core.Map json_)
      : this(
          annotationLabels: (json_['annotationLabels']
                  as core.Map<core.String, core.dynamic>?)
              ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          dataItemLabels:
              (json_['dataItemLabels'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          importSchemaUri: json_['importSchemaUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationLabels != null) 'annotationLabels': annotationLabels!,
        if (dataItemLabels != null) 'dataItemLabels': dataItemLabels!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (importSchemaUri != null) 'importSchemaUri': importSchemaUri!,
      };
}

/// Request message for DatasetService.ImportData.
class GoogleCloudAiplatformV1ImportDataRequest {
  /// The desired input locations.
  ///
  /// The contents of all input locations will be imported in one batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ImportDataConfig>? importConfigs;

  GoogleCloudAiplatformV1ImportDataRequest({
    this.importConfigs,
  });

  GoogleCloudAiplatformV1ImportDataRequest.fromJson(core.Map json_)
      : this(
          importConfigs: (json_['importConfigs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1ImportDataConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (importConfigs != null) 'importConfigs': importConfigs!,
      };
}

/// Request message for FeaturestoreService.ImportFeatureValues.
class GoogleCloudAiplatformV1ImportFeatureValuesRequest {
  GoogleCloudAiplatformV1AvroSource? avroSource;
  GoogleCloudAiplatformV1BigQuerySource? bigquerySource;
  GoogleCloudAiplatformV1CsvSource? csvSource;

  /// If true, API doesn't start ingestion analysis pipeline.
  core.bool? disableIngestionAnalysis;

  /// If set, data will not be imported for online serving.
  ///
  /// This is typically used for backfilling, where Feature generation
  /// timestamps are not in the timestamp range needed for online serving.
  core.bool? disableOnlineServing;

  /// Source column that holds entity IDs.
  ///
  /// If not provided, entity IDs are extracted from the column named entity_id.
  core.String? entityIdField;

  /// Specifications defining which Feature values to import from the entity.
  ///
  /// The request fails if no feature_specs are provided, and having multiple
  /// feature_specs for one Feature is not allowed.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec>?
      featureSpecs;

  /// Single Feature timestamp for all entities being imported.
  ///
  /// The timestamp must not have higher than millisecond precision.
  core.String? featureTime;

  /// Source column that holds the Feature timestamp for all Feature values in
  /// each entity.
  core.String? featureTimeField;

  /// Specifies the number of workers that are used to write data to the
  /// Featurestore.
  ///
  /// Consider the online serving capacity that you require to achieve the
  /// desired import throughput without interfering with online serving. The
  /// value must be positive, and less than or equal to 100. If not set,
  /// defaults to using 1 worker. The low count ensures minimal impact on online
  /// serving performance.
  core.int? workerCount;

  GoogleCloudAiplatformV1ImportFeatureValuesRequest({
    this.avroSource,
    this.bigquerySource,
    this.csvSource,
    this.disableIngestionAnalysis,
    this.disableOnlineServing,
    this.entityIdField,
    this.featureSpecs,
    this.featureTime,
    this.featureTimeField,
    this.workerCount,
  });

  GoogleCloudAiplatformV1ImportFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          avroSource: json_.containsKey('avroSource')
              ? GoogleCloudAiplatformV1AvroSource.fromJson(
                  json_['avroSource'] as core.Map<core.String, core.dynamic>)
              : null,
          bigquerySource: json_.containsKey('bigquerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          csvSource: json_.containsKey('csvSource')
              ? GoogleCloudAiplatformV1CsvSource.fromJson(
                  json_['csvSource'] as core.Map<core.String, core.dynamic>)
              : null,
          disableIngestionAnalysis:
              json_['disableIngestionAnalysis'] as core.bool?,
          disableOnlineServing: json_['disableOnlineServing'] as core.bool?,
          entityIdField: json_['entityIdField'] as core.String?,
          featureSpecs: (json_['featureSpecs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          featureTime: json_['featureTime'] as core.String?,
          featureTimeField: json_['featureTimeField'] as core.String?,
          workerCount: json_['workerCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (avroSource != null) 'avroSource': avroSource!,
        if (bigquerySource != null) 'bigquerySource': bigquerySource!,
        if (csvSource != null) 'csvSource': csvSource!,
        if (disableIngestionAnalysis != null)
          'disableIngestionAnalysis': disableIngestionAnalysis!,
        if (disableOnlineServing != null)
          'disableOnlineServing': disableOnlineServing!,
        if (entityIdField != null) 'entityIdField': entityIdField!,
        if (featureSpecs != null) 'featureSpecs': featureSpecs!,
        if (featureTime != null) 'featureTime': featureTime!,
        if (featureTimeField != null) 'featureTimeField': featureTimeField!,
        if (workerCount != null) 'workerCount': workerCount!,
      };
}

/// Defines the Feature value(s) to import.
class GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec {
  /// ID of the Feature to import values of.
  ///
  /// This Feature must exist in the target EntityType, or the request will
  /// fail.
  ///
  /// Required.
  core.String? id;

  /// Source column to get the Feature values from.
  ///
  /// If not set, uses the column with the same name as the Feature ID.
  core.String? sourceField;

  GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec({
    this.id,
    this.sourceField,
  });

  GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec.fromJson(
      core.Map json_)
      : this(
          id: json_['id'] as core.String?,
          sourceField: json_['sourceField'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (sourceField != null) 'sourceField': sourceField!,
      };
}

/// Request message for ModelService.ImportModelEvaluation
class GoogleCloudAiplatformV1ImportModelEvaluationRequest {
  /// Model evaluation resource to be imported.
  ///
  /// Required.
  GoogleCloudAiplatformV1ModelEvaluation? modelEvaluation;

  GoogleCloudAiplatformV1ImportModelEvaluationRequest({
    this.modelEvaluation,
  });

  GoogleCloudAiplatformV1ImportModelEvaluationRequest.fromJson(core.Map json_)
      : this(
          modelEvaluation: json_.containsKey('modelEvaluation')
              ? GoogleCloudAiplatformV1ModelEvaluation.fromJson(
                  json_['modelEvaluation']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelEvaluation != null) 'modelEvaluation': modelEvaluation!,
      };
}

/// Config for importing RagFiles.
class GoogleCloudAiplatformV1ImportRagFilesConfig {
  /// Google Cloud Storage location.
  ///
  /// Supports importing individual files as well as entire Google Cloud Storage
  /// directories. Sample formats: -
  /// `gs://bucket_name/my_directory/object_name/my_file.txt` -
  /// `gs://bucket_name/my_directory`
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// Google Drive location.
  ///
  /// Supports importing individual files as well as Google Drive folders.
  GoogleCloudAiplatformV1GoogleDriveSource? googleDriveSource;

  /// Jira queries with their corresponding authentication.
  GoogleCloudAiplatformV1JiraSource? jiraSource;

  /// The max number of queries per minute that this job is allowed to make to
  /// the embedding model specified on the corpus.
  ///
  /// This value is specific to this job and not shared across other import
  /// jobs. Consult the Quotas page on the project to set an appropriate value
  /// here. If unspecified, a default value of 1,000 QPM would be used.
  ///
  /// Optional.
  core.int? maxEmbeddingRequestsPerMin;

  /// The BigQuery destination to write partial failures to.
  ///
  /// It should be a bigquery table resource name (e.g.
  /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
  /// table does not exist, it will be created with the expected schema. If the
  /// table exists, the schema will be validated and data will be added to this
  /// existing table. Deprecated. Prefer to use `import_result_bq_sink`.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1BigQueryDestination? partialFailureBigquerySink;

  /// The Cloud Storage path to write partial failures to.
  ///
  /// Deprecated. Prefer to use `import_result_gcs_sink`.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudAiplatformV1GcsDestination? partialFailureGcsSink;

  /// Specifies the transformation config for RagFiles.
  GoogleCloudAiplatformV1RagFileTransformationConfig?
      ragFileTransformationConfig;

  /// SharePoint sources.
  GoogleCloudAiplatformV1SharePointSources? sharePointSources;

  /// Slack channels with their corresponding access tokens.
  GoogleCloudAiplatformV1SlackSource? slackSource;

  GoogleCloudAiplatformV1ImportRagFilesConfig({
    this.gcsSource,
    this.googleDriveSource,
    this.jiraSource,
    this.maxEmbeddingRequestsPerMin,
    this.partialFailureBigquerySink,
    this.partialFailureGcsSink,
    this.ragFileTransformationConfig,
    this.sharePointSources,
    this.slackSource,
  });

  GoogleCloudAiplatformV1ImportRagFilesConfig.fromJson(core.Map json_)
      : this(
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          googleDriveSource: json_.containsKey('googleDriveSource')
              ? GoogleCloudAiplatformV1GoogleDriveSource.fromJson(
                  json_['googleDriveSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          jiraSource: json_.containsKey('jiraSource')
              ? GoogleCloudAiplatformV1JiraSource.fromJson(
                  json_['jiraSource'] as core.Map<core.String, core.dynamic>)
              : null,
          maxEmbeddingRequestsPerMin:
              json_['maxEmbeddingRequestsPerMin'] as core.int?,
          partialFailureBigquerySink:
              json_.containsKey('partialFailureBigquerySink')
                  ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                      json_['partialFailureBigquerySink']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          partialFailureGcsSink: json_.containsKey('partialFailureGcsSink')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['partialFailureGcsSink']
                      as core.Map<core.String, core.dynamic>)
              : null,
          ragFileTransformationConfig:
              json_.containsKey('ragFileTransformationConfig')
                  ? GoogleCloudAiplatformV1RagFileTransformationConfig.fromJson(
                      json_['ragFileTransformationConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          sharePointSources: json_.containsKey('sharePointSources')
              ? GoogleCloudAiplatformV1SharePointSources.fromJson(
                  json_['sharePointSources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          slackSource: json_.containsKey('slackSource')
              ? GoogleCloudAiplatformV1SlackSource.fromJson(
                  json_['slackSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (googleDriveSource != null) 'googleDriveSource': googleDriveSource!,
        if (jiraSource != null) 'jiraSource': jiraSource!,
        if (maxEmbeddingRequestsPerMin != null)
          'maxEmbeddingRequestsPerMin': maxEmbeddingRequestsPerMin!,
        if (partialFailureBigquerySink != null)
          'partialFailureBigquerySink': partialFailureBigquerySink!,
        if (partialFailureGcsSink != null)
          'partialFailureGcsSink': partialFailureGcsSink!,
        if (ragFileTransformationConfig != null)
          'ragFileTransformationConfig': ragFileTransformationConfig!,
        if (sharePointSources != null) 'sharePointSources': sharePointSources!,
        if (slackSource != null) 'slackSource': slackSource!,
      };
}

/// Request message for VertexRagDataService.ImportRagFiles.
class GoogleCloudAiplatformV1ImportRagFilesRequest {
  /// The config for the RagFiles to be synced and imported into the RagCorpus.
  ///
  /// VertexRagDataService.ImportRagFiles.
  ///
  /// Required.
  GoogleCloudAiplatformV1ImportRagFilesConfig? importRagFilesConfig;

  GoogleCloudAiplatformV1ImportRagFilesRequest({
    this.importRagFilesConfig,
  });

  GoogleCloudAiplatformV1ImportRagFilesRequest.fromJson(core.Map json_)
      : this(
          importRagFilesConfig: json_.containsKey('importRagFilesConfig')
              ? GoogleCloudAiplatformV1ImportRagFilesConfig.fromJson(
                  json_['importRagFilesConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (importRagFilesConfig != null)
          'importRagFilesConfig': importRagFilesConfig!,
      };
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
class GoogleCloudAiplatformV1Index {
  /// Timestamp when this Index was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The pointers to DeployedIndexes created from this Index.
  ///
  /// An Index can be only deleted if all its DeployedIndexes had been
  /// undeployed first.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedIndexRef>? deployedIndexes;

  /// The description of the Index.
  core.String? description;

  /// The display name of the Index.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for an Index.
  ///
  /// If set, this Index and all sub-resources of this Index will be secured by
  /// this key.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Stats of the index resource.
  ///
  /// Output only.
  GoogleCloudAiplatformV1IndexStats? indexStats;

  /// The update method to use with this Index.
  ///
  /// If not set, BATCH_UPDATE will be used by default.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "INDEX_UPDATE_METHOD_UNSPECIFIED" : Should not be used.
  /// - "BATCH_UPDATE" : BatchUpdate: user can call UpdateIndex with files on
  /// Cloud Storage of Datapoints to update.
  /// - "STREAM_UPDATE" : StreamUpdate: user can call
  /// UpsertDatapoints/DeleteDatapoints to update the Index and the updates will
  /// be applied in corresponding DeployedIndexes in nearly real-time.
  core.String? indexUpdateMethod;

  /// The labels with user-defined metadata to organize your Indexes.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// An additional information about the Index; the schema of the metadata can
  /// be found in metadata_schema.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Index, that is specific to it.
  ///
  /// Unset if the Index does not have any additional information. The schema is
  /// defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  ///
  /// Immutable.
  core.String? metadataSchemaUri;

  /// The resource name of the Index.
  ///
  /// Output only.
  core.String? name;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this Index was most recently updated.
  ///
  /// This also includes any update to the contents of the Index. Note that
  /// Operations working on this Index may have their
  /// Operations.metadata.generic_metadata.update_time a little after the value
  /// of this timestamp, yet that does not mean their results are not already
  /// reflected in the Index. Result of any successfully completed Operation on
  /// the Index is reflected in it.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Index({
    this.createTime,
    this.deployedIndexes,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.indexStats,
    this.indexUpdateMethod,
    this.labels,
    this.metadata,
    this.metadataSchemaUri,
    this.name,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Index.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          deployedIndexes: (json_['deployedIndexes'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DeployedIndexRef.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          indexStats: json_.containsKey('indexStats')
              ? GoogleCloudAiplatformV1IndexStats.fromJson(
                  json_['indexStats'] as core.Map<core.String, core.dynamic>)
              : null,
          indexUpdateMethod: json_['indexUpdateMethod'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          metadata: json_['metadata'],
          metadataSchemaUri: json_['metadataSchemaUri'] as core.String?,
          name: json_['name'] as core.String?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (deployedIndexes != null) 'deployedIndexes': deployedIndexes!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (indexStats != null) 'indexStats': indexStats!,
        if (indexUpdateMethod != null) 'indexUpdateMethod': indexUpdateMethod!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
        if (name != null) 'name': name!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A datapoint of Index.
class GoogleCloudAiplatformV1IndexDatapoint {
  /// CrowdingTag of the datapoint, the number of neighbors to return in each
  /// crowding can be configured during query.
  ///
  /// Optional.
  GoogleCloudAiplatformV1IndexDatapointCrowdingTag? crowdingTag;

  /// Unique identifier of the datapoint.
  ///
  /// Required.
  core.String? datapointId;

  /// Feature embedding vector for dense index.
  ///
  /// An array of numbers with the length of
  /// \[NearestNeighborSearchConfig.dimensions\].
  ///
  /// Required.
  core.List<core.double>? featureVector;

  /// List of Restrict of the datapoint, used to perform "restricted searches"
  /// where boolean rule are used to filter the subset of the database eligible
  /// for matching.
  ///
  /// This uses numeric comparisons.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1IndexDatapointNumericRestriction>?
      numericRestricts;

  /// List of Restrict of the datapoint, used to perform "restricted searches"
  /// where boolean rule are used to filter the subset of the database eligible
  /// for matching.
  ///
  /// This uses categorical tokens. See:
  /// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1IndexDatapointRestriction>? restricts;

  /// Feature embedding vector for sparse index.
  ///
  /// Optional.
  GoogleCloudAiplatformV1IndexDatapointSparseEmbedding? sparseEmbedding;

  GoogleCloudAiplatformV1IndexDatapoint({
    this.crowdingTag,
    this.datapointId,
    this.featureVector,
    this.numericRestricts,
    this.restricts,
    this.sparseEmbedding,
  });

  GoogleCloudAiplatformV1IndexDatapoint.fromJson(core.Map json_)
      : this(
          crowdingTag: json_.containsKey('crowdingTag')
              ? GoogleCloudAiplatformV1IndexDatapointCrowdingTag.fromJson(
                  json_['crowdingTag'] as core.Map<core.String, core.dynamic>)
              : null,
          datapointId: json_['datapointId'] as core.String?,
          featureVector: (json_['featureVector'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
          numericRestricts: (json_['numericRestricts'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1IndexDatapointNumericRestriction
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          restricts: (json_['restricts'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1IndexDatapointRestriction.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          sparseEmbedding: json_.containsKey('sparseEmbedding')
              ? GoogleCloudAiplatformV1IndexDatapointSparseEmbedding.fromJson(
                  json_['sparseEmbedding']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (crowdingTag != null) 'crowdingTag': crowdingTag!,
        if (datapointId != null) 'datapointId': datapointId!,
        if (featureVector != null) 'featureVector': featureVector!,
        if (numericRestricts != null) 'numericRestricts': numericRestricts!,
        if (restricts != null) 'restricts': restricts!,
        if (sparseEmbedding != null) 'sparseEmbedding': sparseEmbedding!,
      };
}

/// Crowding tag is a constraint on a neighbor list produced by nearest neighbor
/// search requiring that no more than some value k' of the k neighbors returned
/// have the same value of crowding_attribute.
class GoogleCloudAiplatformV1IndexDatapointCrowdingTag {
  /// The attribute value used for crowding.
  ///
  /// The maximum number of neighbors to return per crowding attribute value
  /// (per_crowding_attribute_num_neighbors) is configured per-query. This field
  /// is ignored if per_crowding_attribute_num_neighbors is larger than the
  /// total number of neighbors to return for a given query.
  core.String? crowdingAttribute;

  GoogleCloudAiplatformV1IndexDatapointCrowdingTag({
    this.crowdingAttribute,
  });

  GoogleCloudAiplatformV1IndexDatapointCrowdingTag.fromJson(core.Map json_)
      : this(
          crowdingAttribute: json_['crowdingAttribute'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (crowdingAttribute != null) 'crowdingAttribute': crowdingAttribute!,
      };
}

/// This field allows restricts to be based on numeric comparisons rather than
/// categorical tokens.
class GoogleCloudAiplatformV1IndexDatapointNumericRestriction {
  /// The namespace of this restriction.
  ///
  /// e.g.: cost.
  core.String? namespace;

  /// This MUST be specified for queries and must NOT be specified for
  /// datapoints.
  /// Possible string values are:
  /// - "OPERATOR_UNSPECIFIED" : Default value of the enum.
  /// - "LESS" : Datapoints are eligible iff their value is \< the query's.
  /// - "LESS_EQUAL" : Datapoints are eligible iff their value is \<= the
  /// query's.
  /// - "EQUAL" : Datapoints are eligible iff their value is == the query's.
  /// - "GREATER_EQUAL" : Datapoints are eligible iff their value is \>= the
  /// query's.
  /// - "GREATER" : Datapoints are eligible iff their value is \> the query's.
  /// - "NOT_EQUAL" : Datapoints are eligible iff their value is != the query's.
  core.String? op;

  /// Represents 64 bit float.
  core.double? valueDouble;

  /// Represents 32 bit float.
  core.double? valueFloat;

  /// Represents 64 bit integer.
  core.String? valueInt;

  GoogleCloudAiplatformV1IndexDatapointNumericRestriction({
    this.namespace,
    this.op,
    this.valueDouble,
    this.valueFloat,
    this.valueInt,
  });

  GoogleCloudAiplatformV1IndexDatapointNumericRestriction.fromJson(
      core.Map json_)
      : this(
          namespace: json_['namespace'] as core.String?,
          op: json_['op'] as core.String?,
          valueDouble: (json_['valueDouble'] as core.num?)?.toDouble(),
          valueFloat: (json_['valueFloat'] as core.num?)?.toDouble(),
          valueInt: json_['valueInt'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (namespace != null) 'namespace': namespace!,
        if (op != null) 'op': op!,
        if (valueDouble != null) 'valueDouble': valueDouble!,
        if (valueFloat != null) 'valueFloat': valueFloat!,
        if (valueInt != null) 'valueInt': valueInt!,
      };
}

/// Restriction of a datapoint which describe its attributes(tokens) from each
/// of several attribute categories(namespaces).
class GoogleCloudAiplatformV1IndexDatapointRestriction {
  /// The attributes to allow in this namespace.
  ///
  /// e.g.: 'red'
  core.List<core.String>? allowList;

  /// The attributes to deny in this namespace.
  ///
  /// e.g.: 'blue'
  core.List<core.String>? denyList;

  /// The namespace of this restriction.
  ///
  /// e.g.: color.
  core.String? namespace;

  GoogleCloudAiplatformV1IndexDatapointRestriction({
    this.allowList,
    this.denyList,
    this.namespace,
  });

  GoogleCloudAiplatformV1IndexDatapointRestriction.fromJson(core.Map json_)
      : this(
          allowList: (json_['allowList'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          denyList: (json_['denyList'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          namespace: json_['namespace'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowList != null) 'allowList': allowList!,
        if (denyList != null) 'denyList': denyList!,
        if (namespace != null) 'namespace': namespace!,
      };
}

/// Feature embedding vector for sparse index.
///
/// An array of numbers whose values are located in the specified dimensions.
class GoogleCloudAiplatformV1IndexDatapointSparseEmbedding {
  /// The list of indexes for the embedding values of the sparse vector.
  ///
  /// Required.
  core.List<core.String>? dimensions;

  /// The list of embedding values of the sparse vector.
  ///
  /// Required.
  core.List<core.double>? values;

  GoogleCloudAiplatformV1IndexDatapointSparseEmbedding({
    this.dimensions,
    this.values,
  });

  GoogleCloudAiplatformV1IndexDatapointSparseEmbedding.fromJson(core.Map json_)
      : this(
          dimensions: (json_['dimensions'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          values: (json_['values'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dimensions != null) 'dimensions': dimensions!,
        if (values != null) 'values': values!,
      };
}

/// Indexes are deployed into it.
///
/// An IndexEndpoint can have multiple DeployedIndexes.
class GoogleCloudAiplatformV1IndexEndpoint {
  /// Timestamp when this IndexEndpoint was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The indexes deployed in this endpoint.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedIndex>? deployedIndexes;

  /// The description of the IndexEndpoint.
  core.String? description;

  /// The display name of the IndexEndpoint.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Deprecated: If true, expose the IndexEndpoint via private service connect.
  ///
  /// Only one of the fields, network or enable_private_service_connect, can be
  /// set.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enablePrivateServiceConnect;

  /// Customer-managed encryption key spec for an IndexEndpoint.
  ///
  /// If set, this IndexEndpoint and all sub-resources of this IndexEndpoint
  /// will be secured by this key.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your IndexEndpoints.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the IndexEndpoint.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
  /// to which the IndexEndpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If
  /// left unspecified, the Endpoint is not peered with any network. network and
  /// private_service_connect_config are mutually exclusive.
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in '12345', and {network} is network name.
  ///
  /// Optional.
  core.String? network;

  /// Configuration for private service connect.
  ///
  /// network and private_service_connect_config are mutually exclusive.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PrivateServiceConnectConfig?
      privateServiceConnectConfig;

  /// If public_endpoint_enabled is true, this field will be populated with the
  /// domain name to use for this index endpoint.
  ///
  /// Output only.
  core.String? publicEndpointDomainName;

  /// If true, the deployed index will be accessible through public endpoint.
  ///
  /// Optional.
  core.bool? publicEndpointEnabled;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this IndexEndpoint was last updated.
  ///
  /// This timestamp is not updated when the endpoint's DeployedIndexes are
  /// updated, e.g. due to updates of the original Indexes they are the
  /// deployments of.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1IndexEndpoint({
    this.createTime,
    this.deployedIndexes,
    this.description,
    this.displayName,
    this.enablePrivateServiceConnect,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.network,
    this.privateServiceConnectConfig,
    this.publicEndpointDomainName,
    this.publicEndpointEnabled,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1IndexEndpoint.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          deployedIndexes: (json_['deployedIndexes'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DeployedIndex.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          enablePrivateServiceConnect:
              json_['enablePrivateServiceConnect'] as core.bool?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          network: json_['network'] as core.String?,
          privateServiceConnectConfig:
              json_.containsKey('privateServiceConnectConfig')
                  ? GoogleCloudAiplatformV1PrivateServiceConnectConfig.fromJson(
                      json_['privateServiceConnectConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          publicEndpointDomainName:
              json_['publicEndpointDomainName'] as core.String?,
          publicEndpointEnabled: json_['publicEndpointEnabled'] as core.bool?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (deployedIndexes != null) 'deployedIndexes': deployedIndexes!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (enablePrivateServiceConnect != null)
          'enablePrivateServiceConnect': enablePrivateServiceConnect!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (privateServiceConnectConfig != null)
          'privateServiceConnectConfig': privateServiceConnectConfig!,
        if (publicEndpointDomainName != null)
          'publicEndpointDomainName': publicEndpointDomainName!,
        if (publicEndpointEnabled != null)
          'publicEndpointEnabled': publicEndpointEnabled!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// IndexPrivateEndpoints proto is used to provide paths for users to send
/// requests via private endpoints (e.g. private service access, private service
/// connect).
///
/// To send request via private service access, use match_grpc_address. To send
/// request via private service connect, use service_attachment.
class GoogleCloudAiplatformV1IndexPrivateEndpoints {
  /// The ip address used to send match gRPC requests.
  ///
  /// Output only.
  core.String? matchGrpcAddress;

  /// PscAutomatedEndpoints is populated if private service connect is enabled
  /// if PscAutomatedConfig is set.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1PscAutomatedEndpoints>?
      pscAutomatedEndpoints;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1IndexPrivateEndpoints({
    this.matchGrpcAddress,
    this.pscAutomatedEndpoints,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1IndexPrivateEndpoints.fromJson(core.Map json_)
      : this(
          matchGrpcAddress: json_['matchGrpcAddress'] as core.String?,
          pscAutomatedEndpoints: (json_['pscAutomatedEndpoints'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PscAutomatedEndpoints.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          serviceAttachment: json_['serviceAttachment'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (matchGrpcAddress != null) 'matchGrpcAddress': matchGrpcAddress!,
        if (pscAutomatedEndpoints != null)
          'pscAutomatedEndpoints': pscAutomatedEndpoints!,
        if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
      };
}

/// Stats of the Index.
class GoogleCloudAiplatformV1IndexStats {
  /// The number of shards in the Index.
  ///
  /// Output only.
  core.int? shardsCount;

  /// The number of sparse vectors in the Index.
  ///
  /// Output only.
  core.String? sparseVectorsCount;

  /// The number of dense vectors in the Index.
  ///
  /// Output only.
  core.String? vectorsCount;

  GoogleCloudAiplatformV1IndexStats({
    this.shardsCount,
    this.sparseVectorsCount,
    this.vectorsCount,
  });

  GoogleCloudAiplatformV1IndexStats.fromJson(core.Map json_)
      : this(
          shardsCount: json_['shardsCount'] as core.int?,
          sparseVectorsCount: json_['sparseVectorsCount'] as core.String?,
          vectorsCount: json_['vectorsCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (shardsCount != null) 'shardsCount': shardsCount!,
        if (sparseVectorsCount != null)
          'sparseVectorsCount': sparseVectorsCount!,
        if (vectorsCount != null) 'vectorsCount': vectorsCount!,
      };
}

/// Specifies Vertex AI owned input data to be used for training, and possibly
/// evaluating, the Model.
class GoogleCloudAiplatformV1InputDataConfig {
  /// Applicable only to custom training with Datasets that have DataItems and
  /// Annotations.
  ///
  /// Cloud Storage URI that points to a YAML file describing the annotation
  /// schema. The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/ , note that the
  /// chosen schema must be consistent with metadata of the Dataset specified by
  /// dataset_id. Only Annotations that both match this schema and belong to
  /// DataItems not ignored by the split method are used in respectively
  /// training, validation or test role, depending on the role of the DataItem
  /// they are on. When used in conjunction with annotations_filter, the
  /// Annotations used for training are filtered by both annotations_filter and
  /// annotation_schema_uri.
  core.String? annotationSchemaUri;

  /// Applicable only to Datasets that have DataItems and Annotations.
  ///
  /// A filter on Annotations of the Dataset. Only Annotations that both match
  /// this filter and belong to DataItems not ignored by the split method are
  /// used in respectively training, validation or test role, depending on the
  /// role of the DataItem they are on (for the auto-assigned that role is
  /// decided by Vertex AI). A filter with same syntax as the one used in
  /// ListAnnotations may be used, but note here it filters across all
  /// Annotations of the Dataset, and not just within a single DataItem.
  core.String? annotationsFilter;

  /// Only applicable to custom training with tabular Dataset with BigQuery
  /// source.
  ///
  /// The BigQuery project location where the training data is to be written to.
  /// In the given project a new dataset is created with name `dataset___` where
  /// timestamp is in YYYY_MM_DDThh_mm_ss_sssZ format. All training input data
  /// is written into that dataset. In the dataset three tables are created,
  /// `training`, `validation` and `test`. * AIP_DATA_FORMAT = "bigquery". *
  /// AIP_TRAINING_DATA_URI = "bigquery_destination.dataset___.training" *
  /// AIP_VALIDATION_DATA_URI = "bigquery_destination.dataset___.validation" *
  /// AIP_TEST_DATA_URI = "bigquery_destination.dataset___.test"
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// The ID of the Dataset in the same Project and Location which data will be
  /// used to train the Model.
  ///
  /// The Dataset must use schema compatible with Model being trained, and what
  /// is compatible should be described in the used TrainingPipeline's
  /// training_task_definition. For tabular Datasets, all their data is exported
  /// to training, to pick and choose from.
  ///
  /// Required.
  core.String? datasetId;

  /// Split based on the provided filters for each set.
  GoogleCloudAiplatformV1FilterSplit? filterSplit;

  /// Split based on fractions defining the size of each set.
  GoogleCloudAiplatformV1FractionSplit? fractionSplit;

  /// The Cloud Storage location where the training data is to be written to.
  ///
  /// In the given directory a new directory is created with name: `dataset---`
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All
  /// training input data is written into that directory. The Vertex AI
  /// environment variables representing Cloud Storage data URIs are represented
  /// in the Cloud Storage wildcard format to support sharded data. e.g.:
  /// "gs://.../training-*.jsonl" * AIP_DATA_FORMAT = "jsonl" for non-tabular
  /// data, "csv" for tabular data * AIP_TRAINING_DATA_URI =
  /// "gcs_destination/dataset---/training-*.${AIP_DATA_FORMAT}" *
  /// AIP_VALIDATION_DATA_URI =
  /// "gcs_destination/dataset---/validation-*.${AIP_DATA_FORMAT}" *
  /// AIP_TEST_DATA_URI = "gcs_destination/dataset---/test-*.${AIP_DATA_FORMAT}"
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  /// Whether to persist the ML use assignment to data item system labels.
  core.bool? persistMlUseAssignment;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on a predefined key.
  GoogleCloudAiplatformV1PredefinedSplit? predefinedSplit;

  /// Only applicable to Datasets that have SavedQueries.
  ///
  /// The ID of a SavedQuery (annotation set) under the Dataset specified by
  /// dataset_id used for filtering Annotations for training. Only Annotations
  /// that are associated with this SavedQuery are used in respectively
  /// training. When used in conjunction with annotations_filter, the
  /// Annotations used for training are filtered by both saved_query_id and
  /// annotations_filter. Only one of saved_query_id and annotation_schema_uri
  /// should be specified as both of them represent the same thing: problem
  /// type.
  core.String? savedQueryId;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the distribution of the specified column.
  GoogleCloudAiplatformV1StratifiedSplit? stratifiedSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the timestamp of the input data pieces.
  GoogleCloudAiplatformV1TimestampSplit? timestampSplit;

  GoogleCloudAiplatformV1InputDataConfig({
    this.annotationSchemaUri,
    this.annotationsFilter,
    this.bigqueryDestination,
    this.datasetId,
    this.filterSplit,
    this.fractionSplit,
    this.gcsDestination,
    this.persistMlUseAssignment,
    this.predefinedSplit,
    this.savedQueryId,
    this.stratifiedSplit,
    this.timestampSplit,
  });

  GoogleCloudAiplatformV1InputDataConfig.fromJson(core.Map json_)
      : this(
          annotationSchemaUri: json_['annotationSchemaUri'] as core.String?,
          annotationsFilter: json_['annotationsFilter'] as core.String?,
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          datasetId: json_['datasetId'] as core.String?,
          filterSplit: json_.containsKey('filterSplit')
              ? GoogleCloudAiplatformV1FilterSplit.fromJson(
                  json_['filterSplit'] as core.Map<core.String, core.dynamic>)
              : null,
          fractionSplit: json_.containsKey('fractionSplit')
              ? GoogleCloudAiplatformV1FractionSplit.fromJson(
                  json_['fractionSplit'] as core.Map<core.String, core.dynamic>)
              : null,
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          persistMlUseAssignment: json_['persistMlUseAssignment'] as core.bool?,
          predefinedSplit: json_.containsKey('predefinedSplit')
              ? GoogleCloudAiplatformV1PredefinedSplit.fromJson(
                  json_['predefinedSplit']
                      as core.Map<core.String, core.dynamic>)
              : null,
          savedQueryId: json_['savedQueryId'] as core.String?,
          stratifiedSplit: json_.containsKey('stratifiedSplit')
              ? GoogleCloudAiplatformV1StratifiedSplit.fromJson(
                  json_['stratifiedSplit']
                      as core.Map<core.String, core.dynamic>)
              : null,
          timestampSplit: json_.containsKey('timestampSplit')
              ? GoogleCloudAiplatformV1TimestampSplit.fromJson(
                  json_['timestampSplit']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationSchemaUri != null)
          'annotationSchemaUri': annotationSchemaUri!,
        if (annotationsFilter != null) 'annotationsFilter': annotationsFilter!,
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (datasetId != null) 'datasetId': datasetId!,
        if (filterSplit != null) 'filterSplit': filterSplit!,
        if (fractionSplit != null) 'fractionSplit': fractionSplit!,
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
        if (persistMlUseAssignment != null)
          'persistMlUseAssignment': persistMlUseAssignment!,
        if (predefinedSplit != null) 'predefinedSplit': predefinedSplit!,
        if (savedQueryId != null) 'savedQueryId': savedQueryId!,
        if (stratifiedSplit != null) 'stratifiedSplit': stratifiedSplit!,
        if (timestampSplit != null) 'timestampSplit': timestampSplit!,
      };
}

/// A list of int64 values.
class GoogleCloudAiplatformV1Int64Array {
  /// A list of int64 values.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1Int64Array({
    this.values,
  });

  GoogleCloudAiplatformV1Int64Array.fromJson(core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// An attribution method that computes the Aumann-Shapley value taking
/// advantage of the model's fully differentiable structure.
///
/// Refer to this paper for more details: https://arxiv.org/abs/1703.01365
class GoogleCloudAiplatformV1IntegratedGradientsAttribution {
  /// Config for IG with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image)
  /// is motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  GoogleCloudAiplatformV1BlurBaselineConfig? blurBaselineConfig;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding noise can help
  /// improve the computed gradients. Refer to this paper for more details:
  /// https://arxiv.org/pdf/1706.03825.pdf
  GoogleCloudAiplatformV1SmoothGradConfig? smoothGradConfig;

  /// The number of steps for approximating the path integral.
  ///
  /// A good value to start is 50 and gradually increase until the sum to diff
  /// property is within the desired error range. Valid range of its value is
  /// \[1, 100\], inclusively.
  ///
  /// Required.
  core.int? stepCount;

  GoogleCloudAiplatformV1IntegratedGradientsAttribution({
    this.blurBaselineConfig,
    this.smoothGradConfig,
    this.stepCount,
  });

  GoogleCloudAiplatformV1IntegratedGradientsAttribution.fromJson(core.Map json_)
      : this(
          blurBaselineConfig: json_.containsKey('blurBaselineConfig')
              ? GoogleCloudAiplatformV1BlurBaselineConfig.fromJson(
                  json_['blurBaselineConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          smoothGradConfig: json_.containsKey('smoothGradConfig')
              ? GoogleCloudAiplatformV1SmoothGradConfig.fromJson(
                  json_['smoothGradConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          stepCount: json_['stepCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blurBaselineConfig != null)
          'blurBaselineConfig': blurBaselineConfig!,
        if (smoothGradConfig != null) 'smoothGradConfig': smoothGradConfig!,
        if (stepCount != null) 'stepCount': stepCount!,
      };
}

/// The Jira source for the ImportRagFilesRequest.
class GoogleCloudAiplatformV1JiraSource {
  /// The Jira queries.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1JiraSourceJiraQueries>? jiraQueries;

  GoogleCloudAiplatformV1JiraSource({
    this.jiraQueries,
  });

  GoogleCloudAiplatformV1JiraSource.fromJson(core.Map json_)
      : this(
          jiraQueries: (json_['jiraQueries'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1JiraSourceJiraQueries.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (jiraQueries != null) 'jiraQueries': jiraQueries!,
      };
}

/// JiraQueries contains the Jira queries and corresponding authentication.
class GoogleCloudAiplatformV1JiraSourceJiraQueries {
  /// The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the Jira
  /// API key.
  ///
  /// See
  /// [Manage API tokens for your Atlassian account](https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/).
  ///
  /// Required.
  GoogleCloudAiplatformV1ApiAuthApiKeyConfig? apiKeyConfig;

  /// A list of custom Jira queries to import.
  ///
  /// For information about JQL (Jira Query Language), see
  /// https://support.atlassian.com/jira-service-management-cloud/docs/use-advanced-search-with-jira-query-language-jql/
  core.List<core.String>? customQueries;

  /// The Jira email address.
  ///
  /// Required.
  core.String? email;

  /// A list of Jira projects to import in their entirety.
  core.List<core.String>? projects;

  /// The Jira server URI.
  ///
  /// Required.
  core.String? serverUri;

  GoogleCloudAiplatformV1JiraSourceJiraQueries({
    this.apiKeyConfig,
    this.customQueries,
    this.email,
    this.projects,
    this.serverUri,
  });

  GoogleCloudAiplatformV1JiraSourceJiraQueries.fromJson(core.Map json_)
      : this(
          apiKeyConfig: json_.containsKey('apiKeyConfig')
              ? GoogleCloudAiplatformV1ApiAuthApiKeyConfig.fromJson(
                  json_['apiKeyConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          customQueries: (json_['customQueries'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          email: json_['email'] as core.String?,
          projects: (json_['projects'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          serverUri: json_['serverUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!,
        if (customQueries != null) 'customQueries': customQueries!,
        if (email != null) 'email': email!,
        if (projects != null) 'projects': projects!,
        if (serverUri != null) 'serverUri': serverUri!,
      };
}

/// Contains information about the Large Model.
class GoogleCloudAiplatformV1LargeModelReference {
  /// The unique name of the large Foundation or pre-built model.
  ///
  /// Like "chat-bison", "text-bison". Or model name with version ID, like
  /// "chat-bison@001", "text-bison@005", etc.
  ///
  /// Required.
  core.String? name;

  GoogleCloudAiplatformV1LargeModelReference({
    this.name,
  });

  GoogleCloudAiplatformV1LargeModelReference.fromJson(core.Map json_)
      : this(
          name: json_['name'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
      };
}

/// A subgraph of the overall lineage graph.
///
/// Event edges connect Artifact and Execution nodes.
class GoogleCloudAiplatformV1LineageSubgraph {
  /// The Artifact nodes in the subgraph.
  core.List<GoogleCloudAiplatformV1Artifact>? artifacts;

  /// The Event edges between Artifacts and Executions in the subgraph.
  core.List<GoogleCloudAiplatformV1Event>? events;

  /// The Execution nodes in the subgraph.
  core.List<GoogleCloudAiplatformV1Execution>? executions;

  GoogleCloudAiplatformV1LineageSubgraph({
    this.artifacts,
    this.events,
    this.executions,
  });

  GoogleCloudAiplatformV1LineageSubgraph.fromJson(core.Map json_)
      : this(
          artifacts: (json_['artifacts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Artifact.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          events: (json_['events'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Event.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          executions: (json_['executions'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Execution.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
        if (events != null) 'events': events!,
        if (executions != null) 'executions': executions!,
      };
}

/// Response message for DatasetService.ListAnnotations.
class GoogleCloudAiplatformV1ListAnnotationsResponse {
  /// A list of Annotations that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1Annotation>? annotations;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListAnnotationsResponse({
    this.annotations,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListAnnotationsResponse.fromJson(core.Map json_)
      : this(
          annotations: (json_['annotations'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Annotation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListArtifacts.
class GoogleCloudAiplatformV1ListArtifactsResponse {
  /// The Artifacts retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1Artifact>? artifacts;

  /// A token, which can be sent as ListArtifactsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListArtifactsResponse({
    this.artifacts,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListArtifactsResponse.fromJson(core.Map json_)
      : this(
          artifacts: (json_['artifacts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Artifact.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListBatchPredictionJobs
class GoogleCloudAiplatformV1ListBatchPredictionJobsResponse {
  /// List of BatchPredictionJobs in the requested page.
  core.List<GoogleCloudAiplatformV1BatchPredictionJob>? batchPredictionJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListBatchPredictionJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListBatchPredictionJobsResponse({
    this.batchPredictionJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListBatchPredictionJobsResponse.fromJson(
      core.Map json_)
      : this(
          batchPredictionJobs: (json_['batchPredictionJobs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (batchPredictionJobs != null)
          'batchPredictionJobs': batchPredictionJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response with a list of CachedContents.
class GoogleCloudAiplatformV1ListCachedContentsResponse {
  /// List of cached contents.
  core.List<GoogleCloudAiplatformV1CachedContent>? cachedContents;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListCachedContentsResponse({
    this.cachedContents,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListCachedContentsResponse.fromJson(core.Map json_)
      : this(
          cachedContents: (json_['cachedContents'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1CachedContent.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cachedContents != null) 'cachedContents': cachedContents!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListContexts.
class GoogleCloudAiplatformV1ListContextsResponse {
  /// The Contexts retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1Context>? contexts;

  /// A token, which can be sent as ListContextsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListContextsResponse({
    this.contexts,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListContextsResponse.fromJson(core.Map json_)
      : this(
          contexts: (json_['contexts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Context.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contexts != null) 'contexts': contexts!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListCustomJobs
class GoogleCloudAiplatformV1ListCustomJobsResponse {
  /// List of CustomJobs in the requested page.
  core.List<GoogleCloudAiplatformV1CustomJob>? customJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListCustomJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListCustomJobsResponse({
    this.customJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListCustomJobsResponse.fromJson(core.Map json_)
      : this(
          customJobs: (json_['customJobs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1CustomJob.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (customJobs != null) 'customJobs': customJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for DatasetService.ListDataItems.
class GoogleCloudAiplatformV1ListDataItemsResponse {
  /// A list of DataItems that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1DataItem>? dataItems;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDataItemsResponse({
    this.dataItems,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDataItemsResponse.fromJson(core.Map json_)
      : this(
          dataItems: (json_['dataItems'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DataItem.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataItems != null) 'dataItems': dataItems!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListDataLabelingJobs.
class GoogleCloudAiplatformV1ListDataLabelingJobsResponse {
  /// A list of DataLabelingJobs that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1DataLabelingJob>? dataLabelingJobs;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDataLabelingJobsResponse({
    this.dataLabelingJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDataLabelingJobsResponse.fromJson(core.Map json_)
      : this(
          dataLabelingJobs: (json_['dataLabelingJobs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DataLabelingJob.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataLabelingJobs != null) 'dataLabelingJobs': dataLabelingJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for DatasetService.ListDatasetVersions.
class GoogleCloudAiplatformV1ListDatasetVersionsResponse {
  /// A list of DatasetVersions that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1DatasetVersion>? datasetVersions;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDatasetVersionsResponse({
    this.datasetVersions,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDatasetVersionsResponse.fromJson(core.Map json_)
      : this(
          datasetVersions: (json_['datasetVersions'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DatasetVersion.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datasetVersions != null) 'datasetVersions': datasetVersions!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for DatasetService.ListDatasets.
class GoogleCloudAiplatformV1ListDatasetsResponse {
  /// A list of Datasets that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1Dataset>? datasets;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDatasetsResponse({
    this.datasets,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDatasetsResponse.fromJson(core.Map json_)
      : this(
          datasets: (json_['datasets'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Dataset.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datasets != null) 'datasets': datasets!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ListDeploymentResourcePools method.
class GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse {
  /// The DeploymentResourcePools from the specified location.
  core.List<GoogleCloudAiplatformV1DeploymentResourcePool>?
      deploymentResourcePools;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse({
    this.deploymentResourcePools,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDeploymentResourcePoolsResponse.fromJson(
      core.Map json_)
      : this(
          deploymentResourcePools:
              (json_['deploymentResourcePools'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1DeploymentResourcePool.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deploymentResourcePools != null)
          'deploymentResourcePools': deploymentResourcePools!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for EndpointService.ListEndpoints.
class GoogleCloudAiplatformV1ListEndpointsResponse {
  /// List of Endpoints in the requested page.
  core.List<GoogleCloudAiplatformV1Endpoint>? endpoints;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListEndpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListEndpointsResponse({
    this.endpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListEndpointsResponse.fromJson(core.Map json_)
      : this(
          endpoints: (json_['endpoints'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Endpoint.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoints != null) 'endpoints': endpoints!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeaturestoreService.ListEntityTypes.
class GoogleCloudAiplatformV1ListEntityTypesResponse {
  /// The EntityTypes matching the request.
  core.List<GoogleCloudAiplatformV1EntityType>? entityTypes;

  /// A token, which can be sent as ListEntityTypesRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListEntityTypesResponse({
    this.entityTypes,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListEntityTypesResponse.fromJson(core.Map json_)
      : this(
          entityTypes: (json_['entityTypes'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1EntityType.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityTypes != null) 'entityTypes': entityTypes!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListExecutions.
class GoogleCloudAiplatformV1ListExecutionsResponse {
  /// The Executions retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1Execution>? executions;

  /// A token, which can be sent as ListExecutionsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListExecutionsResponse({
    this.executions,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListExecutionsResponse.fromJson(core.Map json_)
      : this(
          executions: (json_['executions'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Execution.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (executions != null) 'executions': executions!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeatureRegistryService.ListFeatureGroups.
class GoogleCloudAiplatformV1ListFeatureGroupsResponse {
  /// The FeatureGroups matching the request.
  core.List<GoogleCloudAiplatformV1FeatureGroup>? featureGroups;

  /// A token, which can be sent as ListFeatureGroupsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeatureGroupsResponse({
    this.featureGroups,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeatureGroupsResponse.fromJson(core.Map json_)
      : this(
          featureGroups: (json_['featureGroups'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1FeatureGroup.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureGroups != null) 'featureGroups': featureGroups!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeatureOnlineStoreAdminService.ListFeatureOnlineStores.
class GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse {
  /// The FeatureOnlineStores matching the request.
  core.List<GoogleCloudAiplatformV1FeatureOnlineStore>? featureOnlineStores;

  /// A token, which can be sent as ListFeatureOnlineStoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse({
    this.featureOnlineStores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeatureOnlineStoresResponse.fromJson(
      core.Map json_)
      : this(
          featureOnlineStores: (json_['featureOnlineStores'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FeatureOnlineStore.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureOnlineStores != null)
          'featureOnlineStores': featureOnlineStores!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeatureOnlineStoreAdminService.ListFeatureViewSyncs.
class GoogleCloudAiplatformV1ListFeatureViewSyncsResponse {
  /// The FeatureViewSyncs matching the request.
  core.List<GoogleCloudAiplatformV1FeatureViewSync>? featureViewSyncs;

  /// A token, which can be sent as ListFeatureViewSyncsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeatureViewSyncsResponse({
    this.featureViewSyncs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeatureViewSyncsResponse.fromJson(core.Map json_)
      : this(
          featureViewSyncs: (json_['featureViewSyncs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1FeatureViewSync.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureViewSyncs != null) 'featureViewSyncs': featureViewSyncs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeatureOnlineStoreAdminService.ListFeatureViews.
class GoogleCloudAiplatformV1ListFeatureViewsResponse {
  /// The FeatureViews matching the request.
  core.List<GoogleCloudAiplatformV1FeatureView>? featureViews;

  /// A token, which can be sent as ListFeatureViewsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeatureViewsResponse({
    this.featureViews,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeatureViewsResponse.fromJson(core.Map json_)
      : this(
          featureViews: (json_['featureViews'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1FeatureView.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureViews != null) 'featureViews': featureViews!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeaturestoreService.ListFeatures.
///
/// Response message for FeatureRegistryService.ListFeatures.
class GoogleCloudAiplatformV1ListFeaturesResponse {
  /// The Features matching the request.
  core.List<GoogleCloudAiplatformV1Feature>? features;

  /// A token, which can be sent as ListFeaturesRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeaturesResponse({
    this.features,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeaturesResponse.fromJson(core.Map json_)
      : this(
          features: (json_['features'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Feature.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (features != null) 'features': features!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeaturestoreService.ListFeaturestores.
class GoogleCloudAiplatformV1ListFeaturestoresResponse {
  /// The Featurestores matching the request.
  core.List<GoogleCloudAiplatformV1Featurestore>? featurestores;

  /// A token, which can be sent as ListFeaturestoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeaturestoresResponse({
    this.featurestores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeaturestoresResponse.fromJson(core.Map json_)
      : this(
          featurestores: (json_['featurestores'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Featurestore.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featurestores != null) 'featurestores': featurestores!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListHyperparameterTuningJobs
class GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse {
  /// List of HyperparameterTuningJobs in the requested page.
  ///
  /// HyperparameterTuningJob.trials of the jobs will be not be returned.
  core.List<GoogleCloudAiplatformV1HyperparameterTuningJob>?
      hyperparameterTuningJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListHyperparameterTuningJobsRequest.page_token to obtain that
  /// page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse({
    this.hyperparameterTuningJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse.fromJson(
      core.Map json_)
      : this(
          hyperparameterTuningJobs:
              (json_['hyperparameterTuningJobs'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (hyperparameterTuningJobs != null)
          'hyperparameterTuningJobs': hyperparameterTuningJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for IndexEndpointService.ListIndexEndpoints.
class GoogleCloudAiplatformV1ListIndexEndpointsResponse {
  /// List of IndexEndpoints in the requested page.
  core.List<GoogleCloudAiplatformV1IndexEndpoint>? indexEndpoints;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListIndexEndpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListIndexEndpointsResponse({
    this.indexEndpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListIndexEndpointsResponse.fromJson(core.Map json_)
      : this(
          indexEndpoints: (json_['indexEndpoints'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1IndexEndpoint.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (indexEndpoints != null) 'indexEndpoints': indexEndpoints!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for IndexService.ListIndexes.
class GoogleCloudAiplatformV1ListIndexesResponse {
  /// List of indexes in the requested page.
  core.List<GoogleCloudAiplatformV1Index>? indexes;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListIndexesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListIndexesResponse({
    this.indexes,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListIndexesResponse.fromJson(core.Map json_)
      : this(
          indexes: (json_['indexes'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Index.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (indexes != null) 'indexes': indexes!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListMetadataSchemas.
class GoogleCloudAiplatformV1ListMetadataSchemasResponse {
  /// The MetadataSchemas found for the MetadataStore.
  core.List<GoogleCloudAiplatformV1MetadataSchema>? metadataSchemas;

  /// A token, which can be sent as ListMetadataSchemasRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListMetadataSchemasResponse({
    this.metadataSchemas,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListMetadataSchemasResponse.fromJson(core.Map json_)
      : this(
          metadataSchemas: (json_['metadataSchemas'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1MetadataSchema.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metadataSchemas != null) 'metadataSchemas': metadataSchemas!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListMetadataStores.
class GoogleCloudAiplatformV1ListMetadataStoresResponse {
  /// The MetadataStores found for the Location.
  core.List<GoogleCloudAiplatformV1MetadataStore>? metadataStores;

  /// A token, which can be sent as ListMetadataStoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListMetadataStoresResponse({
    this.metadataStores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListMetadataStoresResponse.fromJson(core.Map json_)
      : this(
          metadataStores: (json_['metadataStores'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1MetadataStore.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metadataStores != null) 'metadataStores': metadataStores!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListModelDeploymentMonitoringJobs.
class GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse {
  /// A list of ModelDeploymentMonitoringJobs that matches the specified filter
  /// in the request.
  core.List<GoogleCloudAiplatformV1ModelDeploymentMonitoringJob>?
      modelDeploymentMonitoringJobs;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse({
    this.modelDeploymentMonitoringJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse.fromJson(
      core.Map json_)
      : this(
          modelDeploymentMonitoringJobs: (json_['modelDeploymentMonitoringJobs']
                  as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelDeploymentMonitoringJobs != null)
          'modelDeploymentMonitoringJobs': modelDeploymentMonitoringJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModelEvaluationSlices.
class GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse {
  /// List of ModelEvaluations in the requested page.
  core.List<GoogleCloudAiplatformV1ModelEvaluationSlice>? modelEvaluationSlices;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelEvaluationSlicesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse({
    this.modelEvaluationSlices,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse.fromJson(
      core.Map json_)
      : this(
          modelEvaluationSlices: (json_['modelEvaluationSlices'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelEvaluationSlice.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelEvaluationSlices != null)
          'modelEvaluationSlices': modelEvaluationSlices!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModelEvaluations.
class GoogleCloudAiplatformV1ListModelEvaluationsResponse {
  /// List of ModelEvaluations in the requested page.
  core.List<GoogleCloudAiplatformV1ModelEvaluation>? modelEvaluations;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelEvaluationsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelEvaluationsResponse({
    this.modelEvaluations,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelEvaluationsResponse.fromJson(core.Map json_)
      : this(
          modelEvaluations: (json_['modelEvaluations'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1ModelEvaluation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelEvaluations != null) 'modelEvaluations': modelEvaluations!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModelVersionCheckpoints
class GoogleCloudAiplatformV1ListModelVersionCheckpointsResponse {
  /// List of Model Version checkpoints.
  core.List<GoogleCloudAiplatformV1ModelVersionCheckpoint>? checkpoints;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListModelVersionCheckpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelVersionCheckpointsResponse({
    this.checkpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelVersionCheckpointsResponse.fromJson(
      core.Map json_)
      : this(
          checkpoints: (json_['checkpoints'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelVersionCheckpoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkpoints != null) 'checkpoints': checkpoints!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModelVersions
class GoogleCloudAiplatformV1ListModelVersionsResponse {
  /// List of Model versions in the requested page.
  ///
  /// In the returned Model name field, version ID instead of regvision tag will
  /// be included.
  core.List<GoogleCloudAiplatformV1Model>? models;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListModelVersionsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelVersionsResponse({
    this.models,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelVersionsResponse.fromJson(core.Map json_)
      : this(
          models: (json_['models'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Model.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (models != null) 'models': models!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModels
class GoogleCloudAiplatformV1ListModelsResponse {
  /// List of Models in the requested page.
  core.List<GoogleCloudAiplatformV1Model>? models;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelsResponse({
    this.models,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelsResponse.fromJson(core.Map json_)
      : this(
          models: (json_['models'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Model.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (models != null) 'models': models!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListNasJobs
class GoogleCloudAiplatformV1ListNasJobsResponse {
  /// List of NasJobs in the requested page.
  ///
  /// NasJob.nas_job_output of the jobs will not be returned.
  core.List<GoogleCloudAiplatformV1NasJob>? nasJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListNasJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListNasJobsResponse({
    this.nasJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListNasJobsResponse.fromJson(core.Map json_)
      : this(
          nasJobs: (json_['nasJobs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1NasJob.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nasJobs != null) 'nasJobs': nasJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListNasTrialDetails
class GoogleCloudAiplatformV1ListNasTrialDetailsResponse {
  /// List of top NasTrials in the requested page.
  core.List<GoogleCloudAiplatformV1NasTrialDetail>? nasTrialDetails;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListNasTrialDetailsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListNasTrialDetailsResponse({
    this.nasTrialDetails,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListNasTrialDetailsResponse.fromJson(core.Map json_)
      : this(
          nasTrialDetails: (json_['nasTrialDetails'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1NasTrialDetail.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nasTrialDetails != null) 'nasTrialDetails': nasTrialDetails!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for \[NotebookService.CreateNotebookExecutionJob\]
class GoogleCloudAiplatformV1ListNotebookExecutionJobsResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookExecutionJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of NotebookExecutionJobs in the requested page.
  core.List<GoogleCloudAiplatformV1NotebookExecutionJob>? notebookExecutionJobs;

  GoogleCloudAiplatformV1ListNotebookExecutionJobsResponse({
    this.nextPageToken,
    this.notebookExecutionJobs,
  });

  GoogleCloudAiplatformV1ListNotebookExecutionJobsResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          notebookExecutionJobs: (json_['notebookExecutionJobs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1NotebookExecutionJob.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (notebookExecutionJobs != null)
          'notebookExecutionJobs': notebookExecutionJobs!,
      };
}

/// Response message for NotebookService.ListNotebookRuntimeTemplates.
class GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookRuntimeTemplatesRequest.page_token to obtain that
  /// page.
  core.String? nextPageToken;

  /// List of NotebookRuntimeTemplates in the requested page.
  core.List<GoogleCloudAiplatformV1NotebookRuntimeTemplate>?
      notebookRuntimeTemplates;

  GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse({
    this.nextPageToken,
    this.notebookRuntimeTemplates,
  });

  GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          notebookRuntimeTemplates:
              (json_['notebookRuntimeTemplates'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (notebookRuntimeTemplates != null)
          'notebookRuntimeTemplates': notebookRuntimeTemplates!,
      };
}

/// Response message for NotebookService.ListNotebookRuntimes.
class GoogleCloudAiplatformV1ListNotebookRuntimesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookRuntimesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of NotebookRuntimes in the requested page.
  core.List<GoogleCloudAiplatformV1NotebookRuntime>? notebookRuntimes;

  GoogleCloudAiplatformV1ListNotebookRuntimesResponse({
    this.nextPageToken,
    this.notebookRuntimes,
  });

  GoogleCloudAiplatformV1ListNotebookRuntimesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          notebookRuntimes: (json_['notebookRuntimes'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1NotebookRuntime.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (notebookRuntimes != null) 'notebookRuntimes': notebookRuntimes!,
      };
}

/// Request message for VizierService.ListOptimalTrials.
typedef GoogleCloudAiplatformV1ListOptimalTrialsRequest = $Empty;

/// Response message for VizierService.ListOptimalTrials.
class GoogleCloudAiplatformV1ListOptimalTrialsResponse {
  /// The pareto-optimal Trials for multiple objective Study or the optimal
  /// trial for single objective Study.
  ///
  /// The definition of pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  core.List<GoogleCloudAiplatformV1Trial>? optimalTrials;

  GoogleCloudAiplatformV1ListOptimalTrialsResponse({
    this.optimalTrials,
  });

  GoogleCloudAiplatformV1ListOptimalTrialsResponse.fromJson(core.Map json_)
      : this(
          optimalTrials: (json_['optimalTrials'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Trial.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (optimalTrials != null) 'optimalTrials': optimalTrials!,
      };
}

/// Response message for PersistentResourceService.ListPersistentResources
class GoogleCloudAiplatformV1ListPersistentResourcesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListPersistentResourcesRequest.page_token to obtain that page.
  core.String? nextPageToken;
  core.List<GoogleCloudAiplatformV1PersistentResource>? persistentResources;

  GoogleCloudAiplatformV1ListPersistentResourcesResponse({
    this.nextPageToken,
    this.persistentResources,
  });

  GoogleCloudAiplatformV1ListPersistentResourcesResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          persistentResources: (json_['persistentResources'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PersistentResource.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (persistentResources != null)
          'persistentResources': persistentResources!,
      };
}

/// Response message for PipelineService.ListPipelineJobs
class GoogleCloudAiplatformV1ListPipelineJobsResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListPipelineJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of PipelineJobs in the requested page.
  core.List<GoogleCloudAiplatformV1PipelineJob>? pipelineJobs;

  GoogleCloudAiplatformV1ListPipelineJobsResponse({
    this.nextPageToken,
    this.pipelineJobs,
  });

  GoogleCloudAiplatformV1ListPipelineJobsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          pipelineJobs: (json_['pipelineJobs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1PipelineJob.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (pipelineJobs != null) 'pipelineJobs': pipelineJobs!,
      };
}

/// Response message for VertexRagDataService.ListRagCorpora.
class GoogleCloudAiplatformV1ListRagCorporaResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListRagCorporaRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of RagCorpora in the requested page.
  core.List<GoogleCloudAiplatformV1RagCorpus>? ragCorpora;

  GoogleCloudAiplatformV1ListRagCorporaResponse({
    this.nextPageToken,
    this.ragCorpora,
  });

  GoogleCloudAiplatformV1ListRagCorporaResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          ragCorpora: (json_['ragCorpora'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1RagCorpus.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (ragCorpora != null) 'ragCorpora': ragCorpora!,
      };
}

/// Response message for VertexRagDataService.ListRagFiles.
class GoogleCloudAiplatformV1ListRagFilesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListRagFilesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of RagFiles in the requested page.
  core.List<GoogleCloudAiplatformV1RagFile>? ragFiles;

  GoogleCloudAiplatformV1ListRagFilesResponse({
    this.nextPageToken,
    this.ragFiles,
  });

  GoogleCloudAiplatformV1ListRagFilesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          ragFiles: (json_['ragFiles'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1RagFile.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (ragFiles != null) 'ragFiles': ragFiles!,
      };
}

/// Response message for ReasoningEngineService.ListReasoningEngines
class GoogleCloudAiplatformV1ListReasoningEnginesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListReasoningEnginesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of ReasoningEngines in the requested page.
  core.List<GoogleCloudAiplatformV1ReasoningEngine>? reasoningEngines;

  GoogleCloudAiplatformV1ListReasoningEnginesResponse({
    this.nextPageToken,
    this.reasoningEngines,
  });

  GoogleCloudAiplatformV1ListReasoningEnginesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          reasoningEngines: (json_['reasoningEngines'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1ReasoningEngine.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (reasoningEngines != null) 'reasoningEngines': reasoningEngines!,
      };
}

/// Response message for DatasetService.ListSavedQueries.
class GoogleCloudAiplatformV1ListSavedQueriesResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of SavedQueries that match the specified filter in the request.
  core.List<GoogleCloudAiplatformV1SavedQuery>? savedQueries;

  GoogleCloudAiplatformV1ListSavedQueriesResponse({
    this.nextPageToken,
    this.savedQueries,
  });

  GoogleCloudAiplatformV1ListSavedQueriesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          savedQueries: (json_['savedQueries'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1SavedQuery.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (savedQueries != null) 'savedQueries': savedQueries!,
      };
}

/// Response message for ScheduleService.ListSchedules
class GoogleCloudAiplatformV1ListSchedulesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListSchedulesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of Schedules in the requested page.
  core.List<GoogleCloudAiplatformV1Schedule>? schedules;

  GoogleCloudAiplatformV1ListSchedulesResponse({
    this.nextPageToken,
    this.schedules,
  });

  GoogleCloudAiplatformV1ListSchedulesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          schedules: (json_['schedules'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Schedule.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (schedules != null) 'schedules': schedules!,
      };
}

/// Response message for SpecialistPoolService.ListSpecialistPools.
class GoogleCloudAiplatformV1ListSpecialistPoolsResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of SpecialistPools that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1SpecialistPool>? specialistPools;

  GoogleCloudAiplatformV1ListSpecialistPoolsResponse({
    this.nextPageToken,
    this.specialistPools,
  });

  GoogleCloudAiplatformV1ListSpecialistPoolsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          specialistPools: (json_['specialistPools'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1SpecialistPool.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (specialistPools != null) 'specialistPools': specialistPools!,
      };
}

/// Response message for VizierService.ListStudies.
class GoogleCloudAiplatformV1ListStudiesResponse {
  /// Passes this token as the `page_token` field of the request for a
  /// subsequent call.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The studies associated with the project.
  core.List<GoogleCloudAiplatformV1Study>? studies;

  GoogleCloudAiplatformV1ListStudiesResponse({
    this.nextPageToken,
    this.studies,
  });

  GoogleCloudAiplatformV1ListStudiesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          studies: (json_['studies'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Study.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (studies != null) 'studies': studies!,
      };
}

/// Response message for TensorboardService.ListTensorboardExperiments.
class GoogleCloudAiplatformV1ListTensorboardExperimentsResponse {
  /// A token, which can be sent as ListTensorboardExperimentsRequest.page_token
  /// to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardExperiments mathching the request.
  core.List<GoogleCloudAiplatformV1TensorboardExperiment>?
      tensorboardExperiments;

  GoogleCloudAiplatformV1ListTensorboardExperimentsResponse({
    this.nextPageToken,
    this.tensorboardExperiments,
  });

  GoogleCloudAiplatformV1ListTensorboardExperimentsResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          tensorboardExperiments:
              (json_['tensorboardExperiments'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboardExperiments != null)
          'tensorboardExperiments': tensorboardExperiments!,
      };
}

/// Response message for TensorboardService.ListTensorboardRuns.
class GoogleCloudAiplatformV1ListTensorboardRunsResponse {
  /// A token, which can be sent as ListTensorboardRunsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardRuns mathching the request.
  core.List<GoogleCloudAiplatformV1TensorboardRun>? tensorboardRuns;

  GoogleCloudAiplatformV1ListTensorboardRunsResponse({
    this.nextPageToken,
    this.tensorboardRuns,
  });

  GoogleCloudAiplatformV1ListTensorboardRunsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          tensorboardRuns: (json_['tensorboardRuns'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TensorboardRun.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboardRuns != null) 'tensorboardRuns': tensorboardRuns!,
      };
}

/// Response message for TensorboardService.ListTensorboardTimeSeries.
class GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse {
  /// A token, which can be sent as ListTensorboardTimeSeriesRequest.page_token
  /// to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardTimeSeries mathching the request.
  core.List<GoogleCloudAiplatformV1TensorboardTimeSeries>?
      tensorboardTimeSeries;

  GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse({
    this.nextPageToken,
    this.tensorboardTimeSeries,
  });

  GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          tensorboardTimeSeries: (json_['tensorboardTimeSeries'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboardTimeSeries != null)
          'tensorboardTimeSeries': tensorboardTimeSeries!,
      };
}

/// Response message for TensorboardService.ListTensorboards.
class GoogleCloudAiplatformV1ListTensorboardsResponse {
  /// A token, which can be sent as ListTensorboardsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The Tensorboards mathching the request.
  core.List<GoogleCloudAiplatformV1Tensorboard>? tensorboards;

  GoogleCloudAiplatformV1ListTensorboardsResponse({
    this.nextPageToken,
    this.tensorboards,
  });

  GoogleCloudAiplatformV1ListTensorboardsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          tensorboards: (json_['tensorboards'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tensorboard.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboards != null) 'tensorboards': tensorboards!,
      };
}

/// Response message for PipelineService.ListTrainingPipelines
class GoogleCloudAiplatformV1ListTrainingPipelinesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListTrainingPipelinesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of TrainingPipelines in the requested page.
  core.List<GoogleCloudAiplatformV1TrainingPipeline>? trainingPipelines;

  GoogleCloudAiplatformV1ListTrainingPipelinesResponse({
    this.nextPageToken,
    this.trainingPipelines,
  });

  GoogleCloudAiplatformV1ListTrainingPipelinesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          trainingPipelines: (json_['trainingPipelines'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TrainingPipeline.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (trainingPipelines != null) 'trainingPipelines': trainingPipelines!,
      };
}

/// Response message for VizierService.ListTrials.
class GoogleCloudAiplatformV1ListTrialsResponse {
  /// Pass this token as the `page_token` field of the request for a subsequent
  /// call.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The Trials associated with the Study.
  core.List<GoogleCloudAiplatformV1Trial>? trials;

  GoogleCloudAiplatformV1ListTrialsResponse({
    this.nextPageToken,
    this.trials,
  });

  GoogleCloudAiplatformV1ListTrialsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          trials: (json_['trials'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Trial.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (trials != null) 'trials': trials!,
      };
}

/// Response message for GenAiTuningService.ListTuningJobs
class GoogleCloudAiplatformV1ListTuningJobsResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListTuningJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of TuningJobs in the requested page.
  core.List<GoogleCloudAiplatformV1TuningJob>? tuningJobs;

  GoogleCloudAiplatformV1ListTuningJobsResponse({
    this.nextPageToken,
    this.tuningJobs,
  });

  GoogleCloudAiplatformV1ListTuningJobsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          tuningJobs: (json_['tuningJobs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TuningJob.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tuningJobs != null) 'tuningJobs': tuningJobs!,
      };
}

/// Logprobs Result
class GoogleCloudAiplatformV1LogprobsResult {
  /// Length = total number of decoding steps.
  ///
  /// The chosen candidates may or may not be in top_candidates.
  core.List<GoogleCloudAiplatformV1LogprobsResultCandidate>? chosenCandidates;

  /// Length = total number of decoding steps.
  core.List<GoogleCloudAiplatformV1LogprobsResultTopCandidates>? topCandidates;

  GoogleCloudAiplatformV1LogprobsResult({
    this.chosenCandidates,
    this.topCandidates,
  });

  GoogleCloudAiplatformV1LogprobsResult.fromJson(core.Map json_)
      : this(
          chosenCandidates: (json_['chosenCandidates'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1LogprobsResultCandidate.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          topCandidates: (json_['topCandidates'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1LogprobsResultTopCandidates.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (chosenCandidates != null) 'chosenCandidates': chosenCandidates!,
        if (topCandidates != null) 'topCandidates': topCandidates!,
      };
}

/// Candidate for the logprobs token and score.
class GoogleCloudAiplatformV1LogprobsResultCandidate {
  /// The candidate's log probability.
  core.double? logProbability;

  /// The candidate's token string value.
  core.String? token;

  /// The candidate's token id value.
  core.int? tokenId;

  GoogleCloudAiplatformV1LogprobsResultCandidate({
    this.logProbability,
    this.token,
    this.tokenId,
  });

  GoogleCloudAiplatformV1LogprobsResultCandidate.fromJson(core.Map json_)
      : this(
          logProbability: (json_['logProbability'] as core.num?)?.toDouble(),
          token: json_['token'] as core.String?,
          tokenId: json_['tokenId'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (logProbability != null) 'logProbability': logProbability!,
        if (token != null) 'token': token!,
        if (tokenId != null) 'tokenId': tokenId!,
      };
}

/// Candidates with top log probabilities at each decoding step.
class GoogleCloudAiplatformV1LogprobsResultTopCandidates {
  /// Sorted by log probability in descending order.
  core.List<GoogleCloudAiplatformV1LogprobsResultCandidate>? candidates;

  GoogleCloudAiplatformV1LogprobsResultTopCandidates({
    this.candidates,
  });

  GoogleCloudAiplatformV1LogprobsResultTopCandidates.fromJson(core.Map json_)
      : this(
          candidates: (json_['candidates'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1LogprobsResultCandidate.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (candidates != null) 'candidates': candidates!,
      };
}

/// Request message for VizierService.LookupStudy.
class GoogleCloudAiplatformV1LookupStudyRequest {
  /// The user-defined display name of the Study
  ///
  /// Required.
  core.String? displayName;

  GoogleCloudAiplatformV1LookupStudyRequest({
    this.displayName,
  });

  GoogleCloudAiplatformV1LookupStudyRequest.fromJson(core.Map json_)
      : this(
          displayName: json_['displayName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
      };
}

/// Specification of a single machine.
class GoogleCloudAiplatformV1MachineSpec {
  /// The number of accelerators to attach to the machine.
  core.int? acceleratorCount;

  /// The type of accelerator(s) that may be attached to the machine as per
  /// accelerator_count.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "ACCELERATOR_TYPE_UNSPECIFIED" : Unspecified accelerator type, which
  /// means no accelerator.
  /// - "NVIDIA_TESLA_K80" : Deprecated: Nvidia Tesla K80 GPU has reached end of
  /// support, see https://cloud.google.com/compute/docs/eol/k80-eol.
  /// - "NVIDIA_TESLA_P100" : Nvidia Tesla P100 GPU.
  /// - "NVIDIA_TESLA_V100" : Nvidia Tesla V100 GPU.
  /// - "NVIDIA_TESLA_P4" : Nvidia Tesla P4 GPU.
  /// - "NVIDIA_TESLA_T4" : Nvidia Tesla T4 GPU.
  /// - "NVIDIA_TESLA_A100" : Nvidia Tesla A100 GPU.
  /// - "NVIDIA_A100_80GB" : Nvidia A100 80GB GPU.
  /// - "NVIDIA_L4" : Nvidia L4 GPU.
  /// - "NVIDIA_H100_80GB" : Nvidia H100 80Gb GPU.
  /// - "NVIDIA_H100_MEGA_80GB" : Nvidia H100 Mega 80Gb GPU.
  /// - "TPU_V2" : TPU v2.
  /// - "TPU_V3" : TPU v3.
  /// - "TPU_V4_POD" : TPU v4.
  /// - "TPU_V5_LITEPOD" : TPU v5.
  core.String? acceleratorType;

  /// The type of the machine.
  ///
  /// See the
  /// [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
  /// See the
  /// [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
  /// For DeployedModel this field is optional, and the default value is
  /// `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this
  /// field is required.
  ///
  /// Immutable.
  core.String? machineType;

  /// Configuration controlling how this resource pool consumes reservation.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1ReservationAffinity? reservationAffinity;

  /// The topology of the TPUs.
  ///
  /// Corresponds to the TPU topologies available from GKE. (Example:
  /// tpu_topology: "2x2x1").
  ///
  /// Immutable.
  core.String? tpuTopology;

  GoogleCloudAiplatformV1MachineSpec({
    this.acceleratorCount,
    this.acceleratorType,
    this.machineType,
    this.reservationAffinity,
    this.tpuTopology,
  });

  GoogleCloudAiplatformV1MachineSpec.fromJson(core.Map json_)
      : this(
          acceleratorCount: json_['acceleratorCount'] as core.int?,
          acceleratorType: json_['acceleratorType'] as core.String?,
          machineType: json_['machineType'] as core.String?,
          reservationAffinity: json_.containsKey('reservationAffinity')
              ? GoogleCloudAiplatformV1ReservationAffinity.fromJson(
                  json_['reservationAffinity']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tpuTopology: json_['tpuTopology'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
        if (acceleratorType != null) 'acceleratorType': acceleratorType!,
        if (machineType != null) 'machineType': machineType!,
        if (reservationAffinity != null)
          'reservationAffinity': reservationAffinity!,
        if (tpuTopology != null) 'tpuTopology': tpuTopology!,
      };
}

/// Manual batch tuning parameters.
class GoogleCloudAiplatformV1ManualBatchTuningParameters {
  /// The number of the records (e.g. instances) of the operation given in each
  /// batch to a machine replica.
  ///
  /// Machine type, and size of a single record should be considered when
  /// setting this parameter, higher value speeds up the batch operation's
  /// execution, but too high value will result in a whole batch not fitting in
  /// a machine's memory, and the whole operation will fail. The default value
  /// is 64.
  ///
  /// Immutable.
  core.int? batchSize;

  GoogleCloudAiplatformV1ManualBatchTuningParameters({
    this.batchSize,
  });

  GoogleCloudAiplatformV1ManualBatchTuningParameters.fromJson(core.Map json_)
      : this(
          batchSize: json_['batchSize'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (batchSize != null) 'batchSize': batchSize!,
      };
}

/// A message representing a Measurement of a Trial.
///
/// A Measurement contains the Metrics got by executing a Trial using suggested
/// hyperparameter values.
class GoogleCloudAiplatformV1Measurement {
  /// Time that the Trial has been running at the point of this Measurement.
  ///
  /// Output only.
  core.String? elapsedDuration;

  /// A list of metrics got by evaluating the objective functions using
  /// suggested Parameter values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1MeasurementMetric>? metrics;

  /// The number of steps the machine learning model has been trained for.
  ///
  /// Must be non-negative.
  ///
  /// Output only.
  core.String? stepCount;

  GoogleCloudAiplatformV1Measurement({
    this.elapsedDuration,
    this.metrics,
    this.stepCount,
  });

  GoogleCloudAiplatformV1Measurement.fromJson(core.Map json_)
      : this(
          elapsedDuration: json_['elapsedDuration'] as core.String?,
          metrics: (json_['metrics'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1MeasurementMetric.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          stepCount: json_['stepCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (elapsedDuration != null) 'elapsedDuration': elapsedDuration!,
        if (metrics != null) 'metrics': metrics!,
        if (stepCount != null) 'stepCount': stepCount!,
      };
}

/// A message representing a metric in the measurement.
class GoogleCloudAiplatformV1MeasurementMetric {
  /// The ID of the Metric.
  ///
  /// The Metric should be defined in StudySpec's Metrics.
  ///
  /// Output only.
  core.String? metricId;

  /// The value for this metric.
  ///
  /// Output only.
  core.double? value;

  GoogleCloudAiplatformV1MeasurementMetric({
    this.metricId,
    this.value,
  });

  GoogleCloudAiplatformV1MeasurementMetric.fromJson(core.Map json_)
      : this(
          metricId: json_['metricId'] as core.String?,
          value: (json_['value'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metricId != null) 'metricId': metricId!,
        if (value != null) 'value': value!,
      };
}

/// Request message for ModelService.MergeVersionAliases.
class GoogleCloudAiplatformV1MergeVersionAliasesRequest {
  /// The set of version aliases to merge.
  ///
  /// The alias should be at most 128 characters, and match
  /// `a-z{0,126}[a-z-0-9]`. Add the `-` prefix to an alias means removing that
  /// alias from the version. `-` is NOT counted in the 128 characters. Example:
  /// `-golden` means removing the `golden` alias from the version. There is NO
  /// ordering in aliases, which means 1) The aliases returned from GetModel API
  /// might not have the exactly same order from this MergeVersionAliases API.
  /// 2) Adding and deleting the same alias in the request is not recommended,
  /// and the 2 operations will be cancelled out.
  ///
  /// Required.
  core.List<core.String>? versionAliases;

  GoogleCloudAiplatformV1MergeVersionAliasesRequest({
    this.versionAliases,
  });

  GoogleCloudAiplatformV1MergeVersionAliasesRequest.fromJson(core.Map json_)
      : this(
          versionAliases: (json_['versionAliases'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (versionAliases != null) 'versionAliases': versionAliases!,
      };
}

/// Instance of a general MetadataSchema.
class GoogleCloudAiplatformV1MetadataSchema {
  /// Timestamp when this MetadataSchema was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Metadata Schema
  core.String? description;

  /// The resource name of the MetadataSchema.
  ///
  /// Output only.
  core.String? name;

  /// The raw YAML string representation of the MetadataSchema.
  ///
  /// The combination of \[MetadataSchema.version\] and the schema name given by
  /// `title` in \[MetadataSchema.schema\] must be unique within a
  /// MetadataStore. The schema is defined as an OpenAPI 3.0.2
  /// [MetadataSchema Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#schemaObject)
  ///
  /// Required.
  core.String? schema;

  /// The type of the MetadataSchema.
  ///
  /// This is a property that identifies which metadata types will use the
  /// MetadataSchema.
  /// Possible string values are:
  /// - "METADATA_SCHEMA_TYPE_UNSPECIFIED" : Unspecified type for the
  /// MetadataSchema.
  /// - "ARTIFACT_TYPE" : A type indicating that the MetadataSchema will be used
  /// by Artifacts.
  /// - "EXECUTION_TYPE" : A typee indicating that the MetadataSchema will be
  /// used by Executions.
  /// - "CONTEXT_TYPE" : A state indicating that the MetadataSchema will be used
  /// by Contexts.
  core.String? schemaType;

  /// The version of the MetadataSchema.
  ///
  /// The version's format must match the following regular expression:
  /// `^[0-9]+.+.+$`, which would allow to order/compare different versions.
  /// Example: 1.0.0, 1.0.1, etc.
  core.String? schemaVersion;

  GoogleCloudAiplatformV1MetadataSchema({
    this.createTime,
    this.description,
    this.name,
    this.schema,
    this.schemaType,
    this.schemaVersion,
  });

  GoogleCloudAiplatformV1MetadataSchema.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          name: json_['name'] as core.String?,
          schema: json_['schema'] as core.String?,
          schemaType: json_['schemaType'] as core.String?,
          schemaVersion: json_['schemaVersion'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (name != null) 'name': name!,
        if (schema != null) 'schema': schema!,
        if (schemaType != null) 'schemaType': schemaType!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
      };
}

/// Instance of a metadata store.
///
/// Contains a set of metadata that can be queried.
class GoogleCloudAiplatformV1MetadataStore {
  /// Timestamp when this MetadataStore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Dataplex integration settings.
  ///
  /// Optional.
  GoogleCloudAiplatformV1MetadataStoreDataplexConfig? dataplexConfig;

  /// Description of the MetadataStore.
  core.String? description;

  /// Customer-managed encryption key spec for a Metadata Store.
  ///
  /// If set, this Metadata Store and all sub-resources of this Metadata Store
  /// are secured using this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// The resource name of the MetadataStore instance.
  ///
  /// Output only.
  core.String? name;

  /// State information of the MetadataStore.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MetadataStoreMetadataStoreState? state;

  /// Timestamp when this MetadataStore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1MetadataStore({
    this.createTime,
    this.dataplexConfig,
    this.description,
    this.encryptionSpec,
    this.name,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1MetadataStore.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          dataplexConfig: json_.containsKey('dataplexConfig')
              ? GoogleCloudAiplatformV1MetadataStoreDataplexConfig.fromJson(
                  json_['dataplexConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          description: json_['description'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          state: json_.containsKey('state')
              ? GoogleCloudAiplatformV1MetadataStoreMetadataStoreState.fromJson(
                  json_['state'] as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (dataplexConfig != null) 'dataplexConfig': dataplexConfig!,
        if (description != null) 'description': description!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (name != null) 'name': name!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Represents Dataplex integration settings.
class GoogleCloudAiplatformV1MetadataStoreDataplexConfig {
  /// Whether or not Data Lineage synchronization is enabled for Vertex
  /// Pipelines.
  ///
  /// Optional.
  core.bool? enabledPipelinesLineage;

  GoogleCloudAiplatformV1MetadataStoreDataplexConfig({
    this.enabledPipelinesLineage,
  });

  GoogleCloudAiplatformV1MetadataStoreDataplexConfig.fromJson(core.Map json_)
      : this(
          enabledPipelinesLineage:
              json_['enabledPipelinesLineage'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enabledPipelinesLineage != null)
          'enabledPipelinesLineage': enabledPipelinesLineage!,
      };
}

/// Represents state information for a MetadataStore.
class GoogleCloudAiplatformV1MetadataStoreMetadataStoreState {
  /// The disk utilization of the MetadataStore in bytes.
  core.String? diskUtilizationBytes;

  GoogleCloudAiplatformV1MetadataStoreMetadataStoreState({
    this.diskUtilizationBytes,
  });

  GoogleCloudAiplatformV1MetadataStoreMetadataStoreState.fromJson(
      core.Map json_)
      : this(
          diskUtilizationBytes: json_['diskUtilizationBytes'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskUtilizationBytes != null)
          'diskUtilizationBytes': diskUtilizationBytes!,
      };
}

/// The metric used for dataset level evaluation.
class GoogleCloudAiplatformV1Metric {
  /// The aggregation metrics to use.
  ///
  /// Optional.
  core.List<core.String>? aggregationMetrics;

  /// Spec for bleu metric.
  GoogleCloudAiplatformV1BleuSpec? bleuSpec;

  /// Spec for exact match metric.
  GoogleCloudAiplatformV1ExactMatchSpec? exactMatchSpec;

  /// Spec for pairwise metric.
  GoogleCloudAiplatformV1PairwiseMetricSpec? pairwiseMetricSpec;

  /// Spec for pointwise metric.
  GoogleCloudAiplatformV1PointwiseMetricSpec? pointwiseMetricSpec;

  /// Spec for rouge metric.
  GoogleCloudAiplatformV1RougeSpec? rougeSpec;

  GoogleCloudAiplatformV1Metric({
    this.aggregationMetrics,
    this.bleuSpec,
    this.exactMatchSpec,
    this.pairwiseMetricSpec,
    this.pointwiseMetricSpec,
    this.rougeSpec,
  });

  GoogleCloudAiplatformV1Metric.fromJson(core.Map json_)
      : this(
          aggregationMetrics: (json_['aggregationMetrics'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          bleuSpec: json_.containsKey('bleuSpec')
              ? GoogleCloudAiplatformV1BleuSpec.fromJson(
                  json_['bleuSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          exactMatchSpec: json_.containsKey('exactMatchSpec')
              ? GoogleCloudAiplatformV1ExactMatchSpec.fromJson(
                  json_['exactMatchSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pairwiseMetricSpec: json_.containsKey('pairwiseMetricSpec')
              ? GoogleCloudAiplatformV1PairwiseMetricSpec.fromJson(
                  json_['pairwiseMetricSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pointwiseMetricSpec: json_.containsKey('pointwiseMetricSpec')
              ? GoogleCloudAiplatformV1PointwiseMetricSpec.fromJson(
                  json_['pointwiseMetricSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          rougeSpec: json_.containsKey('rougeSpec')
              ? GoogleCloudAiplatformV1RougeSpec.fromJson(
                  json_['rougeSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (aggregationMetrics != null)
          'aggregationMetrics': aggregationMetrics!,
        if (bleuSpec != null) 'bleuSpec': bleuSpec!,
        if (exactMatchSpec != null) 'exactMatchSpec': exactMatchSpec!,
        if (pairwiseMetricSpec != null)
          'pairwiseMetricSpec': pairwiseMetricSpec!,
        if (pointwiseMetricSpec != null)
          'pointwiseMetricSpec': pointwiseMetricSpec!,
        if (rougeSpec != null) 'rougeSpec': rougeSpec!,
      };
}

/// Input for MetricX metric.
class GoogleCloudAiplatformV1MetricxInput {
  /// Metricx instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1MetricxInstance? instance;

  /// Spec for Metricx metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1MetricxSpec? metricSpec;

  GoogleCloudAiplatformV1MetricxInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1MetricxInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1MetricxInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1MetricxSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for MetricX instance - The fields used for evaluation are dependent on
/// the MetricX version.
typedef GoogleCloudAiplatformV1MetricxInstance = $Instance03;

/// Spec for MetricX result - calculates the MetricX score for the given
/// instance using the version specified in the spec.
class GoogleCloudAiplatformV1MetricxResult {
  /// MetricX score.
  ///
  /// Range depends on version.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1MetricxResult({
    this.score,
  });

  GoogleCloudAiplatformV1MetricxResult.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Spec for MetricX metric.
class GoogleCloudAiplatformV1MetricxSpec {
  /// Source language in BCP-47 format.
  ///
  /// Optional.
  core.String? sourceLanguage;

  /// Target language in BCP-47 format.
  ///
  /// Covers both prediction and reference.
  ///
  /// Optional.
  core.String? targetLanguage;

  /// Which version to use for evaluation.
  ///
  /// Required.
  /// Possible string values are:
  /// - "METRICX_VERSION_UNSPECIFIED" : MetricX version unspecified.
  /// - "METRICX_24_REF" : MetricX 2024 (2.6) for translation + reference
  /// (reference-based).
  /// - "METRICX_24_SRC" : MetricX 2024 (2.6) for translation + source (QE).
  /// - "METRICX_24_SRC_REF" : MetricX 2024 (2.6) for translation + source +
  /// reference (source-reference-combined).
  core.String? version;

  GoogleCloudAiplatformV1MetricxSpec({
    this.sourceLanguage,
    this.targetLanguage,
    this.version,
  });

  GoogleCloudAiplatformV1MetricxSpec.fromJson(core.Map json_)
      : this(
          sourceLanguage: json_['sourceLanguage'] as core.String?,
          targetLanguage: json_['targetLanguage'] as core.String?,
          version: json_['version'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sourceLanguage != null) 'sourceLanguage': sourceLanguage!,
        if (targetLanguage != null) 'targetLanguage': targetLanguage!,
        if (version != null) 'version': version!,
      };
}

/// Represents one resource that exists in automl.googleapis.com,
/// datalabeling.googleapis.com or ml.googleapis.com.
class GoogleCloudAiplatformV1MigratableResource {
  /// Represents one Dataset in automl.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceAutomlDataset? automlDataset;

  /// Represents one Model in automl.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceAutomlModel? automlModel;

  /// Represents one Dataset in datalabeling.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset?
      dataLabelingDataset;

  /// Timestamp when the last migration attempt on this MigratableResource
  /// started.
  ///
  /// Will not be set if there's no migration attempt on this
  /// MigratableResource.
  ///
  /// Output only.
  core.String? lastMigrateTime;

  /// Timestamp when this MigratableResource was last updated.
  ///
  /// Output only.
  core.String? lastUpdateTime;

  /// Represents one Version in ml.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion?
      mlEngineModelVersion;

  GoogleCloudAiplatformV1MigratableResource({
    this.automlDataset,
    this.automlModel,
    this.dataLabelingDataset,
    this.lastMigrateTime,
    this.lastUpdateTime,
    this.mlEngineModelVersion,
  });

  GoogleCloudAiplatformV1MigratableResource.fromJson(core.Map json_)
      : this(
          automlDataset: json_.containsKey('automlDataset')
              ? GoogleCloudAiplatformV1MigratableResourceAutomlDataset.fromJson(
                  json_['automlDataset'] as core.Map<core.String, core.dynamic>)
              : null,
          automlModel: json_.containsKey('automlModel')
              ? GoogleCloudAiplatformV1MigratableResourceAutomlModel.fromJson(
                  json_['automlModel'] as core.Map<core.String, core.dynamic>)
              : null,
          dataLabelingDataset: json_.containsKey('dataLabelingDataset')
              ? GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset
                  .fromJson(json_['dataLabelingDataset']
                      as core.Map<core.String, core.dynamic>)
              : null,
          lastMigrateTime: json_['lastMigrateTime'] as core.String?,
          lastUpdateTime: json_['lastUpdateTime'] as core.String?,
          mlEngineModelVersion: json_.containsKey('mlEngineModelVersion')
              ? GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion
                  .fromJson(json_['mlEngineModelVersion']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automlDataset != null) 'automlDataset': automlDataset!,
        if (automlModel != null) 'automlModel': automlModel!,
        if (dataLabelingDataset != null)
          'dataLabelingDataset': dataLabelingDataset!,
        if (lastMigrateTime != null) 'lastMigrateTime': lastMigrateTime!,
        if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!,
        if (mlEngineModelVersion != null)
          'mlEngineModelVersion': mlEngineModelVersion!,
      };
}

/// Represents one Dataset in automl.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceAutomlDataset {
  /// Full resource name of automl Dataset.
  ///
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`.
  core.String? dataset;

  /// The Dataset's display name in automl.googleapis.com.
  core.String? datasetDisplayName;

  GoogleCloudAiplatformV1MigratableResourceAutomlDataset({
    this.dataset,
    this.datasetDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceAutomlDataset.fromJson(
      core.Map json_)
      : this(
          dataset: json_['dataset'] as core.String?,
          datasetDisplayName: json_['datasetDisplayName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
      };
}

/// Represents one Model in automl.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceAutomlModel {
  /// Full resource name of automl Model.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  core.String? model;

  /// The Model's display name in automl.googleapis.com.
  core.String? modelDisplayName;

  GoogleCloudAiplatformV1MigratableResourceAutomlModel({
    this.model,
    this.modelDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceAutomlModel.fromJson(core.Map json_)
      : this(
          model: json_['model'] as core.String?,
          modelDisplayName: json_['modelDisplayName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
      };
}

/// Represents one Dataset in datalabeling.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset {
  /// The migratable AnnotatedDataset in datalabeling.googleapis.com belongs to
  /// the data labeling Dataset.
  core.List<
          GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset>?
      dataLabelingAnnotatedDatasets;

  /// Full resource name of data labeling Dataset.
  ///
  /// Format: `projects/{project}/datasets/{dataset}`.
  core.String? dataset;

  /// The Dataset's display name in datalabeling.googleapis.com.
  core.String? datasetDisplayName;

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset({
    this.dataLabelingAnnotatedDatasets,
    this.dataset,
    this.datasetDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset.fromJson(
      core.Map json_)
      : this(
          dataLabelingAnnotatedDatasets: (json_['dataLabelingAnnotatedDatasets']
                  as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          dataset: json_['dataset'] as core.String?,
          datasetDisplayName: json_['datasetDisplayName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataLabelingAnnotatedDatasets != null)
          'dataLabelingAnnotatedDatasets': dataLabelingAnnotatedDatasets!,
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
      };
}

/// Represents one AnnotatedDataset in datalabeling.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset {
  /// Full resource name of data labeling AnnotatedDataset.
  ///
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  core.String? annotatedDataset;

  /// The AnnotatedDataset's display name in datalabeling.googleapis.com.
  core.String? annotatedDatasetDisplayName;

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset({
    this.annotatedDataset,
    this.annotatedDatasetDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset.fromJson(
      core.Map json_)
      : this(
          annotatedDataset: json_['annotatedDataset'] as core.String?,
          annotatedDatasetDisplayName:
              json_['annotatedDatasetDisplayName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotatedDataset != null) 'annotatedDataset': annotatedDataset!,
        if (annotatedDatasetDisplayName != null)
          'annotatedDatasetDisplayName': annotatedDatasetDisplayName!,
      };
}

/// Represents one model Version in ml.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion {
  /// The ml.googleapis.com endpoint that this model Version currently lives in.
  ///
  /// Example values: * ml.googleapis.com * us-centrall-ml.googleapis.com *
  /// europe-west4-ml.googleapis.com * asia-east1-ml.googleapis.com
  core.String? endpoint;

  /// Full resource name of ml engine model Version.
  ///
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  core.String? version;

  GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion({
    this.endpoint,
    this.version,
  });

  GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion.fromJson(
      core.Map json_)
      : this(
          endpoint: json_['endpoint'] as core.String?,
          version: json_['version'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
        if (version != null) 'version': version!,
      };
}

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
class GoogleCloudAiplatformV1MigrateResourceRequest {
  /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
  /// Dataset.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig?
      migrateAutomlDatasetConfig;

  /// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig?
      migrateAutomlModelConfig;

  /// Config for migrating Dataset in datalabeling.googleapis.com to Vertex AI's
  /// Dataset.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig?
      migrateDataLabelingDatasetConfig;

  /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig?
      migrateMlEngineModelVersionConfig;

  GoogleCloudAiplatformV1MigrateResourceRequest({
    this.migrateAutomlDatasetConfig,
    this.migrateAutomlModelConfig,
    this.migrateDataLabelingDatasetConfig,
    this.migrateMlEngineModelVersionConfig,
  });

  GoogleCloudAiplatformV1MigrateResourceRequest.fromJson(core.Map json_)
      : this(
          migrateAutomlDatasetConfig: json_
                  .containsKey('migrateAutomlDatasetConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig
                  .fromJson(json_['migrateAutomlDatasetConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          migrateAutomlModelConfig: json_
                  .containsKey('migrateAutomlModelConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig
                  .fromJson(json_['migrateAutomlModelConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          migrateDataLabelingDatasetConfig: json_
                  .containsKey('migrateDataLabelingDatasetConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig
                  .fromJson(json_['migrateDataLabelingDatasetConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          migrateMlEngineModelVersionConfig: json_
                  .containsKey('migrateMlEngineModelVersionConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig
                  .fromJson(json_['migrateMlEngineModelVersionConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (migrateAutomlDatasetConfig != null)
          'migrateAutomlDatasetConfig': migrateAutomlDatasetConfig!,
        if (migrateAutomlModelConfig != null)
          'migrateAutomlModelConfig': migrateAutomlModelConfig!,
        if (migrateDataLabelingDatasetConfig != null)
          'migrateDataLabelingDatasetConfig': migrateDataLabelingDatasetConfig!,
        if (migrateMlEngineModelVersionConfig != null)
          'migrateMlEngineModelVersionConfig':
              migrateMlEngineModelVersionConfig!,
      };
}

/// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
/// Dataset.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig {
  /// Full resource name of automl Dataset.
  ///
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`.
  ///
  /// Required.
  core.String? dataset;

  /// Display name of the Dataset in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Required.
  core.String? datasetDisplayName;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig.fromJson(
      core.Map json_)
      : this(
          dataset: json_['dataset'] as core.String?,
          datasetDisplayName: json_['datasetDisplayName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
      };
}

/// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig {
  /// Full resource name of automl Model.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  ///
  /// Required.
  core.String? model;

  /// Display name of the model in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Optional.
  core.String? modelDisplayName;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig({
    this.model,
    this.modelDisplayName,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig.fromJson(
      core.Map json_)
      : this(
          model: json_['model'] as core.String?,
          modelDisplayName: json_['modelDisplayName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
      };
}

/// Config for migrating Dataset in datalabeling.googleapis.com to Vertex AI's
/// Dataset.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig {
  /// Full resource name of data labeling Dataset.
  ///
  /// Format: `projects/{project}/datasets/{dataset}`.
  ///
  /// Required.
  core.String? dataset;

  /// Display name of the Dataset in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Optional.
  core.String? datasetDisplayName;

  /// Configs for migrating AnnotatedDataset in datalabeling.googleapis.com to
  /// Vertex AI's SavedQuery.
  ///
  /// The specified AnnotatedDatasets have to belong to the datalabeling
  /// Dataset.
  ///
  /// Optional.
  core.List<
          GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig>?
      migrateDataLabelingAnnotatedDatasetConfigs;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
    this.migrateDataLabelingAnnotatedDatasetConfigs,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig.fromJson(
      core.Map json_)
      : this(
          dataset: json_['dataset'] as core.String?,
          datasetDisplayName: json_['datasetDisplayName'] as core.String?,
          migrateDataLabelingAnnotatedDatasetConfigs: (json_[
                  'migrateDataLabelingAnnotatedDatasetConfigs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
        if (migrateDataLabelingAnnotatedDatasetConfigs != null)
          'migrateDataLabelingAnnotatedDatasetConfigs':
              migrateDataLabelingAnnotatedDatasetConfigs!,
      };
}

/// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
/// Vertex AI's SavedQuery.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig {
  /// Full resource name of data labeling AnnotatedDataset.
  ///
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  ///
  /// Required.
  core.String? annotatedDataset;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig({
    this.annotatedDataset,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig.fromJson(
      core.Map json_)
      : this(
          annotatedDataset: json_['annotatedDataset'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotatedDataset != null) 'annotatedDataset': annotatedDataset!,
      };
}

/// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig {
  /// The ml.googleapis.com endpoint that this model version should be migrated
  /// from.
  ///
  /// Example values: * ml.googleapis.com * us-centrall-ml.googleapis.com *
  /// europe-west4-ml.googleapis.com * asia-east1-ml.googleapis.com
  ///
  /// Required.
  core.String? endpoint;

  /// Display name of the model in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Required.
  core.String? modelDisplayName;

  /// Full resource name of ml engine model version.
  ///
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  ///
  /// Required.
  core.String? modelVersion;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig({
    this.endpoint,
    this.modelDisplayName,
    this.modelVersion,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig.fromJson(
      core.Map json_)
      : this(
          endpoint: json_['endpoint'] as core.String?,
          modelDisplayName: json_['modelDisplayName'] as core.String?,
          modelVersion: json_['modelVersion'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
        if (modelVersion != null) 'modelVersion': modelVersion!,
      };
}

/// Represents token counting info for a single modality.
class GoogleCloudAiplatformV1ModalityTokenCount {
  /// The modality associated with this token count.
  /// Possible string values are:
  /// - "MODALITY_UNSPECIFIED" : Unspecified modality.
  /// - "TEXT" : Plain text.
  /// - "IMAGE" : Image.
  /// - "VIDEO" : Video.
  /// - "AUDIO" : Audio.
  /// - "DOCUMENT" : Document, e.g. PDF.
  core.String? modality;

  /// Number of tokens.
  core.int? tokenCount;

  GoogleCloudAiplatformV1ModalityTokenCount({
    this.modality,
    this.tokenCount,
  });

  GoogleCloudAiplatformV1ModalityTokenCount.fromJson(core.Map json_)
      : this(
          modality: json_['modality'] as core.String?,
          tokenCount: json_['tokenCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modality != null) 'modality': modality!,
        if (tokenCount != null) 'tokenCount': tokenCount!,
      };
}

/// A trained machine learning Model.
class GoogleCloudAiplatformV1Model {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  ///
  /// Not required for AutoML Models.
  ///
  /// Immutable.
  core.String? artifactUri;

  /// User input field to specify the base model source.
  ///
  /// Currently it only supports specifing the Model Garden models and Genie
  /// models.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ModelBaseModelSource? baseModelSource;

  /// Input only.
  ///
  /// The specification of the container that is to be used when deploying this
  /// Model. The specification is ingested upon ModelService.UploadModel, and
  /// all binaries it contains are copied and stored internally by Vertex AI.
  /// Not required for AutoML Models.
  GoogleCloudAiplatformV1ModelContainerSpec? containerSpec;

  /// Timestamp when this Model was uploaded into Vertex AI.
  ///
  /// Output only.
  core.String? createTime;

  /// Stats of data used for training or evaluating the Model.
  ///
  /// Only populated when the Model is trained by a TrainingPipeline with
  /// data_input_config.
  GoogleCloudAiplatformV1ModelDataStats? dataStats;

  /// The default checkpoint id of a model version.
  core.String? defaultCheckpointId;

  /// The pointers to DeployedModels created from this Model.
  ///
  /// Note that Model could have been deployed to Endpoints in different
  /// Locations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedModelRef>? deployedModels;

  /// The description of the Model.
  core.String? description;

  /// The display name of the Model.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Model.
  ///
  /// If set, this Model and all sub-resources of this Model will be secured by
  /// this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The default explanation specification for this Model.
  ///
  /// The Model can be used for requesting explanation after being deployed if
  /// it is populated. The Model can be used for batch explanation if it is
  /// populated. All fields of the explanation_spec can be overridden by
  /// explanation_spec of DeployModelRequest.deployed_model, or explanation_spec
  /// of BatchPredictionJob. If the default explanation specification is not set
  /// for this Model, this Model can still be used for requesting explanation by
  /// setting explanation_spec of DeployModelRequest.deployed_model and for
  /// batch explanation by setting explanation_spec of BatchPredictionJob.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// The labels with user-defined metadata to organize your Models.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// An additional information about the Model; the schema of the metadata can
  /// be found in metadata_schema.
  ///
  /// Unset if the Model does not have any additional information.
  ///
  /// Immutable.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Artifact that was created in MetadataStore when
  /// creating the Model.
  ///
  /// The Artifact resource name pattern is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  ///
  /// Output only.
  core.String? metadataArtifact;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Model, that is specific to it.
  ///
  /// Unset if the Model does not have any additional information. The schema is
  /// defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// additional metadata is needed, this field is set to an empty string. Note:
  /// The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  ///
  /// Immutable.
  core.String? metadataSchemaUri;

  /// Source of a model.
  ///
  /// It can either be automl training pipeline, custom training pipeline,
  /// BigQuery ML, or saved and tuned from Genie or Model Garden.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelSourceInfo? modelSourceInfo;

  /// The resource name of the Model.
  core.String? name;

  /// If this Model is a copy of another Model, this contains info about the
  /// original.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelOriginalModelInfo? originalModelInfo;

  /// This field is populated if the model is produced by a pipeline job.
  ///
  /// Optional.
  core.String? pipelineJob;

  /// The schemata that describe formats of the Model's predictions and
  /// explanations as given and returned via PredictionService.Predict and
  /// PredictionService.Explain.
  GoogleCloudAiplatformV1PredictSchemata? predictSchemata;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// When this Model is deployed, its prediction resources are described by the
  /// `prediction_resources` field of the Endpoint.deployed_models object.
  ///
  /// Because not all Models support all resource configuration types, the
  /// configuration types this Model supports are listed here. If no
  /// configuration types are listed, the Model cannot be deployed to an
  /// Endpoint and does not support online predictions
  /// (PredictionService.Predict or PredictionService.Explain). Such a Model can
  /// serve predictions by using a BatchPredictionJob, if it has at least one
  /// entry each in supported_input_storage_formats and
  /// supported_output_storage_formats.
  ///
  /// Output only.
  core.List<core.String>? supportedDeploymentResourcesTypes;

  /// The formats in which this Model may be exported.
  ///
  /// If empty, this Model is not available for export.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModelExportFormat>? supportedExportFormats;

  /// The formats this Model supports in BatchPredictionJob.input_config.
  ///
  /// If PredictSchemata.instance_schema_uri exists, the instances should be
  /// given as per that schema. The possible formats are: * `jsonl` The JSON
  /// Lines format, where each instance is a single line. Uses GcsSource. *
  /// `csv` The CSV format, where each instance is a single comma-separated
  /// line. The first line in the file is the header, containing comma-separated
  /// field names. Uses GcsSource. * `tf-record` The TFRecord format, where each
  /// instance is a single record in tfrecord syntax. Uses GcsSource. *
  /// `tf-record-gzip` Similar to `tf-record`, but the file is gzipped. Uses
  /// GcsSource. * `bigquery` Each instance is a single row in BigQuery. Uses
  /// BigQuerySource. * `file-list` Each line of the file is the location of an
  /// instance to process, uses `gcs_source` field of the InputConfig object. If
  /// this Model doesn't support any of these formats it means it cannot be used
  /// with a BatchPredictionJob. However, if it has
  /// supported_deployment_resources_types, it could serve online predictions by
  /// using PredictionService.Predict or PredictionService.Explain.
  ///
  /// Output only.
  core.List<core.String>? supportedInputStorageFormats;

  /// The formats this Model supports in BatchPredictionJob.output_config.
  ///
  /// If both PredictSchemata.instance_schema_uri and
  /// PredictSchemata.prediction_schema_uri exist, the predictions are returned
  /// together with their instances. In other words, the prediction has the
  /// original instance data first, followed by the actual prediction content
  /// (as per the schema). The possible formats are: * `jsonl` The JSON Lines
  /// format, where each prediction is a single line. Uses GcsDestination. *
  /// `csv` The CSV format, where each prediction is a single comma-separated
  /// line. The first line in the file is the header, containing comma-separated
  /// field names. Uses GcsDestination. * `bigquery` Each prediction is a single
  /// row in a BigQuery table, uses BigQueryDestination . If this Model doesn't
  /// support any of these formats it means it cannot be used with a
  /// BatchPredictionJob. However, if it has
  /// supported_deployment_resources_types, it could serve online predictions by
  /// using PredictionService.Predict or PredictionService.Explain.
  ///
  /// Output only.
  core.List<core.String>? supportedOutputStorageFormats;

  /// The resource name of the TrainingPipeline that uploaded this Model, if
  /// any.
  ///
  /// Output only.
  core.String? trainingPipeline;

  /// Timestamp when this Model was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// User provided version aliases so that a model version can be referenced
  /// via alias (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
  /// instead of auto-generated version id (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
  ///
  /// The format is a-z{0,126}\[a-z0-9\] to distinguish from version_id. A
  /// default version alias will be created for the first version of the model,
  /// and there must be exactly one default version alias for a model.
  core.List<core.String>? versionAliases;

  /// Timestamp when this version was created.
  ///
  /// Output only.
  core.String? versionCreateTime;

  /// The description of this version.
  core.String? versionDescription;

  /// The version ID of the model.
  ///
  /// A new version is committed when a new model version is uploaded or trained
  /// under an existing model id. It is an auto-incrementing decimal number in
  /// string representation.
  ///
  /// Output only. Immutable.
  core.String? versionId;

  /// Timestamp when this version was most recently updated.
  ///
  /// Output only.
  core.String? versionUpdateTime;

  GoogleCloudAiplatformV1Model({
    this.artifactUri,
    this.baseModelSource,
    this.containerSpec,
    this.createTime,
    this.dataStats,
    this.defaultCheckpointId,
    this.deployedModels,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.explanationSpec,
    this.labels,
    this.metadata,
    this.metadataArtifact,
    this.metadataSchemaUri,
    this.modelSourceInfo,
    this.name,
    this.originalModelInfo,
    this.pipelineJob,
    this.predictSchemata,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.supportedDeploymentResourcesTypes,
    this.supportedExportFormats,
    this.supportedInputStorageFormats,
    this.supportedOutputStorageFormats,
    this.trainingPipeline,
    this.updateTime,
    this.versionAliases,
    this.versionCreateTime,
    this.versionDescription,
    this.versionId,
    this.versionUpdateTime,
  });

  GoogleCloudAiplatformV1Model.fromJson(core.Map json_)
      : this(
          artifactUri: json_['artifactUri'] as core.String?,
          baseModelSource: json_.containsKey('baseModelSource')
              ? GoogleCloudAiplatformV1ModelBaseModelSource.fromJson(
                  json_['baseModelSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          dataStats: json_.containsKey('dataStats')
              ? GoogleCloudAiplatformV1ModelDataStats.fromJson(
                  json_['dataStats'] as core.Map<core.String, core.dynamic>)
              : null,
          defaultCheckpointId: json_['defaultCheckpointId'] as core.String?,
          deployedModels: (json_['deployedModels'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DeployedModelRef.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          metadata: json_['metadata'],
          metadataArtifact: json_['metadataArtifact'] as core.String?,
          metadataSchemaUri: json_['metadataSchemaUri'] as core.String?,
          modelSourceInfo: json_.containsKey('modelSourceInfo')
              ? GoogleCloudAiplatformV1ModelSourceInfo.fromJson(
                  json_['modelSourceInfo']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          originalModelInfo: json_.containsKey('originalModelInfo')
              ? GoogleCloudAiplatformV1ModelOriginalModelInfo.fromJson(
                  json_['originalModelInfo']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pipelineJob: json_['pipelineJob'] as core.String?,
          predictSchemata: json_.containsKey('predictSchemata')
              ? GoogleCloudAiplatformV1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          supportedDeploymentResourcesTypes:
              (json_['supportedDeploymentResourcesTypes'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
          supportedExportFormats:
              (json_['supportedExportFormats'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ModelExportFormat.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
          supportedInputStorageFormats:
              (json_['supportedInputStorageFormats'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
          supportedOutputStorageFormats:
              (json_['supportedOutputStorageFormats'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
          trainingPipeline: json_['trainingPipeline'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
          versionAliases: (json_['versionAliases'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          versionCreateTime: json_['versionCreateTime'] as core.String?,
          versionDescription: json_['versionDescription'] as core.String?,
          versionId: json_['versionId'] as core.String?,
          versionUpdateTime: json_['versionUpdateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactUri != null) 'artifactUri': artifactUri!,
        if (baseModelSource != null) 'baseModelSource': baseModelSource!,
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (createTime != null) 'createTime': createTime!,
        if (dataStats != null) 'dataStats': dataStats!,
        if (defaultCheckpointId != null)
          'defaultCheckpointId': defaultCheckpointId!,
        if (deployedModels != null) 'deployedModels': deployedModels!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataArtifact != null) 'metadataArtifact': metadataArtifact!,
        if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
        if (modelSourceInfo != null) 'modelSourceInfo': modelSourceInfo!,
        if (name != null) 'name': name!,
        if (originalModelInfo != null) 'originalModelInfo': originalModelInfo!,
        if (pipelineJob != null) 'pipelineJob': pipelineJob!,
        if (predictSchemata != null) 'predictSchemata': predictSchemata!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (supportedDeploymentResourcesTypes != null)
          'supportedDeploymentResourcesTypes':
              supportedDeploymentResourcesTypes!,
        if (supportedExportFormats != null)
          'supportedExportFormats': supportedExportFormats!,
        if (supportedInputStorageFormats != null)
          'supportedInputStorageFormats': supportedInputStorageFormats!,
        if (supportedOutputStorageFormats != null)
          'supportedOutputStorageFormats': supportedOutputStorageFormats!,
        if (trainingPipeline != null) 'trainingPipeline': trainingPipeline!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (versionAliases != null) 'versionAliases': versionAliases!,
        if (versionCreateTime != null) 'versionCreateTime': versionCreateTime!,
        if (versionDescription != null)
          'versionDescription': versionDescription!,
        if (versionId != null) 'versionId': versionId!,
        if (versionUpdateTime != null) 'versionUpdateTime': versionUpdateTime!,
      };
}

/// User input field to specify the base model source.
///
/// Currently it only supports specifing the Model Garden models and Genie
/// models.
class GoogleCloudAiplatformV1ModelBaseModelSource {
  /// Information about the base model of Genie models.
  GoogleCloudAiplatformV1GenieSource? genieSource;

  /// Source information of Model Garden models.
  GoogleCloudAiplatformV1ModelGardenSource? modelGardenSource;

  GoogleCloudAiplatformV1ModelBaseModelSource({
    this.genieSource,
    this.modelGardenSource,
  });

  GoogleCloudAiplatformV1ModelBaseModelSource.fromJson(core.Map json_)
      : this(
          genieSource: json_.containsKey('genieSource')
              ? GoogleCloudAiplatformV1GenieSource.fromJson(
                  json_['genieSource'] as core.Map<core.String, core.dynamic>)
              : null,
          modelGardenSource: json_.containsKey('modelGardenSource')
              ? GoogleCloudAiplatformV1ModelGardenSource.fromJson(
                  json_['modelGardenSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (genieSource != null) 'genieSource': genieSource!,
        if (modelGardenSource != null) 'modelGardenSource': modelGardenSource!,
      };
}

/// Specification of a container for serving predictions.
///
/// Some fields in this message correspond to fields in the
/// [Kubernetes Container v1 core specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
class GoogleCloudAiplatformV1ModelContainerSpec {
  /// Specifies arguments for the command that runs when the container starts.
  ///
  /// This overrides the container's
  /// \[`CMD`\](https://docs.docker.com/engine/reference/builder/#cmd). Specify
  /// this field as an array of executable and arguments, similar to a Docker
  /// `CMD`'s "default parameters" form. If you don't specify this field but do
  /// specify the command field, then the command from the `command` field runs
  /// without any additional arguments. See the \[Kubernetes documentation about
  /// how the `command` and `args` fields interact with a container's
  /// `ENTRYPOINT` and
  /// `CMD`\](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  /// If you don't specify this field and don't specify the `command` field,
  /// then the container's
  /// \[`ENTRYPOINT`\](https://docs.docker.com/engine/reference/builder/#cmd)
  /// and `CMD` determine what runs based on their default behavior. See the
  /// Docker documentation about \[how `CMD` and `ENTRYPOINT`
  /// interact\](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  /// In this field, you can reference
  /// [environment variables set by Vertex AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the env field. You cannot reference
  /// environment variables set in the Docker image. In order for environment
  /// variables to be expanded, reference them by using the following syntax: $(
  /// VARIABLE_NAME) Note that this differs from Bash variable expansion, which
  /// does not use parentheses. If a variable cannot be resolved, the reference
  /// in the input string is used unchanged. To avoid variable expansion, you
  /// can escape this syntax with `$$`; for example: $$(VARIABLE_NAME) This
  /// field corresponds to the `args` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<core.String>? args;

  /// Specifies the command that runs when the container starts.
  ///
  /// This overrides the container's
  /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
  /// Specify this field as an array of executable and arguments, similar to a
  /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form. If you do not
  /// specify this field, then the container's `ENTRYPOINT` runs, in conjunction
  /// with the args field or the container's
  /// \[`CMD`\](https://docs.docker.com/engine/reference/builder/#cmd), if
  /// either exists. If this field is not specified and the container does not
  /// have an `ENTRYPOINT`, then refer to the Docker documentation about \[how
  /// `CMD` and `ENTRYPOINT`
  /// interact\](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  /// If you specify this field, then you can also specify the `args` field to
  /// provide additional arguments for this command. However, if you specify
  /// this field, then the container's `CMD` is ignored. See the \[Kubernetes
  /// documentation about how the `command` and `args` fields interact with a
  /// container's `ENTRYPOINT` and
  /// `CMD`\](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  /// In this field, you can reference
  /// [environment variables set by Vertex AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the env field. You cannot reference
  /// environment variables set in the Docker image. In order for environment
  /// variables to be expanded, reference them by using the following syntax: $(
  /// VARIABLE_NAME) Note that this differs from Bash variable expansion, which
  /// does not use parentheses. If a variable cannot be resolved, the reference
  /// in the input string is used unchanged. To avoid variable expansion, you
  /// can escape this syntax with `$$`; for example: $$(VARIABLE_NAME) This
  /// field corresponds to the `command` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<core.String>? command;

  /// Deployment timeout.
  ///
  /// Limit for deployment timeout is 2 hours.
  ///
  /// Immutable.
  core.String? deploymentTimeout;

  /// List of environment variables to set in the container.
  ///
  /// After the container starts running, code running in the container can read
  /// these environment variables. Additionally, the command and args fields can
  /// reference these variables. Later entries in this list can also reference
  /// earlier entries. For example, the following example sets the variable
  /// `VAR_2` to have the value `foo bar`: ```json [ { "name": "VAR_1", "value":
  /// "foo" }, { "name": "VAR_2", "value": "$(VAR_1) bar" } ] ``` If you switch
  /// the order of the variables in the example, then the expansion does not
  /// occur. This field corresponds to the `env` field of the Kubernetes
  /// Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// List of ports to expose from the container.
  ///
  /// Vertex AI sends gRPC prediction requests that it receives to the first
  /// port on this list. Vertex AI also sends liveness and health checks to this
  /// port. If you do not specify this field, gRPC requests to the container
  /// will be disabled. Vertex AI does not use ports other than the first one
  /// listed. This field corresponds to the `ports` field of the Kubernetes
  /// Containers v1 core API.
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1Port>? grpcPorts;

  /// Specification for Kubernetes readiness probe.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1Probe? healthProbe;

  /// HTTP path on the container to send health checks to.
  ///
  /// Vertex AI intermittently sends GET requests to this path on the
  /// container's IP address and port to check that the container is healthy.
  /// Read more about
  /// [health checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
  /// For example, if you set this field to `/bar`, then Vertex AI
  /// intermittently sends a GET request to the `/bar` path on the port of your
  /// container specified by the first value of this `ModelContainerSpec`'s
  /// ports field. If you don't specify this field, it defaults to the following
  /// value when you deploy this Model to an Endpoint:
  /// /v1/endpoints/ENDPOINT/deployedModels/ DEPLOYED_MODEL:predict The
  /// placeholders in this value are replaced as follows: * ENDPOINT: The last
  /// segment (following `endpoints/`)of the Endpoint.name\]\[\] field of the
  /// Endpoint where this Model has been deployed. (Vertex AI makes this value
  /// available to your container code as the \[`AIP_ENDPOINT_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  /// * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`. (Vertex AI
  /// makes this value available to your container code as the
  /// \[`AIP_DEPLOYED_MODEL_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// Immutable.
  core.String? healthRoute;

  /// URI of the Docker image to be used as the custom container for serving
  /// predictions.
  ///
  /// This URI must identify an image in Artifact Registry or Container
  /// Registry. Learn more about the
  /// [container publishing requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
  /// including permissions requirements for the Vertex AI Service Agent. The
  /// container image is ingested upon ModelService.UploadModel, stored
  /// internally, and this original path is afterwards not used. To learn about
  /// the requirements for the Docker image itself, see
  /// [Custom container requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
  /// You can use the URI to one of Vertex AI's \[pre-built container images for
  /// prediction\](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
  /// in this field.
  ///
  /// Required. Immutable.
  core.String? imageUri;

  /// Specification for Kubernetes liveness probe.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1Probe? livenessProbe;

  /// List of ports to expose from the container.
  ///
  /// Vertex AI sends any prediction requests that it receives to the first port
  /// on this list. Vertex AI also sends
  /// [liveness and health checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
  /// to this port. If you do not specify this field, it defaults to following
  /// value: ```json [ { "containerPort": 8080 } ] ``` Vertex AI does not use
  /// ports other than the first one listed. This field corresponds to the
  /// `ports` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1Port>? ports;

  /// HTTP path on the container to send prediction requests to.
  ///
  /// Vertex AI forwards requests sent using
  /// projects.locations.endpoints.predict to this path on the container's IP
  /// address and port. Vertex AI then returns the container's response in the
  /// API response. For example, if you set this field to `/foo`, then when
  /// Vertex AI receives a prediction request, it forwards the request body in a
  /// POST request to the `/foo` path on the port of your container specified by
  /// the first value of this `ModelContainerSpec`'s ports field. If you don't
  /// specify this field, it defaults to the following value when you deploy
  /// this Model to an Endpoint:
  /// /v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict The
  /// placeholders in this value are replaced as follows: * ENDPOINT: The last
  /// segment (following `endpoints/`)of the Endpoint.name\]\[\] field of the
  /// Endpoint where this Model has been deployed. (Vertex AI makes this value
  /// available to your container code as the \[`AIP_ENDPOINT_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  /// * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`. (Vertex AI
  /// makes this value available to your container code as the
  /// \[`AIP_DEPLOYED_MODEL_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// Immutable.
  core.String? predictRoute;

  /// The amount of the VM memory to reserve as the shared memory for the model
  /// in megabytes.
  ///
  /// Immutable.
  core.String? sharedMemorySizeMb;

  /// Specification for Kubernetes startup probe.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1Probe? startupProbe;

  GoogleCloudAiplatformV1ModelContainerSpec({
    this.args,
    this.command,
    this.deploymentTimeout,
    this.env,
    this.grpcPorts,
    this.healthProbe,
    this.healthRoute,
    this.imageUri,
    this.livenessProbe,
    this.ports,
    this.predictRoute,
    this.sharedMemorySizeMb,
    this.startupProbe,
  });

  GoogleCloudAiplatformV1ModelContainerSpec.fromJson(core.Map json_)
      : this(
          args: (json_['args'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          command: (json_['command'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          deploymentTimeout: json_['deploymentTimeout'] as core.String?,
          env: (json_['env'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          grpcPorts: (json_['grpcPorts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Port.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          healthProbe: json_.containsKey('healthProbe')
              ? GoogleCloudAiplatformV1Probe.fromJson(
                  json_['healthProbe'] as core.Map<core.String, core.dynamic>)
              : null,
          healthRoute: json_['healthRoute'] as core.String?,
          imageUri: json_['imageUri'] as core.String?,
          livenessProbe: json_.containsKey('livenessProbe')
              ? GoogleCloudAiplatformV1Probe.fromJson(
                  json_['livenessProbe'] as core.Map<core.String, core.dynamic>)
              : null,
          ports: (json_['ports'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Port.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          predictRoute: json_['predictRoute'] as core.String?,
          sharedMemorySizeMb: json_['sharedMemorySizeMb'] as core.String?,
          startupProbe: json_.containsKey('startupProbe')
              ? GoogleCloudAiplatformV1Probe.fromJson(
                  json_['startupProbe'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (args != null) 'args': args!,
        if (command != null) 'command': command!,
        if (deploymentTimeout != null) 'deploymentTimeout': deploymentTimeout!,
        if (env != null) 'env': env!,
        if (grpcPorts != null) 'grpcPorts': grpcPorts!,
        if (healthProbe != null) 'healthProbe': healthProbe!,
        if (healthRoute != null) 'healthRoute': healthRoute!,
        if (imageUri != null) 'imageUri': imageUri!,
        if (livenessProbe != null) 'livenessProbe': livenessProbe!,
        if (ports != null) 'ports': ports!,
        if (predictRoute != null) 'predictRoute': predictRoute!,
        if (sharedMemorySizeMb != null)
          'sharedMemorySizeMb': sharedMemorySizeMb!,
        if (startupProbe != null) 'startupProbe': startupProbe!,
      };
}

/// Stats of data used for train or evaluate the Model.
class GoogleCloudAiplatformV1ModelDataStats {
  /// Number of Annotations that are used for evaluating this Model.
  ///
  /// If the Model is evaluated multiple times, this will be the number of test
  /// Annotations used by the first evaluation. If the Model is not evaluated,
  /// the number is 0.
  core.String? testAnnotationsCount;

  /// Number of DataItems that were used for evaluating this Model.
  ///
  /// If the Model is evaluated multiple times, this will be the number of test
  /// DataItems used by the first evaluation. If the Model is not evaluated, the
  /// number is 0.
  core.String? testDataItemsCount;

  /// Number of Annotations that are used for training this Model.
  core.String? trainingAnnotationsCount;

  /// Number of DataItems that were used for training this Model.
  core.String? trainingDataItemsCount;

  /// Number of Annotations that are used for validating this Model during
  /// training.
  core.String? validationAnnotationsCount;

  /// Number of DataItems that were used for validating this Model during
  /// training.
  core.String? validationDataItemsCount;

  GoogleCloudAiplatformV1ModelDataStats({
    this.testAnnotationsCount,
    this.testDataItemsCount,
    this.trainingAnnotationsCount,
    this.trainingDataItemsCount,
    this.validationAnnotationsCount,
    this.validationDataItemsCount,
  });

  GoogleCloudAiplatformV1ModelDataStats.fromJson(core.Map json_)
      : this(
          testAnnotationsCount: json_['testAnnotationsCount'] as core.String?,
          testDataItemsCount: json_['testDataItemsCount'] as core.String?,
          trainingAnnotationsCount:
              json_['trainingAnnotationsCount'] as core.String?,
          trainingDataItemsCount:
              json_['trainingDataItemsCount'] as core.String?,
          validationAnnotationsCount:
              json_['validationAnnotationsCount'] as core.String?,
          validationDataItemsCount:
              json_['validationDataItemsCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (testAnnotationsCount != null)
          'testAnnotationsCount': testAnnotationsCount!,
        if (testDataItemsCount != null)
          'testDataItemsCount': testDataItemsCount!,
        if (trainingAnnotationsCount != null)
          'trainingAnnotationsCount': trainingAnnotationsCount!,
        if (trainingDataItemsCount != null)
          'trainingDataItemsCount': trainingDataItemsCount!,
        if (validationAnnotationsCount != null)
          'validationAnnotationsCount': validationAnnotationsCount!,
        if (validationDataItemsCount != null)
          'validationDataItemsCount': validationDataItemsCount!,
      };
}

/// ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as
/// well as some information of the logs stored in this table.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable {
  /// The created BigQuery table to store logs.
  ///
  /// Customer could do their own query & analysis. Format:
  /// `bq://.model_deployment_monitoring_._`
  core.String? bigqueryTablePath;

  /// The source of log.
  /// Possible string values are:
  /// - "LOG_SOURCE_UNSPECIFIED" : Unspecified source.
  /// - "TRAINING" : Logs coming from Training dataset.
  /// - "SERVING" : Logs coming from Serving traffic.
  core.String? logSource;

  /// The type of log.
  /// Possible string values are:
  /// - "LOG_TYPE_UNSPECIFIED" : Unspecified type.
  /// - "PREDICT" : Predict logs.
  /// - "EXPLAIN" : Explain logs.
  core.String? logType;

  /// The schema version of the request/response logging BigQuery table.
  ///
  /// Default to v1 if unset.
  ///
  /// Output only.
  core.String? requestResponseLoggingSchemaVersion;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable({
    this.bigqueryTablePath,
    this.logSource,
    this.logType,
    this.requestResponseLoggingSchemaVersion,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable.fromJson(
      core.Map json_)
      : this(
          bigqueryTablePath: json_['bigqueryTablePath'] as core.String?,
          logSource: json_['logSource'] as core.String?,
          logType: json_['logType'] as core.String?,
          requestResponseLoggingSchemaVersion:
              json_['requestResponseLoggingSchemaVersion'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryTablePath != null) 'bigqueryTablePath': bigqueryTablePath!,
        if (logSource != null) 'logSource': logSource!,
        if (logType != null) 'logType': logType!,
        if (requestResponseLoggingSchemaVersion != null)
          'requestResponseLoggingSchemaVersion':
              requestResponseLoggingSchemaVersion!,
      };
}

/// Represents a job that runs periodically to monitor the deployed models in an
/// endpoint.
///
/// It will analyze the logged training & prediction data to detect any abnormal
/// behaviors.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringJob {
  /// YAML schema file uri describing the format of a single instance that you
  /// want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If this field is empty, all the feature data types are inferred from
  /// predict_instance_schema_uri, meaning that TFDV will use the data in the
  /// exact format(data type) as prediction request/response. If there are any
  /// data type differences between predict instance and TFDV instance, this
  /// field can be used to override the schema. For models trained with Vertex
  /// AI, this field must be set as all the fields in predict instance formatted
  /// as string.
  core.String? analysisInstanceSchemaUri;

  /// The created bigquery tables for the job under customer project.
  ///
  /// Customer could do their own query & analysis. There could be 4 log tables
  /// in maximum: 1. Training data logging predict request/response 2. Serving
  /// data logging predict request/response
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable>?
      bigqueryTables;

  /// Timestamp when this ModelDeploymentMonitoringJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the ModelDeploymentMonitoringJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. Display name of a ModelDeploymentMonitoringJob.
  ///
  /// Required.
  core.String? displayName;

  /// If true, the scheduled monitoring pipeline logs are sent to Google Cloud
  /// Logging, including pipeline status and anomalies detected.
  ///
  /// Please note the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
  core.bool? enableMonitoringPipelineLogs;

  /// Customer-managed encryption key spec for a ModelDeploymentMonitoringJob.
  ///
  /// If set, this ModelDeploymentMonitoringJob and all sub-resources of this
  /// ModelDeploymentMonitoringJob will be secured by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Endpoint resource name.
  ///
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Required.
  core.String? endpoint;

  /// Only populated when the job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize your
  /// ModelDeploymentMonitoringJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Latest triggered monitoring pipeline metadata.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata?
      latestMonitoringPipelineMetadata;

  /// The TTL of BigQuery tables in user projects which stores logs.
  ///
  /// A day is the basic unit of the TTL and we take the ceil of TTL/86400(a
  /// day). e.g. { second: 3600} indicates ttl = 1 day.
  core.String? logTtl;

  /// Sample Strategy for logging.
  ///
  /// Required.
  GoogleCloudAiplatformV1SamplingStrategy? loggingSamplingStrategy;

  /// The config for monitoring objectives.
  ///
  /// This is a per DeployedModel config. Each DeployedModel needs to be
  /// configured separately.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig>?
      modelDeploymentMonitoringObjectiveConfigs;

  /// Schedule config for running the monitoring job.
  ///
  /// Required.
  GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig?
      modelDeploymentMonitoringScheduleConfig;

  /// Alert config for model monitoring.
  GoogleCloudAiplatformV1ModelMonitoringAlertConfig? modelMonitoringAlertConfig;

  /// Resource name of a ModelDeploymentMonitoringJob.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this monitoring pipeline will be scheduled to run for the
  /// next round.
  ///
  /// Output only.
  core.String? nextScheduleTime;

  /// YAML schema file uri describing the format of a single instance, which are
  /// given to format this Endpoint's prediction (and explanation).
  ///
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  core.String? predictInstanceSchemaUri;

  /// Sample Predict instance, same format as PredictRequest.instances, this can
  /// be set as a replacement of
  /// ModelDeploymentMonitoringJob.predict_instance_schema_uri.
  ///
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? samplePredictInstance;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Schedule state when the monitoring job is in Running state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MONITORING_SCHEDULE_STATE_UNSPECIFIED" : Unspecified state.
  /// - "PENDING" : The pipeline is picked up and wait to run.
  /// - "OFFLINE" : The pipeline is offline and will be scheduled for next run.
  /// - "RUNNING" : The pipeline is running.
  core.String? scheduleState;

  /// The detailed state of the monitoring job.
  ///
  /// When the job is still creating, the state will be 'PENDING'. Once the job
  /// is successfully created, the state will be 'RUNNING'. Pause the job, the
  /// state will be 'PAUSED'. Resume the job, the state will return to
  /// 'RUNNING'.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Stats anomalies base folder path.
  GoogleCloudAiplatformV1GcsDestination? statsAnomaliesBaseDirectory;

  /// Timestamp when this ModelDeploymentMonitoringJob was updated most
  /// recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJob({
    this.analysisInstanceSchemaUri,
    this.bigqueryTables,
    this.createTime,
    this.displayName,
    this.enableMonitoringPipelineLogs,
    this.encryptionSpec,
    this.endpoint,
    this.error,
    this.labels,
    this.latestMonitoringPipelineMetadata,
    this.logTtl,
    this.loggingSamplingStrategy,
    this.modelDeploymentMonitoringObjectiveConfigs,
    this.modelDeploymentMonitoringScheduleConfig,
    this.modelMonitoringAlertConfig,
    this.name,
    this.nextScheduleTime,
    this.predictInstanceSchemaUri,
    this.samplePredictInstance,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.scheduleState,
    this.state,
    this.statsAnomaliesBaseDirectory,
    this.updateTime,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(core.Map json_)
      : this(
          analysisInstanceSchemaUri:
              json_['analysisInstanceSchemaUri'] as core.String?,
          bigqueryTables: (json_['bigqueryTables'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          enableMonitoringPipelineLogs:
              json_['enableMonitoringPipelineLogs'] as core.bool?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endpoint: json_['endpoint'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          latestMonitoringPipelineMetadata: json_
                  .containsKey('latestMonitoringPipelineMetadata')
              ? GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata
                  .fromJson(json_['latestMonitoringPipelineMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          logTtl: json_['logTtl'] as core.String?,
          loggingSamplingStrategy: json_.containsKey('loggingSamplingStrategy')
              ? GoogleCloudAiplatformV1SamplingStrategy.fromJson(
                  json_['loggingSamplingStrategy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelDeploymentMonitoringObjectiveConfigs: (json_[
                  'modelDeploymentMonitoringObjectiveConfigs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          modelDeploymentMonitoringScheduleConfig: json_
                  .containsKey('modelDeploymentMonitoringScheduleConfig')
              ? GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig
                  .fromJson(json_['modelDeploymentMonitoringScheduleConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelMonitoringAlertConfig:
              json_.containsKey('modelMonitoringAlertConfig')
                  ? GoogleCloudAiplatformV1ModelMonitoringAlertConfig.fromJson(
                      json_['modelMonitoringAlertConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          name: json_['name'] as core.String?,
          nextScheduleTime: json_['nextScheduleTime'] as core.String?,
          predictInstanceSchemaUri:
              json_['predictInstanceSchemaUri'] as core.String?,
          samplePredictInstance: json_['samplePredictInstance'],
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          scheduleState: json_['scheduleState'] as core.String?,
          state: json_['state'] as core.String?,
          statsAnomaliesBaseDirectory:
              json_.containsKey('statsAnomaliesBaseDirectory')
                  ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                      json_['statsAnomaliesBaseDirectory']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (analysisInstanceSchemaUri != null)
          'analysisInstanceSchemaUri': analysisInstanceSchemaUri!,
        if (bigqueryTables != null) 'bigqueryTables': bigqueryTables!,
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (enableMonitoringPipelineLogs != null)
          'enableMonitoringPipelineLogs': enableMonitoringPipelineLogs!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endpoint != null) 'endpoint': endpoint!,
        if (error != null) 'error': error!,
        if (labels != null) 'labels': labels!,
        if (latestMonitoringPipelineMetadata != null)
          'latestMonitoringPipelineMetadata': latestMonitoringPipelineMetadata!,
        if (logTtl != null) 'logTtl': logTtl!,
        if (loggingSamplingStrategy != null)
          'loggingSamplingStrategy': loggingSamplingStrategy!,
        if (modelDeploymentMonitoringObjectiveConfigs != null)
          'modelDeploymentMonitoringObjectiveConfigs':
              modelDeploymentMonitoringObjectiveConfigs!,
        if (modelDeploymentMonitoringScheduleConfig != null)
          'modelDeploymentMonitoringScheduleConfig':
              modelDeploymentMonitoringScheduleConfig!,
        if (modelMonitoringAlertConfig != null)
          'modelMonitoringAlertConfig': modelMonitoringAlertConfig!,
        if (name != null) 'name': name!,
        if (nextScheduleTime != null) 'nextScheduleTime': nextScheduleTime!,
        if (predictInstanceSchemaUri != null)
          'predictInstanceSchemaUri': predictInstanceSchemaUri!,
        if (samplePredictInstance != null)
          'samplePredictInstance': samplePredictInstance!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (scheduleState != null) 'scheduleState': scheduleState!,
        if (state != null) 'state': state!,
        if (statsAnomaliesBaseDirectory != null)
          'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// All metadata of most recent monitoring pipelines.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata {
  /// The time that most recent monitoring pipelines that is related to this
  /// run.
  core.String? runTime;

  /// The status of the most recent monitoring pipeline.
  GoogleRpcStatus? status;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata({
    this.runTime,
    this.status,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata.fromJson(
      core.Map json_)
      : this(
          runTime: json_['runTime'] as core.String?,
          status: json_.containsKey('status')
              ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (runTime != null) 'runTime': runTime!,
        if (status != null) 'status': status!,
      };
}

/// ModelDeploymentMonitoringObjectiveConfig contains the pair of
/// deployed_model_id to ModelMonitoringObjectiveConfig.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig {
  /// The DeployedModel ID of the objective config.
  core.String? deployedModelId;

  /// The objective config of for the modelmonitoring job of this deployed
  /// model.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig? objectiveConfig;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig({
    this.deployedModelId,
    this.objectiveConfig,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig.fromJson(
      core.Map json_)
      : this(
          deployedModelId: json_['deployedModelId'] as core.String?,
          objectiveConfig: json_.containsKey('objectiveConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig.fromJson(
                  json_['objectiveConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (objectiveConfig != null) 'objectiveConfig': objectiveConfig!,
      };
}

/// The config for scheduling monitoring job.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig {
  /// The model monitoring job scheduling interval.
  ///
  /// It will be rounded up to next full hour. This defines how often the
  /// monitoring jobs are triggered.
  ///
  /// Required.
  core.String? monitorInterval;

  /// The time window of the prediction data being included in each prediction
  /// dataset.
  ///
  /// This window specifies how long the data should be collected from
  /// historical model results for each run. If not set,
  /// ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used.
  /// e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the
  /// monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to
  /// 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the
  /// monitoring statistics.
  core.String? monitorWindow;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig({
    this.monitorInterval,
    this.monitorWindow,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig.fromJson(
      core.Map json_)
      : this(
          monitorInterval: json_['monitorInterval'] as core.String?,
          monitorWindow: json_['monitorWindow'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (monitorInterval != null) 'monitorInterval': monitorInterval!,
        if (monitorWindow != null) 'monitorWindow': monitorWindow!,
      };
}

/// A collection of metrics calculated by comparing Model's predictions on all
/// of the test data against annotations from the test data.
class GoogleCloudAiplatformV1ModelEvaluation {
  /// Points to a YAML file stored on Google Cloud Storage describing
  /// EvaluatedDataItemView.predictions, EvaluatedDataItemView.ground_truths,
  /// EvaluatedAnnotation.predictions, and EvaluatedAnnotation.ground_truths.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// This field is not populated if there are neither EvaluatedDataItemViews
  /// nor EvaluatedAnnotations under this ModelEvaluation.
  core.String? annotationSchemaUri;

  /// Timestamp when this ModelEvaluation was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Points to a YAML file stored on Google Cloud Storage describing
  /// EvaluatedDataItemView.data_item_payload and
  /// EvaluatedAnnotation.data_item_payload.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// This field is not populated if there are neither EvaluatedDataItemViews
  /// nor EvaluatedAnnotations under this ModelEvaluation.
  core.String? dataItemSchemaUri;

  /// The display name of the ModelEvaluation.
  core.String? displayName;

  /// Describes the values of ExplanationSpec that are used for explaining the
  /// predicted values on the evaluated data.
  core.List<
          GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec>?
      explanationSpecs;

  /// The metadata of the ModelEvaluation.
  ///
  /// For the ModelEvaluation uploaded from Managed Pipeline, metadata contains
  /// a structured value with keys of "pipeline_job_id",
  /// "evaluation_dataset_type", "evaluation_dataset_path",
  /// "row_based_metrics_path".
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Evaluation metrics of the Model.
  ///
  /// The schema of the metrics is stored in metrics_schema_uri
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metrics;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// metrics of this ModelEvaluation.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  core.String? metricsSchemaUri;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses.
  ///
  /// This field is populated only if the Model is evaluated with explanations,
  /// and only for AutoML tabular Models.
  GoogleCloudAiplatformV1ModelExplanation? modelExplanation;

  /// The resource name of the ModelEvaluation.
  ///
  /// Output only.
  core.String? name;

  /// All possible dimensions of ModelEvaluationSlices.
  ///
  /// The dimensions can be used as the filter of the
  /// ModelService.ListModelEvaluationSlices request, in the form of
  /// `slice.dimension = `.
  core.List<core.String>? sliceDimensions;

  GoogleCloudAiplatformV1ModelEvaluation({
    this.annotationSchemaUri,
    this.createTime,
    this.dataItemSchemaUri,
    this.displayName,
    this.explanationSpecs,
    this.metadata,
    this.metrics,
    this.metricsSchemaUri,
    this.modelExplanation,
    this.name,
    this.sliceDimensions,
  });

  GoogleCloudAiplatformV1ModelEvaluation.fromJson(core.Map json_)
      : this(
          annotationSchemaUri: json_['annotationSchemaUri'] as core.String?,
          createTime: json_['createTime'] as core.String?,
          dataItemSchemaUri: json_['dataItemSchemaUri'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          explanationSpecs: (json_['explanationSpecs'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          metadata: json_['metadata'],
          metrics: json_['metrics'],
          metricsSchemaUri: json_['metricsSchemaUri'] as core.String?,
          modelExplanation: json_.containsKey('modelExplanation')
              ? GoogleCloudAiplatformV1ModelExplanation.fromJson(
                  json_['modelExplanation']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          sliceDimensions: (json_['sliceDimensions'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationSchemaUri != null)
          'annotationSchemaUri': annotationSchemaUri!,
        if (createTime != null) 'createTime': createTime!,
        if (dataItemSchemaUri != null) 'dataItemSchemaUri': dataItemSchemaUri!,
        if (displayName != null) 'displayName': displayName!,
        if (explanationSpecs != null) 'explanationSpecs': explanationSpecs!,
        if (metadata != null) 'metadata': metadata!,
        if (metrics != null) 'metrics': metrics!,
        if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri!,
        if (modelExplanation != null) 'modelExplanation': modelExplanation!,
        if (name != null) 'name': name!,
        if (sliceDimensions != null) 'sliceDimensions': sliceDimensions!,
      };
}

class GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec {
  /// Explanation spec details.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are: *
  /// `image-integrated-gradients` * `image-xrai`
  core.String? explanationType;

  GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec({
    this.explanationSpec,
    this.explanationType,
  });

  GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec.fromJson(
      core.Map json_)
      : this(
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          explanationType: json_['explanationType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (explanationType != null) 'explanationType': explanationType!,
      };
}

/// A collection of metrics calculated by comparing Model's predictions on a
/// slice of the test data against ground truth annotations.
class GoogleCloudAiplatformV1ModelEvaluationSlice {
  /// Timestamp when this ModelEvaluationSlice was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Sliced evaluation metrics of the Model.
  ///
  /// The schema of the metrics is stored in metrics_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metrics;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// metrics of this ModelEvaluationSlice.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  ///
  /// Output only.
  core.String? metricsSchemaUri;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses.
  ///
  /// This field is populated only if the Model is evaluated with explanations,
  /// and only for tabular Models.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelExplanation? modelExplanation;

  /// The resource name of the ModelEvaluationSlice.
  ///
  /// Output only.
  core.String? name;

  /// The slice of the test data that is used to evaluate the Model.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelEvaluationSliceSlice? slice;

  GoogleCloudAiplatformV1ModelEvaluationSlice({
    this.createTime,
    this.metrics,
    this.metricsSchemaUri,
    this.modelExplanation,
    this.name,
    this.slice,
  });

  GoogleCloudAiplatformV1ModelEvaluationSlice.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          metrics: json_['metrics'],
          metricsSchemaUri: json_['metricsSchemaUri'] as core.String?,
          modelExplanation: json_.containsKey('modelExplanation')
              ? GoogleCloudAiplatformV1ModelExplanation.fromJson(
                  json_['modelExplanation']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          slice: json_.containsKey('slice')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSlice.fromJson(
                  json_['slice'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (metrics != null) 'metrics': metrics!,
        if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri!,
        if (modelExplanation != null) 'modelExplanation': modelExplanation!,
        if (name != null) 'name': name!,
        if (slice != null) 'slice': slice!,
      };
}

/// Definition of a slice.
class GoogleCloudAiplatformV1ModelEvaluationSliceSlice {
  /// The dimension of the slice.
  ///
  /// Well-known dimensions are: * `annotationSpec`: This slice is on the test
  /// data that has either ground truth or prediction with
  /// AnnotationSpec.display_name equals to value. * `slice`: This slice is a
  /// user customized slice defined by its SliceSpec.
  ///
  /// Output only.
  core.String? dimension;

  /// Specification for how the data was sliced.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec? sliceSpec;

  /// The value of the dimension in this slice.
  ///
  /// Output only.
  core.String? value;

  GoogleCloudAiplatformV1ModelEvaluationSliceSlice({
    this.dimension,
    this.sliceSpec,
    this.value,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSlice.fromJson(core.Map json_)
      : this(
          dimension: json_['dimension'] as core.String?,
          sliceSpec: json_.containsKey('sliceSpec')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec
                  .fromJson(
                      json_['sliceSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          value: json_['value'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dimension != null) 'dimension': dimension!,
        if (sliceSpec != null) 'sliceSpec': sliceSpec!,
        if (value != null) 'value': value!,
      };
}

/// Specification for how the data should be sliced.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec {
  /// Mapping configuration for this SliceSpec.
  ///
  /// The key is the name of the feature. By default, the key will be prefixed
  /// by "instance" as a dictionary prefix for Vertex Batch Predictions output
  /// format.
  core.Map<core.String,
          GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig>?
      configs;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec({
    this.configs,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec.fromJson(
      core.Map json_)
      : this(
          configs:
              (json_['configs'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig
                  .fromJson(value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (configs != null) 'configs': configs!,
      };
}

/// A range of values for slice(s).
///
/// `low` is inclusive, `high` is exclusive.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange {
  /// Exclusive high value for the range.
  core.double? high;

  /// Inclusive low value for the range.
  core.double? low;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange({
    this.high,
    this.low,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange.fromJson(
      core.Map json_)
      : this(
          high: (json_['high'] as core.num?)?.toDouble(),
          low: (json_['low'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (high != null) 'high': high!,
        if (low != null) 'low': low!,
      };
}

/// Specification message containing the config for this SliceSpec.
///
/// When `kind` is selected as `value` and/or `range`, only a single slice will
/// be computed. When `all_values` is present, a separate slice will be computed
/// for each possible label/value for the corresponding key in `config`.
/// Examples, with feature zip_code with values 12345, 23334, 88888 and feature
/// country with values "US", "Canada", "Mexico" in the dataset: Example 1: {
/// "zip_code": { "value": { "float_value": 12345.0 } } } A single slice for any
/// data with zip_code 12345 in the dataset. Example 2: { "zip_code": { "range":
/// { "low": 12345, "high": 20000 } } } A single slice containing data where the
/// zip_codes between 12345 and 20000 For this example, data with the zip_code
/// of 12345 will be in this slice. Example 3: { "zip_code": { "range": { "low":
/// 10000, "high": 20000 } }, "country": { "value": { "string_value": "US" } } }
/// A single slice containing data where the zip_codes between 10000 and 20000
/// has the country "US". For this example, data with the zip_code of 12345 and
/// country "US" will be in this slice. Example 4: { "country": {"all_values": {
/// "value": true } } } Three slices are computed, one for each unique country
/// in the dataset. Example 5: { "country": { "all_values": { "value": true } },
/// "zip_code": { "value": { "float_value": 12345.0 } } } Three slices are
/// computed, one for each unique country in the dataset where the zip_code is
/// also 12345. For this example, data with zip_code 12345 and country "US" will
/// be in one slice, zip_code 12345 and country "Canada" in another slice, and
/// zip_code 12345 and country "Mexico" in another slice, totaling 3 slices.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig {
  /// If all_values is set to true, then all possible labels of the keyed
  /// feature will have another slice computed.
  ///
  /// Example: `{"all_values":{"value":true}}`
  core.bool? allValues;

  /// A range of values for a numerical feature.
  ///
  /// Example: `{"range":{"low":10000.0,"high":50000.0}}` will capture 12345 and
  /// 23334 in the slice.
  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange? range;

  /// A unique specific value for a given feature.
  ///
  /// Example: `{ "value": { "string_value": "12345" } }`
  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue? value;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig({
    this.allValues,
    this.range,
    this.value,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig.fromJson(
      core.Map json_)
      : this(
          allValues: json_['allValues'] as core.bool?,
          range: json_.containsKey('range')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange
                  .fromJson(
                      json_['range'] as core.Map<core.String, core.dynamic>)
              : null,
          value: json_.containsKey('value')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue
                  .fromJson(
                      json_['value'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allValues != null) 'allValues': allValues!,
        if (range != null) 'range': range!,
        if (value != null) 'value': value!,
      };
}

/// Single value that supports strings and floats.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue {
  /// Float type.
  core.double? floatValue;

  /// String type.
  core.String? stringValue;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue({
    this.floatValue,
    this.stringValue,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue.fromJson(
      core.Map json_)
      : this(
          floatValue: (json_['floatValue'] as core.num?)?.toDouble(),
          stringValue: json_['stringValue'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (floatValue != null) 'floatValue': floatValue!,
        if (stringValue != null) 'stringValue': stringValue!,
      };
}

/// Aggregated explanation metrics for a Model over a set of instances.
class GoogleCloudAiplatformV1ModelExplanation {
  /// Aggregated attributions explaining the Model's prediction outputs over the
  /// set of instances.
  ///
  /// The attributions are grouped by outputs. For Models that predict only one
  /// output, such as regression Models that predict only one score, there is
  /// only one attibution that explains the predicted output. For Models that
  /// predict multiple outputs, such as multiclass Models that predict multiple
  /// classes, each element explains one specific item. Attribution.output_index
  /// can be used to identify which output this attribution is explaining. The
  /// baselineOutputValue, instanceOutputValue and featureAttributions fields
  /// are averaged over the test data. NOTE: Currently AutoML tabular
  /// classification Models produce only one attribution, which averages
  /// attributions over all the classes it predicts.
  /// Attribution.approximation_error is not populated.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Attribution>? meanAttributions;

  GoogleCloudAiplatformV1ModelExplanation({
    this.meanAttributions,
  });

  GoogleCloudAiplatformV1ModelExplanation.fromJson(core.Map json_)
      : this(
          meanAttributions: (json_['meanAttributions'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Attribution.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (meanAttributions != null) 'meanAttributions': meanAttributions!,
      };
}

/// Represents export format supported by the Model.
///
/// All formats export to Google Cloud Storage.
class GoogleCloudAiplatformV1ModelExportFormat {
  /// The content of this Model that may be exported.
  ///
  /// Output only.
  core.List<core.String>? exportableContents;

  /// The ID of the export format.
  ///
  /// The possible format IDs are: * `tflite` Used for Android mobile devices. *
  /// `edgetpu-tflite` Used for [Edge TPU](https://cloud.google.com/edge-tpu/)
  /// devices. * `tf-saved-model` A tensorflow model in SavedModel format. *
  /// `tf-js` A [TensorFlow.js](https://www.tensorflow.org/js) model that can be
  /// used in the browser and in Node.js using JavaScript. * `core-ml` Used for
  /// iOS mobile devices. * `custom-trained` A Model that was uploaded or
  /// trained by custom code. * `genie` A tuned Model Garden model.
  ///
  /// Output only.
  core.String? id;

  GoogleCloudAiplatformV1ModelExportFormat({
    this.exportableContents,
    this.id,
  });

  GoogleCloudAiplatformV1ModelExportFormat.fromJson(core.Map json_)
      : this(
          exportableContents: (json_['exportableContents'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          id: json_['id'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exportableContents != null)
          'exportableContents': exportableContents!,
        if (id != null) 'id': id!,
      };
}

/// Contains information about the source of the models generated from Model
/// Garden.
class GoogleCloudAiplatformV1ModelGardenSource {
  /// The model garden source model resource name.
  ///
  /// Required.
  core.String? publicModelName;

  /// Whether to avoid pulling the model from the HF cache.
  ///
  /// Optional.
  core.bool? skipHfModelCache;

  /// The model garden source model version ID.
  ///
  /// Optional.
  core.String? versionId;

  GoogleCloudAiplatformV1ModelGardenSource({
    this.publicModelName,
    this.skipHfModelCache,
    this.versionId,
  });

  GoogleCloudAiplatformV1ModelGardenSource.fromJson(core.Map json_)
      : this(
          publicModelName: json_['publicModelName'] as core.String?,
          skipHfModelCache: json_['skipHfModelCache'] as core.bool?,
          versionId: json_['versionId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (publicModelName != null) 'publicModelName': publicModelName!,
        if (skipHfModelCache != null) 'skipHfModelCache': skipHfModelCache!,
        if (versionId != null) 'versionId': versionId!,
      };
}

/// The alert config for model monitoring.
class GoogleCloudAiplatformV1ModelMonitoringAlertConfig {
  /// Email alert config.
  GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig?
      emailAlertConfig;

  /// Dump the anomalies to Cloud Logging.
  ///
  /// The anomalies will be put to json payload encoded from proto
  /// ModelMonitoringStatsAnomalies. This can be further synced to Pub/Sub or
  /// any other services supported by Cloud Logging.
  core.bool? enableLogging;

  /// Resource names of the NotificationChannels to send alert.
  ///
  /// Must be of the format `projects//notificationChannels/`
  core.List<core.String>? notificationChannels;

  GoogleCloudAiplatformV1ModelMonitoringAlertConfig({
    this.emailAlertConfig,
    this.enableLogging,
    this.notificationChannels,
  });

  GoogleCloudAiplatformV1ModelMonitoringAlertConfig.fromJson(core.Map json_)
      : this(
          emailAlertConfig: json_.containsKey('emailAlertConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig
                  .fromJson(json_['emailAlertConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          enableLogging: json_['enableLogging'] as core.bool?,
          notificationChannels: (json_['notificationChannels'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (emailAlertConfig != null) 'emailAlertConfig': emailAlertConfig!,
        if (enableLogging != null) 'enableLogging': enableLogging!,
        if (notificationChannels != null)
          'notificationChannels': notificationChannels!,
      };
}

/// The config for email alert.
class GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig {
  /// The email addresses to send the alert.
  core.List<core.String>? userEmails;

  GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig({
    this.userEmails,
  });

  GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig.fromJson(
      core.Map json_)
      : this(
          userEmails: (json_['userEmails'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (userEmails != null) 'userEmails': userEmails!,
      };
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig {
  /// The config for integrating with Vertex Explainable AI.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig?
      explanationConfig;

  /// The config for drift of prediction data.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig?
      predictionDriftDetectionConfig;

  /// Training dataset for models.
  ///
  /// This field has to be set only if TrainingPredictionSkewDetectionConfig is
  /// specified.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset?
      trainingDataset;

  /// The config for skew between training data and prediction data.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig?
      trainingPredictionSkewDetectionConfig;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig({
    this.explanationConfig,
    this.predictionDriftDetectionConfig,
    this.trainingDataset,
    this.trainingPredictionSkewDetectionConfig,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig.fromJson(core.Map json_)
      : this(
          explanationConfig: json_.containsKey('explanationConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig
                  .fromJson(json_['explanationConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          predictionDriftDetectionConfig: json_
                  .containsKey('predictionDriftDetectionConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig
                  .fromJson(json_['predictionDriftDetectionConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trainingDataset: json_.containsKey('trainingDataset')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset
                  .fromJson(json_['trainingDataset']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trainingPredictionSkewDetectionConfig: json_
                  .containsKey('trainingPredictionSkewDetectionConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig
                  .fromJson(json_['trainingPredictionSkewDetectionConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanationConfig != null) 'explanationConfig': explanationConfig!,
        if (predictionDriftDetectionConfig != null)
          'predictionDriftDetectionConfig': predictionDriftDetectionConfig!,
        if (trainingDataset != null) 'trainingDataset': trainingDataset!,
        if (trainingPredictionSkewDetectionConfig != null)
          'trainingPredictionSkewDetectionConfig':
              trainingPredictionSkewDetectionConfig!,
      };
}

/// The config for integrating with Vertex Explainable AI.
///
/// Only applicable if the Model has explanation_spec populated.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig {
  /// If want to analyze the Vertex Explainable AI feature attribute scores or
  /// not.
  ///
  /// If set to true, Vertex AI will log the feature attributions from explain
  /// response and do the skew/drift detection for them.
  core.bool? enableFeatureAttributes;

  /// Predictions generated by the BatchPredictionJob using baseline dataset.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline?
      explanationBaseline;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig({
    this.enableFeatureAttributes,
    this.explanationBaseline,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig.fromJson(
      core.Map json_)
      : this(
          enableFeatureAttributes:
              json_['enableFeatureAttributes'] as core.bool?,
          explanationBaseline: json_.containsKey('explanationBaseline')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline
                  .fromJson(json_['explanationBaseline']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableFeatureAttributes != null)
          'enableFeatureAttributes': enableFeatureAttributes!,
        if (explanationBaseline != null)
          'explanationBaseline': explanationBaseline!,
      };
}

/// Output from BatchPredictionJob for Model Monitoring baseline dataset, which
/// can be used to generate baseline attribution scores.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline {
  /// BigQuery location for BatchExplain output.
  GoogleCloudAiplatformV1BigQueryDestination? bigquery;

  /// Cloud Storage location for BatchExplain output.
  GoogleCloudAiplatformV1GcsDestination? gcs;

  /// The storage format of the predictions generated BatchPrediction job.
  /// Possible string values are:
  /// - "PREDICTION_FORMAT_UNSPECIFIED" : Should not be set.
  /// - "JSONL" : Predictions are in JSONL files.
  /// - "BIGQUERY" : Predictions are in BigQuery.
  core.String? predictionFormat;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline({
    this.bigquery,
    this.gcs,
    this.predictionFormat,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline.fromJson(
      core.Map json_)
      : this(
          bigquery: json_.containsKey('bigquery')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigquery'] as core.Map<core.String, core.dynamic>)
              : null,
          gcs: json_.containsKey('gcs')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcs'] as core.Map<core.String, core.dynamic>)
              : null,
          predictionFormat: json_['predictionFormat'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigquery != null) 'bigquery': bigquery!,
        if (gcs != null) 'gcs': gcs!,
        if (predictionFormat != null) 'predictionFormat': predictionFormat!,
      };
}

/// The config for Prediction data drift detection.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig {
  /// Key is the feature name and value is the threshold.
  ///
  /// The threshold here is against attribution score distance between different
  /// time windows.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>?
      attributionScoreDriftThresholds;

  /// Drift anomaly detection threshold used by all features.
  ///
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  GoogleCloudAiplatformV1ThresholdConfig? defaultDriftThreshold;

  /// Key is the feature name and value is the threshold.
  ///
  /// If a feature needs to be monitored for drift, a value threshold must be
  /// configured for that feature. The threshold here is against feature
  /// distribution distance between different time windws.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>?
      driftThresholds;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig({
    this.attributionScoreDriftThresholds,
    this.defaultDriftThreshold,
    this.driftThresholds,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig.fromJson(
      core.Map json_)
      : this(
          attributionScoreDriftThresholds:
              (json_['attributionScoreDriftThresholds']
                      as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          defaultDriftThreshold: json_.containsKey('defaultDriftThreshold')
              ? GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  json_['defaultDriftThreshold']
                      as core.Map<core.String, core.dynamic>)
              : null,
          driftThresholds:
              (json_['driftThresholds'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributionScoreDriftThresholds != null)
          'attributionScoreDriftThresholds': attributionScoreDriftThresholds!,
        if (defaultDriftThreshold != null)
          'defaultDriftThreshold': defaultDriftThreshold!,
        if (driftThresholds != null) 'driftThresholds': driftThresholds!,
      };
}

/// Training Dataset information.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset {
  /// The BigQuery table of the unmanaged Dataset used to train this Model.
  GoogleCloudAiplatformV1BigQuerySource? bigquerySource;

  /// Data format of the dataset, only applicable if the input is from Google
  /// Cloud Storage.
  ///
  /// The possible formats are: "tf-record" The source file is a TFRecord file.
  /// "csv" The source file is a CSV file. "jsonl" The source file is a JSONL
  /// file.
  core.String? dataFormat;

  /// The resource name of the Dataset used to train this Model.
  core.String? dataset;

  /// The Google Cloud Storage uri of the unmanaged Dataset used to train this
  /// Model.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// Strategy to sample data from Training Dataset.
  ///
  /// If not set, we process the whole dataset.
  GoogleCloudAiplatformV1SamplingStrategy? loggingSamplingStrategy;

  /// The target field name the model is to predict.
  ///
  /// This field will be excluded when doing Predict and (or) Explain for the
  /// training data.
  core.String? targetField;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset({
    this.bigquerySource,
    this.dataFormat,
    this.dataset,
    this.gcsSource,
    this.loggingSamplingStrategy,
    this.targetField,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset.fromJson(
      core.Map json_)
      : this(
          bigquerySource: json_.containsKey('bigquerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          dataFormat: json_['dataFormat'] as core.String?,
          dataset: json_['dataset'] as core.String?,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          loggingSamplingStrategy: json_.containsKey('loggingSamplingStrategy')
              ? GoogleCloudAiplatformV1SamplingStrategy.fromJson(
                  json_['loggingSamplingStrategy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          targetField: json_['targetField'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigquerySource != null) 'bigquerySource': bigquerySource!,
        if (dataFormat != null) 'dataFormat': dataFormat!,
        if (dataset != null) 'dataset': dataset!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (loggingSamplingStrategy != null)
          'loggingSamplingStrategy': loggingSamplingStrategy!,
        if (targetField != null) 'targetField': targetField!,
      };
}

/// The config for Training & Prediction data skew detection.
///
/// It specifies the training dataset sources and the skew detection parameters.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig {
  /// Key is the feature name and value is the threshold.
  ///
  /// The threshold here is against attribution score distance between the
  /// training and prediction feature.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>?
      attributionScoreSkewThresholds;

  /// Skew anomaly detection threshold used by all features.
  ///
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  GoogleCloudAiplatformV1ThresholdConfig? defaultSkewThreshold;

  /// Key is the feature name and value is the threshold.
  ///
  /// If a feature needs to be monitored for skew, a value threshold must be
  /// configured for that feature. The threshold here is against feature
  /// distribution distance between the training and prediction feature.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>? skewThresholds;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig({
    this.attributionScoreSkewThresholds,
    this.defaultSkewThreshold,
    this.skewThresholds,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig.fromJson(
      core.Map json_)
      : this(
          attributionScoreSkewThresholds:
              (json_['attributionScoreSkewThresholds']
                      as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          defaultSkewThreshold: json_.containsKey('defaultSkewThreshold')
              ? GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  json_['defaultSkewThreshold']
                      as core.Map<core.String, core.dynamic>)
              : null,
          skewThresholds:
              (json_['skewThresholds'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributionScoreSkewThresholds != null)
          'attributionScoreSkewThresholds': attributionScoreSkewThresholds!,
        if (defaultSkewThreshold != null)
          'defaultSkewThreshold': defaultSkewThreshold!,
        if (skewThresholds != null) 'skewThresholds': skewThresholds!,
      };
}

/// Statistics and anomalies generated by Model Monitoring.
class GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies {
  /// Number of anomalies within all stats.
  core.int? anomalyCount;

  /// Deployed Model ID.
  core.String? deployedModelId;

  /// A list of historical Stats and Anomalies generated for all Features.
  core.List<
          GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies>?
      featureStats;

  /// Model Monitoring Objective those stats and anomalies belonging to.
  /// Possible string values are:
  /// - "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" : Default
  /// value, should not be set.
  /// - "RAW_FEATURE_SKEW" : Raw feature values' stats to detect skew between
  /// Training-Prediction datasets.
  /// - "RAW_FEATURE_DRIFT" : Raw feature values' stats to detect drift between
  /// Serving-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_SKEW" : Feature attribution scores to detect skew
  /// between Training-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_DRIFT" : Feature attribution scores to detect skew
  /// between Prediction datasets collected within different time windows.
  core.String? objective;

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies({
    this.anomalyCount,
    this.deployedModelId,
    this.featureStats,
    this.objective,
  });

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies.fromJson(core.Map json_)
      : this(
          anomalyCount: json_['anomalyCount'] as core.int?,
          deployedModelId: json_['deployedModelId'] as core.String?,
          featureStats: (json_['featureStats'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          objective: json_['objective'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (anomalyCount != null) 'anomalyCount': anomalyCount!,
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (featureStats != null) 'featureStats': featureStats!,
        if (objective != null) 'objective': objective!,
      };
}

/// Historical Stats (and Anomalies) for a specific Feature.
class GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies {
  /// Display Name of the Feature.
  core.String? featureDisplayName;

  /// A list of historical stats generated by different time window's Prediction
  /// Dataset.
  core.List<GoogleCloudAiplatformV1FeatureStatsAnomaly>? predictionStats;

  /// Threshold for anomaly detection.
  GoogleCloudAiplatformV1ThresholdConfig? threshold;

  /// Stats calculated for the Training Dataset.
  GoogleCloudAiplatformV1FeatureStatsAnomaly? trainingStats;

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies({
    this.featureDisplayName,
    this.predictionStats,
    this.threshold,
    this.trainingStats,
  });

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies.fromJson(
      core.Map json_)
      : this(
          featureDisplayName: json_['featureDisplayName'] as core.String?,
          predictionStats: (json_['predictionStats'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          threshold: json_.containsKey('threshold')
              ? GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  json_['threshold'] as core.Map<core.String, core.dynamic>)
              : null,
          trainingStats: json_.containsKey('trainingStats')
              ? GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(
                  json_['trainingStats'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureDisplayName != null)
          'featureDisplayName': featureDisplayName!,
        if (predictionStats != null) 'predictionStats': predictionStats!,
        if (threshold != null) 'threshold': threshold!,
        if (trainingStats != null) 'trainingStats': trainingStats!,
      };
}

/// Contains information about the original Model if this Model is a copy.
class GoogleCloudAiplatformV1ModelOriginalModelInfo {
  /// The resource name of the Model this Model is a copy of, including the
  /// revision.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
  ///
  /// Output only.
  core.String? model;

  GoogleCloudAiplatformV1ModelOriginalModelInfo({
    this.model,
  });

  GoogleCloudAiplatformV1ModelOriginalModelInfo.fromJson(core.Map json_)
      : this(
          model: json_['model'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
      };
}

/// Detail description of the source information of the model.
typedef GoogleCloudAiplatformV1ModelSourceInfo = $ModelSourceInfo;

/// Describes the machine learning model version checkpoint.
class GoogleCloudAiplatformV1ModelVersionCheckpoint {
  /// The ID of the checkpoint.
  core.String? checkpointId;

  /// The epoch of the checkpoint.
  core.String? epoch;

  /// Identifier.
  ///
  /// The resource name of the ModelVersionCheckpoint. Format:
  /// `projects/{project}/locations/{location}/models/{model}/versions/{version}/checkpoints/{checkpoint}`
  core.String? name;

  /// The step of the checkpoint.
  core.String? step;

  GoogleCloudAiplatformV1ModelVersionCheckpoint({
    this.checkpointId,
    this.epoch,
    this.name,
    this.step,
  });

  GoogleCloudAiplatformV1ModelVersionCheckpoint.fromJson(core.Map json_)
      : this(
          checkpointId: json_['checkpointId'] as core.String?,
          epoch: json_['epoch'] as core.String?,
          name: json_['name'] as core.String?,
          step: json_['step'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (checkpointId != null) 'checkpointId': checkpointId!,
        if (epoch != null) 'epoch': epoch!,
        if (name != null) 'name': name!,
        if (step != null) 'step': step!,
      };
}

/// Request message for EndpointService.MutateDeployedModel.
class GoogleCloudAiplatformV1MutateDeployedModelRequest {
  /// The DeployedModel to be mutated within the Endpoint.
  ///
  /// Only the following fields can be mutated: * `min_replica_count` in either
  /// DedicatedResources or AutomaticResources * `max_replica_count` in either
  /// DedicatedResources or AutomaticResources * autoscaling_metric_specs *
  /// `disable_container_logging` (v1 only) * `enable_container_logging`
  /// (v1beta1 only)
  ///
  /// Required.
  GoogleCloudAiplatformV1DeployedModel? deployedModel;

  /// The update mask applies to the resource.
  ///
  /// See google.protobuf.FieldMask.
  ///
  /// Required.
  core.String? updateMask;

  GoogleCloudAiplatformV1MutateDeployedModelRequest({
    this.deployedModel,
    this.updateMask,
  });

  GoogleCloudAiplatformV1MutateDeployedModelRequest.fromJson(core.Map json_)
      : this(
          deployedModel: json_.containsKey('deployedModel')
              ? GoogleCloudAiplatformV1DeployedModel.fromJson(
                  json_['deployedModel'] as core.Map<core.String, core.dynamic>)
              : null,
          updateMask: json_['updateMask'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModel != null) 'deployedModel': deployedModel!,
        if (updateMask != null) 'updateMask': updateMask!,
      };
}

/// Represents a Neural Architecture Search (NAS) job.
class GoogleCloudAiplatformV1NasJob {
  /// Time when the NasJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the NasJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Enable a separation of Custom model training and restricted image training
  /// for tenant project.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableRestrictedImageTraining;

  /// Customer-managed encryption key options for a NasJob.
  ///
  /// If this is set, then all resources created by the NasJob will be encrypted
  /// with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the NasJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize NasJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the NasJob.
  ///
  /// Output only.
  core.String? name;

  /// Output of the NasJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NasJobOutput? nasJobOutput;

  /// The specification of a NasJob.
  ///
  /// Required.
  GoogleCloudAiplatformV1NasJobSpec? nasJobSpec;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the NasJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Time when the NasJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1NasJob({
    this.createTime,
    this.displayName,
    this.enableRestrictedImageTraining,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.labels,
    this.name,
    this.nasJobOutput,
    this.nasJobSpec,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1NasJob.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          enableRestrictedImageTraining:
              json_['enableRestrictedImageTraining'] as core.bool?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          nasJobOutput: json_.containsKey('nasJobOutput')
              ? GoogleCloudAiplatformV1NasJobOutput.fromJson(
                  json_['nasJobOutput'] as core.Map<core.String, core.dynamic>)
              : null,
          nasJobSpec: json_.containsKey('nasJobSpec')
              ? GoogleCloudAiplatformV1NasJobSpec.fromJson(
                  json_['nasJobSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (enableRestrictedImageTraining != null)
          'enableRestrictedImageTraining': enableRestrictedImageTraining!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (nasJobOutput != null) 'nasJobOutput': nasJobOutput!,
        if (nasJobSpec != null) 'nasJobSpec': nasJobSpec!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Represents a uCAIP NasJob output.
class GoogleCloudAiplatformV1NasJobOutput {
  /// The output of this multi-trial Neural Architecture Search (NAS) job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput? multiTrialJobOutput;

  GoogleCloudAiplatformV1NasJobOutput({
    this.multiTrialJobOutput,
  });

  GoogleCloudAiplatformV1NasJobOutput.fromJson(core.Map json_)
      : this(
          multiTrialJobOutput: json_.containsKey('multiTrialJobOutput')
              ? GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput.fromJson(
                  json_['multiTrialJobOutput']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (multiTrialJobOutput != null)
          'multiTrialJobOutput': multiTrialJobOutput!,
      };
}

/// The output of a multi-trial Neural Architecture Search (NAS) jobs.
class GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput {
  /// List of NasTrials that were started as part of search stage.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1NasTrial>? searchTrials;

  /// List of NasTrials that were started as part of train stage.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1NasTrial>? trainTrials;

  GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput({
    this.searchTrials,
    this.trainTrials,
  });

  GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput.fromJson(
      core.Map json_)
      : this(
          searchTrials: (json_['searchTrials'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1NasTrial.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          trainTrials: (json_['trainTrials'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1NasTrial.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (searchTrials != null) 'searchTrials': searchTrials!,
        if (trainTrials != null) 'trainTrials': trainTrials!,
      };
}

/// Represents the spec of a NasJob.
class GoogleCloudAiplatformV1NasJobSpec {
  /// The spec of multi-trial algorithms.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec?
      multiTrialAlgorithmSpec;

  /// The ID of the existing NasJob in the same Project and Location which will
  /// be used to resume search.
  ///
  /// search_space_spec and nas_algorithm_spec are obtained from previous NasJob
  /// hence should not provide them again for this NasJob.
  core.String? resumeNasJobId;

  /// It defines the search space for Neural Architecture Search (NAS).
  core.String? searchSpaceSpec;

  GoogleCloudAiplatformV1NasJobSpec({
    this.multiTrialAlgorithmSpec,
    this.resumeNasJobId,
    this.searchSpaceSpec,
  });

  GoogleCloudAiplatformV1NasJobSpec.fromJson(core.Map json_)
      : this(
          multiTrialAlgorithmSpec: json_.containsKey('multiTrialAlgorithmSpec')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec
                  .fromJson(json_['multiTrialAlgorithmSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          resumeNasJobId: json_['resumeNasJobId'] as core.String?,
          searchSpaceSpec: json_['searchSpaceSpec'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (multiTrialAlgorithmSpec != null)
          'multiTrialAlgorithmSpec': multiTrialAlgorithmSpec!,
        if (resumeNasJobId != null) 'resumeNasJobId': resumeNasJobId!,
        if (searchSpaceSpec != null) 'searchSpaceSpec': searchSpaceSpec!,
      };
}

/// The spec of multi-trial Neural Architecture Search (NAS).
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec {
  /// Metric specs for the NAS job.
  ///
  /// Validation for this field is done at `multi_trial_algorithm_spec` field.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec? metric;

  /// The multi-trial Neural Architecture Search (NAS) algorithm type.
  ///
  /// Defaults to `REINFORCEMENT_LEARNING`.
  /// Possible string values are:
  /// - "MULTI_TRIAL_ALGORITHM_UNSPECIFIED" : Defaults to
  /// `REINFORCEMENT_LEARNING`.
  /// - "REINFORCEMENT_LEARNING" : The Reinforcement Learning Algorithm for
  /// Multi-trial Neural Architecture Search (NAS).
  /// - "GRID_SEARCH" : The Grid Search Algorithm for Multi-trial Neural
  /// Architecture Search (NAS).
  core.String? multiTrialAlgorithm;

  /// Spec for search trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec?
      searchTrialSpec;

  /// Spec for train trials.
  ///
  /// Top N \[TrainTrialSpec.max_parallel_trial_count\] search trials will be
  /// trained for every M \[TrainTrialSpec.frequency\] trials searched.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec?
      trainTrialSpec;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec({
    this.metric,
    this.multiTrialAlgorithm,
    this.searchTrialSpec,
    this.trainTrialSpec,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec.fromJson(
      core.Map json_)
      : this(
          metric: json_.containsKey('metric')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec
                  .fromJson(
                      json_['metric'] as core.Map<core.String, core.dynamic>)
              : null,
          multiTrialAlgorithm: json_['multiTrialAlgorithm'] as core.String?,
          searchTrialSpec: json_.containsKey('searchTrialSpec')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec
                  .fromJson(json_['searchTrialSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trainTrialSpec: json_.containsKey('trainTrialSpec')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec
                  .fromJson(json_['trainTrialSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metric != null) 'metric': metric!,
        if (multiTrialAlgorithm != null)
          'multiTrialAlgorithm': multiTrialAlgorithm!,
        if (searchTrialSpec != null) 'searchTrialSpec': searchTrialSpec!,
        if (trainTrialSpec != null) 'trainTrialSpec': trainTrialSpec!,
      };
}

/// Represents a metric to optimize.
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec {
  /// The optimization goal of the metric.
  ///
  /// Required.
  /// Possible string values are:
  /// - "GOAL_TYPE_UNSPECIFIED" : Goal Type will default to maximize.
  /// - "MAXIMIZE" : Maximize the goal metric.
  /// - "MINIMIZE" : Minimize the goal metric.
  core.String? goal;

  /// The ID of the metric.
  ///
  /// Must not contain whitespaces.
  ///
  /// Required.
  core.String? metricId;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec({
    this.goal,
    this.metricId,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec.fromJson(
      core.Map json_)
      : this(
          goal: json_['goal'] as core.String?,
          metricId: json_['metricId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (goal != null) 'goal': goal!,
        if (metricId != null) 'metricId': metricId!,
      };
}

/// Represent spec for search trials.
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec {
  /// The number of failed trials that need to be seen before failing the
  /// NasJob.
  ///
  /// If set to 0, Vertex AI decides how many trials must fail before the whole
  /// job fails.
  core.int? maxFailedTrialCount;

  /// The maximum number of trials to run in parallel.
  ///
  /// Required.
  core.int? maxParallelTrialCount;

  /// The maximum number of Neural Architecture Search (NAS) trials to run.
  ///
  /// Required.
  core.int? maxTrialCount;

  /// The spec of a search trial job.
  ///
  /// The same spec applies to all search trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? searchTrialJobSpec;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec({
    this.maxFailedTrialCount,
    this.maxParallelTrialCount,
    this.maxTrialCount,
    this.searchTrialJobSpec,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec.fromJson(
      core.Map json_)
      : this(
          maxFailedTrialCount: json_['maxFailedTrialCount'] as core.int?,
          maxParallelTrialCount: json_['maxParallelTrialCount'] as core.int?,
          maxTrialCount: json_['maxTrialCount'] as core.int?,
          searchTrialJobSpec: json_.containsKey('searchTrialJobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['searchTrialJobSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxFailedTrialCount != null)
          'maxFailedTrialCount': maxFailedTrialCount!,
        if (maxParallelTrialCount != null)
          'maxParallelTrialCount': maxParallelTrialCount!,
        if (maxTrialCount != null) 'maxTrialCount': maxTrialCount!,
        if (searchTrialJobSpec != null)
          'searchTrialJobSpec': searchTrialJobSpec!,
      };
}

/// Represent spec for train trials.
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec {
  /// Frequency of search trials to start train stage.
  ///
  /// Top N \[TrainTrialSpec.max_parallel_trial_count\] search trials will be
  /// trained for every M \[TrainTrialSpec.frequency\] trials searched.
  ///
  /// Required.
  core.int? frequency;

  /// The maximum number of trials to run in parallel.
  ///
  /// Required.
  core.int? maxParallelTrialCount;

  /// The spec of a train trial job.
  ///
  /// The same spec applies to all train trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? trainTrialJobSpec;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec({
    this.frequency,
    this.maxParallelTrialCount,
    this.trainTrialJobSpec,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec.fromJson(
      core.Map json_)
      : this(
          frequency: json_['frequency'] as core.int?,
          maxParallelTrialCount: json_['maxParallelTrialCount'] as core.int?,
          trainTrialJobSpec: json_.containsKey('trainTrialJobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['trainTrialJobSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (frequency != null) 'frequency': frequency!,
        if (maxParallelTrialCount != null)
          'maxParallelTrialCount': maxParallelTrialCount!,
        if (trainTrialJobSpec != null) 'trainTrialJobSpec': trainTrialJobSpec!,
      };
}

/// Represents a uCAIP NasJob trial.
class GoogleCloudAiplatformV1NasTrial {
  /// Time when the NasTrial's status changed to `SUCCEEDED` or `INFEASIBLE`.
  ///
  /// Output only.
  core.String? endTime;

  /// The final measurement containing the objective value.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Measurement? finalMeasurement;

  /// The identifier of the NasTrial assigned by the service.
  ///
  /// Output only.
  core.String? id;

  /// Time when the NasTrial was started.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the NasTrial.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The NasTrial state is unspecified.
  /// - "REQUESTED" : Indicates that a specific NasTrial has been requested, but
  /// it has not yet been suggested by the service.
  /// - "ACTIVE" : Indicates that the NasTrial has been suggested.
  /// - "STOPPING" : Indicates that the NasTrial should stop according to the
  /// service.
  /// - "SUCCEEDED" : Indicates that the NasTrial is completed successfully.
  /// - "INFEASIBLE" : Indicates that the NasTrial should not be attempted
  /// again. The service will set a NasTrial to INFEASIBLE when it's done but
  /// missing the final_measurement.
  core.String? state;

  GoogleCloudAiplatformV1NasTrial({
    this.endTime,
    this.finalMeasurement,
    this.id,
    this.startTime,
    this.state,
  });

  GoogleCloudAiplatformV1NasTrial.fromJson(core.Map json_)
      : this(
          endTime: json_['endTime'] as core.String?,
          finalMeasurement: json_.containsKey('finalMeasurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>)
              : null,
          id: json_['id'] as core.String?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endTime != null) 'endTime': endTime!,
        if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
        if (id != null) 'id': id!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
      };
}

/// Represents a NasTrial details along with its parameters.
///
/// If there is a corresponding train NasTrial, the train NasTrial is also
/// returned.
class GoogleCloudAiplatformV1NasTrialDetail {
  /// Resource name of the NasTrialDetail.
  ///
  /// Output only.
  core.String? name;

  /// The parameters for the NasJob NasTrial.
  core.String? parameters;

  /// The requested search NasTrial.
  GoogleCloudAiplatformV1NasTrial? searchTrial;

  /// The train NasTrial corresponding to search_trial.
  ///
  /// Only populated if search_trial is used for training.
  GoogleCloudAiplatformV1NasTrial? trainTrial;

  GoogleCloudAiplatformV1NasTrialDetail({
    this.name,
    this.parameters,
    this.searchTrial,
    this.trainTrial,
  });

  GoogleCloudAiplatformV1NasTrialDetail.fromJson(core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          parameters: json_['parameters'] as core.String?,
          searchTrial: json_.containsKey('searchTrial')
              ? GoogleCloudAiplatformV1NasTrial.fromJson(
                  json_['searchTrial'] as core.Map<core.String, core.dynamic>)
              : null,
          trainTrial: json_.containsKey('trainTrial')
              ? GoogleCloudAiplatformV1NasTrial.fromJson(
                  json_['trainTrial'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (parameters != null) 'parameters': parameters!,
        if (searchTrial != null) 'searchTrial': searchTrial!,
        if (trainTrial != null) 'trainTrial': trainTrial!,
      };
}

/// A query to find a number of similar entities.
class GoogleCloudAiplatformV1NearestNeighborQuery {
  /// The embedding vector that be used for similar search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1NearestNeighborQueryEmbedding? embedding;

  /// The entity id whose similar entities should be searched for.
  ///
  /// If embedding is set, search will use embedding instead of entity_id.
  ///
  /// Optional.
  core.String? entityId;

  /// The number of similar entities to be retrieved from feature view for each
  /// query.
  ///
  /// Optional.
  core.int? neighborCount;

  /// The list of numeric filters.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1NearestNeighborQueryNumericFilter>?
      numericFilters;

  /// Parameters that can be set to tune query on the fly.
  ///
  /// Optional.
  GoogleCloudAiplatformV1NearestNeighborQueryParameters? parameters;

  /// Crowding is a constraint on a neighbor list produced by nearest neighbor
  /// search requiring that no more than sper_crowding_attribute_neighbor_count
  /// of the k neighbors returned have the same value of crowding_attribute.
  ///
  /// It's used for improving result diversity.
  ///
  /// Optional.
  core.int? perCrowdingAttributeNeighborCount;

  /// The list of string filters.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1NearestNeighborQueryStringFilter>?
      stringFilters;

  GoogleCloudAiplatformV1NearestNeighborQuery({
    this.embedding,
    this.entityId,
    this.neighborCount,
    this.numericFilters,
    this.parameters,
    this.perCrowdingAttributeNeighborCount,
    this.stringFilters,
  });

  GoogleCloudAiplatformV1NearestNeighborQuery.fromJson(core.Map json_)
      : this(
          embedding: json_.containsKey('embedding')
              ? GoogleCloudAiplatformV1NearestNeighborQueryEmbedding.fromJson(
                  json_['embedding'] as core.Map<core.String, core.dynamic>)
              : null,
          entityId: json_['entityId'] as core.String?,
          neighborCount: json_['neighborCount'] as core.int?,
          numericFilters: (json_['numericFilters'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1NearestNeighborQueryNumericFilter
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1NearestNeighborQueryParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
          perCrowdingAttributeNeighborCount:
              json_['perCrowdingAttributeNeighborCount'] as core.int?,
          stringFilters: (json_['stringFilters'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1NearestNeighborQueryStringFilter
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (embedding != null) 'embedding': embedding!,
        if (entityId != null) 'entityId': entityId!,
        if (neighborCount != null) 'neighborCount': neighborCount!,
        if (numericFilters != null) 'numericFilters': numericFilters!,
        if (parameters != null) 'parameters': parameters!,
        if (perCrowdingAttributeNeighborCount != null)
          'perCrowdingAttributeNeighborCount':
              perCrowdingAttributeNeighborCount!,
        if (stringFilters != null) 'stringFilters': stringFilters!,
      };
}

/// The embedding vector.
class GoogleCloudAiplatformV1NearestNeighborQueryEmbedding {
  /// Individual value in the embedding.
  ///
  /// Optional.
  core.List<core.double>? value;

  GoogleCloudAiplatformV1NearestNeighborQueryEmbedding({
    this.value,
  });

  GoogleCloudAiplatformV1NearestNeighborQueryEmbedding.fromJson(core.Map json_)
      : this(
          value: (json_['value'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
      };
}

/// Numeric filter is used to search a subset of the entities by using boolean
/// rules on numeric columns.
///
/// For example: Database Point 0: {name: "a" value_int: 42} {name: "b"
/// value_float: 1.0} Database Point 1: {name: "a" value_int: 10} {name: "b"
/// value_float: 2.0} Database Point 2: {name: "a" value_int: -1} {name: "b"
/// value_float: 3.0} Query: {name: "a" value_int: 12 operator: LESS} // Matches
/// Point 1, 2 {name: "b" value_float: 2.0 operator: EQUAL} // Matches Point 1
class GoogleCloudAiplatformV1NearestNeighborQueryNumericFilter {
  /// Column name in BigQuery that used as filters.
  ///
  /// Required.
  core.String? name;

  /// This MUST be specified for queries and must NOT be specified for database
  /// points.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "OPERATOR_UNSPECIFIED" : Unspecified operator.
  /// - "LESS" : Entities are eligible if their value is \< the query's.
  /// - "LESS_EQUAL" : Entities are eligible if their value is \<= the query's.
  /// - "EQUAL" : Entities are eligible if their value is == the query's.
  /// - "GREATER_EQUAL" : Entities are eligible if their value is \>= the
  /// query's.
  /// - "GREATER" : Entities are eligible if their value is \> the query's.
  /// - "NOT_EQUAL" : Entities are eligible if their value is != the query's.
  core.String? op;

  /// double value type.
  core.double? valueDouble;

  /// float value type.
  core.double? valueFloat;

  /// int value type.
  core.String? valueInt;

  GoogleCloudAiplatformV1NearestNeighborQueryNumericFilter({
    this.name,
    this.op,
    this.valueDouble,
    this.valueFloat,
    this.valueInt,
  });

  GoogleCloudAiplatformV1NearestNeighborQueryNumericFilter.fromJson(
      core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          op: json_['op'] as core.String?,
          valueDouble: (json_['valueDouble'] as core.num?)?.toDouble(),
          valueFloat: (json_['valueFloat'] as core.num?)?.toDouble(),
          valueInt: json_['valueInt'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (op != null) 'op': op!,
        if (valueDouble != null) 'valueDouble': valueDouble!,
        if (valueFloat != null) 'valueFloat': valueFloat!,
        if (valueInt != null) 'valueInt': valueInt!,
      };
}

/// Parameters that can be overrided in each query to tune query latency and
/// recall.
class GoogleCloudAiplatformV1NearestNeighborQueryParameters {
  /// The number of neighbors to find via approximate search before exact
  /// reordering is performed; if set, this value must be \> neighbor_count.
  ///
  /// Optional.
  core.int? approximateNeighborCandidates;

  /// The fraction of the number of leaves to search, set at query time allows
  /// user to tune search performance.
  ///
  /// This value increase result in both search accuracy and latency increase.
  /// The value should be between 0.0 and 1.0.
  ///
  /// Optional.
  core.double? leafNodesSearchFraction;

  GoogleCloudAiplatformV1NearestNeighborQueryParameters({
    this.approximateNeighborCandidates,
    this.leafNodesSearchFraction,
  });

  GoogleCloudAiplatformV1NearestNeighborQueryParameters.fromJson(core.Map json_)
      : this(
          approximateNeighborCandidates:
              json_['approximateNeighborCandidates'] as core.int?,
          leafNodesSearchFraction:
              (json_['leafNodesSearchFraction'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (approximateNeighborCandidates != null)
          'approximateNeighborCandidates': approximateNeighborCandidates!,
        if (leafNodesSearchFraction != null)
          'leafNodesSearchFraction': leafNodesSearchFraction!,
      };
}

/// String filter is used to search a subset of the entities by using boolean
/// rules on string columns.
///
/// For example: if a query specifies string filter with 'name = color,
/// allow_tokens = {red, blue}, deny_tokens = {purple}',' then that query will
/// match entities that are red or blue, but if those points are also purple,
/// then they will be excluded even if they are red/blue. Only string filter is
/// supported for now, numeric filter will be supported in the near future.
class GoogleCloudAiplatformV1NearestNeighborQueryStringFilter {
  /// The allowed tokens.
  ///
  /// Optional.
  core.List<core.String>? allowTokens;

  /// The denied tokens.
  ///
  /// Optional.
  core.List<core.String>? denyTokens;

  /// Column names in BigQuery that used as filters.
  ///
  /// Required.
  core.String? name;

  GoogleCloudAiplatformV1NearestNeighborQueryStringFilter({
    this.allowTokens,
    this.denyTokens,
    this.name,
  });

  GoogleCloudAiplatformV1NearestNeighborQueryStringFilter.fromJson(
      core.Map json_)
      : this(
          allowTokens: (json_['allowTokens'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          denyTokens: (json_['denyTokens'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          name: json_['name'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowTokens != null) 'allowTokens': allowTokens!,
        if (denyTokens != null) 'denyTokens': denyTokens!,
        if (name != null) 'name': name!,
      };
}

/// Nearest neighbors for one query.
class GoogleCloudAiplatformV1NearestNeighbors {
  /// All its neighbors.
  core.List<GoogleCloudAiplatformV1NearestNeighborsNeighbor>? neighbors;

  GoogleCloudAiplatformV1NearestNeighbors({
    this.neighbors,
  });

  GoogleCloudAiplatformV1NearestNeighbors.fromJson(core.Map json_)
      : this(
          neighbors: (json_['neighbors'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1NearestNeighborsNeighbor.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (neighbors != null) 'neighbors': neighbors!,
      };
}

/// A neighbor of the query vector.
class GoogleCloudAiplatformV1NearestNeighborsNeighbor {
  /// The distance between the neighbor and the query vector.
  core.double? distance;

  /// The id of the similar entity.
  core.String? entityId;

  /// The attributes of the neighbor, e.g. filters, crowding and metadata Note
  /// that full entities are returned only when "return_full_entity" is set to
  /// true.
  ///
  /// Otherwise, only the "entity_id" and "distance" fields are populated.
  GoogleCloudAiplatformV1FetchFeatureValuesResponse? entityKeyValues;

  GoogleCloudAiplatformV1NearestNeighborsNeighbor({
    this.distance,
    this.entityId,
    this.entityKeyValues,
  });

  GoogleCloudAiplatformV1NearestNeighborsNeighbor.fromJson(core.Map json_)
      : this(
          distance: (json_['distance'] as core.num?)?.toDouble(),
          entityId: json_['entityId'] as core.String?,
          entityKeyValues: json_.containsKey('entityKeyValues')
              ? GoogleCloudAiplatformV1FetchFeatureValuesResponse.fromJson(
                  json_['entityKeyValues']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (distance != null) 'distance': distance!,
        if (entityId != null) 'entityId': entityId!,
        if (entityKeyValues != null) 'entityKeyValues': entityKeyValues!,
      };
}

/// Neighbors for example-based explanations.
class GoogleCloudAiplatformV1Neighbor {
  /// The neighbor distance.
  ///
  /// Output only.
  core.double? neighborDistance;

  /// The neighbor id.
  ///
  /// Output only.
  core.String? neighborId;

  GoogleCloudAiplatformV1Neighbor({
    this.neighborDistance,
    this.neighborId,
  });

  GoogleCloudAiplatformV1Neighbor.fromJson(core.Map json_)
      : this(
          neighborDistance:
              (json_['neighborDistance'] as core.num?)?.toDouble(),
          neighborId: json_['neighborId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (neighborDistance != null) 'neighborDistance': neighborDistance!,
        if (neighborId != null) 'neighborId': neighborId!,
      };
}

/// Network spec.
class GoogleCloudAiplatformV1NetworkSpec {
  /// Whether to enable public internet access.
  ///
  /// Default false.
  core.bool? enableInternetAccess;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  core.String? network;

  /// The name of the subnet that this instance is in.
  ///
  /// Format:
  /// `projects/{project_id_or_number}/regions/{region}/subnetworks/{subnetwork_id}`
  core.String? subnetwork;

  GoogleCloudAiplatformV1NetworkSpec({
    this.enableInternetAccess,
    this.network,
    this.subnetwork,
  });

  GoogleCloudAiplatformV1NetworkSpec.fromJson(core.Map json_)
      : this(
          enableInternetAccess: json_['enableInternetAccess'] as core.bool?,
          network: json_['network'] as core.String?,
          subnetwork: json_['subnetwork'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableInternetAccess != null)
          'enableInternetAccess': enableInternetAccess!,
        if (network != null) 'network': network!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
      };
}

/// Represents a mount configuration for Network File System (NFS) to mount.
class GoogleCloudAiplatformV1NfsMount {
  /// Destination mount path.
  ///
  /// The NFS will be mounted for the user under /mnt/nfs/
  ///
  /// Required.
  core.String? mountPoint;

  /// Source path exported from NFS server.
  ///
  /// Has to start with '/', and combined with the ip address, it indicates the
  /// source mount path in the form of `server:path`
  ///
  /// Required.
  core.String? path;

  /// IP address of the NFS server.
  ///
  /// Required.
  core.String? server;

  GoogleCloudAiplatformV1NfsMount({
    this.mountPoint,
    this.path,
    this.server,
  });

  GoogleCloudAiplatformV1NfsMount.fromJson(core.Map json_)
      : this(
          mountPoint: json_['mountPoint'] as core.String?,
          path: json_['path'] as core.String?,
          server: json_['server'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (mountPoint != null) 'mountPoint': mountPoint!,
        if (path != null) 'path': path!,
        if (server != null) 'server': server!,
      };
}

/// The euc configuration of NotebookRuntimeTemplate.
class GoogleCloudAiplatformV1NotebookEucConfig {
  /// Whether ActAs check is bypassed for service account attached to the VM.
  ///
  /// If false, we need ActAs check for the default Compute Engine Service
  /// account. When a Runtime is created, a VM is allocated using Default
  /// Compute Engine Service Account. Any user requesting to use this Runtime
  /// requires Service Account User (ActAs) permission over this SA. If true,
  /// Runtime owner is using EUC and does not require the above permission as VM
  /// no longer use default Compute Engine SA, but a P4SA.
  ///
  /// Output only.
  core.bool? bypassActasCheck;

  /// Input only.
  ///
  /// Whether EUC is disabled in this NotebookRuntimeTemplate. In proto3, the
  /// default value of a boolean is false. In this way, by default EUC will be
  /// enabled for NotebookRuntimeTemplate.
  core.bool? eucDisabled;

  GoogleCloudAiplatformV1NotebookEucConfig({
    this.bypassActasCheck,
    this.eucDisabled,
  });

  GoogleCloudAiplatformV1NotebookEucConfig.fromJson(core.Map json_)
      : this(
          bypassActasCheck: json_['bypassActasCheck'] as core.bool?,
          eucDisabled: json_['eucDisabled'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bypassActasCheck != null) 'bypassActasCheck': bypassActasCheck!,
        if (eucDisabled != null) 'eucDisabled': eucDisabled!,
      };
}

/// NotebookExecutionJob represents an instance of a notebook execution.
class GoogleCloudAiplatformV1NotebookExecutionJob {
  /// Timestamp when this NotebookExecutionJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The custom compute configuration for an execution job.
  GoogleCloudAiplatformV1NotebookExecutionJobCustomEnvironmentSpec?
      customEnvironmentSpec;

  /// The Dataform Repository pointing to a single file notebook repository.
  GoogleCloudAiplatformV1NotebookExecutionJobDataformRepositorySource?
      dataformRepositorySource;

  /// The contents of an input notebook file.
  GoogleCloudAiplatformV1NotebookExecutionJobDirectNotebookSource?
      directNotebookSource;

  /// The display name of the NotebookExecutionJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  core.String? displayName;

  /// Customer-managed encryption key spec for the notebook execution job.
  ///
  /// This field is auto-populated if the NotebookRuntimeTemplate has an
  /// encryption spec.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Max running time of the execution job in seconds (default 86400s / 24
  /// hrs).
  core.String? executionTimeout;

  /// The user email to run the execution as.
  ///
  /// Only supported by Colab runtimes.
  core.String? executionUser;

  /// The Cloud Storage url pointing to the ipynb file.
  ///
  /// Format: `gs://bucket/notebook_file.ipynb`
  GoogleCloudAiplatformV1NotebookExecutionJobGcsNotebookSource?
      gcsNotebookSource;

  /// The Cloud Storage location to upload the result to.
  ///
  /// Format: `gs://bucket-name`
  core.String? gcsOutputUri;

  /// The state of the NotebookExecutionJob.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? jobState;

  /// The name of the kernel to use during notebook execution.
  ///
  /// If unset, the default kernel is used.
  core.String? kernelName;

  /// The labels with user-defined metadata to organize NotebookExecutionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? labels;

  /// The resource name of this NotebookExecutionJob.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
  ///
  /// Output only.
  core.String? name;

  /// The NotebookRuntimeTemplate to source compute configuration from.
  core.String? notebookRuntimeTemplateResourceName;

  /// The Schedule resource name if this job is triggered by one.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
  core.String? scheduleResourceName;

  /// The service account to run the execution as.
  core.String? serviceAccount;

  /// Populated when the NotebookExecutionJob is completed.
  ///
  /// When there is an error during notebook execution, the error details are
  /// populated.
  ///
  /// Output only.
  GoogleRpcStatus? status;

  /// Timestamp when this NotebookExecutionJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The Workbench runtime configuration to use for the notebook execution.
  GoogleCloudAiplatformV1NotebookExecutionJobWorkbenchRuntime? workbenchRuntime;

  GoogleCloudAiplatformV1NotebookExecutionJob({
    this.createTime,
    this.customEnvironmentSpec,
    this.dataformRepositorySource,
    this.directNotebookSource,
    this.displayName,
    this.encryptionSpec,
    this.executionTimeout,
    this.executionUser,
    this.gcsNotebookSource,
    this.gcsOutputUri,
    this.jobState,
    this.kernelName,
    this.labels,
    this.name,
    this.notebookRuntimeTemplateResourceName,
    this.scheduleResourceName,
    this.serviceAccount,
    this.status,
    this.updateTime,
    this.workbenchRuntime,
  });

  GoogleCloudAiplatformV1NotebookExecutionJob.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          customEnvironmentSpec: json_.containsKey('customEnvironmentSpec')
              ? GoogleCloudAiplatformV1NotebookExecutionJobCustomEnvironmentSpec
                  .fromJson(json_['customEnvironmentSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          dataformRepositorySource: json_
                  .containsKey('dataformRepositorySource')
              ? GoogleCloudAiplatformV1NotebookExecutionJobDataformRepositorySource
                  .fromJson(json_['dataformRepositorySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          directNotebookSource: json_.containsKey('directNotebookSource')
              ? GoogleCloudAiplatformV1NotebookExecutionJobDirectNotebookSource
                  .fromJson(json_['directNotebookSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          executionTimeout: json_['executionTimeout'] as core.String?,
          executionUser: json_['executionUser'] as core.String?,
          gcsNotebookSource: json_.containsKey('gcsNotebookSource')
              ? GoogleCloudAiplatformV1NotebookExecutionJobGcsNotebookSource
                  .fromJson(json_['gcsNotebookSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          gcsOutputUri: json_['gcsOutputUri'] as core.String?,
          jobState: json_['jobState'] as core.String?,
          kernelName: json_['kernelName'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          notebookRuntimeTemplateResourceName:
              json_['notebookRuntimeTemplateResourceName'] as core.String?,
          scheduleResourceName: json_['scheduleResourceName'] as core.String?,
          serviceAccount: json_['serviceAccount'] as core.String?,
          status: json_.containsKey('status')
              ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
          workbenchRuntime: json_.containsKey('workbenchRuntime')
              ? GoogleCloudAiplatformV1NotebookExecutionJobWorkbenchRuntime
                  .fromJson(json_['workbenchRuntime']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (customEnvironmentSpec != null)
          'customEnvironmentSpec': customEnvironmentSpec!,
        if (dataformRepositorySource != null)
          'dataformRepositorySource': dataformRepositorySource!,
        if (directNotebookSource != null)
          'directNotebookSource': directNotebookSource!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (executionTimeout != null) 'executionTimeout': executionTimeout!,
        if (executionUser != null) 'executionUser': executionUser!,
        if (gcsNotebookSource != null) 'gcsNotebookSource': gcsNotebookSource!,
        if (gcsOutputUri != null) 'gcsOutputUri': gcsOutputUri!,
        if (jobState != null) 'jobState': jobState!,
        if (kernelName != null) 'kernelName': kernelName!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (notebookRuntimeTemplateResourceName != null)
          'notebookRuntimeTemplateResourceName':
              notebookRuntimeTemplateResourceName!,
        if (scheduleResourceName != null)
          'scheduleResourceName': scheduleResourceName!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (status != null) 'status': status!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (workbenchRuntime != null) 'workbenchRuntime': workbenchRuntime!,
      };
}

/// Compute configuration to use for an execution job.
class GoogleCloudAiplatformV1NotebookExecutionJobCustomEnvironmentSpec {
  /// The specification of a single machine for the execution job.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The network configuration to use for the execution job.
  GoogleCloudAiplatformV1NetworkSpec? networkSpec;

  /// The specification of a persistent disk to attach for the execution job.
  GoogleCloudAiplatformV1PersistentDiskSpec? persistentDiskSpec;

  GoogleCloudAiplatformV1NotebookExecutionJobCustomEnvironmentSpec({
    this.machineSpec,
    this.networkSpec,
    this.persistentDiskSpec,
  });

  GoogleCloudAiplatformV1NotebookExecutionJobCustomEnvironmentSpec.fromJson(
      core.Map json_)
      : this(
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          networkSpec: json_.containsKey('networkSpec')
              ? GoogleCloudAiplatformV1NetworkSpec.fromJson(
                  json_['networkSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          persistentDiskSpec: json_.containsKey('persistentDiskSpec')
              ? GoogleCloudAiplatformV1PersistentDiskSpec.fromJson(
                  json_['persistentDiskSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (networkSpec != null) 'networkSpec': networkSpec!,
        if (persistentDiskSpec != null)
          'persistentDiskSpec': persistentDiskSpec!,
      };
}

/// The Dataform Repository containing the input notebook.
class GoogleCloudAiplatformV1NotebookExecutionJobDataformRepositorySource {
  /// The commit SHA to read repository with.
  ///
  /// If unset, the file will be read at HEAD.
  core.String? commitSha;

  /// The resource name of the Dataform Repository.
  ///
  /// Format:
  /// `projects/{project_id}/locations/{location}/repositories/{repository_id}`
  core.String? dataformRepositoryResourceName;

  GoogleCloudAiplatformV1NotebookExecutionJobDataformRepositorySource({
    this.commitSha,
    this.dataformRepositoryResourceName,
  });

  GoogleCloudAiplatformV1NotebookExecutionJobDataformRepositorySource.fromJson(
      core.Map json_)
      : this(
          commitSha: json_['commitSha'] as core.String?,
          dataformRepositoryResourceName:
              json_['dataformRepositoryResourceName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (commitSha != null) 'commitSha': commitSha!,
        if (dataformRepositoryResourceName != null)
          'dataformRepositoryResourceName': dataformRepositoryResourceName!,
      };
}

/// The content of the input notebook in ipynb format.
class GoogleCloudAiplatformV1NotebookExecutionJobDirectNotebookSource {
  /// The base64-encoded contents of the input notebook file.
  core.String? content;
  core.List<core.int> get contentAsBytes => convert.base64.decode(content!);

  set contentAsBytes(core.List<core.int> bytes_) {
    content =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  GoogleCloudAiplatformV1NotebookExecutionJobDirectNotebookSource({
    this.content,
  });

  GoogleCloudAiplatformV1NotebookExecutionJobDirectNotebookSource.fromJson(
      core.Map json_)
      : this(
          content: json_['content'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (content != null) 'content': content!,
      };
}

/// The Cloud Storage uri for the input notebook.
class GoogleCloudAiplatformV1NotebookExecutionJobGcsNotebookSource {
  /// The version of the Cloud Storage object to read.
  ///
  /// If unset, the current version of the object is read. See
  /// https://cloud.google.com/storage/docs/metadata#generation-number.
  core.String? generation;

  /// The Cloud Storage uri pointing to the ipynb file.
  ///
  /// Format: `gs://bucket/notebook_file.ipynb`
  core.String? uri;

  GoogleCloudAiplatformV1NotebookExecutionJobGcsNotebookSource({
    this.generation,
    this.uri,
  });

  GoogleCloudAiplatformV1NotebookExecutionJobGcsNotebookSource.fromJson(
      core.Map json_)
      : this(
          generation: json_['generation'] as core.String?,
          uri: json_['uri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (generation != null) 'generation': generation!,
        if (uri != null) 'uri': uri!,
      };
}

/// Configuration for a Workbench Instances-based environment.
typedef GoogleCloudAiplatformV1NotebookExecutionJobWorkbenchRuntime = $Empty;

/// The idle shutdown configuration of NotebookRuntimeTemplate, which contains
/// the idle_timeout as required field.
class GoogleCloudAiplatformV1NotebookIdleShutdownConfig {
  /// Whether Idle Shutdown is disabled in this NotebookRuntimeTemplate.
  core.bool? idleShutdownDisabled;

  /// Duration is accurate to the second.
  ///
  /// In Notebook, Idle Timeout is accurate to minute so the range of
  /// idle_timeout (second) is: 10 * 60 ~ 1440 * 60.
  ///
  /// Required.
  core.String? idleTimeout;

  GoogleCloudAiplatformV1NotebookIdleShutdownConfig({
    this.idleShutdownDisabled,
    this.idleTimeout,
  });

  GoogleCloudAiplatformV1NotebookIdleShutdownConfig.fromJson(core.Map json_)
      : this(
          idleShutdownDisabled: json_['idleShutdownDisabled'] as core.bool?,
          idleTimeout: json_['idleTimeout'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (idleShutdownDisabled != null)
          'idleShutdownDisabled': idleShutdownDisabled!,
        if (idleTimeout != null) 'idleTimeout': idleTimeout!,
      };
}

/// A runtime is a virtual machine allocated to a particular user for a
/// particular Notebook file on temporary basis with lifetime limited to 24
/// hours.
class GoogleCloudAiplatformV1NotebookRuntime {
  /// Timestamp when this NotebookRuntime was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The specification of persistent disk attached to the notebook runtime as
  /// data disk storage.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PersistentDiskSpec? dataPersistentDiskSpec;

  /// The description of the NotebookRuntime.
  core.String? description;

  /// The display name of the NotebookRuntime.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// EUC configuration of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NotebookEucConfig? eucConfig;

  /// Timestamp when this NotebookRuntime will be expired: 1.
  ///
  /// System Predefined NotebookRuntime: 24 hours after creation. After
  /// expiration, system predifined runtime will be deleted. 2. User created
  /// NotebookRuntime: 6 months after last upgrade. After expiration, user
  /// created runtime will be stopped and allowed for upgrade.
  ///
  /// Output only.
  core.String? expirationTime;

  /// The health state of the NotebookRuntime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HEALTH_STATE_UNSPECIFIED" : Unspecified health state.
  /// - "HEALTHY" : NotebookRuntime is in healthy state. Applies to ACTIVE
  /// state.
  /// - "UNHEALTHY" : NotebookRuntime is in unhealthy state. Applies to ACTIVE
  /// state.
  core.String? healthState;

  /// The idle shutdown configuration of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NotebookIdleShutdownConfig? idleShutdownConfig;

  /// Whether NotebookRuntime is upgradable.
  ///
  /// Output only.
  core.bool? isUpgradable;

  /// The labels with user-defined metadata to organize your NotebookRuntime.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one NotebookRuntime (System labels
  /// are excluded). See https://goo.gl/xmQnxf for more information and examples
  /// of labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for NotebookRuntime: *
  /// "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output only,
  /// its value is the Compute Engine instance id. *
  /// "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
  /// either "bigquery" or "vertex"; if absent, it should be "vertex". This is
  /// to describe the entry service, either BigQuery or Vertex.
  core.Map<core.String, core.String>? labels;

  /// The specification of a single machine used by the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The resource name of the NotebookRuntime.
  ///
  /// Output only.
  core.String? name;

  /// Network spec of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NetworkSpec? networkSpec;

  /// The Compute Engine tags to add to runtime (see
  /// [Tagging instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  ///
  /// Optional.
  core.List<core.String>? networkTags;

  /// The pointer to NotebookRuntimeTemplate this NotebookRuntime is created
  /// from.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NotebookRuntimeTemplateRef? notebookRuntimeTemplateRef;

  /// The type of the notebook runtime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" : Unspecified notebook runtime type,
  /// NotebookRuntimeType will default to USER_DEFINED.
  /// - "USER_DEFINED" : runtime or template with coustomized configurations
  /// from user.
  /// - "ONE_CLICK" : runtime or template with system defined configurations.
  core.String? notebookRuntimeType;

  /// The proxy endpoint used to access the NotebookRuntime.
  ///
  /// Output only.
  core.String? proxyUri;

  /// The runtime (instance) state of the NotebookRuntime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "RUNTIME_STATE_UNSPECIFIED" : Unspecified runtime state.
  /// - "RUNNING" : NotebookRuntime is in running state.
  /// - "BEING_STARTED" : NotebookRuntime is in starting state.
  /// - "BEING_STOPPED" : NotebookRuntime is in stopping state.
  /// - "STOPPED" : NotebookRuntime is in stopped state.
  /// - "BEING_UPGRADED" : NotebookRuntime is in upgrading state. It is in the
  /// middle of upgrading process.
  /// - "ERROR" : NotebookRuntime was unable to start/stop properly.
  /// - "INVALID" : NotebookRuntime is in invalid state. Cannot be recovered.
  core.String? runtimeState;

  /// The user email of the NotebookRuntime.
  ///
  /// Required.
  core.String? runtimeUser;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Deprecated: This field is no longer used and the "Vertex AI Notebook
  /// Service Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  ///
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details. The service account that the NotebookRuntime workload
  /// runs as.
  ///
  /// Output only.
  core.String? serviceAccount;

  /// Runtime Shielded VM spec.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ShieldedVmConfig? shieldedVmConfig;

  /// Software config of the notebook runtime.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NotebookSoftwareConfig? softwareConfig;

  /// Timestamp when this NotebookRuntime was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The VM os image version of NotebookRuntime.
  ///
  /// Output only.
  core.String? version;

  GoogleCloudAiplatformV1NotebookRuntime({
    this.createTime,
    this.dataPersistentDiskSpec,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.eucConfig,
    this.expirationTime,
    this.healthState,
    this.idleShutdownConfig,
    this.isUpgradable,
    this.labels,
    this.machineSpec,
    this.name,
    this.networkSpec,
    this.networkTags,
    this.notebookRuntimeTemplateRef,
    this.notebookRuntimeType,
    this.proxyUri,
    this.runtimeState,
    this.runtimeUser,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.serviceAccount,
    this.shieldedVmConfig,
    this.softwareConfig,
    this.updateTime,
    this.version,
  });

  GoogleCloudAiplatformV1NotebookRuntime.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          dataPersistentDiskSpec: json_.containsKey('dataPersistentDiskSpec')
              ? GoogleCloudAiplatformV1PersistentDiskSpec.fromJson(
                  json_['dataPersistentDiskSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          eucConfig: json_.containsKey('eucConfig')
              ? GoogleCloudAiplatformV1NotebookEucConfig.fromJson(
                  json_['eucConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          expirationTime: json_['expirationTime'] as core.String?,
          healthState: json_['healthState'] as core.String?,
          idleShutdownConfig: json_.containsKey('idleShutdownConfig')
              ? GoogleCloudAiplatformV1NotebookIdleShutdownConfig.fromJson(
                  json_['idleShutdownConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          isUpgradable: json_['isUpgradable'] as core.bool?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          networkSpec: json_.containsKey('networkSpec')
              ? GoogleCloudAiplatformV1NetworkSpec.fromJson(
                  json_['networkSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          networkTags: (json_['networkTags'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          notebookRuntimeTemplateRef:
              json_.containsKey('notebookRuntimeTemplateRef')
                  ? GoogleCloudAiplatformV1NotebookRuntimeTemplateRef.fromJson(
                      json_['notebookRuntimeTemplateRef']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          notebookRuntimeType: json_['notebookRuntimeType'] as core.String?,
          proxyUri: json_['proxyUri'] as core.String?,
          runtimeState: json_['runtimeState'] as core.String?,
          runtimeUser: json_['runtimeUser'] as core.String?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          serviceAccount: json_['serviceAccount'] as core.String?,
          shieldedVmConfig: json_.containsKey('shieldedVmConfig')
              ? GoogleCloudAiplatformV1ShieldedVmConfig.fromJson(
                  json_['shieldedVmConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          softwareConfig: json_.containsKey('softwareConfig')
              ? GoogleCloudAiplatformV1NotebookSoftwareConfig.fromJson(
                  json_['softwareConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
          version: json_['version'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (dataPersistentDiskSpec != null)
          'dataPersistentDiskSpec': dataPersistentDiskSpec!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (eucConfig != null) 'eucConfig': eucConfig!,
        if (expirationTime != null) 'expirationTime': expirationTime!,
        if (healthState != null) 'healthState': healthState!,
        if (idleShutdownConfig != null)
          'idleShutdownConfig': idleShutdownConfig!,
        if (isUpgradable != null) 'isUpgradable': isUpgradable!,
        if (labels != null) 'labels': labels!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (name != null) 'name': name!,
        if (networkSpec != null) 'networkSpec': networkSpec!,
        if (networkTags != null) 'networkTags': networkTags!,
        if (notebookRuntimeTemplateRef != null)
          'notebookRuntimeTemplateRef': notebookRuntimeTemplateRef!,
        if (notebookRuntimeType != null)
          'notebookRuntimeType': notebookRuntimeType!,
        if (proxyUri != null) 'proxyUri': proxyUri!,
        if (runtimeState != null) 'runtimeState': runtimeState!,
        if (runtimeUser != null) 'runtimeUser': runtimeUser!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (shieldedVmConfig != null) 'shieldedVmConfig': shieldedVmConfig!,
        if (softwareConfig != null) 'softwareConfig': softwareConfig!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (version != null) 'version': version!,
      };
}

/// A template that specifies runtime configurations such as machine type,
/// runtime version, network configurations, etc.
///
/// Multiple runtimes can be created from a runtime template.
class GoogleCloudAiplatformV1NotebookRuntimeTemplate {
  /// Timestamp when this NotebookRuntimeTemplate was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The specification of persistent disk attached to the runtime as data disk
  /// storage.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PersistentDiskSpec? dataPersistentDiskSpec;

  /// The description of the NotebookRuntimeTemplate.
  core.String? description;

  /// The display name of the NotebookRuntimeTemplate.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for the notebook runtime.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// EUC configuration of the NotebookRuntimeTemplate.
  GoogleCloudAiplatformV1NotebookEucConfig? eucConfig;

  /// The idle shutdown configuration of NotebookRuntimeTemplate.
  ///
  /// This config will only be set when idle shutdown is enabled.
  GoogleCloudAiplatformV1NotebookIdleShutdownConfig? idleShutdownConfig;

  /// Deprecated: This field has no behavior.
  ///
  /// Use notebook_runtime_type = 'ONE_CLICK' instead. The default template to
  /// use if not specified.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? isDefault;

  /// The labels with user-defined metadata to organize the
  /// NotebookRuntimeTemplates.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The specification of a single machine for the template.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The resource name of the NotebookRuntimeTemplate.
  core.String? name;

  /// Network spec.
  ///
  /// Optional.
  GoogleCloudAiplatformV1NetworkSpec? networkSpec;

  /// The Compute Engine tags to add to runtime (see
  /// [Tagging instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  ///
  /// Optional.
  core.List<core.String>? networkTags;

  /// The type of the notebook runtime template.
  ///
  /// Optional. Immutable.
  /// Possible string values are:
  /// - "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" : Unspecified notebook runtime type,
  /// NotebookRuntimeType will default to USER_DEFINED.
  /// - "USER_DEFINED" : runtime or template with coustomized configurations
  /// from user.
  /// - "ONE_CLICK" : runtime or template with system defined configurations.
  core.String? notebookRuntimeType;

  /// Deprecated: This field is ignored and the "Vertex AI Notebook Service
  /// Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  ///
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details. For NotebookExecutionJob, use
  /// NotebookExecutionJob.service_account instead. The service account that the
  /// runtime workload runs as. You can use any service account within the same
  /// project, but you must have the service account user permission to use the
  /// instance. If not specified, the
  /// [Compute Engine default service account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
  /// is used.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? serviceAccount;

  /// Runtime Shielded VM spec.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1ShieldedVmConfig? shieldedVmConfig;

  /// The notebook software configuration of the notebook runtime.
  ///
  /// Optional.
  GoogleCloudAiplatformV1NotebookSoftwareConfig? softwareConfig;

  /// Timestamp when this NotebookRuntimeTemplate was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1NotebookRuntimeTemplate({
    this.createTime,
    this.dataPersistentDiskSpec,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.eucConfig,
    this.idleShutdownConfig,
    this.isDefault,
    this.labels,
    this.machineSpec,
    this.name,
    this.networkSpec,
    this.networkTags,
    this.notebookRuntimeType,
    this.serviceAccount,
    this.shieldedVmConfig,
    this.softwareConfig,
    this.updateTime,
  });

  GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          dataPersistentDiskSpec: json_.containsKey('dataPersistentDiskSpec')
              ? GoogleCloudAiplatformV1PersistentDiskSpec.fromJson(
                  json_['dataPersistentDiskSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          eucConfig: json_.containsKey('eucConfig')
              ? GoogleCloudAiplatformV1NotebookEucConfig.fromJson(
                  json_['eucConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          idleShutdownConfig: json_.containsKey('idleShutdownConfig')
              ? GoogleCloudAiplatformV1NotebookIdleShutdownConfig.fromJson(
                  json_['idleShutdownConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          isDefault: json_['isDefault'] as core.bool?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          networkSpec: json_.containsKey('networkSpec')
              ? GoogleCloudAiplatformV1NetworkSpec.fromJson(
                  json_['networkSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          networkTags: (json_['networkTags'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          notebookRuntimeType: json_['notebookRuntimeType'] as core.String?,
          serviceAccount: json_['serviceAccount'] as core.String?,
          shieldedVmConfig: json_.containsKey('shieldedVmConfig')
              ? GoogleCloudAiplatformV1ShieldedVmConfig.fromJson(
                  json_['shieldedVmConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          softwareConfig: json_.containsKey('softwareConfig')
              ? GoogleCloudAiplatformV1NotebookSoftwareConfig.fromJson(
                  json_['softwareConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (dataPersistentDiskSpec != null)
          'dataPersistentDiskSpec': dataPersistentDiskSpec!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (eucConfig != null) 'eucConfig': eucConfig!,
        if (idleShutdownConfig != null)
          'idleShutdownConfig': idleShutdownConfig!,
        if (isDefault != null) 'isDefault': isDefault!,
        if (labels != null) 'labels': labels!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (name != null) 'name': name!,
        if (networkSpec != null) 'networkSpec': networkSpec!,
        if (networkTags != null) 'networkTags': networkTags!,
        if (notebookRuntimeType != null)
          'notebookRuntimeType': notebookRuntimeType!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (shieldedVmConfig != null) 'shieldedVmConfig': shieldedVmConfig!,
        if (softwareConfig != null) 'softwareConfig': softwareConfig!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Points to a NotebookRuntimeTemplateRef.
class GoogleCloudAiplatformV1NotebookRuntimeTemplateRef {
  /// A resource name of the NotebookRuntimeTemplate.
  ///
  /// Immutable.
  core.String? notebookRuntimeTemplate;

  GoogleCloudAiplatformV1NotebookRuntimeTemplateRef({
    this.notebookRuntimeTemplate,
  });

  GoogleCloudAiplatformV1NotebookRuntimeTemplateRef.fromJson(core.Map json_)
      : this(
          notebookRuntimeTemplate:
              json_['notebookRuntimeTemplate'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (notebookRuntimeTemplate != null)
          'notebookRuntimeTemplate': notebookRuntimeTemplate!,
      };
}

/// Notebook Software Config.
class GoogleCloudAiplatformV1NotebookSoftwareConfig {
  /// Environment variables to be passed to the container.
  ///
  /// Maximum limit is 100.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// Post startup script config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PostStartupScriptConfig? postStartupScriptConfig;

  GoogleCloudAiplatformV1NotebookSoftwareConfig({
    this.env,
    this.postStartupScriptConfig,
  });

  GoogleCloudAiplatformV1NotebookSoftwareConfig.fromJson(core.Map json_)
      : this(
          env: (json_['env'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          postStartupScriptConfig: json_.containsKey('postStartupScriptConfig')
              ? GoogleCloudAiplatformV1PostStartupScriptConfig.fromJson(
                  json_['postStartupScriptConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (env != null) 'env': env!,
        if (postStartupScriptConfig != null)
          'postStartupScriptConfig': postStartupScriptConfig!,
      };
}

/// Config for evaluation output.
class GoogleCloudAiplatformV1OutputConfig {
  /// Cloud storage destination for evaluation output.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1OutputConfig({
    this.gcsDestination,
  });

  GoogleCloudAiplatformV1OutputConfig.fromJson(core.Map json_)
      : this(
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
      };
}

/// PSC config that is used to automatically create forwarding rule via
/// ServiceConnectionMap.
class GoogleCloudAiplatformV1PSCAutomationConfig {
  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
  ///
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in '12345', and {network} is network name.
  ///
  /// Required.
  core.String? network;

  /// Project id used to create forwarding rule.
  ///
  /// Required.
  core.String? projectId;

  GoogleCloudAiplatformV1PSCAutomationConfig({
    this.network,
    this.projectId,
  });

  GoogleCloudAiplatformV1PSCAutomationConfig.fromJson(core.Map json_)
      : this(
          network: json_['network'] as core.String?,
          projectId: json_['projectId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (network != null) 'network': network!,
        if (projectId != null) 'projectId': projectId!,
      };
}

/// Input for pairwise metric.
class GoogleCloudAiplatformV1PairwiseMetricInput {
  /// Pairwise metric instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1PairwiseMetricInstance? instance;

  /// Spec for pairwise metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1PairwiseMetricSpec? metricSpec;

  GoogleCloudAiplatformV1PairwiseMetricInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1PairwiseMetricInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1PairwiseMetricInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1PairwiseMetricSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Pairwise metric instance.
///
/// Usually one instance corresponds to one row in an evaluation dataset.
class GoogleCloudAiplatformV1PairwiseMetricInstance {
  /// Instance specified as a json string.
  ///
  /// String key-value pairs are expected in the json_instance to render
  /// PairwiseMetricSpec.instance_prompt_template.
  core.String? jsonInstance;

  GoogleCloudAiplatformV1PairwiseMetricInstance({
    this.jsonInstance,
  });

  GoogleCloudAiplatformV1PairwiseMetricInstance.fromJson(core.Map json_)
      : this(
          jsonInstance: json_['jsonInstance'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (jsonInstance != null) 'jsonInstance': jsonInstance!,
      };
}

/// Spec for pairwise metric result.
class GoogleCloudAiplatformV1PairwiseMetricResult {
  /// Explanation for pairwise metric score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pairwise metric choice.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PAIRWISE_CHOICE_UNSPECIFIED" : Unspecified prediction choice.
  /// - "BASELINE" : Baseline prediction wins
  /// - "CANDIDATE" : Candidate prediction wins
  /// - "TIE" : Winner cannot be determined
  core.String? pairwiseChoice;

  GoogleCloudAiplatformV1PairwiseMetricResult({
    this.explanation,
    this.pairwiseChoice,
  });

  GoogleCloudAiplatformV1PairwiseMetricResult.fromJson(core.Map json_)
      : this(
          explanation: json_['explanation'] as core.String?,
          pairwiseChoice: json_['pairwiseChoice'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanation != null) 'explanation': explanation!,
        if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!,
      };
}

/// Spec for pairwise metric.
class GoogleCloudAiplatformV1PairwiseMetricSpec {
  /// The field name of the baseline response.
  ///
  /// Optional.
  core.String? baselineResponseFieldName;

  /// The field name of the candidate response.
  ///
  /// Optional.
  core.String? candidateResponseFieldName;

  /// Metric prompt template for pairwise metric.
  ///
  /// Required.
  core.String? metricPromptTemplate;

  /// System instructions for pairwise metric.
  ///
  /// Optional.
  core.String? systemInstruction;

  GoogleCloudAiplatformV1PairwiseMetricSpec({
    this.baselineResponseFieldName,
    this.candidateResponseFieldName,
    this.metricPromptTemplate,
    this.systemInstruction,
  });

  GoogleCloudAiplatformV1PairwiseMetricSpec.fromJson(core.Map json_)
      : this(
          baselineResponseFieldName:
              json_['baselineResponseFieldName'] as core.String?,
          candidateResponseFieldName:
              json_['candidateResponseFieldName'] as core.String?,
          metricPromptTemplate: json_['metricPromptTemplate'] as core.String?,
          systemInstruction: json_['systemInstruction'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baselineResponseFieldName != null)
          'baselineResponseFieldName': baselineResponseFieldName!,
        if (candidateResponseFieldName != null)
          'candidateResponseFieldName': candidateResponseFieldName!,
        if (metricPromptTemplate != null)
          'metricPromptTemplate': metricPromptTemplate!,
        if (systemInstruction != null) 'systemInstruction': systemInstruction!,
      };
}

/// Input for pairwise question answering quality metric.
class GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInput {
  /// Pairwise question answering quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInstance? instance;

  /// Spec for pairwise question answering quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualitySpec? metricSpec;

  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInput.fromJson(
      core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInstance
                  .fromJson(
                      json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualitySpec
                  .fromJson(json_['metricSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for pairwise question answering quality instance.
class GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInstance {
  /// Output of the baseline model.
  ///
  /// Required.
  core.String? baselinePrediction;

  /// Text to answer the question.
  ///
  /// Required.
  core.String? context;

  /// Question Answering prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the candidate model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInstance({
    this.baselinePrediction,
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityInstance.fromJson(
      core.Map json_)
      : this(
          baselinePrediction: json_['baselinePrediction'] as core.String?,
          context: json_['context'] as core.String?,
          instruction: json_['instruction'] as core.String?,
          prediction: json_['prediction'] as core.String?,
          reference: json_['reference'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baselinePrediction != null)
          'baselinePrediction': baselinePrediction!,
        if (context != null) 'context': context!,
        if (instruction != null) 'instruction': instruction!,
        if (prediction != null) 'prediction': prediction!,
        if (reference != null) 'reference': reference!,
      };
}

/// Spec for pairwise question answering quality result.
class GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityResult {
  /// Confidence for question answering quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pairwise question answering prediction choice.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PAIRWISE_CHOICE_UNSPECIFIED" : Unspecified prediction choice.
  /// - "BASELINE" : Baseline prediction wins
  /// - "CANDIDATE" : Candidate prediction wins
  /// - "TIE" : Winner cannot be determined
  core.String? pairwiseChoice;

  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityResult({
    this.confidence,
    this.explanation,
    this.pairwiseChoice,
  });

  GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualityResult.fromJson(
      core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          pairwiseChoice: json_['pairwiseChoice'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!,
      };
}

/// Spec for pairwise question answering quality score metric.
typedef GoogleCloudAiplatformV1PairwiseQuestionAnsweringQualitySpec
    = $QuestionAnsweringQualitySpec;

/// Input for pairwise summarization quality metric.
class GoogleCloudAiplatformV1PairwiseSummarizationQualityInput {
  /// Pairwise summarization quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1PairwiseSummarizationQualityInstance? instance;

  /// Spec for pairwise summarization quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1PairwiseSummarizationQualitySpec? metricSpec;

  GoogleCloudAiplatformV1PairwiseSummarizationQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1PairwiseSummarizationQualityInput.fromJson(
      core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1PairwiseSummarizationQualityInstance
                  .fromJson(
                      json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1PairwiseSummarizationQualitySpec
                  .fromJson(json_['metricSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for pairwise summarization quality instance.
class GoogleCloudAiplatformV1PairwiseSummarizationQualityInstance {
  /// Output of the baseline model.
  ///
  /// Required.
  core.String? baselinePrediction;

  /// Text to be summarized.
  ///
  /// Required.
  core.String? context;

  /// Summarization prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the candidate model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  GoogleCloudAiplatformV1PairwiseSummarizationQualityInstance({
    this.baselinePrediction,
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  GoogleCloudAiplatformV1PairwiseSummarizationQualityInstance.fromJson(
      core.Map json_)
      : this(
          baselinePrediction: json_['baselinePrediction'] as core.String?,
          context: json_['context'] as core.String?,
          instruction: json_['instruction'] as core.String?,
          prediction: json_['prediction'] as core.String?,
          reference: json_['reference'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baselinePrediction != null)
          'baselinePrediction': baselinePrediction!,
        if (context != null) 'context': context!,
        if (instruction != null) 'instruction': instruction!,
        if (prediction != null) 'prediction': prediction!,
        if (reference != null) 'reference': reference!,
      };
}

/// Spec for pairwise summarization quality result.
class GoogleCloudAiplatformV1PairwiseSummarizationQualityResult {
  /// Confidence for summarization quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pairwise summarization prediction choice.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PAIRWISE_CHOICE_UNSPECIFIED" : Unspecified prediction choice.
  /// - "BASELINE" : Baseline prediction wins
  /// - "CANDIDATE" : Candidate prediction wins
  /// - "TIE" : Winner cannot be determined
  core.String? pairwiseChoice;

  GoogleCloudAiplatformV1PairwiseSummarizationQualityResult({
    this.confidence,
    this.explanation,
    this.pairwiseChoice,
  });

  GoogleCloudAiplatformV1PairwiseSummarizationQualityResult.fromJson(
      core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          pairwiseChoice: json_['pairwiseChoice'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!,
      };
}

/// Spec for pairwise summarization quality score metric.
class GoogleCloudAiplatformV1PairwiseSummarizationQualitySpec {
  /// Whether to use instance.reference to compute pairwise summarization
  /// quality.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  GoogleCloudAiplatformV1PairwiseSummarizationQualitySpec({
    this.useReference,
    this.version,
  });

  GoogleCloudAiplatformV1PairwiseSummarizationQualitySpec.fromJson(
      core.Map json_)
      : this(
          useReference: json_['useReference'] as core.bool?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useReference != null) 'useReference': useReference!,
        if (version != null) 'version': version!,
      };
}

/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can
/// only contain one of the accepted types in `Part.data`. A `Part` must have a
/// fixed IANA MIME type identifying the type and subtype of the media if
/// `inline_data` or `file_data` field is filled with raw bytes.
class GoogleCloudAiplatformV1Part {
  /// Result of executing the \[ExecutableCode\].
  ///
  /// Optional.
  GoogleCloudAiplatformV1CodeExecutionResult? codeExecutionResult;

  /// Code generated by the model that is meant to be executed.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ExecutableCode? executableCode;

  /// URI based data.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FileData? fileData;

  /// A predicted \[FunctionCall\] returned from the model that contains a
  /// string representing the \[FunctionDeclaration.name\] with the parameters
  /// and their values.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FunctionCall? functionCall;

  /// The result output of a \[FunctionCall\] that contains a string
  /// representing the \[FunctionDeclaration.name\] and a structured JSON object
  /// containing any output from the function call.
  ///
  /// It is used as context to the model.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FunctionResponse? functionResponse;

  /// Inlined bytes data.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Blob? inlineData;

  /// Text part (can be code).
  ///
  /// Optional.
  core.String? text;

  /// Video metadata.
  ///
  /// The metadata should only be specified while the video data is presented in
  /// inline_data or file_data.
  ///
  /// Optional.
  GoogleCloudAiplatformV1VideoMetadata? videoMetadata;

  GoogleCloudAiplatformV1Part({
    this.codeExecutionResult,
    this.executableCode,
    this.fileData,
    this.functionCall,
    this.functionResponse,
    this.inlineData,
    this.text,
    this.videoMetadata,
  });

  GoogleCloudAiplatformV1Part.fromJson(core.Map json_)
      : this(
          codeExecutionResult: json_.containsKey('codeExecutionResult')
              ? GoogleCloudAiplatformV1CodeExecutionResult.fromJson(
                  json_['codeExecutionResult']
                      as core.Map<core.String, core.dynamic>)
              : null,
          executableCode: json_.containsKey('executableCode')
              ? GoogleCloudAiplatformV1ExecutableCode.fromJson(
                  json_['executableCode']
                      as core.Map<core.String, core.dynamic>)
              : null,
          fileData: json_.containsKey('fileData')
              ? GoogleCloudAiplatformV1FileData.fromJson(
                  json_['fileData'] as core.Map<core.String, core.dynamic>)
              : null,
          functionCall: json_.containsKey('functionCall')
              ? GoogleCloudAiplatformV1FunctionCall.fromJson(
                  json_['functionCall'] as core.Map<core.String, core.dynamic>)
              : null,
          functionResponse: json_.containsKey('functionResponse')
              ? GoogleCloudAiplatformV1FunctionResponse.fromJson(
                  json_['functionResponse']
                      as core.Map<core.String, core.dynamic>)
              : null,
          inlineData: json_.containsKey('inlineData')
              ? GoogleCloudAiplatformV1Blob.fromJson(
                  json_['inlineData'] as core.Map<core.String, core.dynamic>)
              : null,
          text: json_['text'] as core.String?,
          videoMetadata: json_.containsKey('videoMetadata')
              ? GoogleCloudAiplatformV1VideoMetadata.fromJson(
                  json_['videoMetadata'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (codeExecutionResult != null)
          'codeExecutionResult': codeExecutionResult!,
        if (executableCode != null) 'executableCode': executableCode!,
        if (fileData != null) 'fileData': fileData!,
        if (functionCall != null) 'functionCall': functionCall!,
        if (functionResponse != null) 'functionResponse': functionResponse!,
        if (inlineData != null) 'inlineData': inlineData!,
        if (text != null) 'text': text!,
        if (videoMetadata != null) 'videoMetadata': videoMetadata!,
      };
}

/// Request message for JobService.PauseModelDeploymentMonitoringJob.
typedef GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest
    = $Empty;

/// Request message for ScheduleService.PauseSchedule.
typedef GoogleCloudAiplatformV1PauseScheduleRequest = $Empty;

/// Represents the spec of persistent disk options.
class GoogleCloudAiplatformV1PersistentDiskSpec {
  /// Size in GB of the disk (default is 100GB).
  core.String? diskSizeGb;

  /// Type of the disk (default is "pd-standard").
  ///
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive) "pd-standard"
  /// (Persistent Disk Hard Disk Drive) "pd-balanced" (Balanced Persistent Disk)
  /// "pd-extreme" (Extreme Persistent Disk)
  core.String? diskType;

  GoogleCloudAiplatformV1PersistentDiskSpec({
    this.diskSizeGb,
    this.diskType,
  });

  GoogleCloudAiplatformV1PersistentDiskSpec.fromJson(core.Map json_)
      : this(
          diskSizeGb: json_['diskSizeGb'] as core.String?,
          diskType: json_['diskType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (diskType != null) 'diskType': diskType!,
      };
}

/// Represents long-lasting resources that are dedicated to users to runs custom
/// workloads.
///
/// A PersistentResource can have multiple node pools and each node pool can
/// have its own machine spec.
class GoogleCloudAiplatformV1PersistentResource {
  /// Time when the PersistentResource was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the PersistentResource.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Optional.
  core.String? displayName;

  /// Customer-managed encryption key spec for a PersistentResource.
  ///
  /// If set, this PersistentResource and all sub-resources of this
  /// PersistentResource will be secured by this key.
  ///
  /// Optional.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Only populated when persistent resource's state is `STOPPING` or `ERROR`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize PersistentResource.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Resource name of a PersistentResource.
  ///
  /// Immutable.
  core.String? name;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to peered with
  /// Vertex AI to host the persistent resources.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. To specify
  /// this field, you must have already
  /// [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  /// If this field is left unspecified, the resources aren't peered with any
  /// network.
  ///
  /// Optional.
  core.String? network;

  /// A list of names for the reserved IP ranges under the VPC network that can
  /// be used for this persistent resource.
  ///
  /// If set, we will deploy the persistent resource within the provided IP
  /// ranges. Otherwise, the persistent resource is deployed to any IP ranges
  /// under the provided VPC network. Example: \['vertex-ai-ip-range'\].
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  /// The spec of the pools of different resources.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ResourcePool>? resourcePools;

  /// Runtime information of the Persistent Resource.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ResourceRuntime? resourceRuntime;

  /// Persistent Resource runtime spec.
  ///
  /// For example, used for Ray cluster configuration.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ResourceRuntimeSpec? resourceRuntimeSpec;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Time when the PersistentResource for the first time entered the `RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of a Study.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Not set.
  /// - "PROVISIONING" : The PROVISIONING state indicates the persistent
  /// resources is being created.
  /// - "RUNNING" : The RUNNING state indicates the persistent resource is
  /// healthy and fully usable.
  /// - "STOPPING" : The STOPPING state indicates the persistent resource is
  /// being deleted.
  /// - "ERROR" : The ERROR state indicates the persistent resource may be
  /// unusable. Details can be found in the `error` field.
  /// - "REBOOTING" : The REBOOTING state indicates the persistent resource is
  /// being rebooted (PR is not available right now but is expected to be ready
  /// again later).
  /// - "UPDATING" : The UPDATING state indicates the persistent resource is
  /// being updated.
  core.String? state;

  /// Time when the PersistentResource was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1PersistentResource({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.error,
    this.labels,
    this.name,
    this.network,
    this.reservedIpRanges,
    this.resourcePools,
    this.resourceRuntime,
    this.resourceRuntimeSpec,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.startTime,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1PersistentResource.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          network: json_['network'] as core.String?,
          reservedIpRanges: (json_['reservedIpRanges'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          resourcePools: (json_['resourcePools'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1ResourcePool.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          resourceRuntime: json_.containsKey('resourceRuntime')
              ? GoogleCloudAiplatformV1ResourceRuntime.fromJson(
                  json_['resourceRuntime']
                      as core.Map<core.String, core.dynamic>)
              : null,
          resourceRuntimeSpec: json_.containsKey('resourceRuntimeSpec')
              ? GoogleCloudAiplatformV1ResourceRuntimeSpec.fromJson(
                  json_['resourceRuntimeSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (error != null) 'error': error!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
        if (resourcePools != null) 'resourcePools': resourcePools!,
        if (resourceRuntime != null) 'resourceRuntime': resourceRuntime!,
        if (resourceRuntimeSpec != null)
          'resourceRuntimeSpec': resourceRuntimeSpec!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// An instance of a machine learning PipelineJob.
class GoogleCloudAiplatformV1PipelineJob {
  /// Pipeline creation time.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the Pipeline.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  core.String? displayName;

  /// Customer-managed encryption key spec for a pipelineJob.
  ///
  /// If set, this PipelineJob and all of its sub-resources will be secured by
  /// this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Pipeline end time.
  ///
  /// Output only.
  core.String? endTime;

  /// The error that occurred during pipeline execution.
  ///
  /// Only populated when the pipeline's state is FAILED or CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The details of pipeline run.
  ///
  /// Not available in the list view.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineJobDetail? jobDetail;

  /// The labels with user-defined metadata to organize PipelineJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. Note
  /// there is some reserved label key for Vertex AI Pipelines. -
  /// `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the PipelineJob.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to which the
  /// Pipeline Job's workload should be peered.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. Private
  /// services access must already be configured for the network. Pipeline job
  /// will apply the network configuration to the Google Cloud resources being
  /// launched, if applied, such as Vertex AI Training or Dataflow job. If left
  /// unspecified, the workload is not peered with any network.
  core.String? network;

  /// The spec of the pipeline.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? pipelineSpec;

  /// Whether to do component level validations before job creation.
  ///
  /// Optional.
  core.bool? preflightValidations;

  /// A list of names for the reserved ip ranges under the VPC network that can
  /// be used for this Pipeline Job's workload.
  ///
  /// If set, we will deploy the Pipeline Job's workload within the provided ip
  /// ranges. Otherwise, the job will be deployed to any ip ranges under the
  /// provided VPC network. Example: \['vertex-ai-ip-range'\].
  core.List<core.String>? reservedIpRanges;

  /// Runtime config of the pipeline.
  GoogleCloudAiplatformV1PipelineJobRuntimeConfig? runtimeConfig;

  /// The schedule resource name.
  ///
  /// Only returned if the Pipeline is created by Schedule API.
  ///
  /// Output only.
  core.String? scheduleName;

  /// The service account that the pipeline workload runs as.
  ///
  /// If not specified, the Compute Engine default service account in the
  /// project will be used. See
  /// https://cloud.google.com/compute/docs/access/service-accounts#default_service_account
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  core.String? serviceAccount;

  /// Pipeline start time.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PIPELINE_STATE_UNSPECIFIED" : The pipeline state is unspecified.
  /// - "PIPELINE_STATE_QUEUED" : The pipeline has been created or resumed, and
  /// processing has not yet begun.
  /// - "PIPELINE_STATE_PENDING" : The service is preparing to run the pipeline.
  /// - "PIPELINE_STATE_RUNNING" : The pipeline is in progress.
  /// - "PIPELINE_STATE_SUCCEEDED" : The pipeline completed successfully.
  /// - "PIPELINE_STATE_FAILED" : The pipeline failed.
  /// - "PIPELINE_STATE_CANCELLING" : The pipeline is being cancelled. From this
  /// state, the pipeline may only go to either PIPELINE_STATE_SUCCEEDED,
  /// PIPELINE_STATE_FAILED or PIPELINE_STATE_CANCELLED.
  /// - "PIPELINE_STATE_CANCELLED" : The pipeline has been cancelled.
  /// - "PIPELINE_STATE_PAUSED" : The pipeline has been stopped, and can be
  /// resumed.
  core.String? state;

  /// Pipeline template metadata.
  ///
  /// Will fill up fields if PipelineJob.template_uri is from supported template
  /// registry.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTemplateMetadata? templateMetadata;

  /// A template uri from where the PipelineJob.pipeline_spec, if empty, will be
  /// downloaded.
  ///
  /// Currently, only uri from Vertex Template Registry & Gallery is supported.
  /// Reference to
  /// https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
  core.String? templateUri;

  /// Timestamp when this PipelineJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1PipelineJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.jobDetail,
    this.labels,
    this.name,
    this.network,
    this.pipelineSpec,
    this.preflightValidations,
    this.reservedIpRanges,
    this.runtimeConfig,
    this.scheduleName,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.templateMetadata,
    this.templateUri,
    this.updateTime,
  });

  GoogleCloudAiplatformV1PipelineJob.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          jobDetail: json_.containsKey('jobDetail')
              ? GoogleCloudAiplatformV1PipelineJobDetail.fromJson(
                  json_['jobDetail'] as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          network: json_['network'] as core.String?,
          pipelineSpec: json_.containsKey('pipelineSpec')
              ? json_['pipelineSpec'] as core.Map<core.String, core.dynamic>
              : null,
          preflightValidations: json_['preflightValidations'] as core.bool?,
          reservedIpRanges: (json_['reservedIpRanges'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          runtimeConfig: json_.containsKey('runtimeConfig')
              ? GoogleCloudAiplatformV1PipelineJobRuntimeConfig.fromJson(
                  json_['runtimeConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          scheduleName: json_['scheduleName'] as core.String?,
          serviceAccount: json_['serviceAccount'] as core.String?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          templateMetadata: json_.containsKey('templateMetadata')
              ? GoogleCloudAiplatformV1PipelineTemplateMetadata.fromJson(
                  json_['templateMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          templateUri: json_['templateUri'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (jobDetail != null) 'jobDetail': jobDetail!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (pipelineSpec != null) 'pipelineSpec': pipelineSpec!,
        if (preflightValidations != null)
          'preflightValidations': preflightValidations!,
        if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
        if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!,
        if (scheduleName != null) 'scheduleName': scheduleName!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (templateMetadata != null) 'templateMetadata': templateMetadata!,
        if (templateUri != null) 'templateUri': templateUri!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// The runtime detail of PipelineJob.
class GoogleCloudAiplatformV1PipelineJobDetail {
  /// The context of the pipeline.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Context? pipelineContext;

  /// The context of the current pipeline run.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Context? pipelineRunContext;

  /// The runtime details of the tasks under the pipeline.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1PipelineTaskDetail>? taskDetails;

  GoogleCloudAiplatformV1PipelineJobDetail({
    this.pipelineContext,
    this.pipelineRunContext,
    this.taskDetails,
  });

  GoogleCloudAiplatformV1PipelineJobDetail.fromJson(core.Map json_)
      : this(
          pipelineContext: json_.containsKey('pipelineContext')
              ? GoogleCloudAiplatformV1Context.fromJson(json_['pipelineContext']
                  as core.Map<core.String, core.dynamic>)
              : null,
          pipelineRunContext: json_.containsKey('pipelineRunContext')
              ? GoogleCloudAiplatformV1Context.fromJson(
                  json_['pipelineRunContext']
                      as core.Map<core.String, core.dynamic>)
              : null,
          taskDetails: (json_['taskDetails'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PipelineTaskDetail.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (pipelineContext != null) 'pipelineContext': pipelineContext!,
        if (pipelineRunContext != null)
          'pipelineRunContext': pipelineRunContext!,
        if (taskDetails != null) 'taskDetails': taskDetails!,
      };
}

/// The runtime config of a PipelineJob.
class GoogleCloudAiplatformV1PipelineJobRuntimeConfig {
  /// Represents the failure policy of a pipeline.
  ///
  /// Currently, the default of a pipeline is that the pipeline will continue to
  /// run until no more tasks can be executed, also known as
  /// PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to
  /// PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks
  /// when a task has failed. Any scheduled tasks will continue to completion.
  /// Possible string values are:
  /// - "PIPELINE_FAILURE_POLICY_UNSPECIFIED" : Default value, and follows fail
  /// slow behavior.
  /// - "PIPELINE_FAILURE_POLICY_FAIL_SLOW" : Indicates that the pipeline should
  /// continue to run until all possible tasks have been scheduled and
  /// completed.
  /// - "PIPELINE_FAILURE_POLICY_FAIL_FAST" : Indicates that the pipeline should
  /// stop scheduling new tasks after a task has failed.
  core.String? failurePolicy;

  /// A path in a Cloud Storage bucket, which will be treated as the root output
  /// directory of the pipeline.
  ///
  /// It is used by the system to generate the paths of output artifacts. The
  /// artifact paths are generated with a sub-path pattern
  /// `{job_id}/{task_id}/{output_key}` under the specified output directory.
  /// The service account specified in this pipeline must have the
  /// `storage.objects.get` and `storage.objects.create` permissions for this
  /// bucket.
  ///
  /// Required.
  core.String? gcsOutputDirectory;

  /// The runtime artifacts of the PipelineJob.
  ///
  /// The key will be the input artifact name and the value would be one of the
  /// InputArtifact.
  core.Map<core.String,
          GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact>?
      inputArtifacts;

  /// The runtime parameters of the PipelineJob.
  ///
  /// The parameters will be passed into PipelineJob.pipeline_spec to replace
  /// the placeholders at runtime. This field is used by pipelines built using
  /// `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built
  /// using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? parameterValues;

  /// Use RuntimeConfig.parameter_values instead.
  ///
  /// The runtime parameters of the PipelineJob. The parameters will be passed
  /// into PipelineJob.pipeline_spec to replace the placeholders at runtime.
  /// This field is used by pipelines built using
  /// `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as
  /// pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.Map<core.String, GoogleCloudAiplatformV1Value>? parameters;

  GoogleCloudAiplatformV1PipelineJobRuntimeConfig({
    this.failurePolicy,
    this.gcsOutputDirectory,
    this.inputArtifacts,
    this.parameterValues,
    this.parameters,
  });

  GoogleCloudAiplatformV1PipelineJobRuntimeConfig.fromJson(core.Map json_)
      : this(
          failurePolicy: json_['failurePolicy'] as core.String?,
          gcsOutputDirectory: json_['gcsOutputDirectory'] as core.String?,
          inputArtifacts:
              (json_['inputArtifacts'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact
                  .fromJson(value as core.Map<core.String, core.dynamic>),
            ),
          ),
          parameterValues: json_.containsKey('parameterValues')
              ? json_['parameterValues'] as core.Map<core.String, core.dynamic>
              : null,
          parameters:
              (json_['parameters'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1Value.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failurePolicy != null) 'failurePolicy': failurePolicy!,
        if (gcsOutputDirectory != null)
          'gcsOutputDirectory': gcsOutputDirectory!,
        if (inputArtifacts != null) 'inputArtifacts': inputArtifacts!,
        if (parameterValues != null) 'parameterValues': parameterValues!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// The type of an input artifact.
class GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact {
  /// Artifact resource id from MLMD.
  ///
  /// Which is the last portion of an artifact resource name:
  /// `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`.
  /// The artifact must stay within the same project, location and default
  /// metadatastore as the pipeline.
  core.String? artifactId;

  GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact({
    this.artifactId,
  });

  GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact.fromJson(
      core.Map json_)
      : this(
          artifactId: json_['artifactId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactId != null) 'artifactId': artifactId!,
      };
}

/// The runtime detail of a task execution.
class GoogleCloudAiplatformV1PipelineTaskDetail {
  /// Task create time.
  ///
  /// Output only.
  core.String? createTime;

  /// Task end time.
  ///
  /// Output only.
  core.String? endTime;

  /// The error that occurred during task execution.
  ///
  /// Only populated when the task's state is FAILED or CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The execution metadata of the task.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Execution? execution;

  /// The detailed execution info.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTaskExecutorDetail? executorDetail;

  /// The runtime input artifacts of the task.
  ///
  /// Output only.
  core.Map<core.String, GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>?
      inputs;

  /// The runtime output artifacts of the task.
  ///
  /// Output only.
  core.Map<core.String, GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>?
      outputs;

  /// The id of the parent task if the task is within a component scope.
  ///
  /// Empty if the task is at the root level.
  ///
  /// Output only.
  core.String? parentTaskId;

  /// A list of task status.
  ///
  /// This field keeps a record of task status evolving over time.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus>?
      pipelineTaskStatus;

  /// Task start time.
  ///
  /// Output only.
  core.String? startTime;

  /// State of the task.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "PENDING" : Specifies pending state for the task.
  /// - "RUNNING" : Specifies task is being executed.
  /// - "SUCCEEDED" : Specifies task completed successfully.
  /// - "CANCEL_PENDING" : Specifies Task cancel is in pending state.
  /// - "CANCELLING" : Specifies task is being cancelled.
  /// - "CANCELLED" : Specifies task was cancelled.
  /// - "FAILED" : Specifies task failed.
  /// - "SKIPPED" : Specifies task was skipped due to cache hit.
  /// - "NOT_TRIGGERED" : Specifies that the task was not triggered because the
  /// task's trigger policy is not satisfied. The trigger policy is specified in
  /// the `condition` field of PipelineJob.pipeline_spec.
  core.String? state;

  /// The system generated ID of the task.
  ///
  /// Output only.
  core.String? taskId;

  /// The user specified name of the task that is defined in pipeline_spec.
  ///
  /// Output only.
  core.String? taskName;

  GoogleCloudAiplatformV1PipelineTaskDetail({
    this.createTime,
    this.endTime,
    this.error,
    this.execution,
    this.executorDetail,
    this.inputs,
    this.outputs,
    this.parentTaskId,
    this.pipelineTaskStatus,
    this.startTime,
    this.state,
    this.taskId,
    this.taskName,
  });

  GoogleCloudAiplatformV1PipelineTaskDetail.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          execution: json_.containsKey('execution')
              ? GoogleCloudAiplatformV1Execution.fromJson(
                  json_['execution'] as core.Map<core.String, core.dynamic>)
              : null,
          executorDetail: json_.containsKey('executorDetail')
              ? GoogleCloudAiplatformV1PipelineTaskExecutorDetail.fromJson(
                  json_['executorDetail']
                      as core.Map<core.String, core.dynamic>)
              : null,
          inputs:
              (json_['inputs'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1PipelineTaskDetailArtifactList.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          outputs:
              (json_['outputs'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1PipelineTaskDetailArtifactList.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          parentTaskId: json_['parentTaskId'] as core.String?,
          pipelineTaskStatus: (json_['pipelineTaskStatus'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          taskId: json_['taskId'] as core.String?,
          taskName: json_['taskName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (execution != null) 'execution': execution!,
        if (executorDetail != null) 'executorDetail': executorDetail!,
        if (inputs != null) 'inputs': inputs!,
        if (outputs != null) 'outputs': outputs!,
        if (parentTaskId != null) 'parentTaskId': parentTaskId!,
        if (pipelineTaskStatus != null)
          'pipelineTaskStatus': pipelineTaskStatus!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (taskId != null) 'taskId': taskId!,
        if (taskName != null) 'taskName': taskName!,
      };
}

/// A list of artifact metadata.
class GoogleCloudAiplatformV1PipelineTaskDetailArtifactList {
  /// A list of artifact metadata.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Artifact>? artifacts;

  GoogleCloudAiplatformV1PipelineTaskDetailArtifactList({
    this.artifacts,
  });

  GoogleCloudAiplatformV1PipelineTaskDetailArtifactList.fromJson(core.Map json_)
      : this(
          artifacts: (json_['artifacts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Artifact.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
      };
}

/// A single record of the task status.
class GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus {
  /// The error that occurred during the state.
  ///
  /// May be set when the state is any of the non-final state
  /// (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the
  /// error here is final and not going to be retried. If the state is a
  /// non-final state, the error indicates a system-error being retried.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The state of the task.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "PENDING" : Specifies pending state for the task.
  /// - "RUNNING" : Specifies task is being executed.
  /// - "SUCCEEDED" : Specifies task completed successfully.
  /// - "CANCEL_PENDING" : Specifies Task cancel is in pending state.
  /// - "CANCELLING" : Specifies task is being cancelled.
  /// - "CANCELLED" : Specifies task was cancelled.
  /// - "FAILED" : Specifies task failed.
  /// - "SKIPPED" : Specifies task was skipped due to cache hit.
  /// - "NOT_TRIGGERED" : Specifies that the task was not triggered because the
  /// task's trigger policy is not satisfied. The trigger policy is specified in
  /// the `condition` field of PipelineJob.pipeline_spec.
  core.String? state;

  /// Update time of this status.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus({
    this.error,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus.fromJson(
      core.Map json_)
      : this(
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (error != null) 'error': error!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// The runtime detail of a pipeline executor.
class GoogleCloudAiplatformV1PipelineTaskExecutorDetail {
  /// The detailed info for a container executor.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail?
      containerDetail;

  /// The detailed info for a custom job executor.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail?
      customJobDetail;

  GoogleCloudAiplatformV1PipelineTaskExecutorDetail({
    this.containerDetail,
    this.customJobDetail,
  });

  GoogleCloudAiplatformV1PipelineTaskExecutorDetail.fromJson(core.Map json_)
      : this(
          containerDetail: json_.containsKey('containerDetail')
              ? GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail
                  .fromJson(json_['containerDetail']
                      as core.Map<core.String, core.dynamic>)
              : null,
          customJobDetail: json_.containsKey('customJobDetail')
              ? GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail
                  .fromJson(json_['customJobDetail']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerDetail != null) 'containerDetail': containerDetail!,
        if (customJobDetail != null) 'customJobDetail': customJobDetail!,
      };
}

/// The detail of a container execution.
///
/// It contains the job names of the lifecycle of a container execution.
class GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail {
  /// The names of the previously failed CustomJob for the main container
  /// executions.
  ///
  /// The list includes the all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedMainJobs;

  /// The names of the previously failed CustomJob for the pre-caching-check
  /// container executions.
  ///
  /// This job will be available if the PipelineJob.pipeline_spec specifies the
  /// `pre_caching_check` hook in the lifecycle events. The list includes the
  /// all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedPreCachingCheckJobs;

  /// The name of the CustomJob for the main container execution.
  ///
  /// Output only.
  core.String? mainJob;

  /// The name of the CustomJob for the pre-caching-check container execution.
  ///
  /// This job will be available if the PipelineJob.pipeline_spec specifies the
  /// `pre_caching_check` hook in the lifecycle events.
  ///
  /// Output only.
  core.String? preCachingCheckJob;

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail({
    this.failedMainJobs,
    this.failedPreCachingCheckJobs,
    this.mainJob,
    this.preCachingCheckJob,
  });

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail.fromJson(
      core.Map json_)
      : this(
          failedMainJobs: (json_['failedMainJobs'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          failedPreCachingCheckJobs:
              (json_['failedPreCachingCheckJobs'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
          mainJob: json_['mainJob'] as core.String?,
          preCachingCheckJob: json_['preCachingCheckJob'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failedMainJobs != null) 'failedMainJobs': failedMainJobs!,
        if (failedPreCachingCheckJobs != null)
          'failedPreCachingCheckJobs': failedPreCachingCheckJobs!,
        if (mainJob != null) 'mainJob': mainJob!,
        if (preCachingCheckJob != null)
          'preCachingCheckJob': preCachingCheckJob!,
      };
}

/// The detailed info for a custom job executor.
class GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail {
  /// The names of the previously failed CustomJob.
  ///
  /// The list includes the all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedJobs;

  /// The name of the CustomJob.
  ///
  /// Output only.
  core.String? job;

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail({
    this.failedJobs,
    this.job,
  });

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail.fromJson(
      core.Map json_)
      : this(
          failedJobs: (json_['failedJobs'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          job: json_['job'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failedJobs != null) 'failedJobs': failedJobs!,
        if (job != null) 'job': job!,
      };
}

/// Pipeline template metadata if PipelineJob.template_uri is from supported
/// template registry.
///
/// Currently, the only supported registry is Artifact Registry.
class GoogleCloudAiplatformV1PipelineTemplateMetadata {
  /// The version_name in artifact registry.
  ///
  /// Will always be presented in output if the PipelineJob.template_uri is from
  /// supported template registry. Format is "sha256:abcdef123456...".
  core.String? version;

  GoogleCloudAiplatformV1PipelineTemplateMetadata({
    this.version,
  });

  GoogleCloudAiplatformV1PipelineTemplateMetadata.fromJson(core.Map json_)
      : this(
          version: json_['version'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (version != null) 'version': version!,
      };
}

/// Input for pointwise metric.
class GoogleCloudAiplatformV1PointwiseMetricInput {
  /// Pointwise metric instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1PointwiseMetricInstance? instance;

  /// Spec for pointwise metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1PointwiseMetricSpec? metricSpec;

  GoogleCloudAiplatformV1PointwiseMetricInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1PointwiseMetricInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1PointwiseMetricInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1PointwiseMetricSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Pointwise metric instance.
///
/// Usually one instance corresponds to one row in an evaluation dataset.
class GoogleCloudAiplatformV1PointwiseMetricInstance {
  /// Instance specified as a json string.
  ///
  /// String key-value pairs are expected in the json_instance to render
  /// PointwiseMetricSpec.instance_prompt_template.
  core.String? jsonInstance;

  GoogleCloudAiplatformV1PointwiseMetricInstance({
    this.jsonInstance,
  });

  GoogleCloudAiplatformV1PointwiseMetricInstance.fromJson(core.Map json_)
      : this(
          jsonInstance: json_['jsonInstance'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (jsonInstance != null) 'jsonInstance': jsonInstance!,
      };
}

/// Spec for pointwise metric result.
class GoogleCloudAiplatformV1PointwiseMetricResult {
  /// Explanation for pointwise metric score.
  ///
  /// Output only.
  core.String? explanation;

  /// Pointwise metric score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1PointwiseMetricResult({
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1PointwiseMetricResult.fromJson(core.Map json_)
      : this(
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for pointwise metric.
class GoogleCloudAiplatformV1PointwiseMetricSpec {
  /// Metric prompt template for pointwise metric.
  ///
  /// Required.
  core.String? metricPromptTemplate;

  /// System instructions for pointwise metric.
  ///
  /// Optional.
  core.String? systemInstruction;

  GoogleCloudAiplatformV1PointwiseMetricSpec({
    this.metricPromptTemplate,
    this.systemInstruction,
  });

  GoogleCloudAiplatformV1PointwiseMetricSpec.fromJson(core.Map json_)
      : this(
          metricPromptTemplate: json_['metricPromptTemplate'] as core.String?,
          systemInstruction: json_['systemInstruction'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metricPromptTemplate != null)
          'metricPromptTemplate': metricPromptTemplate!,
        if (systemInstruction != null) 'systemInstruction': systemInstruction!,
      };
}

/// Represents a network port in a container.
class GoogleCloudAiplatformV1Port {
  /// The number of the port to expose on the pod's IP address.
  ///
  /// Must be a valid port number, between 1 and 65535 inclusive.
  core.int? containerPort;

  GoogleCloudAiplatformV1Port({
    this.containerPort,
  });

  GoogleCloudAiplatformV1Port.fromJson(core.Map json_)
      : this(
          containerPort: json_['containerPort'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerPort != null) 'containerPort': containerPort!,
      };
}

/// Post startup script config.
class GoogleCloudAiplatformV1PostStartupScriptConfig {
  /// Post startup script to run after runtime is started.
  ///
  /// Optional.
  core.String? postStartupScript;

  /// Post startup script behavior that defines download and execution behavior.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED" : Unspecified post startup
  /// script behavior.
  /// - "RUN_ONCE" : Run post startup script after runtime is started.
  /// - "RUN_EVERY_START" : Run post startup script after runtime is stopped.
  /// - "DOWNLOAD_AND_RUN_EVERY_START" : Download and run post startup script
  /// every time runtime is started.
  core.String? postStartupScriptBehavior;

  /// Post startup script url to download.
  ///
  /// Example: https://bucket/script.sh
  ///
  /// Optional.
  core.String? postStartupScriptUrl;

  GoogleCloudAiplatformV1PostStartupScriptConfig({
    this.postStartupScript,
    this.postStartupScriptBehavior,
    this.postStartupScriptUrl,
  });

  GoogleCloudAiplatformV1PostStartupScriptConfig.fromJson(core.Map json_)
      : this(
          postStartupScript: json_['postStartupScript'] as core.String?,
          postStartupScriptBehavior:
              json_['postStartupScriptBehavior'] as core.String?,
          postStartupScriptUrl: json_['postStartupScriptUrl'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (postStartupScript != null) 'postStartupScript': postStartupScript!,
        if (postStartupScriptBehavior != null)
          'postStartupScriptBehavior': postStartupScriptBehavior!,
        if (postStartupScriptUrl != null)
          'postStartupScriptUrl': postStartupScriptUrl!,
      };
}

/// The configuration for the prebuilt speaker to use.
class GoogleCloudAiplatformV1PrebuiltVoiceConfig {
  /// The name of the preset voice to use.
  core.String? voiceName;

  GoogleCloudAiplatformV1PrebuiltVoiceConfig({
    this.voiceName,
  });

  GoogleCloudAiplatformV1PrebuiltVoiceConfig.fromJson(core.Map json_)
      : this(
          voiceName: json_['voiceName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (voiceName != null) 'voiceName': voiceName!,
      };
}

/// Assigns input data to training, validation, and test sets based on the value
/// of a provided key.
///
/// Supported only for tabular Datasets.
class GoogleCloudAiplatformV1PredefinedSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The value of the key (either the label's value or value in the column)
  /// must be one of {`training`, `validation`, `test`}, and it defines to which
  /// set the given piece of data is assigned. If for a piece of data the key is
  /// not present or has an invalid value, that piece is ignored by the
  /// pipeline.
  ///
  /// Required.
  core.String? key;

  GoogleCloudAiplatformV1PredefinedSplit({
    this.key,
  });

  GoogleCloudAiplatformV1PredefinedSplit.fromJson(core.Map json_)
      : this(
          key: json_['key'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
      };
}

/// Request message for PredictionService.PredictLongRunning.
class GoogleCloudAiplatformV1PredictLongRunningRequest {
  /// The instances that are the input to the prediction call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the prediction call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  GoogleCloudAiplatformV1PredictLongRunningRequest({
    this.instances,
    this.parameters,
  });

  GoogleCloudAiplatformV1PredictLongRunningRequest.fromJson(core.Map json_)
      : this(
          instances: json_.containsKey('instances')
              ? json_['instances'] as core.List
              : null,
          parameters: json_['parameters'],
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Request message for PredictionService.Predict.
class GoogleCloudAiplatformV1PredictRequest {
  /// The instances that are the input to the prediction call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the prediction call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  GoogleCloudAiplatformV1PredictRequest({
    this.instances,
    this.parameters,
  });

  GoogleCloudAiplatformV1PredictRequest.fromJson(core.Map json_)
      : this(
          instances: json_.containsKey('instances')
              ? json_['instances'] as core.List
              : null,
          parameters: json_['parameters'],
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Configuration for logging request-response to a BigQuery table.
class GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig {
  /// BigQuery table for logging.
  ///
  /// If only given a project, a new dataset will be created with name
  /// `logging__` where will be made BigQuery-dataset-name compatible (e.g. most
  /// special characters will become underscores). If no table name is given, a
  /// new table will be created with name `request_response_logging`
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// If logging is enabled or not.
  core.bool? enabled;

  /// Percentage of requests to be logged, expressed as a fraction in
  /// range(0,1\].
  core.double? samplingRate;

  GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig({
    this.bigqueryDestination,
    this.enabled,
    this.samplingRate,
  });

  GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig.fromJson(
      core.Map json_)
      : this(
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          enabled: json_['enabled'] as core.bool?,
          samplingRate: (json_['samplingRate'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (enabled != null) 'enabled': enabled!,
        if (samplingRate != null) 'samplingRate': samplingRate!,
      };
}

/// Response message for PredictionService.Predict.
class GoogleCloudAiplatformV1PredictResponse {
  /// ID of the Endpoint's DeployedModel that served this prediction.
  core.String? deployedModelId;

  /// Request-level metadata returned by the model.
  ///
  /// The metadata type will be dependent upon the model implementation.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? model;

  /// The display name of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? modelDisplayName;

  /// The version ID of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// The predictions that are the output of the predictions call.
  ///
  /// The schema of any single prediction may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's prediction_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  GoogleCloudAiplatformV1PredictResponse({
    this.deployedModelId,
    this.metadata,
    this.model,
    this.modelDisplayName,
    this.modelVersionId,
    this.predictions,
  });

  GoogleCloudAiplatformV1PredictResponse.fromJson(core.Map json_)
      : this(
          deployedModelId: json_['deployedModelId'] as core.String?,
          metadata: json_['metadata'],
          model: json_['model'] as core.String?,
          modelDisplayName: json_['modelDisplayName'] as core.String?,
          modelVersionId: json_['modelVersionId'] as core.String?,
          predictions: json_.containsKey('predictions')
              ? json_['predictions'] as core.List
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (metadata != null) 'metadata': metadata!,
        if (model != null) 'model': model!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
        if (modelVersionId != null) 'modelVersionId': modelVersionId!,
        if (predictions != null) 'predictions': predictions!,
      };
}

/// Contains the schemata used in Model's predictions and explanations via
/// PredictionService.Predict, PredictionService.Explain and BatchPredictionJob.
class GoogleCloudAiplatformV1PredictSchemata {
  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of a single instance, which are used in PredictRequest.instances,
  /// ExplainRequest.instances and BatchPredictionJob.input_config.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? instanceSchemaUri;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// parameters of prediction and explanation via PredictRequest.parameters,
  /// ExplainRequest.parameters and BatchPredictionJob.model_parameters.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// parameters are supported, then it is set to an empty string. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? parametersSchemaUri;

  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of a single prediction produced by this Model, which are returned via
  /// PredictResponse.predictions, ExplainResponse.explanations, and
  /// BatchPredictionJob.output_config.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? predictionSchemaUri;

  GoogleCloudAiplatformV1PredictSchemata({
    this.instanceSchemaUri,
    this.parametersSchemaUri,
    this.predictionSchemaUri,
  });

  GoogleCloudAiplatformV1PredictSchemata.fromJson(core.Map json_)
      : this(
          instanceSchemaUri: json_['instanceSchemaUri'] as core.String?,
          parametersSchemaUri: json_['parametersSchemaUri'] as core.String?,
          predictionSchemaUri: json_['predictionSchemaUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceSchemaUri != null) 'instanceSchemaUri': instanceSchemaUri!,
        if (parametersSchemaUri != null)
          'parametersSchemaUri': parametersSchemaUri!,
        if (predictionSchemaUri != null)
          'predictionSchemaUri': predictionSchemaUri!,
      };
}

/// Preset configuration for example-based explanations
class GoogleCloudAiplatformV1Presets {
  /// The modality of the uploaded model, which automatically configures the
  /// distance measurement and feature normalization for the underlying example
  /// index and queries.
  ///
  /// If your model does not precisely fit one of these types, it is okay to
  /// choose the closest type.
  /// Possible string values are:
  /// - "MODALITY_UNSPECIFIED" : Should not be set. Added as a recommended best
  /// practice for enums
  /// - "IMAGE" : IMAGE modality
  /// - "TEXT" : TEXT modality
  /// - "TABULAR" : TABULAR modality
  core.String? modality;

  /// Preset option controlling parameters for speed-precision trade-off when
  /// querying for examples.
  ///
  /// If omitted, defaults to `PRECISE`.
  /// Possible string values are:
  /// - "PRECISE" : More precise neighbors as a trade-off against slower
  /// response.
  /// - "FAST" : Faster response as a trade-off against less precise neighbors.
  core.String? query;

  GoogleCloudAiplatformV1Presets({
    this.modality,
    this.query,
  });

  GoogleCloudAiplatformV1Presets.fromJson(core.Map json_)
      : this(
          modality: json_['modality'] as core.String?,
          query: json_['query'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modality != null) 'modality': modality!,
        if (query != null) 'query': query!,
      };
}

/// PrivateEndpoints proto is used to provide paths for users to send requests
/// privately.
///
/// To send request via private service access, use predict_http_uri,
/// explain_http_uri or health_http_uri. To send request via private service
/// connect, use service_attachment.
class GoogleCloudAiplatformV1PrivateEndpoints {
  /// Http(s) path to send explain requests.
  ///
  /// Output only.
  core.String? explainHttpUri;

  /// Http(s) path to send health check requests.
  ///
  /// Output only.
  core.String? healthHttpUri;

  /// Http(s) path to send prediction requests.
  ///
  /// Output only.
  core.String? predictHttpUri;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1PrivateEndpoints({
    this.explainHttpUri,
    this.healthHttpUri,
    this.predictHttpUri,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1PrivateEndpoints.fromJson(core.Map json_)
      : this(
          explainHttpUri: json_['explainHttpUri'] as core.String?,
          healthHttpUri: json_['healthHttpUri'] as core.String?,
          predictHttpUri: json_['predictHttpUri'] as core.String?,
          serviceAttachment: json_['serviceAttachment'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explainHttpUri != null) 'explainHttpUri': explainHttpUri!,
        if (healthHttpUri != null) 'healthHttpUri': healthHttpUri!,
        if (predictHttpUri != null) 'predictHttpUri': predictHttpUri!,
        if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
      };
}

/// Represents configuration for private service connect.
class GoogleCloudAiplatformV1PrivateServiceConnectConfig {
  /// If true, expose the IndexEndpoint via private service connect.
  ///
  /// Required.
  core.bool? enablePrivateServiceConnect;

  /// A list of Projects from which the forwarding rule will target the service
  /// attachment.
  core.List<core.String>? projectAllowlist;

  /// The name of the generated service attachment resource.
  ///
  /// This is only populated if the endpoint is deployed with
  /// PrivateServiceConnect.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1PrivateServiceConnectConfig({
    this.enablePrivateServiceConnect,
    this.projectAllowlist,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1PrivateServiceConnectConfig.fromJson(core.Map json_)
      : this(
          enablePrivateServiceConnect:
              json_['enablePrivateServiceConnect'] as core.bool?,
          projectAllowlist: (json_['projectAllowlist'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          serviceAttachment: json_['serviceAttachment'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enablePrivateServiceConnect != null)
          'enablePrivateServiceConnect': enablePrivateServiceConnect!,
        if (projectAllowlist != null) 'projectAllowlist': projectAllowlist!,
        if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
      };
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
class GoogleCloudAiplatformV1Probe {
  /// ExecAction probes the health of a container by executing a command.
  GoogleCloudAiplatformV1ProbeExecAction? exec;

  /// Number of consecutive failures before the probe is considered failed.
  ///
  /// Defaults to 3. Minimum value is 1. Maps to Kubernetes probe argument
  /// 'failureThreshold'.
  core.int? failureThreshold;

  /// GrpcAction probes the health of a container by sending a gRPC request.
  GoogleCloudAiplatformV1ProbeGrpcAction? grpc;

  /// HttpGetAction probes the health of a container by sending an HTTP GET
  /// request.
  GoogleCloudAiplatformV1ProbeHttpGetAction? httpGet;

  /// Number of seconds to wait before starting the probe.
  ///
  /// Defaults to 0. Minimum value is 0. Maps to Kubernetes probe argument
  /// 'initialDelaySeconds'.
  core.int? initialDelaySeconds;

  /// How often (in seconds) to perform the probe.
  ///
  /// Default to 10 seconds. Minimum value is 1. Must be less than
  /// timeout_seconds. Maps to Kubernetes probe argument 'periodSeconds'.
  core.int? periodSeconds;

  /// Number of consecutive successes before the probe is considered successful.
  ///
  /// Defaults to 1. Minimum value is 1. Maps to Kubernetes probe argument
  /// 'successThreshold'.
  core.int? successThreshold;

  /// TcpSocketAction probes the health of a container by opening a TCP socket
  /// connection.
  GoogleCloudAiplatformV1ProbeTcpSocketAction? tcpSocket;

  /// Number of seconds after which the probe times out.
  ///
  /// Defaults to 1 second. Minimum value is 1. Must be greater or equal to
  /// period_seconds. Maps to Kubernetes probe argument 'timeoutSeconds'.
  core.int? timeoutSeconds;

  GoogleCloudAiplatformV1Probe({
    this.exec,
    this.failureThreshold,
    this.grpc,
    this.httpGet,
    this.initialDelaySeconds,
    this.periodSeconds,
    this.successThreshold,
    this.tcpSocket,
    this.timeoutSeconds,
  });

  GoogleCloudAiplatformV1Probe.fromJson(core.Map json_)
      : this(
          exec: json_.containsKey('exec')
              ? GoogleCloudAiplatformV1ProbeExecAction.fromJson(
                  json_['exec'] as core.Map<core.String, core.dynamic>)
              : null,
          failureThreshold: json_['failureThreshold'] as core.int?,
          grpc: json_.containsKey('grpc')
              ? GoogleCloudAiplatformV1ProbeGrpcAction.fromJson(
                  json_['grpc'] as core.Map<core.String, core.dynamic>)
              : null,
          httpGet: json_.containsKey('httpGet')
              ? GoogleCloudAiplatformV1ProbeHttpGetAction.fromJson(
                  json_['httpGet'] as core.Map<core.String, core.dynamic>)
              : null,
          initialDelaySeconds: json_['initialDelaySeconds'] as core.int?,
          periodSeconds: json_['periodSeconds'] as core.int?,
          successThreshold: json_['successThreshold'] as core.int?,
          tcpSocket: json_.containsKey('tcpSocket')
              ? GoogleCloudAiplatformV1ProbeTcpSocketAction.fromJson(
                  json_['tcpSocket'] as core.Map<core.String, core.dynamic>)
              : null,
          timeoutSeconds: json_['timeoutSeconds'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exec != null) 'exec': exec!,
        if (failureThreshold != null) 'failureThreshold': failureThreshold!,
        if (grpc != null) 'grpc': grpc!,
        if (httpGet != null) 'httpGet': httpGet!,
        if (initialDelaySeconds != null)
          'initialDelaySeconds': initialDelaySeconds!,
        if (periodSeconds != null) 'periodSeconds': periodSeconds!,
        if (successThreshold != null) 'successThreshold': successThreshold!,
        if (tcpSocket != null) 'tcpSocket': tcpSocket!,
        if (timeoutSeconds != null) 'timeoutSeconds': timeoutSeconds!,
      };
}

/// ExecAction specifies a command to execute.
typedef GoogleCloudAiplatformV1ProbeExecAction = $ExecAction;

/// GrpcAction checks the health of a container using a gRPC service.
class GoogleCloudAiplatformV1ProbeGrpcAction {
  /// Port number of the gRPC service.
  ///
  /// Number must be in the range 1 to 65535.
  core.int? port;

  /// Service is the name of the service to place in the gRPC HealthCheckRequest
  /// (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
  ///
  /// If this is not specified, the default behavior is defined by gRPC.
  core.String? service;

  GoogleCloudAiplatformV1ProbeGrpcAction({
    this.port,
    this.service,
  });

  GoogleCloudAiplatformV1ProbeGrpcAction.fromJson(core.Map json_)
      : this(
          port: json_['port'] as core.int?,
          service: json_['service'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (port != null) 'port': port!,
        if (service != null) 'service': service!,
      };
}

/// HttpGetAction describes an action based on HTTP Get requests.
class GoogleCloudAiplatformV1ProbeHttpGetAction {
  /// Host name to connect to, defaults to the model serving container's IP.
  ///
  /// You probably want to set "Host" in httpHeaders instead.
  core.String? host;

  /// Custom headers to set in the request.
  ///
  /// HTTP allows repeated headers.
  core.List<GoogleCloudAiplatformV1ProbeHttpHeader>? httpHeaders;

  /// Path to access on the HTTP server.
  core.String? path;

  /// Number of the port to access on the container.
  ///
  /// Number must be in the range 1 to 65535.
  core.int? port;

  /// Scheme to use for connecting to the host.
  ///
  /// Defaults to HTTP. Acceptable values are "HTTP" or "HTTPS".
  core.String? scheme;

  GoogleCloudAiplatformV1ProbeHttpGetAction({
    this.host,
    this.httpHeaders,
    this.path,
    this.port,
    this.scheme,
  });

  GoogleCloudAiplatformV1ProbeHttpGetAction.fromJson(core.Map json_)
      : this(
          host: json_['host'] as core.String?,
          httpHeaders: (json_['httpHeaders'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1ProbeHttpHeader.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          path: json_['path'] as core.String?,
          port: json_['port'] as core.int?,
          scheme: json_['scheme'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (httpHeaders != null) 'httpHeaders': httpHeaders!,
        if (path != null) 'path': path!,
        if (port != null) 'port': port!,
        if (scheme != null) 'scheme': scheme!,
      };
}

/// HttpHeader describes a custom header to be used in HTTP probes
class GoogleCloudAiplatformV1ProbeHttpHeader {
  /// The header field name.
  ///
  /// This will be canonicalized upon output, so case-variant names will be
  /// understood as the same header.
  core.String? name;

  /// The header field value
  core.String? value;

  GoogleCloudAiplatformV1ProbeHttpHeader({
    this.name,
    this.value,
  });

  GoogleCloudAiplatformV1ProbeHttpHeader.fromJson(core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          value: json_['value'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// TcpSocketAction probes the health of a container by opening a TCP socket
/// connection.
class GoogleCloudAiplatformV1ProbeTcpSocketAction {
  /// Optional: Host name to connect to, defaults to the model serving
  /// container's IP.
  core.String? host;

  /// Number of the port to access on the container.
  ///
  /// Number must be in the range 1 to 65535.
  core.int? port;

  GoogleCloudAiplatformV1ProbeTcpSocketAction({
    this.host,
    this.port,
  });

  GoogleCloudAiplatformV1ProbeTcpSocketAction.fromJson(core.Map json_)
      : this(
          host: json_['host'] as core.String?,
          port: json_['port'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (host != null) 'host': host!,
        if (port != null) 'port': port!,
      };
}

/// PscAutomatedEndpoints defines the output of the forwarding rule
/// automatically created by each PscAutomationConfig.
class GoogleCloudAiplatformV1PscAutomatedEndpoints {
  /// Ip Address created by the automated forwarding rule.
  core.String? matchAddress;

  /// Corresponding network in pscAutomationConfigs.
  core.String? network;

  /// Corresponding project_id in pscAutomationConfigs
  core.String? projectId;

  GoogleCloudAiplatformV1PscAutomatedEndpoints({
    this.matchAddress,
    this.network,
    this.projectId,
  });

  GoogleCloudAiplatformV1PscAutomatedEndpoints.fromJson(core.Map json_)
      : this(
          matchAddress: json_['matchAddress'] as core.String?,
          network: json_['network'] as core.String?,
          projectId: json_['projectId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (matchAddress != null) 'matchAddress': matchAddress!,
        if (network != null) 'network': network!,
        if (projectId != null) 'projectId': projectId!,
      };
}

/// A Model Garden Publisher Model.
class GoogleCloudAiplatformV1PublisherModel {
  /// Additional information about the model's Frameworks.
  ///
  /// Optional.
  core.List<core.String>? frameworks;

  /// Indicates the launch stage of the model.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "LAUNCH_STAGE_UNSPECIFIED" : The model launch stage is unspecified.
  /// - "EXPERIMENTAL" : Used to indicate the PublisherModel is at Experimental
  /// launch stage, available to a small set of customers.
  /// - "PRIVATE_PREVIEW" : Used to indicate the PublisherModel is at Private
  /// Preview launch stage, only available to a small set of customers, although
  /// a larger set of customers than an Experimental launch. Previews are the
  /// first launch stage used to get feedback from customers.
  /// - "PUBLIC_PREVIEW" : Used to indicate the PublisherModel is at Public
  /// Preview launch stage, available to all customers, although not supported
  /// for production workloads.
  /// - "GA" : Used to indicate the PublisherModel is at GA launch stage,
  /// available to all customers and ready for production workload.
  core.String? launchStage;

  /// The resource name of the PublisherModel.
  ///
  /// Output only.
  core.String? name;

  /// Indicates the open source category of the publisher model.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OPEN_SOURCE_CATEGORY_UNSPECIFIED" : The open source category is
  /// unspecified, which should not be used.
  /// - "PROPRIETARY" : Used to indicate the PublisherModel is not open sourced.
  /// - "GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" : Used to indicate the
  /// PublisherModel is a Google-owned open source model w/ Google checkpoint.
  /// - "THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" : Used to indicate the
  /// PublisherModel is a 3p-owned open source model w/ Google checkpoint.
  /// - "GOOGLE_OWNED_OSS" : Used to indicate the PublisherModel is a
  /// Google-owned pure open source model.
  /// - "THIRD_PARTY_OWNED_OSS" : Used to indicate the PublisherModel is a
  /// 3p-owned pure open source model.
  core.String? openSourceCategory;

  /// The schemata that describes formats of the PublisherModel's predictions
  /// and explanations as given and returned via PredictionService.Predict.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PredictSchemata? predictSchemata;

  /// Used to indicate this model has a publisher model and provide the template
  /// of the publisher model resource name.
  ///
  /// Optional. Output only. Immutable.
  core.String? publisherModelTemplate;

  /// Supported call-to-action options.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToAction? supportedActions;

  /// The version ID of the PublisherModel.
  ///
  /// A new version is committed when a new model version is uploaded under an
  /// existing model id. It is an auto-incrementing decimal number in string
  /// representation.
  ///
  /// Output only. Immutable.
  core.String? versionId;

  /// Indicates the state of the model version.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "VERSION_STATE_UNSPECIFIED" : The version state is unspecified.
  /// - "VERSION_STATE_STABLE" : Used to indicate the version is stable.
  /// - "VERSION_STATE_UNSTABLE" : Used to indicate the version is unstable.
  core.String? versionState;

  GoogleCloudAiplatformV1PublisherModel({
    this.frameworks,
    this.launchStage,
    this.name,
    this.openSourceCategory,
    this.predictSchemata,
    this.publisherModelTemplate,
    this.supportedActions,
    this.versionId,
    this.versionState,
  });

  GoogleCloudAiplatformV1PublisherModel.fromJson(core.Map json_)
      : this(
          frameworks: (json_['frameworks'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          launchStage: json_['launchStage'] as core.String?,
          name: json_['name'] as core.String?,
          openSourceCategory: json_['openSourceCategory'] as core.String?,
          predictSchemata: json_.containsKey('predictSchemata')
              ? GoogleCloudAiplatformV1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          publisherModelTemplate:
              json_['publisherModelTemplate'] as core.String?,
          supportedActions: json_.containsKey('supportedActions')
              ? GoogleCloudAiplatformV1PublisherModelCallToAction.fromJson(
                  json_['supportedActions']
                      as core.Map<core.String, core.dynamic>)
              : null,
          versionId: json_['versionId'] as core.String?,
          versionState: json_['versionState'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (frameworks != null) 'frameworks': frameworks!,
        if (launchStage != null) 'launchStage': launchStage!,
        if (name != null) 'name': name!,
        if (openSourceCategory != null)
          'openSourceCategory': openSourceCategory!,
        if (predictSchemata != null) 'predictSchemata': predictSchemata!,
        if (publisherModelTemplate != null)
          'publisherModelTemplate': publisherModelTemplate!,
        if (supportedActions != null) 'supportedActions': supportedActions!,
        if (versionId != null) 'versionId': versionId!,
        if (versionState != null) 'versionState': versionState!,
      };
}

/// Actions could take on this Publisher Model.
class GoogleCloudAiplatformV1PublisherModelCallToAction {
  /// Create application using the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      createApplication;

  /// Deploy the PublisherModel to Vertex Endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionDeploy? deploy;

  /// Deploy PublisherModel to Google Kubernetes Engine.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke? deployGke;

  /// Multiple setups to deploy the PublisherModel to Vertex Endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionDeployVertex?
      multiDeployVertex;

  /// Open evaluation pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openEvaluationPipeline;

  /// Open fine-tuning pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openFineTuningPipeline;

  /// Open fine-tuning pipelines of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines?
      openFineTuningPipelines;

  /// Open in Generation AI Studio.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openGenerationAiStudio;

  /// Open Genie / Playground.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openGenie;

  /// Open notebook of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openNotebook;

  /// Open notebooks of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks? openNotebooks;

  /// Open prompt-tuning pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openPromptTuningPipeline;

  /// Request for access.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      requestAccess;

  /// To view Rest API docs.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi? viewRestApi;

  GoogleCloudAiplatformV1PublisherModelCallToAction({
    this.createApplication,
    this.deploy,
    this.deployGke,
    this.multiDeployVertex,
    this.openEvaluationPipeline,
    this.openFineTuningPipeline,
    this.openFineTuningPipelines,
    this.openGenerationAiStudio,
    this.openGenie,
    this.openNotebook,
    this.openNotebooks,
    this.openPromptTuningPipeline,
    this.requestAccess,
    this.viewRestApi,
  });

  GoogleCloudAiplatformV1PublisherModelCallToAction.fromJson(core.Map json_)
      : this(
          createApplication: json_.containsKey('createApplication')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['createApplication']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deploy: json_.containsKey('deploy')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionDeploy
                  .fromJson(
                      json_['deploy'] as core.Map<core.String, core.dynamic>)
              : null,
          deployGke: json_.containsKey('deployGke')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke
                  .fromJson(
                      json_['deployGke'] as core.Map<core.String, core.dynamic>)
              : null,
          multiDeployVertex: json_.containsKey('multiDeployVertex')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionDeployVertex
                  .fromJson(json_['multiDeployVertex']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openEvaluationPipeline: json_.containsKey('openEvaluationPipeline')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openEvaluationPipeline']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openFineTuningPipeline: json_.containsKey('openFineTuningPipeline')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openFineTuningPipeline']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openFineTuningPipelines: json_.containsKey('openFineTuningPipelines')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines
                  .fromJson(json_['openFineTuningPipelines']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openGenerationAiStudio: json_.containsKey('openGenerationAiStudio')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openGenerationAiStudio']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openGenie: json_.containsKey('openGenie')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(
                      json_['openGenie'] as core.Map<core.String, core.dynamic>)
              : null,
          openNotebook: json_.containsKey('openNotebook')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openNotebook']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openNotebooks: json_.containsKey('openNotebooks')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks
                  .fromJson(json_['openNotebooks']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openPromptTuningPipeline: json_
                  .containsKey('openPromptTuningPipeline')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openPromptTuningPipeline']
                      as core.Map<core.String, core.dynamic>)
              : null,
          requestAccess: json_.containsKey('requestAccess')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['requestAccess']
                      as core.Map<core.String, core.dynamic>)
              : null,
          viewRestApi: json_.containsKey('viewRestApi')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi
                  .fromJson(json_['viewRestApi']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createApplication != null) 'createApplication': createApplication!,
        if (deploy != null) 'deploy': deploy!,
        if (deployGke != null) 'deployGke': deployGke!,
        if (multiDeployVertex != null) 'multiDeployVertex': multiDeployVertex!,
        if (openEvaluationPipeline != null)
          'openEvaluationPipeline': openEvaluationPipeline!,
        if (openFineTuningPipeline != null)
          'openFineTuningPipeline': openFineTuningPipeline!,
        if (openFineTuningPipelines != null)
          'openFineTuningPipelines': openFineTuningPipelines!,
        if (openGenerationAiStudio != null)
          'openGenerationAiStudio': openGenerationAiStudio!,
        if (openGenie != null) 'openGenie': openGenie!,
        if (openNotebook != null) 'openNotebook': openNotebook!,
        if (openNotebooks != null) 'openNotebooks': openNotebooks!,
        if (openPromptTuningPipeline != null)
          'openPromptTuningPipeline': openPromptTuningPipeline!,
        if (requestAccess != null) 'requestAccess': requestAccess!,
        if (viewRestApi != null) 'viewRestApi': viewRestApi!,
      };
}

/// Model metadata that is needed for UploadModel or DeployModel/CreateEndpoint
/// requests.
class GoogleCloudAiplatformV1PublisherModelCallToActionDeploy {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  ///
  /// Optional.
  core.String? artifactUri;

  /// A description of resources that to large degree are decided by Vertex AI,
  /// and require only a modest additional configuration.
  GoogleCloudAiplatformV1AutomaticResources? automaticResources;

  /// The specification of the container that is to be used when deploying this
  /// Model in Vertex AI.
  ///
  /// Not present for Large Models.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ModelContainerSpec? containerSpec;

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  GoogleCloudAiplatformV1DedicatedResources? dedicatedResources;

  /// Metadata information about this deployment config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionDeployDeployMetadata?
      deployMetadata;

  /// The name of the deploy task (e.g., "text to image generation").
  ///
  /// Optional.
  core.String? deployTaskName;

  /// Large model reference.
  ///
  /// When this is set, model_artifact_spec is not needed.
  ///
  /// Optional.
  GoogleCloudAiplatformV1LargeModelReference? largeModelReference;

  /// Default model display name.
  ///
  /// Optional.
  core.String? modelDisplayName;

  /// The signed URI for ephemeral Cloud Storage access to model artifact.
  ///
  /// Optional.
  core.String? publicArtifactUri;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  core.String? sharedResources;

  /// The title of the regional resource reference.
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelCallToActionDeploy({
    this.artifactUri,
    this.automaticResources,
    this.containerSpec,
    this.dedicatedResources,
    this.deployMetadata,
    this.deployTaskName,
    this.largeModelReference,
    this.modelDisplayName,
    this.publicArtifactUri,
    this.sharedResources,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionDeploy.fromJson(
      core.Map json_)
      : this(
          artifactUri: json_['artifactUri'] as core.String?,
          automaticResources: json_.containsKey('automaticResources')
              ? GoogleCloudAiplatformV1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deployMetadata: json_.containsKey('deployMetadata')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionDeployDeployMetadata
                  .fromJson(json_['deployMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deployTaskName: json_['deployTaskName'] as core.String?,
          largeModelReference: json_.containsKey('largeModelReference')
              ? GoogleCloudAiplatformV1LargeModelReference.fromJson(
                  json_['largeModelReference']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelDisplayName: json_['modelDisplayName'] as core.String?,
          publicArtifactUri: json_['publicArtifactUri'] as core.String?,
          sharedResources: json_['sharedResources'] as core.String?,
          title: json_['title'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactUri != null) 'artifactUri': artifactUri!,
        if (automaticResources != null)
          'automaticResources': automaticResources!,
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (deployMetadata != null) 'deployMetadata': deployMetadata!,
        if (deployTaskName != null) 'deployTaskName': deployTaskName!,
        if (largeModelReference != null)
          'largeModelReference': largeModelReference!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
        if (publicArtifactUri != null) 'publicArtifactUri': publicArtifactUri!,
        if (sharedResources != null) 'sharedResources': sharedResources!,
        if (title != null) 'title': title!,
      };
}

/// Metadata information about the deployment for managing deployment config.
class GoogleCloudAiplatformV1PublisherModelCallToActionDeployDeployMetadata {
  /// Labels for the deployment config.
  ///
  /// For managing deployment config like verifying, source of deployment
  /// config, etc.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Sample request for deployed endpoint.
  ///
  /// Optional.
  core.String? sampleRequest;

  GoogleCloudAiplatformV1PublisherModelCallToActionDeployDeployMetadata({
    this.labels,
    this.sampleRequest,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionDeployDeployMetadata.fromJson(
      core.Map json_)
      : this(
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          sampleRequest: json_['sampleRequest'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (labels != null) 'labels': labels!,
        if (sampleRequest != null) 'sampleRequest': sampleRequest!,
      };
}

/// Configurations for PublisherModel GKE deployment
class GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke {
  /// GKE deployment configuration in yaml format.
  ///
  /// Optional.
  core.List<core.String>? gkeYamlConfigs;

  GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke({
    this.gkeYamlConfigs,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionDeployGke.fromJson(
      core.Map json_)
      : this(
          gkeYamlConfigs: (json_['gkeYamlConfigs'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gkeYamlConfigs != null) 'gkeYamlConfigs': gkeYamlConfigs!,
      };
}

/// Multiple setups to deploy the PublisherModel.
class GoogleCloudAiplatformV1PublisherModelCallToActionDeployVertex {
  /// One click deployment configurations.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1PublisherModelCallToActionDeploy>?
      multiDeployVertex;

  GoogleCloudAiplatformV1PublisherModelCallToActionDeployVertex({
    this.multiDeployVertex,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionDeployVertex.fromJson(
      core.Map json_)
      : this(
          multiDeployVertex: (json_['multiDeployVertex'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PublisherModelCallToActionDeploy
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (multiDeployVertex != null) 'multiDeployVertex': multiDeployVertex!,
      };
}

/// Open fine tuning pipelines.
class GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines {
  /// Regional resource references to fine tuning pipelines.
  ///
  /// Required.
  core.List<
          GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences>?
      fineTuningPipelines;

  GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines({
    this.fineTuningPipelines,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionOpenFineTuningPipelines.fromJson(
      core.Map json_)
      : this(
          fineTuningPipelines: (json_['fineTuningPipelines'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fineTuningPipelines != null)
          'fineTuningPipelines': fineTuningPipelines!,
      };
}

/// Open notebooks.
class GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks {
  /// Regional resource references to notebooks.
  ///
  /// Required.
  core.List<
          GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences>?
      notebooks;

  GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks({
    this.notebooks,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionOpenNotebooks.fromJson(
      core.Map json_)
      : this(
          notebooks: (json_['notebooks'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (notebooks != null) 'notebooks': notebooks!,
      };
}

/// The regional resource name or the URI.
///
/// Key is region, e.g., us-central1, europe-west2, global, etc..
class GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences {
  /// Required.
  core.Map<core.String, GoogleCloudAiplatformV1PublisherModelResourceReference>?
      references;

  /// Description of the resource.
  ///
  /// Optional.
  core.String? resourceDescription;

  /// Title of the resource.
  ///
  /// Optional.
  core.String? resourceTitle;

  /// Use case (CUJ) of the resource.
  ///
  /// Optional.
  core.String? resourceUseCase;

  ///
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences({
    this.references,
    this.resourceDescription,
    this.resourceTitle,
    this.resourceUseCase,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences.fromJson(
      core.Map json_)
      : this(
          references:
              (json_['references'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1PublisherModelResourceReference.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          resourceDescription: json_['resourceDescription'] as core.String?,
          resourceTitle: json_['resourceTitle'] as core.String?,
          resourceUseCase: json_['resourceUseCase'] as core.String?,
          title: json_['title'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (references != null) 'references': references!,
        if (resourceDescription != null)
          'resourceDescription': resourceDescription!,
        if (resourceTitle != null) 'resourceTitle': resourceTitle!,
        if (resourceUseCase != null) 'resourceUseCase': resourceUseCase!,
        if (title != null) 'title': title!,
      };
}

/// Rest API docs.
class GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi {
  /// Required.
  core.List<GoogleCloudAiplatformV1PublisherModelDocumentation>? documentations;

  /// The title of the view rest API.
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi({
    this.documentations,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi.fromJson(
      core.Map json_)
      : this(
          documentations: (json_['documentations'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1PublisherModelDocumentation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          title: json_['title'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (documentations != null) 'documentations': documentations!,
        if (title != null) 'title': title!,
      };
}

/// A named piece of documentation.
class GoogleCloudAiplatformV1PublisherModelDocumentation {
  /// Content of this piece of document (in Markdown format).
  ///
  /// Required.
  core.String? content;

  /// E.g., OVERVIEW, USE CASES, DOCUMENTATION, SDK & SAMPLES, JAVA, NODE.JS,
  /// etc..
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelDocumentation({
    this.content,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelDocumentation.fromJson(core.Map json_)
      : this(
          content: json_['content'] as core.String?,
          title: json_['title'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (content != null) 'content': content!,
        if (title != null) 'title': title!,
      };
}

/// Reference to a resource.
class GoogleCloudAiplatformV1PublisherModelResourceReference {
  /// Description of the resource.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? description;

  /// The resource name of the Google Cloud resource.
  core.String? resourceName;

  /// The URI of the resource.
  core.String? uri;

  /// Use case (CUJ) of the resource.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? useCase;

  GoogleCloudAiplatformV1PublisherModelResourceReference({
    this.description,
    this.resourceName,
    this.uri,
    this.useCase,
  });

  GoogleCloudAiplatformV1PublisherModelResourceReference.fromJson(
      core.Map json_)
      : this(
          description: json_['description'] as core.String?,
          resourceName: json_['resourceName'] as core.String?,
          uri: json_['uri'] as core.String?,
          useCase: json_['useCase'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (resourceName != null) 'resourceName': resourceName!,
        if (uri != null) 'uri': uri!,
        if (useCase != null) 'useCase': useCase!,
      };
}

/// Request message for MetadataService.PurgeArtifacts.
class GoogleCloudAiplatformV1PurgeArtifactsRequest {
  /// A required filter matching the Artifacts to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Artifact
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  GoogleCloudAiplatformV1PurgeArtifactsRequest({
    this.filter,
    this.force,
  });

  GoogleCloudAiplatformV1PurgeArtifactsRequest.fromJson(core.Map json_)
      : this(
          filter: json_['filter'] as core.String?,
          force: json_['force'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (force != null) 'force': force!,
      };
}

/// Request message for MetadataService.PurgeContexts.
class GoogleCloudAiplatformV1PurgeContextsRequest {
  /// A required filter matching the Contexts to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Context
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  GoogleCloudAiplatformV1PurgeContextsRequest({
    this.filter,
    this.force,
  });

  GoogleCloudAiplatformV1PurgeContextsRequest.fromJson(core.Map json_)
      : this(
          filter: json_['filter'] as core.String?,
          force: json_['force'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (force != null) 'force': force!,
      };
}

/// Request message for MetadataService.PurgeExecutions.
class GoogleCloudAiplatformV1PurgeExecutionsRequest {
  /// A required filter matching the Executions to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Execution
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  GoogleCloudAiplatformV1PurgeExecutionsRequest({
    this.filter,
    this.force,
  });

  GoogleCloudAiplatformV1PurgeExecutionsRequest.fromJson(core.Map json_)
      : this(
          filter: json_['filter'] as core.String?,
          force: json_['force'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (force != null) 'force': force!,
      };
}

/// The spec of a Python packaged code.
class GoogleCloudAiplatformV1PythonPackageSpec {
  /// Command line arguments to be passed to the Python task.
  core.List<core.String>? args;

  /// Environment variables to be passed to the python module.
  ///
  /// Maximum limit is 100.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// The URI of a container image in Artifact Registry that will run the
  /// provided Python package.
  ///
  /// Vertex AI provides a wide range of executor images with pre-installed
  /// packages to meet users' various use cases. See the list of \[pre-built
  /// containers for
  /// training\](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// You must use an image from this list.
  ///
  /// Required.
  core.String? executorImageUri;

  /// The Google Cloud Storage location of the Python package files which are
  /// the training program and its dependent packages.
  ///
  /// The maximum number of package URIs is 100.
  ///
  /// Required.
  core.List<core.String>? packageUris;

  /// The Python module name to run after installing the packages.
  ///
  /// Required.
  core.String? pythonModule;

  GoogleCloudAiplatformV1PythonPackageSpec({
    this.args,
    this.env,
    this.executorImageUri,
    this.packageUris,
    this.pythonModule,
  });

  GoogleCloudAiplatformV1PythonPackageSpec.fromJson(core.Map json_)
      : this(
          args: (json_['args'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          env: (json_['env'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          executorImageUri: json_['executorImageUri'] as core.String?,
          packageUris: (json_['packageUris'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          pythonModule: json_['pythonModule'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (args != null) 'args': args!,
        if (env != null) 'env': env!,
        if (executorImageUri != null) 'executorImageUri': executorImageUri!,
        if (packageUris != null) 'packageUris': packageUris!,
        if (pythonModule != null) 'pythonModule': pythonModule!,
      };
}

/// Response message for QueryDeployedModels method.
class GoogleCloudAiplatformV1QueryDeployedModelsResponse {
  /// References to the DeployedModels that share the specified
  /// deploymentResourcePool.
  core.List<GoogleCloudAiplatformV1DeployedModelRef>? deployedModelRefs;

  /// DEPRECATED Use deployed_model_refs instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<GoogleCloudAiplatformV1DeployedModel>? deployedModels;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The total number of DeployedModels on this DeploymentResourcePool.
  core.int? totalDeployedModelCount;

  /// The total number of Endpoints that have DeployedModels on this
  /// DeploymentResourcePool.
  core.int? totalEndpointCount;

  GoogleCloudAiplatformV1QueryDeployedModelsResponse({
    this.deployedModelRefs,
    this.deployedModels,
    this.nextPageToken,
    this.totalDeployedModelCount,
    this.totalEndpointCount,
  });

  GoogleCloudAiplatformV1QueryDeployedModelsResponse.fromJson(core.Map json_)
      : this(
          deployedModelRefs: (json_['deployedModelRefs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DeployedModelRef.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          deployedModels: (json_['deployedModels'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DeployedModel.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
          totalDeployedModelCount:
              json_['totalDeployedModelCount'] as core.int?,
          totalEndpointCount: json_['totalEndpointCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelRefs != null) 'deployedModelRefs': deployedModelRefs!,
        if (deployedModels != null) 'deployedModels': deployedModels!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (totalDeployedModelCount != null)
          'totalDeployedModelCount': totalDeployedModelCount!,
        if (totalEndpointCount != null)
          'totalEndpointCount': totalEndpointCount!,
      };
}

/// Request message for ReasoningEngineExecutionService.Query.
class GoogleCloudAiplatformV1QueryReasoningEngineRequest {
  /// Class method to be used for the query.
  ///
  /// It is optional and defaults to "query" if unspecified.
  ///
  /// Optional.
  core.String? classMethod;

  /// Input content provided by users in JSON object format.
  ///
  /// Examples include text query, function calling parameters, media bytes,
  /// etc.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? input;

  GoogleCloudAiplatformV1QueryReasoningEngineRequest({
    this.classMethod,
    this.input,
  });

  GoogleCloudAiplatformV1QueryReasoningEngineRequest.fromJson(core.Map json_)
      : this(
          classMethod: json_['classMethod'] as core.String?,
          input: json_.containsKey('input')
              ? json_['input'] as core.Map<core.String, core.dynamic>
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (classMethod != null) 'classMethod': classMethod!,
        if (input != null) 'input': input!,
      };
}

/// Response message for ReasoningEngineExecutionService.Query
class GoogleCloudAiplatformV1QueryReasoningEngineResponse {
  /// Response provided by users in JSON object format.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? output;

  GoogleCloudAiplatformV1QueryReasoningEngineResponse({
    this.output,
  });

  GoogleCloudAiplatformV1QueryReasoningEngineResponse.fromJson(core.Map json_)
      : this(
          output: json_['output'],
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (output != null) 'output': output!,
      };
}

/// Input for question answering correctness metric.
class GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInput {
  /// Question answering correctness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInstance? instance;

  /// Spec for question answering correctness score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessSpec? metricSpec;

  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInput.fromJson(
      core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInstance
                  .fromJson(
                      json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1QuestionAnsweringCorrectnessSpec
                  .fromJson(json_['metricSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for question answering correctness instance.
typedef GoogleCloudAiplatformV1QuestionAnsweringCorrectnessInstance
    = $Instance02;

/// Spec for question answering correctness result.
class GoogleCloudAiplatformV1QuestionAnsweringCorrectnessResult {
  /// Confidence for question answering correctness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering correctness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Correctness score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessResult.fromJson(
      core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for question answering correctness metric.
class GoogleCloudAiplatformV1QuestionAnsweringCorrectnessSpec {
  /// Whether to use instance.reference to compute question answering
  /// correctness.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessSpec({
    this.useReference,
    this.version,
  });

  GoogleCloudAiplatformV1QuestionAnsweringCorrectnessSpec.fromJson(
      core.Map json_)
      : this(
          useReference: json_['useReference'] as core.bool?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useReference != null) 'useReference': useReference!,
        if (version != null) 'version': version!,
      };
}

/// Input for question answering helpfulness metric.
class GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInput {
  /// Question answering helpfulness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInstance? instance;

  /// Spec for question answering helpfulness score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessSpec? metricSpec;

  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInput.fromJson(
      core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInstance
                  .fromJson(
                      json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessSpec
                  .fromJson(json_['metricSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for question answering helpfulness instance.
typedef GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessInstance
    = $Instance02;

/// Spec for question answering helpfulness result.
class GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessResult {
  /// Confidence for question answering helpfulness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering helpfulness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Helpfulness score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessResult.fromJson(
      core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for question answering helpfulness metric.
class GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessSpec {
  /// Whether to use instance.reference to compute question answering
  /// helpfulness.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessSpec({
    this.useReference,
    this.version,
  });

  GoogleCloudAiplatformV1QuestionAnsweringHelpfulnessSpec.fromJson(
      core.Map json_)
      : this(
          useReference: json_['useReference'] as core.bool?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useReference != null) 'useReference': useReference!,
        if (version != null) 'version': version!,
      };
}

/// Input for question answering quality metric.
class GoogleCloudAiplatformV1QuestionAnsweringQualityInput {
  /// Question answering quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringQualityInstance? instance;

  /// Spec for question answering quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringQualitySpec? metricSpec;

  GoogleCloudAiplatformV1QuestionAnsweringQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1QuestionAnsweringQualityInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1QuestionAnsweringQualityInstance
                  .fromJson(
                      json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1QuestionAnsweringQualitySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for question answering quality instance.
class GoogleCloudAiplatformV1QuestionAnsweringQualityInstance {
  /// Text to answer the question.
  ///
  /// Required.
  core.String? context;

  /// Question Answering prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  GoogleCloudAiplatformV1QuestionAnsweringQualityInstance({
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  GoogleCloudAiplatformV1QuestionAnsweringQualityInstance.fromJson(
      core.Map json_)
      : this(
          context: json_['context'] as core.String?,
          instruction: json_['instruction'] as core.String?,
          prediction: json_['prediction'] as core.String?,
          reference: json_['reference'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (context != null) 'context': context!,
        if (instruction != null) 'instruction': instruction!,
        if (prediction != null) 'prediction': prediction!,
        if (reference != null) 'reference': reference!,
      };
}

/// Spec for question answering quality result.
class GoogleCloudAiplatformV1QuestionAnsweringQualityResult {
  /// Confidence for question answering quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Quality score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1QuestionAnsweringQualityResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1QuestionAnsweringQualityResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for question answering quality score metric.
typedef GoogleCloudAiplatformV1QuestionAnsweringQualitySpec
    = $QuestionAnsweringQualitySpec;

/// Input for question answering relevance metric.
class GoogleCloudAiplatformV1QuestionAnsweringRelevanceInput {
  /// Question answering relevance instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringRelevanceInstance? instance;

  /// Spec for question answering relevance score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1QuestionAnsweringRelevanceSpec? metricSpec;

  GoogleCloudAiplatformV1QuestionAnsweringRelevanceInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1QuestionAnsweringRelevanceInput.fromJson(
      core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1QuestionAnsweringRelevanceInstance
                  .fromJson(
                      json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1QuestionAnsweringRelevanceSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for question answering relevance instance.
typedef GoogleCloudAiplatformV1QuestionAnsweringRelevanceInstance = $Instance02;

/// Spec for question answering relevance result.
class GoogleCloudAiplatformV1QuestionAnsweringRelevanceResult {
  /// Confidence for question answering relevance score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for question answering relevance score.
  ///
  /// Output only.
  core.String? explanation;

  /// Question Answering Relevance score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1QuestionAnsweringRelevanceResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1QuestionAnsweringRelevanceResult.fromJson(
      core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for question answering relevance metric.
class GoogleCloudAiplatformV1QuestionAnsweringRelevanceSpec {
  /// Whether to use instance.reference to compute question answering relevance.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  GoogleCloudAiplatformV1QuestionAnsweringRelevanceSpec({
    this.useReference,
    this.version,
  });

  GoogleCloudAiplatformV1QuestionAnsweringRelevanceSpec.fromJson(core.Map json_)
      : this(
          useReference: json_['useReference'] as core.bool?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useReference != null) 'useReference': useReference!,
        if (version != null) 'version': version!,
      };
}

/// Relevant contexts for one query.
class GoogleCloudAiplatformV1RagContexts {
  /// All its contexts.
  core.List<GoogleCloudAiplatformV1RagContextsContext>? contexts;

  GoogleCloudAiplatformV1RagContexts({
    this.contexts,
  });

  GoogleCloudAiplatformV1RagContexts.fromJson(core.Map json_)
      : this(
          contexts: (json_['contexts'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1RagContextsContext.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contexts != null) 'contexts': contexts!,
      };
}

/// A context of the query.
class GoogleCloudAiplatformV1RagContextsContext {
  /// According to the underlying Vector DB and the selected metric type, the
  /// score can be either the distance or the similarity between the query and
  /// the context and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the context. The larger the distance, the
  /// less relevant the context is to the query. The range is \[0, 2\], while 0
  /// means the most relevant and 2 means the least relevant.
  core.double? score;

  /// The file display name.
  core.String? sourceDisplayName;

  /// If the file is imported from Cloud Storage or Google Drive, source_uri
  /// will be original file URI in Cloud Storage or Google Drive; if file is
  /// uploaded, source_uri will be file display name.
  core.String? sourceUri;

  /// The text chunk.
  core.String? text;

  GoogleCloudAiplatformV1RagContextsContext({
    this.score,
    this.sourceDisplayName,
    this.sourceUri,
    this.text,
  });

  GoogleCloudAiplatformV1RagContextsContext.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
          sourceDisplayName: json_['sourceDisplayName'] as core.String?,
          sourceUri: json_['sourceUri'] as core.String?,
          text: json_['text'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
        if (sourceDisplayName != null) 'sourceDisplayName': sourceDisplayName!,
        if (sourceUri != null) 'sourceUri': sourceUri!,
        if (text != null) 'text': text!,
      };
}

/// A RagCorpus is a RagFile container and a project can have multiple
/// RagCorpora.
class GoogleCloudAiplatformV1RagCorpus {
  /// RagCorpus state.
  ///
  /// Output only.
  GoogleCloudAiplatformV1CorpusStatus? corpusStatus;

  /// Timestamp when this RagCorpus was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the RagCorpus.
  ///
  /// Optional.
  core.String? description;

  /// The display name of the RagCorpus.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// The resource name of the RagCorpus.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this RagCorpus was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The config for the Vector DBs.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1RagVectorDbConfig? vectorDbConfig;

  GoogleCloudAiplatformV1RagCorpus({
    this.corpusStatus,
    this.createTime,
    this.description,
    this.displayName,
    this.name,
    this.updateTime,
    this.vectorDbConfig,
  });

  GoogleCloudAiplatformV1RagCorpus.fromJson(core.Map json_)
      : this(
          corpusStatus: json_.containsKey('corpusStatus')
              ? GoogleCloudAiplatformV1CorpusStatus.fromJson(
                  json_['corpusStatus'] as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          name: json_['name'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
          vectorDbConfig: json_.containsKey('vectorDbConfig')
              ? GoogleCloudAiplatformV1RagVectorDbConfig.fromJson(
                  json_['vectorDbConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (corpusStatus != null) 'corpusStatus': corpusStatus!,
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (vectorDbConfig != null) 'vectorDbConfig': vectorDbConfig!,
      };
}

/// Config for the embedding model to use for RAG.
class GoogleCloudAiplatformV1RagEmbeddingModelConfig {
  /// The Vertex AI Prediction Endpoint that either refers to a publisher model
  /// or an endpoint that is hosting a 1P fine-tuned text embedding model.
  ///
  /// Endpoints hosting non-1P fine-tuned text embedding models are currently
  /// not supported. This is used for dense vector search.
  GoogleCloudAiplatformV1RagEmbeddingModelConfigVertexPredictionEndpoint?
      vertexPredictionEndpoint;

  GoogleCloudAiplatformV1RagEmbeddingModelConfig({
    this.vertexPredictionEndpoint,
  });

  GoogleCloudAiplatformV1RagEmbeddingModelConfig.fromJson(core.Map json_)
      : this(
          vertexPredictionEndpoint: json_
                  .containsKey('vertexPredictionEndpoint')
              ? GoogleCloudAiplatformV1RagEmbeddingModelConfigVertexPredictionEndpoint
                  .fromJson(json_['vertexPredictionEndpoint']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (vertexPredictionEndpoint != null)
          'vertexPredictionEndpoint': vertexPredictionEndpoint!,
      };
}

/// Config representing a model hosted on Vertex Prediction Endpoint.
class GoogleCloudAiplatformV1RagEmbeddingModelConfigVertexPredictionEndpoint {
  /// The endpoint resource name.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// or `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Required.
  core.String? endpoint;

  /// The resource name of the model that is deployed on the endpoint.
  ///
  /// Present only when the endpoint is not a publisher model. Pattern:
  /// `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Output only.
  core.String? model;

  /// Version ID of the model that is deployed on the endpoint.
  ///
  /// Present only when the endpoint is not a publisher model.
  ///
  /// Output only.
  core.String? modelVersionId;

  GoogleCloudAiplatformV1RagEmbeddingModelConfigVertexPredictionEndpoint({
    this.endpoint,
    this.model,
    this.modelVersionId,
  });

  GoogleCloudAiplatformV1RagEmbeddingModelConfigVertexPredictionEndpoint.fromJson(
      core.Map json_)
      : this(
          endpoint: json_['endpoint'] as core.String?,
          model: json_['model'] as core.String?,
          modelVersionId: json_['modelVersionId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
        if (model != null) 'model': model!,
        if (modelVersionId != null) 'modelVersionId': modelVersionId!,
      };
}

/// A RagFile contains user data for chunking, embedding and indexing.
class GoogleCloudAiplatformV1RagFile {
  /// Timestamp when this RagFile was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the RagFile.
  ///
  /// Optional.
  core.String? description;

  /// The RagFile is encapsulated and uploaded in the UploadRagFile request.
  ///
  /// Output only.
  GoogleCloudAiplatformV1DirectUploadSource? directUploadSource;

  /// The display name of the RagFile.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// State of the RagFile.
  ///
  /// Output only.
  GoogleCloudAiplatformV1FileStatus? fileStatus;

  /// Google Cloud Storage location of the RagFile.
  ///
  /// It does not support wildcards in the Cloud Storage uri for now.
  ///
  /// Output only.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// Google Drive location.
  ///
  /// Supports importing individual files as well as Google Drive folders.
  ///
  /// Output only.
  GoogleCloudAiplatformV1GoogleDriveSource? googleDriveSource;

  /// The RagFile is imported from a Jira query.
  GoogleCloudAiplatformV1JiraSource? jiraSource;

  /// The resource name of the RagFile.
  ///
  /// Output only.
  core.String? name;

  /// The RagFile is imported from a SharePoint source.
  GoogleCloudAiplatformV1SharePointSources? sharePointSources;

  /// The RagFile is imported from a Slack channel.
  GoogleCloudAiplatformV1SlackSource? slackSource;

  /// Timestamp when this RagFile was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1RagFile({
    this.createTime,
    this.description,
    this.directUploadSource,
    this.displayName,
    this.fileStatus,
    this.gcsSource,
    this.googleDriveSource,
    this.jiraSource,
    this.name,
    this.sharePointSources,
    this.slackSource,
    this.updateTime,
  });

  GoogleCloudAiplatformV1RagFile.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          directUploadSource: json_.containsKey('directUploadSource')
              ? GoogleCloudAiplatformV1DirectUploadSource.fromJson(
                  json_['directUploadSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          displayName: json_['displayName'] as core.String?,
          fileStatus: json_.containsKey('fileStatus')
              ? GoogleCloudAiplatformV1FileStatus.fromJson(
                  json_['fileStatus'] as core.Map<core.String, core.dynamic>)
              : null,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          googleDriveSource: json_.containsKey('googleDriveSource')
              ? GoogleCloudAiplatformV1GoogleDriveSource.fromJson(
                  json_['googleDriveSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          jiraSource: json_.containsKey('jiraSource')
              ? GoogleCloudAiplatformV1JiraSource.fromJson(
                  json_['jiraSource'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          sharePointSources: json_.containsKey('sharePointSources')
              ? GoogleCloudAiplatformV1SharePointSources.fromJson(
                  json_['sharePointSources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          slackSource: json_.containsKey('slackSource')
              ? GoogleCloudAiplatformV1SlackSource.fromJson(
                  json_['slackSource'] as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (directUploadSource != null)
          'directUploadSource': directUploadSource!,
        if (displayName != null) 'displayName': displayName!,
        if (fileStatus != null) 'fileStatus': fileStatus!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (googleDriveSource != null) 'googleDriveSource': googleDriveSource!,
        if (jiraSource != null) 'jiraSource': jiraSource!,
        if (name != null) 'name': name!,
        if (sharePointSources != null) 'sharePointSources': sharePointSources!,
        if (slackSource != null) 'slackSource': slackSource!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Specifies the size and overlap of chunks for RagFiles.
class GoogleCloudAiplatformV1RagFileChunkingConfig {
  /// Specifies the fixed length chunking config.
  GoogleCloudAiplatformV1RagFileChunkingConfigFixedLengthChunking?
      fixedLengthChunking;

  GoogleCloudAiplatformV1RagFileChunkingConfig({
    this.fixedLengthChunking,
  });

  GoogleCloudAiplatformV1RagFileChunkingConfig.fromJson(core.Map json_)
      : this(
          fixedLengthChunking: json_.containsKey('fixedLengthChunking')
              ? GoogleCloudAiplatformV1RagFileChunkingConfigFixedLengthChunking
                  .fromJson(json_['fixedLengthChunking']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fixedLengthChunking != null)
          'fixedLengthChunking': fixedLengthChunking!,
      };
}

/// Specifies the fixed length chunking config.
class GoogleCloudAiplatformV1RagFileChunkingConfigFixedLengthChunking {
  /// The overlap between chunks.
  core.int? chunkOverlap;

  /// The size of the chunks.
  core.int? chunkSize;

  GoogleCloudAiplatformV1RagFileChunkingConfigFixedLengthChunking({
    this.chunkOverlap,
    this.chunkSize,
  });

  GoogleCloudAiplatformV1RagFileChunkingConfigFixedLengthChunking.fromJson(
      core.Map json_)
      : this(
          chunkOverlap: json_['chunkOverlap'] as core.int?,
          chunkSize: json_['chunkSize'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (chunkOverlap != null) 'chunkOverlap': chunkOverlap!,
        if (chunkSize != null) 'chunkSize': chunkSize!,
      };
}

/// Specifies the transformation config for RagFiles.
class GoogleCloudAiplatformV1RagFileTransformationConfig {
  /// Specifies the chunking config for RagFiles.
  GoogleCloudAiplatformV1RagFileChunkingConfig? ragFileChunkingConfig;

  GoogleCloudAiplatformV1RagFileTransformationConfig({
    this.ragFileChunkingConfig,
  });

  GoogleCloudAiplatformV1RagFileTransformationConfig.fromJson(core.Map json_)
      : this(
          ragFileChunkingConfig: json_.containsKey('ragFileChunkingConfig')
              ? GoogleCloudAiplatformV1RagFileChunkingConfig.fromJson(
                  json_['ragFileChunkingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragFileChunkingConfig != null)
          'ragFileChunkingConfig': ragFileChunkingConfig!,
      };
}

/// A query to retrieve relevant contexts.
class GoogleCloudAiplatformV1RagQuery {
  /// The retrieval config for the query.
  ///
  /// Optional.
  GoogleCloudAiplatformV1RagRetrievalConfig? ragRetrievalConfig;

  /// The query in text format to get relevant contexts.
  ///
  /// Optional.
  core.String? text;

  GoogleCloudAiplatformV1RagQuery({
    this.ragRetrievalConfig,
    this.text,
  });

  GoogleCloudAiplatformV1RagQuery.fromJson(core.Map json_)
      : this(
          ragRetrievalConfig: json_.containsKey('ragRetrievalConfig')
              ? GoogleCloudAiplatformV1RagRetrievalConfig.fromJson(
                  json_['ragRetrievalConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          text: json_['text'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragRetrievalConfig != null)
          'ragRetrievalConfig': ragRetrievalConfig!,
        if (text != null) 'text': text!,
      };
}

/// Specifies the context retrieval config.
class GoogleCloudAiplatformV1RagRetrievalConfig {
  /// Config for filters.
  ///
  /// Optional.
  GoogleCloudAiplatformV1RagRetrievalConfigFilter? filter;

  /// The number of contexts to retrieve.
  ///
  /// Optional.
  core.int? topK;

  GoogleCloudAiplatformV1RagRetrievalConfig({
    this.filter,
    this.topK,
  });

  GoogleCloudAiplatformV1RagRetrievalConfig.fromJson(core.Map json_)
      : this(
          filter: json_.containsKey('filter')
              ? GoogleCloudAiplatformV1RagRetrievalConfigFilter.fromJson(
                  json_['filter'] as core.Map<core.String, core.dynamic>)
              : null,
          topK: json_['topK'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (topK != null) 'topK': topK!,
      };
}

/// Config for filters.
class GoogleCloudAiplatformV1RagRetrievalConfigFilter {
  /// String for metadata filtering.
  ///
  /// Optional.
  core.String? metadataFilter;

  /// Only returns contexts with vector distance smaller than the threshold.
  ///
  /// Optional.
  core.double? vectorDistanceThreshold;

  /// Only returns contexts with vector similarity larger than the threshold.
  ///
  /// Optional.
  core.double? vectorSimilarityThreshold;

  GoogleCloudAiplatformV1RagRetrievalConfigFilter({
    this.metadataFilter,
    this.vectorDistanceThreshold,
    this.vectorSimilarityThreshold,
  });

  GoogleCloudAiplatformV1RagRetrievalConfigFilter.fromJson(core.Map json_)
      : this(
          metadataFilter: json_['metadataFilter'] as core.String?,
          vectorDistanceThreshold:
              (json_['vectorDistanceThreshold'] as core.num?)?.toDouble(),
          vectorSimilarityThreshold:
              (json_['vectorSimilarityThreshold'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metadataFilter != null) 'metadataFilter': metadataFilter!,
        if (vectorDistanceThreshold != null)
          'vectorDistanceThreshold': vectorDistanceThreshold!,
        if (vectorSimilarityThreshold != null)
          'vectorSimilarityThreshold': vectorSimilarityThreshold!,
      };
}

/// Config for the Vector DB to use for RAG.
class GoogleCloudAiplatformV1RagVectorDbConfig {
  /// Authentication config for the chosen Vector DB.
  GoogleCloudAiplatformV1ApiAuth? apiAuth;

  /// The config for the Pinecone.
  GoogleCloudAiplatformV1RagVectorDbConfigPinecone? pinecone;

  /// The embedding model config of the Vector DB.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1RagEmbeddingModelConfig? ragEmbeddingModelConfig;

  /// The config for the RAG-managed Vector DB.
  GoogleCloudAiplatformV1RagVectorDbConfigRagManagedDb? ragManagedDb;

  /// The config for the Vertex Vector Search.
  GoogleCloudAiplatformV1RagVectorDbConfigVertexVectorSearch?
      vertexVectorSearch;

  GoogleCloudAiplatformV1RagVectorDbConfig({
    this.apiAuth,
    this.pinecone,
    this.ragEmbeddingModelConfig,
    this.ragManagedDb,
    this.vertexVectorSearch,
  });

  GoogleCloudAiplatformV1RagVectorDbConfig.fromJson(core.Map json_)
      : this(
          apiAuth: json_.containsKey('apiAuth')
              ? GoogleCloudAiplatformV1ApiAuth.fromJson(
                  json_['apiAuth'] as core.Map<core.String, core.dynamic>)
              : null,
          pinecone: json_.containsKey('pinecone')
              ? GoogleCloudAiplatformV1RagVectorDbConfigPinecone.fromJson(
                  json_['pinecone'] as core.Map<core.String, core.dynamic>)
              : null,
          ragEmbeddingModelConfig: json_.containsKey('ragEmbeddingModelConfig')
              ? GoogleCloudAiplatformV1RagEmbeddingModelConfig.fromJson(
                  json_['ragEmbeddingModelConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          ragManagedDb: json_.containsKey('ragManagedDb')
              ? GoogleCloudAiplatformV1RagVectorDbConfigRagManagedDb.fromJson(
                  json_['ragManagedDb'] as core.Map<core.String, core.dynamic>)
              : null,
          vertexVectorSearch: json_.containsKey('vertexVectorSearch')
              ? GoogleCloudAiplatformV1RagVectorDbConfigVertexVectorSearch
                  .fromJson(json_['vertexVectorSearch']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (apiAuth != null) 'apiAuth': apiAuth!,
        if (pinecone != null) 'pinecone': pinecone!,
        if (ragEmbeddingModelConfig != null)
          'ragEmbeddingModelConfig': ragEmbeddingModelConfig!,
        if (ragManagedDb != null) 'ragManagedDb': ragManagedDb!,
        if (vertexVectorSearch != null)
          'vertexVectorSearch': vertexVectorSearch!,
      };
}

/// The config for the Pinecone.
class GoogleCloudAiplatformV1RagVectorDbConfigPinecone {
  /// Pinecone index name.
  ///
  /// This value cannot be changed after it's set.
  core.String? indexName;

  GoogleCloudAiplatformV1RagVectorDbConfigPinecone({
    this.indexName,
  });

  GoogleCloudAiplatformV1RagVectorDbConfigPinecone.fromJson(core.Map json_)
      : this(
          indexName: json_['indexName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (indexName != null) 'indexName': indexName!,
      };
}

/// The config for the default RAG-managed Vector DB.
typedef GoogleCloudAiplatformV1RagVectorDbConfigRagManagedDb = $Empty;

/// The config for the Vertex Vector Search.
class GoogleCloudAiplatformV1RagVectorDbConfigVertexVectorSearch {
  /// The resource name of the Index.
  ///
  /// Format: `projects/{project}/locations/{location}/indexes/{index}`
  core.String? index;

  /// The resource name of the Index Endpoint.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  core.String? indexEndpoint;

  GoogleCloudAiplatformV1RagVectorDbConfigVertexVectorSearch({
    this.index,
    this.indexEndpoint,
  });

  GoogleCloudAiplatformV1RagVectorDbConfigVertexVectorSearch.fromJson(
      core.Map json_)
      : this(
          index: json_['index'] as core.String?,
          indexEndpoint: json_['indexEndpoint'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (index != null) 'index': index!,
        if (indexEndpoint != null) 'indexEndpoint': indexEndpoint!,
      };
}

/// Request message for PredictionService.RawPredict.
class GoogleCloudAiplatformV1RawPredictRequest {
  /// The prediction input.
  ///
  /// Supports HTTP headers and arbitrary data payload. A DeployedModel may have
  /// an upper limit on the number of instances it supports per request. When
  /// this limit it is exceeded for an AutoML model, the RawPredict method
  /// returns an error. When this limit is exceeded for a custom-trained model,
  /// the behavior varies depending on the model. You can specify the schema for
  /// each instance in the predict_schemata.instance_schema_uri field when you
  /// create a Model. This schema applies when you deploy the `Model` as a
  /// `DeployedModel` to an Endpoint and use the `RawPredict` method.
  GoogleApiHttpBody? httpBody;

  GoogleCloudAiplatformV1RawPredictRequest({
    this.httpBody,
  });

  GoogleCloudAiplatformV1RawPredictRequest.fromJson(core.Map json_)
      : this(
          httpBody: json_.containsKey('httpBody')
              ? GoogleApiHttpBody.fromJson(
                  json_['httpBody'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (httpBody != null) 'httpBody': httpBody!,
      };
}

/// Configuration for the Ray OSS Logs.
class GoogleCloudAiplatformV1RayLogsSpec {
  /// Flag to disable the export of Ray OSS logs to Cloud Logging.
  ///
  /// Optional.
  core.bool? disabled;

  GoogleCloudAiplatformV1RayLogsSpec({
    this.disabled,
  });

  GoogleCloudAiplatformV1RayLogsSpec.fromJson(core.Map json_)
      : this(
          disabled: json_['disabled'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disabled != null) 'disabled': disabled!,
      };
}

/// Configuration for the Ray metrics.
class GoogleCloudAiplatformV1RayMetricSpec {
  /// Flag to disable the Ray metrics collection.
  ///
  /// Optional.
  core.bool? disabled;

  GoogleCloudAiplatformV1RayMetricSpec({
    this.disabled,
  });

  GoogleCloudAiplatformV1RayMetricSpec.fromJson(core.Map json_)
      : this(
          disabled: json_['disabled'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disabled != null) 'disabled': disabled!,
      };
}

/// Configuration information for the Ray cluster.
///
/// For experimental launch, Ray cluster creation and Persistent cluster
/// creation are 1:1 mapping: We will provision all the nodes within the
/// Persistent cluster as Ray nodes.
class GoogleCloudAiplatformV1RaySpec {
  /// This will be used to indicate which resource pool will serve as the Ray
  /// head node(the first node within that pool).
  ///
  /// Will use the machine from the first workerpool as the head node by default
  /// if this field isn't set.
  ///
  /// Optional.
  core.String? headNodeResourcePoolId;

  /// Default image for user to choose a preferred ML framework (for example,
  /// TensorFlow or Pytorch) by choosing from
  /// [Vertex prebuilt images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  ///
  /// Either this or the resource_pool_images is required. Use this field if you
  /// need all the resource pools to have the same Ray image. Otherwise, use the
  /// {@code resource_pool_images} field.
  ///
  /// Optional.
  core.String? imageUri;

  /// OSS Ray logging configurations.
  ///
  /// Optional.
  GoogleCloudAiplatformV1RayLogsSpec? rayLogsSpec;

  /// Ray metrics configurations.
  ///
  /// Optional.
  GoogleCloudAiplatformV1RayMetricSpec? rayMetricSpec;

  /// Required if image_uri isn't set.
  ///
  /// A map of resource_pool_id to prebuild Ray image if user need to use
  /// different images for different head/worker pools. This map needs to cover
  /// all the resource pool ids. Example: { "ray_head_node_pool": "head image"
  /// "ray_worker_node_pool1": "worker image" "ray_worker_node_pool2": "another
  /// worker image" }
  ///
  /// Optional.
  core.Map<core.String, core.String>? resourcePoolImages;

  GoogleCloudAiplatformV1RaySpec({
    this.headNodeResourcePoolId,
    this.imageUri,
    this.rayLogsSpec,
    this.rayMetricSpec,
    this.resourcePoolImages,
  });

  GoogleCloudAiplatformV1RaySpec.fromJson(core.Map json_)
      : this(
          headNodeResourcePoolId:
              json_['headNodeResourcePoolId'] as core.String?,
          imageUri: json_['imageUri'] as core.String?,
          rayLogsSpec: json_.containsKey('rayLogsSpec')
              ? GoogleCloudAiplatformV1RayLogsSpec.fromJson(
                  json_['rayLogsSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          rayMetricSpec: json_.containsKey('rayMetricSpec')
              ? GoogleCloudAiplatformV1RayMetricSpec.fromJson(
                  json_['rayMetricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          resourcePoolImages: (json_['resourcePoolImages']
                  as core.Map<core.String, core.dynamic>?)
              ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (headNodeResourcePoolId != null)
          'headNodeResourcePoolId': headNodeResourcePoolId!,
        if (imageUri != null) 'imageUri': imageUri!,
        if (rayLogsSpec != null) 'rayLogsSpec': rayLogsSpec!,
        if (rayMetricSpec != null) 'rayMetricSpec': rayMetricSpec!,
        if (resourcePoolImages != null)
          'resourcePoolImages': resourcePoolImages!,
      };
}

/// Request message for FeaturestoreOnlineServingService.ReadFeatureValues.
class GoogleCloudAiplatformV1ReadFeatureValuesRequest {
  /// ID for a specific entity.
  ///
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an entity ID could be `user_123`.
  ///
  /// Required.
  core.String? entityId;

  /// Selector choosing Features of the target EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  GoogleCloudAiplatformV1ReadFeatureValuesRequest({
    this.entityId,
    this.featureSelector,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          entityId: json_['entityId'] as core.String?,
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityId != null) 'entityId': entityId!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
      };
}

/// Response message for FeaturestoreOnlineServingService.ReadFeatureValues.
class GoogleCloudAiplatformV1ReadFeatureValuesResponse {
  /// Entity view with Feature values.
  ///
  /// This may be the entity in the Featurestore if values for all Features were
  /// requested, or a projection of the entity in the Featurestore if values for
  /// only some Features were requested.
  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView? entityView;

  /// Response header.
  GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader? header;

  GoogleCloudAiplatformV1ReadFeatureValuesResponse({
    this.entityView,
    this.header,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponse.fromJson(core.Map json_)
      : this(
          entityView: json_.containsKey('entityView')
              ? GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView
                  .fromJson(json_['entityView']
                      as core.Map<core.String, core.dynamic>)
              : null,
          header: json_.containsKey('header')
              ? GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader.fromJson(
                  json_['header'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityView != null) 'entityView': entityView!,
        if (header != null) 'header': header!,
      };
}

/// Entity view with Feature values.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView {
  /// Each piece of data holds the k requested values for one requested Feature.
  ///
  /// If no values for the requested Feature exist, the corresponding cell will
  /// be empty. This has the same size and is in the same order as the features
  /// from the header ReadFeatureValuesResponse.header.
  core.List<GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData>?
      data;

  /// ID of the requested entity.
  core.String? entityId;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView({
    this.data,
    this.entityId,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView.fromJson(
      core.Map json_)
      : this(
          data: (json_['data'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          entityId: json_['entityId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (data != null) 'data': data!,
        if (entityId != null) 'entityId': entityId!,
      };
}

/// Container to hold value(s), successive in time, for one Feature from the
/// request.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData {
  /// Feature value if a single value is requested.
  GoogleCloudAiplatformV1FeatureValue? value;

  /// Feature values list if values, successive in time, are requested.
  ///
  /// If the requested number of values is greater than the number of existing
  /// Feature values, nonexistent values are omitted instead of being returned
  /// as empty.
  GoogleCloudAiplatformV1FeatureValueList? values;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData({
    this.value,
    this.values,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData.fromJson(
      core.Map json_)
      : this(
          value: json_.containsKey('value')
              ? GoogleCloudAiplatformV1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>)
              : null,
          values: json_.containsKey('values')
              ? GoogleCloudAiplatformV1FeatureValueList.fromJson(
                  json_['values'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
        if (values != null) 'values': values!,
      };
}

/// Metadata for requested Features.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor {
  /// Feature ID.
  core.String? id;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor({
    this.id,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor.fromJson(
      core.Map json_)
      : this(
          id: json_['id'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
      };
}

/// Response header with metadata for the requested
/// ReadFeatureValuesRequest.entity_type and Features.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader {
  /// The resource name of the EntityType from the ReadFeatureValuesRequest.
  ///
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  core.String? entityType;

  /// List of Feature metadata corresponding to each piece of
  /// ReadFeatureValuesResponse.EntityView.data.
  core.List<GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor>?
      featureDescriptors;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader({
    this.entityType,
    this.featureDescriptors,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader.fromJson(
      core.Map json_)
      : this(
          entityType: json_['entityType'] as core.String?,
          featureDescriptors: (json_['featureDescriptors'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityType != null) 'entityType': entityType!,
        if (featureDescriptors != null)
          'featureDescriptors': featureDescriptors!,
      };
}

/// The request message for MatchService.ReadIndexDatapoints.
class GoogleCloudAiplatformV1ReadIndexDatapointsRequest {
  /// The ID of the DeployedIndex that will serve the request.
  core.String? deployedIndexId;

  /// IDs of the datapoints to be searched for.
  core.List<core.String>? ids;

  GoogleCloudAiplatformV1ReadIndexDatapointsRequest({
    this.deployedIndexId,
    this.ids,
  });

  GoogleCloudAiplatformV1ReadIndexDatapointsRequest.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_['deployedIndexId'] as core.String?,
          ids: (json_['ids'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
        if (ids != null) 'ids': ids!,
      };
}

/// The response message for MatchService.ReadIndexDatapoints.
class GoogleCloudAiplatformV1ReadIndexDatapointsResponse {
  /// The result list of datapoints.
  core.List<GoogleCloudAiplatformV1IndexDatapoint>? datapoints;

  GoogleCloudAiplatformV1ReadIndexDatapointsResponse({
    this.datapoints,
  });

  GoogleCloudAiplatformV1ReadIndexDatapointsResponse.fromJson(core.Map json_)
      : this(
          datapoints: (json_['datapoints'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapoints != null) 'datapoints': datapoints!,
      };
}

/// Response message for TensorboardService.ReadTensorboardBlobData.
class GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse {
  /// Blob messages containing blob bytes.
  core.List<GoogleCloudAiplatformV1TensorboardBlob>? blobs;

  GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse({
    this.blobs,
  });

  GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse.fromJson(
      core.Map json_)
      : this(
          blobs: (json_['blobs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TensorboardBlob.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blobs != null) 'blobs': blobs!,
      };
}

/// Response message for TensorboardService.ReadTensorboardSize.
class GoogleCloudAiplatformV1ReadTensorboardSizeResponse {
  /// Payload storage size for the TensorBoard
  core.String? storageSizeByte;

  GoogleCloudAiplatformV1ReadTensorboardSizeResponse({
    this.storageSizeByte,
  });

  GoogleCloudAiplatformV1ReadTensorboardSizeResponse.fromJson(core.Map json_)
      : this(
          storageSizeByte: json_['storageSizeByte'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (storageSizeByte != null) 'storageSizeByte': storageSizeByte!,
      };
}

/// Response message for TensorboardService.ReadTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse {
  /// The returned time series data.
  GoogleCloudAiplatformV1TimeSeriesData? timeSeriesData;

  GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse({
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse.fromJson(
      core.Map json_)
      : this(
          timeSeriesData: json_.containsKey('timeSeriesData')
              ? GoogleCloudAiplatformV1TimeSeriesData.fromJson(
                  json_['timeSeriesData']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
      };
}

/// Response message for TensorboardService.ReadTensorboardUsage.
class GoogleCloudAiplatformV1ReadTensorboardUsageResponse {
  /// Maps year-month (YYYYMM) string to per month usage data.
  core.Map<core.String,
          GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData>?
      monthlyUsageData;

  GoogleCloudAiplatformV1ReadTensorboardUsageResponse({
    this.monthlyUsageData,
  });

  GoogleCloudAiplatformV1ReadTensorboardUsageResponse.fromJson(core.Map json_)
      : this(
          monthlyUsageData: (json_['monthlyUsageData']
                  as core.Map<core.String, core.dynamic>?)
              ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData
                  .fromJson(value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (monthlyUsageData != null) 'monthlyUsageData': monthlyUsageData!,
      };
}

/// Per month usage data
class GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData {
  /// Usage data for each user in the given month.
  core.List<
          GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData>?
      userUsageData;

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData({
    this.userUsageData,
  });

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData.fromJson(
      core.Map json_)
      : this(
          userUsageData: (json_['userUsageData'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (userUsageData != null) 'userUsageData': userUsageData!,
      };
}

/// Per user usage data.
class GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData {
  /// User's username
  core.String? username;

  /// Number of times the user has read data within the Tensorboard.
  core.String? viewCount;

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData({
    this.username,
    this.viewCount,
  });

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData.fromJson(
      core.Map json_)
      : this(
          username: json_['username'] as core.String?,
          viewCount: json_['viewCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (username != null) 'username': username!,
        if (viewCount != null) 'viewCount': viewCount!,
      };
}

/// ReasoningEngine provides a customizable runtime for models to determine
/// which actions to take and in which order.
class GoogleCloudAiplatformV1ReasoningEngine {
  /// Timestamp when this ReasoningEngine was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the ReasoningEngine.
  ///
  /// Optional.
  core.String? description;

  /// The display name of the ReasoningEngine.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Identifier.
  ///
  /// The resource name of the ReasoningEngine.
  core.String? name;

  /// Configurations of the ReasoningEngine
  ///
  /// Required.
  GoogleCloudAiplatformV1ReasoningEngineSpec? spec;

  /// Timestamp when this ReasoningEngine was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1ReasoningEngine({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.name,
    this.spec,
    this.updateTime,
  });

  GoogleCloudAiplatformV1ReasoningEngine.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          name: json_['name'] as core.String?,
          spec: json_.containsKey('spec')
              ? GoogleCloudAiplatformV1ReasoningEngineSpec.fromJson(
                  json_['spec'] as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (name != null) 'name': name!,
        if (spec != null) 'spec': spec!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// ReasoningEngine configurations
class GoogleCloudAiplatformV1ReasoningEngineSpec {
  /// Declarations for object class methods in OpenAPI specification format.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Map<core.String, core.Object?>>? classMethods;

  /// The specification of a Reasoning Engine deployment.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ReasoningEngineSpecDeploymentSpec? deploymentSpec;

  /// User provided package spec of the ReasoningEngine.
  ///
  /// Required.
  GoogleCloudAiplatformV1ReasoningEngineSpecPackageSpec? packageSpec;

  GoogleCloudAiplatformV1ReasoningEngineSpec({
    this.classMethods,
    this.deploymentSpec,
    this.packageSpec,
  });

  GoogleCloudAiplatformV1ReasoningEngineSpec.fromJson(core.Map json_)
      : this(
          classMethods: (json_['classMethods'] as core.List?)
              ?.map((value) => value as core.Map<core.String, core.dynamic>)
              .toList(),
          deploymentSpec: json_.containsKey('deploymentSpec')
              ? GoogleCloudAiplatformV1ReasoningEngineSpecDeploymentSpec
                  .fromJson(json_['deploymentSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          packageSpec: json_.containsKey('packageSpec')
              ? GoogleCloudAiplatformV1ReasoningEngineSpecPackageSpec.fromJson(
                  json_['packageSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (classMethods != null) 'classMethods': classMethods!,
        if (deploymentSpec != null) 'deploymentSpec': deploymentSpec!,
        if (packageSpec != null) 'packageSpec': packageSpec!,
      };
}

/// The specification of a Reasoning Engine deployment.
class GoogleCloudAiplatformV1ReasoningEngineSpecDeploymentSpec {
  /// Environment variables to be set with the Reasoning Engine deployment.
  ///
  /// The environment variables can be updated through the UpdateReasoningEngine
  /// API.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// Environment variables where the value is a secret in Cloud Secret Manager.
  ///
  /// To use this feature, add 'Secret Manager Secret Accessor' role
  /// (roles/secretmanager.secretAccessor) to AI Platform Reasoning Engine
  /// Service Agent.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1SecretEnvVar>? secretEnv;

  GoogleCloudAiplatformV1ReasoningEngineSpecDeploymentSpec({
    this.env,
    this.secretEnv,
  });

  GoogleCloudAiplatformV1ReasoningEngineSpecDeploymentSpec.fromJson(
      core.Map json_)
      : this(
          env: (json_['env'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          secretEnv: (json_['secretEnv'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1SecretEnvVar.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (env != null) 'env': env!,
        if (secretEnv != null) 'secretEnv': secretEnv!,
      };
}

/// User provided package spec like pickled object and package requirements.
class GoogleCloudAiplatformV1ReasoningEngineSpecPackageSpec {
  /// The Cloud Storage URI of the dependency files in tar.gz format.
  ///
  /// Optional.
  core.String? dependencyFilesGcsUri;

  /// The Cloud Storage URI of the pickled python object.
  ///
  /// Optional.
  core.String? pickleObjectGcsUri;

  /// The Python version.
  ///
  /// Currently support 3.8, 3.9, 3.10, 3.11. If not specified, default value is
  /// 3.10.
  ///
  /// Optional.
  core.String? pythonVersion;

  /// The Cloud Storage URI of the `requirements.txt` file
  ///
  /// Optional.
  core.String? requirementsGcsUri;

  GoogleCloudAiplatformV1ReasoningEngineSpecPackageSpec({
    this.dependencyFilesGcsUri,
    this.pickleObjectGcsUri,
    this.pythonVersion,
    this.requirementsGcsUri,
  });

  GoogleCloudAiplatformV1ReasoningEngineSpecPackageSpec.fromJson(core.Map json_)
      : this(
          dependencyFilesGcsUri: json_['dependencyFilesGcsUri'] as core.String?,
          pickleObjectGcsUri: json_['pickleObjectGcsUri'] as core.String?,
          pythonVersion: json_['pythonVersion'] as core.String?,
          requirementsGcsUri: json_['requirementsGcsUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dependencyFilesGcsUri != null)
          'dependencyFilesGcsUri': dependencyFilesGcsUri!,
        if (pickleObjectGcsUri != null)
          'pickleObjectGcsUri': pickleObjectGcsUri!,
        if (pythonVersion != null) 'pythonVersion': pythonVersion!,
        if (requirementsGcsUri != null)
          'requirementsGcsUri': requirementsGcsUri!,
      };
}

/// Request message for GenAiTuningService.RebaseTunedModel.
class GoogleCloudAiplatformV1RebaseTunedModelRequest {
  /// The Google Cloud Storage location to write the artifacts.
  ///
  /// Optional.
  GoogleCloudAiplatformV1GcsDestination? artifactDestination;

  /// By default, bison to gemini migration will always create new
  /// model/endpoint, but for gemini-1.0 to gemini-1.5 migration, we default
  /// deploy to the same endpoint.
  ///
  /// See details in this Section.
  ///
  /// Optional.
  core.bool? deployToSameEndpoint;

  /// TunedModel reference to retrieve the legacy model information.
  ///
  /// Required.
  GoogleCloudAiplatformV1TunedModelRef? tunedModelRef;

  /// The TuningJob to be updated.
  ///
  /// Users can use this TuningJob field to overwrite tuning configs.
  ///
  /// Optional.
  GoogleCloudAiplatformV1TuningJob? tuningJob;

  GoogleCloudAiplatformV1RebaseTunedModelRequest({
    this.artifactDestination,
    this.deployToSameEndpoint,
    this.tunedModelRef,
    this.tuningJob,
  });

  GoogleCloudAiplatformV1RebaseTunedModelRequest.fromJson(core.Map json_)
      : this(
          artifactDestination: json_.containsKey('artifactDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['artifactDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deployToSameEndpoint: json_['deployToSameEndpoint'] as core.bool?,
          tunedModelRef: json_.containsKey('tunedModelRef')
              ? GoogleCloudAiplatformV1TunedModelRef.fromJson(
                  json_['tunedModelRef'] as core.Map<core.String, core.dynamic>)
              : null,
          tuningJob: json_.containsKey('tuningJob')
              ? GoogleCloudAiplatformV1TuningJob.fromJson(
                  json_['tuningJob'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactDestination != null)
          'artifactDestination': artifactDestination!,
        if (deployToSameEndpoint != null)
          'deployToSameEndpoint': deployToSameEndpoint!,
        if (tunedModelRef != null) 'tunedModelRef': tunedModelRef!,
        if (tuningJob != null) 'tuningJob': tuningJob!,
      };
}

/// Request message for PersistentResourceService.RebootPersistentResource.
typedef GoogleCloudAiplatformV1RebootPersistentResourceRequest = $Empty;

/// Request message for MetadataService.DeleteContextChildrenRequest.
typedef GoogleCloudAiplatformV1RemoveContextChildrenRequest
    = $ContextChildrenRequest;

/// Response message for MetadataService.RemoveContextChildren.
typedef GoogleCloudAiplatformV1RemoveContextChildrenResponse = $Empty;

/// Request message for IndexService.RemoveDatapoints
class GoogleCloudAiplatformV1RemoveDatapointsRequest {
  /// A list of datapoint ids to be deleted.
  core.List<core.String>? datapointIds;

  GoogleCloudAiplatformV1RemoveDatapointsRequest({
    this.datapointIds,
  });

  GoogleCloudAiplatformV1RemoveDatapointsRequest.fromJson(core.Map json_)
      : this(
          datapointIds: (json_['datapointIds'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapointIds != null) 'datapointIds': datapointIds!,
      };
}

/// Response message for IndexService.RemoveDatapoints
typedef GoogleCloudAiplatformV1RemoveDatapointsResponse = $Empty;

/// A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a
/// DeployedModel) to draw its Compute Engine resources from a Shared
/// Reservation, or exclusively from on-demand capacity.
class GoogleCloudAiplatformV1ReservationAffinity {
  /// Corresponds to the label key of a reservation resource.
  ///
  /// To target a SPECIFIC_RESERVATION by name, use
  /// `compute.googleapis.com/reservation-name` as the key and specify the name
  /// of your reservation as its value.
  ///
  /// Optional.
  core.String? key;

  /// Specifies the reservation affinity type.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Default value. This should not be used.
  /// - "NO_RESERVATION" : Do not consume from any reserved capacity, only use
  /// on-demand.
  /// - "ANY_RESERVATION" : Consume any reservation available, falling back to
  /// on-demand.
  /// - "SPECIFIC_RESERVATION" : Consume from a specific reservation. When
  /// chosen, the reservation must be identified via the `key` and `values`
  /// fields.
  core.String? reservationAffinityType;

  /// Corresponds to the label values of a reservation resource.
  ///
  /// This must be the full resource name of the reservation or reservation
  /// block.
  ///
  /// Optional.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1ReservationAffinity({
    this.key,
    this.reservationAffinityType,
    this.values,
  });

  GoogleCloudAiplatformV1ReservationAffinity.fromJson(core.Map json_)
      : this(
          key: json_['key'] as core.String?,
          reservationAffinityType:
              json_['reservationAffinityType'] as core.String?,
          values: (json_['values'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (reservationAffinityType != null)
          'reservationAffinityType': reservationAffinityType!,
        if (values != null) 'values': values!,
      };
}

/// Represents the spec of a group of resources of the same type, for example
/// machine type, disk, and accelerators, in a PersistentResource.
class GoogleCloudAiplatformV1ResourcePool {
  /// Optional spec to configure GKE or Ray-on-Vertex autoscaling
  ///
  /// Optional.
  GoogleCloudAiplatformV1ResourcePoolAutoscalingSpec? autoscalingSpec;

  /// Disk spec for the machine in this node pool.
  ///
  /// Optional.
  GoogleCloudAiplatformV1DiskSpec? diskSpec;

  /// The unique ID in a PersistentResource for referring to this resource pool.
  ///
  /// User can specify it if necessary. Otherwise, it's generated automatically.
  ///
  /// Immutable.
  core.String? id;

  /// The specification of a single machine.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The total number of machines to use for this resource pool.
  ///
  /// Optional.
  core.String? replicaCount;

  /// The number of machines currently in use by training jobs for this resource
  /// pool.
  ///
  /// Will replace idle_replica_count.
  ///
  /// Output only.
  core.String? usedReplicaCount;

  GoogleCloudAiplatformV1ResourcePool({
    this.autoscalingSpec,
    this.diskSpec,
    this.id,
    this.machineSpec,
    this.replicaCount,
    this.usedReplicaCount,
  });

  GoogleCloudAiplatformV1ResourcePool.fromJson(core.Map json_)
      : this(
          autoscalingSpec: json_.containsKey('autoscalingSpec')
              ? GoogleCloudAiplatformV1ResourcePoolAutoscalingSpec.fromJson(
                  json_['autoscalingSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          diskSpec: json_.containsKey('diskSpec')
              ? GoogleCloudAiplatformV1DiskSpec.fromJson(
                  json_['diskSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          id: json_['id'] as core.String?,
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          replicaCount: json_['replicaCount'] as core.String?,
          usedReplicaCount: json_['usedReplicaCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalingSpec != null) 'autoscalingSpec': autoscalingSpec!,
        if (diskSpec != null) 'diskSpec': diskSpec!,
        if (id != null) 'id': id!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (replicaCount != null) 'replicaCount': replicaCount!,
        if (usedReplicaCount != null) 'usedReplicaCount': usedReplicaCount!,
      };
}

/// The min/max number of replicas allowed if enabling autoscaling
class GoogleCloudAiplatformV1ResourcePoolAutoscalingSpec {
  /// max replicas in the node pool, must be  replica_count and \>
  /// min_replica_count or will throw error
  ///
  /// Optional.
  core.String? maxReplicaCount;

  /// min replicas in the node pool, must be  replica_count and \<
  /// max_replica_count or will throw error.
  ///
  /// For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
  /// resource_pool to be 0 to match the OSS Ray
  /// behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters).
  /// As for Persistent Resource, the min_replica_count must be \> 0, we added a
  /// corresponding validation inside
  /// CreatePersistentResourceRequestValidator.java.
  ///
  /// Optional.
  core.String? minReplicaCount;

  GoogleCloudAiplatformV1ResourcePoolAutoscalingSpec({
    this.maxReplicaCount,
    this.minReplicaCount,
  });

  GoogleCloudAiplatformV1ResourcePoolAutoscalingSpec.fromJson(core.Map json_)
      : this(
          maxReplicaCount: json_['maxReplicaCount'] as core.String?,
          minReplicaCount: json_['minReplicaCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
        if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
      };
}

/// Persistent Cluster runtime information as output
class GoogleCloudAiplatformV1ResourceRuntime {
  /// URIs for user to connect to the Cluster.
  ///
  /// Example: { "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
  /// "RAY_DASHBOARD_URI": "ray-dashboard-address:8888" }
  ///
  /// Output only.
  core.Map<core.String, core.String>? accessUris;

  GoogleCloudAiplatformV1ResourceRuntime({
    this.accessUris,
  });

  GoogleCloudAiplatformV1ResourceRuntime.fromJson(core.Map json_)
      : this(
          accessUris:
              (json_['accessUris'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (accessUris != null) 'accessUris': accessUris!,
      };
}

/// Configuration for the runtime on a PersistentResource instance, including
/// but not limited to: * Service accounts used to run the workloads.
///
/// * Whether to make it a dedicated Ray Cluster.
class GoogleCloudAiplatformV1ResourceRuntimeSpec {
  /// Ray cluster configuration.
  ///
  /// Required when creating a dedicated RayCluster on the PersistentResource.
  ///
  /// Optional.
  GoogleCloudAiplatformV1RaySpec? raySpec;

  /// Configure the use of workload identity on the PersistentResource
  ///
  /// Optional.
  GoogleCloudAiplatformV1ServiceAccountSpec? serviceAccountSpec;

  GoogleCloudAiplatformV1ResourceRuntimeSpec({
    this.raySpec,
    this.serviceAccountSpec,
  });

  GoogleCloudAiplatformV1ResourceRuntimeSpec.fromJson(core.Map json_)
      : this(
          raySpec: json_.containsKey('raySpec')
              ? GoogleCloudAiplatformV1RaySpec.fromJson(
                  json_['raySpec'] as core.Map<core.String, core.dynamic>)
              : null,
          serviceAccountSpec: json_.containsKey('serviceAccountSpec')
              ? GoogleCloudAiplatformV1ServiceAccountSpec.fromJson(
                  json_['serviceAccountSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (raySpec != null) 'raySpec': raySpec!,
        if (serviceAccountSpec != null)
          'serviceAccountSpec': serviceAccountSpec!,
      };
}

/// Statistics information about resource consumption.
class GoogleCloudAiplatformV1ResourcesConsumed {
  /// The number of replica hours used.
  ///
  /// Note that many replicas may run in parallel, and additionally any given
  /// work may be queued for some time. Therefore this value is not strictly
  /// related to wall time.
  ///
  /// Output only.
  core.double? replicaHours;

  GoogleCloudAiplatformV1ResourcesConsumed({
    this.replicaHours,
  });

  GoogleCloudAiplatformV1ResourcesConsumed.fromJson(core.Map json_)
      : this(
          replicaHours: (json_['replicaHours'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (replicaHours != null) 'replicaHours': replicaHours!,
      };
}

/// Request message for JobService.ResumeModelDeploymentMonitoringJob.
typedef GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest
    = $Empty;

/// Request message for ScheduleService.ResumeSchedule.
class GoogleCloudAiplatformV1ResumeScheduleRequest {
  /// Whether to backfill missed runs when the schedule is resumed from PAUSED
  /// state.
  ///
  /// If set to true, all missed runs will be scheduled. New runs will be
  /// scheduled after the backfill is complete. This will also update
  /// Schedule.catch_up field. Default to false.
  ///
  /// Optional.
  core.bool? catchUp;

  GoogleCloudAiplatformV1ResumeScheduleRequest({
    this.catchUp,
  });

  GoogleCloudAiplatformV1ResumeScheduleRequest.fromJson(core.Map json_)
      : this(
          catchUp: json_['catchUp'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (catchUp != null) 'catchUp': catchUp!,
      };
}

/// Defines a retrieval tool that model can call to access external knowledge.
class GoogleCloudAiplatformV1Retrieval {
  /// This option is no longer supported.
  ///
  /// Optional. Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? disableAttribution;

  /// Set to use data source powered by Vertex AI Search.
  GoogleCloudAiplatformV1VertexAISearch? vertexAiSearch;

  /// Set to use data source powered by Vertex RAG store.
  ///
  /// User data is uploaded via the VertexRagDataService.
  GoogleCloudAiplatformV1VertexRagStore? vertexRagStore;

  GoogleCloudAiplatformV1Retrieval({
    this.disableAttribution,
    this.vertexAiSearch,
    this.vertexRagStore,
  });

  GoogleCloudAiplatformV1Retrieval.fromJson(core.Map json_)
      : this(
          disableAttribution: json_['disableAttribution'] as core.bool?,
          vertexAiSearch: json_.containsKey('vertexAiSearch')
              ? GoogleCloudAiplatformV1VertexAISearch.fromJson(
                  json_['vertexAiSearch']
                      as core.Map<core.String, core.dynamic>)
              : null,
          vertexRagStore: json_.containsKey('vertexRagStore')
              ? GoogleCloudAiplatformV1VertexRagStore.fromJson(
                  json_['vertexRagStore']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disableAttribution != null)
          'disableAttribution': disableAttribution!,
        if (vertexAiSearch != null) 'vertexAiSearch': vertexAiSearch!,
        if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!,
      };
}

/// Retrieval config.
class GoogleCloudAiplatformV1RetrievalConfig {
  /// The language code of the user.
  core.String? languageCode;

  /// The location of the user.
  GoogleTypeLatLng? latLng;

  GoogleCloudAiplatformV1RetrievalConfig({
    this.languageCode,
    this.latLng,
  });

  GoogleCloudAiplatformV1RetrievalConfig.fromJson(core.Map json_)
      : this(
          languageCode: json_['languageCode'] as core.String?,
          latLng: json_.containsKey('latLng')
              ? GoogleTypeLatLng.fromJson(
                  json_['latLng'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (languageCode != null) 'languageCode': languageCode!,
        if (latLng != null) 'latLng': latLng!,
      };
}

/// Metadata related to retrieval in the grounding flow.
class GoogleCloudAiplatformV1RetrievalMetadata {
  /// Score indicating how likely information from Google Search could help
  /// answer the prompt.
  ///
  /// The score is in the range `[0, 1]`, where 0 is the least likely and 1 is
  /// the most likely. This score is only populated when Google Search grounding
  /// and dynamic retrieval is enabled. It will be compared to the threshold to
  /// determine whether to trigger Google Search.
  ///
  /// Optional.
  core.double? googleSearchDynamicRetrievalScore;

  GoogleCloudAiplatformV1RetrievalMetadata({
    this.googleSearchDynamicRetrievalScore,
  });

  GoogleCloudAiplatformV1RetrievalMetadata.fromJson(core.Map json_)
      : this(
          googleSearchDynamicRetrievalScore:
              (json_['googleSearchDynamicRetrievalScore'] as core.num?)
                  ?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (googleSearchDynamicRetrievalScore != null)
          'googleSearchDynamicRetrievalScore':
              googleSearchDynamicRetrievalScore!,
      };
}

/// Request message for VertexRagService.RetrieveContexts.
class GoogleCloudAiplatformV1RetrieveContextsRequest {
  /// Single RAG retrieve query.
  ///
  /// Required.
  GoogleCloudAiplatformV1RagQuery? query;

  /// The data source for Vertex RagStore.
  GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStore? vertexRagStore;

  GoogleCloudAiplatformV1RetrieveContextsRequest({
    this.query,
    this.vertexRagStore,
  });

  GoogleCloudAiplatformV1RetrieveContextsRequest.fromJson(core.Map json_)
      : this(
          query: json_.containsKey('query')
              ? GoogleCloudAiplatformV1RagQuery.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>)
              : null,
          vertexRagStore: json_.containsKey('vertexRagStore')
              ? GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStore
                  .fromJson(json_['vertexRagStore']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (query != null) 'query': query!,
        if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!,
      };
}

/// The data source for Vertex RagStore.
class GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStore {
  /// The representation of the rag source.
  ///
  /// It can be used to specify corpus only or ragfiles. Currently only support
  /// one corpus or multiple files from one corpus. In the future we may open up
  /// multiple corpora support.
  ///
  /// Optional.
  core.List<
          GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStoreRagResource>?
      ragResources;

  /// Only return contexts with vector distance smaller than the threshold.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? vectorDistanceThreshold;

  GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStore({
    this.ragResources,
    this.vectorDistanceThreshold,
  });

  GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStore.fromJson(
      core.Map json_)
      : this(
          ragResources: (json_['ragResources'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStoreRagResource
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          vectorDistanceThreshold:
              (json_['vectorDistanceThreshold'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragResources != null) 'ragResources': ragResources!,
        if (vectorDistanceThreshold != null)
          'vectorDistanceThreshold': vectorDistanceThreshold!,
      };
}

/// The definition of the Rag resource.
typedef GoogleCloudAiplatformV1RetrieveContextsRequestVertexRagStoreRagResource
    = $VertexRagStoreRagResource;

/// Response message for VertexRagService.RetrieveContexts.
class GoogleCloudAiplatformV1RetrieveContextsResponse {
  /// The contexts of the query.
  GoogleCloudAiplatformV1RagContexts? contexts;

  GoogleCloudAiplatformV1RetrieveContextsResponse({
    this.contexts,
  });

  GoogleCloudAiplatformV1RetrieveContextsResponse.fromJson(core.Map json_)
      : this(
          contexts: json_.containsKey('contexts')
              ? GoogleCloudAiplatformV1RagContexts.fromJson(
                  json_['contexts'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contexts != null) 'contexts': contexts!,
      };
}

/// Input for rouge metric.
class GoogleCloudAiplatformV1RougeInput {
  /// Repeated rouge instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1RougeInstance>? instances;

  /// Spec for rouge score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1RougeSpec? metricSpec;

  GoogleCloudAiplatformV1RougeInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1RougeInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1RougeInstance.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1RougeSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for rouge instance.
typedef GoogleCloudAiplatformV1RougeInstance = $Instance00;

/// Rouge metric value for an instance.
class GoogleCloudAiplatformV1RougeMetricValue {
  /// Rouge score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1RougeMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1RougeMetricValue.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for rouge metric.
class GoogleCloudAiplatformV1RougeResults {
  /// Rouge metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1RougeMetricValue>? rougeMetricValues;

  GoogleCloudAiplatformV1RougeResults({
    this.rougeMetricValues,
  });

  GoogleCloudAiplatformV1RougeResults.fromJson(core.Map json_)
      : this(
          rougeMetricValues: (json_['rougeMetricValues'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1RougeMetricValue.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (rougeMetricValues != null) 'rougeMetricValues': rougeMetricValues!,
      };
}

/// Spec for rouge score metric - calculates the recall of n-grams in prediction
/// as compared to reference - returns a score ranging between 0 and 1.
class GoogleCloudAiplatformV1RougeSpec {
  /// Supported rouge types are rougen\[1-9\], rougeL, and rougeLsum.
  ///
  /// Optional.
  core.String? rougeType;

  /// Whether to split summaries while using rougeLsum.
  ///
  /// Optional.
  core.bool? splitSummaries;

  /// Whether to use stemmer to compute rouge score.
  ///
  /// Optional.
  core.bool? useStemmer;

  GoogleCloudAiplatformV1RougeSpec({
    this.rougeType,
    this.splitSummaries,
    this.useStemmer,
  });

  GoogleCloudAiplatformV1RougeSpec.fromJson(core.Map json_)
      : this(
          rougeType: json_['rougeType'] as core.String?,
          splitSummaries: json_['splitSummaries'] as core.bool?,
          useStemmer: json_['useStemmer'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (rougeType != null) 'rougeType': rougeType!,
        if (splitSummaries != null) 'splitSummaries': splitSummaries!,
        if (useStemmer != null) 'useStemmer': useStemmer!,
      };
}

/// Input for safety metric.
class GoogleCloudAiplatformV1SafetyInput {
  /// Safety instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1SafetyInstance? instance;

  /// Spec for safety metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1SafetySpec? metricSpec;

  GoogleCloudAiplatformV1SafetyInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1SafetyInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1SafetyInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1SafetySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for safety instance.
typedef GoogleCloudAiplatformV1SafetyInstance = $Instance01;

/// Safety rating corresponding to the generated content.
class GoogleCloudAiplatformV1SafetyRating {
  /// Indicates whether the content was filtered out because of this rating.
  ///
  /// Output only.
  core.bool? blocked;

  /// Harm category.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_CATEGORY_UNSPECIFIED" : The harm category is unspecified.
  /// - "HARM_CATEGORY_HATE_SPEECH" : The harm category is hate speech.
  /// - "HARM_CATEGORY_DANGEROUS_CONTENT" : The harm category is dangerous
  /// content.
  /// - "HARM_CATEGORY_HARASSMENT" : The harm category is harassment.
  /// - "HARM_CATEGORY_SEXUALLY_EXPLICIT" : The harm category is sexually
  /// explicit content.
  /// - "HARM_CATEGORY_CIVIC_INTEGRITY" : The harm category is civic integrity.
  core.String? category;

  /// Harm probability levels in the content.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_PROBABILITY_UNSPECIFIED" : Harm probability unspecified.
  /// - "NEGLIGIBLE" : Negligible level of harm.
  /// - "LOW" : Low level of harm.
  /// - "MEDIUM" : Medium level of harm.
  /// - "HIGH" : High level of harm.
  core.String? probability;

  /// Harm probability score.
  ///
  /// Output only.
  core.double? probabilityScore;

  /// Harm severity levels in the content.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HARM_SEVERITY_UNSPECIFIED" : Harm severity unspecified.
  /// - "HARM_SEVERITY_NEGLIGIBLE" : Negligible level of harm severity.
  /// - "HARM_SEVERITY_LOW" : Low level of harm severity.
  /// - "HARM_SEVERITY_MEDIUM" : Medium level of harm severity.
  /// - "HARM_SEVERITY_HIGH" : High level of harm severity.
  core.String? severity;

  /// Harm severity score.
  ///
  /// Output only.
  core.double? severityScore;

  GoogleCloudAiplatformV1SafetyRating({
    this.blocked,
    this.category,
    this.probability,
    this.probabilityScore,
    this.severity,
    this.severityScore,
  });

  GoogleCloudAiplatformV1SafetyRating.fromJson(core.Map json_)
      : this(
          blocked: json_['blocked'] as core.bool?,
          category: json_['category'] as core.String?,
          probability: json_['probability'] as core.String?,
          probabilityScore:
              (json_['probabilityScore'] as core.num?)?.toDouble(),
          severity: json_['severity'] as core.String?,
          severityScore: (json_['severityScore'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blocked != null) 'blocked': blocked!,
        if (category != null) 'category': category!,
        if (probability != null) 'probability': probability!,
        if (probabilityScore != null) 'probabilityScore': probabilityScore!,
        if (severity != null) 'severity': severity!,
        if (severityScore != null) 'severityScore': severityScore!,
      };
}

/// Spec for safety result.
class GoogleCloudAiplatformV1SafetyResult {
  /// Confidence for safety score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for safety score.
  ///
  /// Output only.
  core.String? explanation;

  /// Safety score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1SafetyResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1SafetyResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Safety settings.
class GoogleCloudAiplatformV1SafetySetting {
  /// Harm category.
  ///
  /// Required.
  /// Possible string values are:
  /// - "HARM_CATEGORY_UNSPECIFIED" : The harm category is unspecified.
  /// - "HARM_CATEGORY_HATE_SPEECH" : The harm category is hate speech.
  /// - "HARM_CATEGORY_DANGEROUS_CONTENT" : The harm category is dangerous
  /// content.
  /// - "HARM_CATEGORY_HARASSMENT" : The harm category is harassment.
  /// - "HARM_CATEGORY_SEXUALLY_EXPLICIT" : The harm category is sexually
  /// explicit content.
  /// - "HARM_CATEGORY_CIVIC_INTEGRITY" : The harm category is civic integrity.
  core.String? category;

  /// Specify if the threshold is used for probability or severity score.
  ///
  /// If not specified, the threshold is used for probability score.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "HARM_BLOCK_METHOD_UNSPECIFIED" : The harm block method is unspecified.
  /// - "SEVERITY" : The harm block method uses both probability and severity
  /// scores.
  /// - "PROBABILITY" : The harm block method uses the probability score.
  core.String? method;

  /// The harm block threshold.
  ///
  /// Required.
  /// Possible string values are:
  /// - "HARM_BLOCK_THRESHOLD_UNSPECIFIED" : Unspecified harm block threshold.
  /// - "BLOCK_LOW_AND_ABOVE" : Block low threshold and above (i.e. block more).
  /// - "BLOCK_MEDIUM_AND_ABOVE" : Block medium threshold and above.
  /// - "BLOCK_ONLY_HIGH" : Block only high threshold (i.e. block less).
  /// - "BLOCK_NONE" : Block none.
  /// - "OFF" : Turn off the safety filter.
  core.String? threshold;

  GoogleCloudAiplatformV1SafetySetting({
    this.category,
    this.method,
    this.threshold,
  });

  GoogleCloudAiplatformV1SafetySetting.fromJson(core.Map json_)
      : this(
          category: json_['category'] as core.String?,
          method: json_['method'] as core.String?,
          threshold: json_['threshold'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (category != null) 'category': category!,
        if (method != null) 'method': method!,
        if (threshold != null) 'threshold': threshold!,
      };
}

/// Spec for safety metric.
typedef GoogleCloudAiplatformV1SafetySpec = $Spec;

/// Active learning data sampling config.
///
/// For every active learning labeling iteration, it will select a batch of data
/// based on the sampling strategy.
class GoogleCloudAiplatformV1SampleConfig {
  /// The percentage of data needed to be labeled in each following batch
  /// (except the first batch).
  core.int? followingBatchSamplePercentage;

  /// The percentage of data needed to be labeled in the first batch.
  core.int? initialBatchSamplePercentage;

  /// Field to choose sampling strategy.
  ///
  /// Sampling strategy will decide which data should be selected for human
  /// labeling in every batch.
  /// Possible string values are:
  /// - "SAMPLE_STRATEGY_UNSPECIFIED" : Default will be treated as UNCERTAINTY.
  /// - "UNCERTAINTY" : Sample the most uncertain data to label.
  core.String? sampleStrategy;

  GoogleCloudAiplatformV1SampleConfig({
    this.followingBatchSamplePercentage,
    this.initialBatchSamplePercentage,
    this.sampleStrategy,
  });

  GoogleCloudAiplatformV1SampleConfig.fromJson(core.Map json_)
      : this(
          followingBatchSamplePercentage:
              json_['followingBatchSamplePercentage'] as core.int?,
          initialBatchSamplePercentage:
              json_['initialBatchSamplePercentage'] as core.int?,
          sampleStrategy: json_['sampleStrategy'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (followingBatchSamplePercentage != null)
          'followingBatchSamplePercentage': followingBatchSamplePercentage!,
        if (initialBatchSamplePercentage != null)
          'initialBatchSamplePercentage': initialBatchSamplePercentage!,
        if (sampleStrategy != null) 'sampleStrategy': sampleStrategy!,
      };
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted.
///
/// A sampling strategy is used to approximate the value rather than considering
/// all subsets of features.
class GoogleCloudAiplatformV1SampledShapleyAttribution {
  /// The number of feature permutations to consider when approximating the
  /// Shapley values.
  ///
  /// Valid range of its value is \[1, 50\], inclusively.
  ///
  /// Required.
  core.int? pathCount;

  GoogleCloudAiplatformV1SampledShapleyAttribution({
    this.pathCount,
  });

  GoogleCloudAiplatformV1SampledShapleyAttribution.fromJson(core.Map json_)
      : this(
          pathCount: json_['pathCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (pathCount != null) 'pathCount': pathCount!,
      };
}

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
class GoogleCloudAiplatformV1SamplingStrategy {
  /// Random sample config.
  ///
  /// Will support more sampling strategies later.
  GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig? randomSampleConfig;

  GoogleCloudAiplatformV1SamplingStrategy({
    this.randomSampleConfig,
  });

  GoogleCloudAiplatformV1SamplingStrategy.fromJson(core.Map json_)
      : this(
          randomSampleConfig: json_.containsKey('randomSampleConfig')
              ? GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig
                  .fromJson(json_['randomSampleConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (randomSampleConfig != null)
          'randomSampleConfig': randomSampleConfig!,
      };
}

/// Requests are randomly selected.
class GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig {
  /// Sample rate (0, 1\]
  core.double? sampleRate;

  GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig({
    this.sampleRate,
  });

  GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig.fromJson(
      core.Map json_)
      : this(
          sampleRate: (json_['sampleRate'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sampleRate != null) 'sampleRate': sampleRate!,
      };
}

/// A SavedQuery is a view of the dataset.
///
/// It references a subset of annotations by problem type and filters.
class GoogleCloudAiplatformV1SavedQuery {
  /// Filters on the Annotations in the dataset.
  ///
  /// Output only.
  core.String? annotationFilter;

  /// Number of AnnotationSpecs in the context of the SavedQuery.
  ///
  /// Output only.
  core.int? annotationSpecCount;

  /// Timestamp when this SavedQuery was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the SavedQuery.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write update.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Some additional information about the SavedQuery.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Resource name of the SavedQuery.
  ///
  /// Output only.
  core.String? name;

  /// Problem type of the SavedQuery.
  ///
  /// Allowed values: * IMAGE_CLASSIFICATION_SINGLE_LABEL *
  /// IMAGE_CLASSIFICATION_MULTI_LABEL * IMAGE_BOUNDING_POLY *
  /// IMAGE_BOUNDING_BOX * TEXT_CLASSIFICATION_SINGLE_LABEL *
  /// TEXT_CLASSIFICATION_MULTI_LABEL * TEXT_EXTRACTION * TEXT_SENTIMENT *
  /// VIDEO_CLASSIFICATION * VIDEO_OBJECT_TRACKING
  ///
  /// Required.
  core.String? problemType;

  /// If the Annotations belonging to the SavedQuery can be used for AutoML
  /// training.
  ///
  /// Output only.
  core.bool? supportAutomlTraining;

  /// Timestamp when SavedQuery was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1SavedQuery({
    this.annotationFilter,
    this.annotationSpecCount,
    this.createTime,
    this.displayName,
    this.etag,
    this.metadata,
    this.name,
    this.problemType,
    this.supportAutomlTraining,
    this.updateTime,
  });

  GoogleCloudAiplatformV1SavedQuery.fromJson(core.Map json_)
      : this(
          annotationFilter: json_['annotationFilter'] as core.String?,
          annotationSpecCount: json_['annotationSpecCount'] as core.int?,
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          metadata: json_['metadata'],
          name: json_['name'] as core.String?,
          problemType: json_['problemType'] as core.String?,
          supportAutomlTraining: json_['supportAutomlTraining'] as core.bool?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationFilter != null) 'annotationFilter': annotationFilter!,
        if (annotationSpecCount != null)
          'annotationSpecCount': annotationSpecCount!,
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (problemType != null) 'problemType': problemType!,
        if (supportAutomlTraining != null)
          'supportAutomlTraining': supportAutomlTraining!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// One point viewable on a scalar metric plot.
class GoogleCloudAiplatformV1Scalar {
  /// Value of the point at this step / timestamp.
  core.double? value;

  GoogleCloudAiplatformV1Scalar({
    this.value,
  });

  GoogleCloudAiplatformV1Scalar.fromJson(core.Map json_)
      : this(
          value: (json_['value'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
      };
}

/// An instance of a Schedule periodically schedules runs to make API calls
/// based on user specified time specification and API request type.
class GoogleCloudAiplatformV1Schedule {
  /// Whether new scheduled runs can be queued when max_concurrent_runs limit is
  /// reached.
  ///
  /// If set to true, new runs will be queued instead of skipped. Default to
  /// false.
  ///
  /// Optional.
  core.bool? allowQueueing;

  /// Whether to backfill missed runs when the schedule is resumed from PAUSED
  /// state.
  ///
  /// If set to true, all missed runs will be scheduled. New runs will be
  /// scheduled after the backfill is complete. Default to false.
  ///
  /// Output only.
  core.bool? catchUp;

  /// Request for NotebookService.CreateNotebookExecutionJob.
  GoogleCloudAiplatformV1CreateNotebookExecutionJobRequest?
      createNotebookExecutionJobRequest;

  /// Request for PipelineService.CreatePipelineJob.
  ///
  /// CreatePipelineJobRequest.parent field is required (format:
  /// projects/{project}/locations/{location}).
  GoogleCloudAiplatformV1CreatePipelineJobRequest? createPipelineJobRequest;

  /// Timestamp when this Schedule was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs.
  ///
  /// To explicitly set a timezone to the cron tab, apply a prefix in the cron
  /// tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The
  /// ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database.
  /// For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York
  /// 1 * * * *".
  core.String? cron;

  /// User provided name of the Schedule.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Timestamp after which no new runs can be scheduled.
  ///
  /// If specified, The schedule will be completed when either end_time is
  /// reached or when scheduled_run_count \>= max_run_count. If not specified,
  /// new runs will keep getting scheduled until this Schedule is paused or
  /// deleted. Already scheduled runs will be allowed to complete. Unset if not
  /// specified.
  ///
  /// Optional.
  core.String? endTime;

  /// Timestamp when this Schedule was last paused.
  ///
  /// Unset if never paused.
  ///
  /// Output only.
  core.String? lastPauseTime;

  /// Timestamp when this Schedule was last resumed.
  ///
  /// Unset if never resumed from pause.
  ///
  /// Output only.
  core.String? lastResumeTime;

  /// Response of the last scheduled run.
  ///
  /// This is the response for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  /// Unset if no run has been scheduled yet.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ScheduleRunResponse? lastScheduledRunResponse;

  /// Maximum number of runs that can be started concurrently for this Schedule.
  ///
  /// This is the limit for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  ///
  /// Required.
  core.String? maxConcurrentRunCount;

  /// Maximum run count of the schedule.
  ///
  /// If specified, The schedule will be completed when either started_run_count
  /// \>= max_run_count or when end_time is reached. If not specified, new runs
  /// will keep getting scheduled until this Schedule is paused or deleted.
  /// Already scheduled runs will be allowed to complete. Unset if not
  /// specified.
  ///
  /// Optional.
  core.String? maxRunCount;

  /// The resource name of the Schedule.
  ///
  /// Immutable.
  core.String? name;

  /// Timestamp when this Schedule should schedule the next run.
  ///
  /// Having a next_run_time in the past means the runs are being started behind
  /// schedule.
  ///
  /// Output only.
  core.String? nextRunTime;

  /// Timestamp after which the first run can be scheduled.
  ///
  /// Default to Schedule create time if not specified.
  ///
  /// Optional.
  core.String? startTime;

  /// The number of runs started by this schedule.
  ///
  /// Output only.
  core.String? startedRunCount;

  /// The state of this Schedule.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "ACTIVE" : The Schedule is active. Runs are being scheduled on the
  /// user-specified timespec.
  /// - "PAUSED" : The schedule is paused. No new runs will be created until the
  /// schedule is resumed. Already started runs will be allowed to complete.
  /// - "COMPLETED" : The Schedule is completed. No new runs will be scheduled.
  /// Already started runs will be allowed to complete. Schedules in completed
  /// state cannot be paused or resumed.
  core.String? state;

  /// Timestamp when this Schedule was updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Schedule({
    this.allowQueueing,
    this.catchUp,
    this.createNotebookExecutionJobRequest,
    this.createPipelineJobRequest,
    this.createTime,
    this.cron,
    this.displayName,
    this.endTime,
    this.lastPauseTime,
    this.lastResumeTime,
    this.lastScheduledRunResponse,
    this.maxConcurrentRunCount,
    this.maxRunCount,
    this.name,
    this.nextRunTime,
    this.startTime,
    this.startedRunCount,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Schedule.fromJson(core.Map json_)
      : this(
          allowQueueing: json_['allowQueueing'] as core.bool?,
          catchUp: json_['catchUp'] as core.bool?,
          createNotebookExecutionJobRequest:
              json_.containsKey('createNotebookExecutionJobRequest')
                  ? GoogleCloudAiplatformV1CreateNotebookExecutionJobRequest
                      .fromJson(json_['createNotebookExecutionJobRequest']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          createPipelineJobRequest:
              json_.containsKey('createPipelineJobRequest')
                  ? GoogleCloudAiplatformV1CreatePipelineJobRequest.fromJson(
                      json_['createPipelineJobRequest']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          createTime: json_['createTime'] as core.String?,
          cron: json_['cron'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          endTime: json_['endTime'] as core.String?,
          lastPauseTime: json_['lastPauseTime'] as core.String?,
          lastResumeTime: json_['lastResumeTime'] as core.String?,
          lastScheduledRunResponse:
              json_.containsKey('lastScheduledRunResponse')
                  ? GoogleCloudAiplatformV1ScheduleRunResponse.fromJson(
                      json_['lastScheduledRunResponse']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          maxConcurrentRunCount: json_['maxConcurrentRunCount'] as core.String?,
          maxRunCount: json_['maxRunCount'] as core.String?,
          name: json_['name'] as core.String?,
          nextRunTime: json_['nextRunTime'] as core.String?,
          startTime: json_['startTime'] as core.String?,
          startedRunCount: json_['startedRunCount'] as core.String?,
          state: json_['state'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowQueueing != null) 'allowQueueing': allowQueueing!,
        if (catchUp != null) 'catchUp': catchUp!,
        if (createNotebookExecutionJobRequest != null)
          'createNotebookExecutionJobRequest':
              createNotebookExecutionJobRequest!,
        if (createPipelineJobRequest != null)
          'createPipelineJobRequest': createPipelineJobRequest!,
        if (createTime != null) 'createTime': createTime!,
        if (cron != null) 'cron': cron!,
        if (displayName != null) 'displayName': displayName!,
        if (endTime != null) 'endTime': endTime!,
        if (lastPauseTime != null) 'lastPauseTime': lastPauseTime!,
        if (lastResumeTime != null) 'lastResumeTime': lastResumeTime!,
        if (lastScheduledRunResponse != null)
          'lastScheduledRunResponse': lastScheduledRunResponse!,
        if (maxConcurrentRunCount != null)
          'maxConcurrentRunCount': maxConcurrentRunCount!,
        if (maxRunCount != null) 'maxRunCount': maxRunCount!,
        if (name != null) 'name': name!,
        if (nextRunTime != null) 'nextRunTime': nextRunTime!,
        if (startTime != null) 'startTime': startTime!,
        if (startedRunCount != null) 'startedRunCount': startedRunCount!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Status of a scheduled run.
class GoogleCloudAiplatformV1ScheduleRunResponse {
  /// The response of the scheduled run.
  core.String? runResponse;

  /// The scheduled run time based on the user-specified schedule.
  core.String? scheduledRunTime;

  GoogleCloudAiplatformV1ScheduleRunResponse({
    this.runResponse,
    this.scheduledRunTime,
  });

  GoogleCloudAiplatformV1ScheduleRunResponse.fromJson(core.Map json_)
      : this(
          runResponse: json_['runResponse'] as core.String?,
          scheduledRunTime: json_['scheduledRunTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (runResponse != null) 'runResponse': runResponse!,
        if (scheduledRunTime != null) 'scheduledRunTime': scheduledRunTime!,
      };
}

/// All parameters related to queuing and scheduling of custom jobs.
class GoogleCloudAiplatformV1Scheduling {
  /// Indicates if the job should retry for internal errors after the job starts
  /// running.
  ///
  /// If true, overrides `Scheduling.restart_job_on_worker_restart` to false.
  ///
  /// Optional.
  core.bool? disableRetries;

  /// This is the maximum duration that a job will wait for the requested
  /// resources to be provisioned if the scheduling strategy is set to
  /// \[Strategy.DWS_FLEX_START\].
  ///
  /// If set to 0, the job will wait indefinitely. The default is 24 hours.
  ///
  /// Optional.
  core.String? maxWaitDuration;

  /// Restarts the entire CustomJob if a worker gets restarted.
  ///
  /// This feature can be used by distributed training jobs that are not
  /// resilient to workers leaving and joining a job.
  ///
  /// Optional.
  core.bool? restartJobOnWorkerRestart;

  /// This determines which type of scheduling strategy to use.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "STRATEGY_UNSPECIFIED" : Strategy will default to STANDARD.
  /// - "ON_DEMAND" : Deprecated. Regular on-demand provisioning strategy.
  /// - "LOW_COST" : Deprecated. Low cost by making potential use of spot
  /// resources.
  /// - "STANDARD" : Standard provisioning strategy uses regular on-demand
  /// resources.
  /// - "SPOT" : Spot provisioning strategy uses spot resources.
  /// - "FLEX_START" : Flex Start strategy uses DWS to queue for resources.
  core.String? strategy;

  /// The maximum job running time.
  ///
  /// The default is 7 days.
  ///
  /// Optional.
  core.String? timeout;

  GoogleCloudAiplatformV1Scheduling({
    this.disableRetries,
    this.maxWaitDuration,
    this.restartJobOnWorkerRestart,
    this.strategy,
    this.timeout,
  });

  GoogleCloudAiplatformV1Scheduling.fromJson(core.Map json_)
      : this(
          disableRetries: json_['disableRetries'] as core.bool?,
          maxWaitDuration: json_['maxWaitDuration'] as core.String?,
          restartJobOnWorkerRestart:
              json_['restartJobOnWorkerRestart'] as core.bool?,
          strategy: json_['strategy'] as core.String?,
          timeout: json_['timeout'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disableRetries != null) 'disableRetries': disableRetries!,
        if (maxWaitDuration != null) 'maxWaitDuration': maxWaitDuration!,
        if (restartJobOnWorkerRestart != null)
          'restartJobOnWorkerRestart': restartJobOnWorkerRestart!,
        if (strategy != null) 'strategy': strategy!,
        if (timeout != null) 'timeout': timeout!,
      };
}

/// Schema is used to define the format of input/output data.
///
/// Represents a select subset of an
/// [OpenAPI 3.0 schema object](https://spec.openapis.org/oas/v3.0.3#schema-object).
/// More fields may be added in the future as needed.
class GoogleCloudAiplatformV1Schema {
  /// The value should be validated against any (one or more) of the subschemas
  /// in the list.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1Schema>? anyOf;

  /// Default value of the data.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? default_;

  /// The description of the data.
  ///
  /// Optional.
  core.String? description;

  /// Possible values of the element of primitive type with enum format.
  ///
  /// Examples: 1. We can define direction as : {type:STRING, format:enum,
  /// enum:\["EAST", NORTH", "SOUTH", "WEST"\]} 2. We can define apartment
  /// number as : {type:INTEGER, format:enum, enum:\["101", "201", "301"\]}
  ///
  /// Optional.
  core.List<core.String>? enum_;

  /// Example of the object.
  ///
  /// Will only populated when the object is the root.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? example;

  /// The format of the data.
  ///
  /// Supported formats: for NUMBER type: "float", "double" for INTEGER type:
  /// "int32", "int64" for STRING type: "email", "byte", etc
  ///
  /// Optional.
  core.String? format;

  /// SCHEMA FIELDS FOR TYPE ARRAY Schema of the elements of Type.ARRAY.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Schema? items;

  /// Maximum number of the elements for Type.ARRAY.
  ///
  /// Optional.
  core.String? maxItems;

  /// Maximum length of the Type.STRING
  ///
  /// Optional.
  core.String? maxLength;

  /// Maximum number of the properties for Type.OBJECT.
  ///
  /// Optional.
  core.String? maxProperties;

  /// Maximum value of the Type.INTEGER and Type.NUMBER
  ///
  /// Optional.
  core.double? maximum;

  /// Minimum number of the elements for Type.ARRAY.
  ///
  /// Optional.
  core.String? minItems;

  /// SCHEMA FIELDS FOR TYPE STRING Minimum length of the Type.STRING
  ///
  /// Optional.
  core.String? minLength;

  /// Minimum number of the properties for Type.OBJECT.
  ///
  /// Optional.
  core.String? minProperties;

  /// SCHEMA FIELDS FOR TYPE INTEGER and NUMBER Minimum value of the
  /// Type.INTEGER and Type.NUMBER
  ///
  /// Optional.
  core.double? minimum;

  /// Indicates if the value may be null.
  ///
  /// Optional.
  core.bool? nullable;

  /// Pattern of the Type.STRING to restrict a string to a regular expression.
  ///
  /// Optional.
  core.String? pattern;

  /// SCHEMA FIELDS FOR TYPE OBJECT Properties of Type.OBJECT.
  ///
  /// Optional.
  core.Map<core.String, GoogleCloudAiplatformV1Schema>? properties;

  /// The order of the properties.
  ///
  /// Not a standard field in open api spec. Only used to support the order of
  /// the properties.
  ///
  /// Optional.
  core.List<core.String>? propertyOrdering;

  /// Required properties of Type.OBJECT.
  ///
  /// Optional.
  core.List<core.String>? required;

  /// The title of the Schema.
  ///
  /// Optional.
  core.String? title;

  /// The type of the data.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Not specified, should not be used.
  /// - "STRING" : OpenAPI string type
  /// - "NUMBER" : OpenAPI number type
  /// - "INTEGER" : OpenAPI integer type
  /// - "BOOLEAN" : OpenAPI boolean type
  /// - "ARRAY" : OpenAPI array type
  /// - "OBJECT" : OpenAPI object type
  core.String? type;

  GoogleCloudAiplatformV1Schema({
    this.anyOf,
    this.default_,
    this.description,
    this.enum_,
    this.example,
    this.format,
    this.items,
    this.maxItems,
    this.maxLength,
    this.maxProperties,
    this.maximum,
    this.minItems,
    this.minLength,
    this.minProperties,
    this.minimum,
    this.nullable,
    this.pattern,
    this.properties,
    this.propertyOrdering,
    this.required,
    this.title,
    this.type,
  });

  GoogleCloudAiplatformV1Schema.fromJson(core.Map json_)
      : this(
          anyOf: (json_['anyOf'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Schema.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          default_: json_['default'],
          description: json_['description'] as core.String?,
          enum_: (json_['enum'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          example: json_['example'],
          format: json_['format'] as core.String?,
          items: json_.containsKey('items')
              ? GoogleCloudAiplatformV1Schema.fromJson(
                  json_['items'] as core.Map<core.String, core.dynamic>)
              : null,
          maxItems: json_['maxItems'] as core.String?,
          maxLength: json_['maxLength'] as core.String?,
          maxProperties: json_['maxProperties'] as core.String?,
          maximum: (json_['maximum'] as core.num?)?.toDouble(),
          minItems: json_['minItems'] as core.String?,
          minLength: json_['minLength'] as core.String?,
          minProperties: json_['minProperties'] as core.String?,
          minimum: (json_['minimum'] as core.num?)?.toDouble(),
          nullable: json_['nullable'] as core.bool?,
          pattern: json_['pattern'] as core.String?,
          properties:
              (json_['properties'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1Schema.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          propertyOrdering: (json_['propertyOrdering'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          required: (json_['required'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          title: json_['title'] as core.String?,
          type: json_['type'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (anyOf != null) 'anyOf': anyOf!,
        if (default_ != null) 'default': default_!,
        if (description != null) 'description': description!,
        if (enum_ != null) 'enum': enum_!,
        if (example != null) 'example': example!,
        if (format != null) 'format': format!,
        if (items != null) 'items': items!,
        if (maxItems != null) 'maxItems': maxItems!,
        if (maxLength != null) 'maxLength': maxLength!,
        if (maxProperties != null) 'maxProperties': maxProperties!,
        if (maximum != null) 'maximum': maximum!,
        if (minItems != null) 'minItems': minItems!,
        if (minLength != null) 'minLength': minLength!,
        if (minProperties != null) 'minProperties': minProperties!,
        if (minimum != null) 'minimum': minimum!,
        if (nullable != null) 'nullable': nullable!,
        if (pattern != null) 'pattern': pattern!,
        if (properties != null) 'properties': properties!,
        if (propertyOrdering != null) 'propertyOrdering': propertyOrdering!,
        if (required != null) 'required': required!,
        if (title != null) 'title': title!,
        if (type != null) 'type': type!,
      };
}

/// Response message for DatasetService.SearchDataItems.
class GoogleCloudAiplatformV1SearchDataItemsResponse {
  /// The DataItemViews read.
  core.List<GoogleCloudAiplatformV1DataItemView>? dataItemViews;

  /// A token to retrieve next page of results.
  ///
  /// Pass to SearchDataItemsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchDataItemsResponse({
    this.dataItemViews,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchDataItemsResponse.fromJson(core.Map json_)
      : this(
          dataItemViews: (json_['dataItemViews'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1DataItemView.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataItemViews != null) 'dataItemViews': dataItemViews!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Google search entry point.
class GoogleCloudAiplatformV1SearchEntryPoint {
  /// Web content snippet that can be embedded in a web page or an app webview.
  ///
  /// Optional.
  core.String? renderedContent;

  /// Base64 encoded JSON representing array of tuple.
  ///
  /// Optional.
  core.String? sdkBlob;
  core.List<core.int> get sdkBlobAsBytes => convert.base64.decode(sdkBlob!);

  set sdkBlobAsBytes(core.List<core.int> bytes_) {
    sdkBlob =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  GoogleCloudAiplatformV1SearchEntryPoint({
    this.renderedContent,
    this.sdkBlob,
  });

  GoogleCloudAiplatformV1SearchEntryPoint.fromJson(core.Map json_)
      : this(
          renderedContent: json_['renderedContent'] as core.String?,
          sdkBlob: json_['sdkBlob'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (renderedContent != null) 'renderedContent': renderedContent!,
        if (sdkBlob != null) 'sdkBlob': sdkBlob!,
      };
}

/// Response message for FeaturestoreService.SearchFeatures.
class GoogleCloudAiplatformV1SearchFeaturesResponse {
  /// The Features matching the request.
  ///
  /// Fields returned: * `name` * `description` * `labels` * `create_time` *
  /// `update_time`
  core.List<GoogleCloudAiplatformV1Feature>? features;

  /// A token, which can be sent as SearchFeaturesRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchFeaturesResponse({
    this.features,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchFeaturesResponse.fromJson(core.Map json_)
      : this(
          features: (json_['features'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Feature.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (features != null) 'features': features!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Request message for MigrationService.SearchMigratableResources.
class GoogleCloudAiplatformV1SearchMigratableResourcesRequest {
  /// A filter for your search.
  ///
  /// You can use the following types of filters: * Resource type filters. The
  /// following strings filter for a specific type of MigratableResource: *
  /// `ml_engine_model_version:*` * `automl_model:*` * `automl_dataset:*` *
  /// `data_labeling_dataset:*` * "Migrated or not" filters. The following
  /// strings filter for resources that either have or have not already been
  /// migrated: * `last_migrate_time:*` filters for migrated resources. * `NOT
  /// last_migrate_time:*` filters for not yet migrated resources.
  core.String? filter;

  /// The standard page size.
  ///
  /// The default and maximum value is 100.
  core.int? pageSize;

  /// The standard page token.
  core.String? pageToken;

  GoogleCloudAiplatformV1SearchMigratableResourcesRequest({
    this.filter,
    this.pageSize,
    this.pageToken,
  });

  GoogleCloudAiplatformV1SearchMigratableResourcesRequest.fromJson(
      core.Map json_)
      : this(
          filter: json_['filter'] as core.String?,
          pageSize: json_['pageSize'] as core.int?,
          pageToken: json_['pageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (pageSize != null) 'pageSize': pageSize!,
        if (pageToken != null) 'pageToken': pageToken!,
      };
}

/// Response message for MigrationService.SearchMigratableResources.
class GoogleCloudAiplatformV1SearchMigratableResourcesResponse {
  /// All migratable resources that can be migrated to the location specified in
  /// the request.
  core.List<GoogleCloudAiplatformV1MigratableResource>? migratableResources;

  /// The standard next-page token.
  ///
  /// The migratable_resources may not fill page_size in
  /// SearchMigratableResourcesRequest even when there are subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchMigratableResourcesResponse({
    this.migratableResources,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchMigratableResourcesResponse.fromJson(
      core.Map json_)
      : this(
          migratableResources: (json_['migratableResources'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1MigratableResource.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (migratableResources != null)
          'migratableResources': migratableResources!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Request message for
/// JobService.SearchModelDeploymentMonitoringStatsAnomalies.
class GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest {
  /// The DeployedModel ID of the
  /// \[ModelDeploymentMonitoringObjectiveConfig.deployed_model_id\].
  ///
  /// Required.
  core.String? deployedModelId;

  /// The latest timestamp of stats being generated.
  ///
  /// If not set, indicates feching stats till the latest possible one.
  core.String? endTime;

  /// The feature display name.
  ///
  /// If specified, only return the stats belonging to this feature. Format:
  /// ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name,
  /// example: "user_destination".
  core.String? featureDisplayName;

  /// Objectives of the stats to retrieve.
  ///
  /// Required.
  core.List<
          GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective>?
      objectives;

  /// The standard list page size.
  core.int? pageSize;

  /// A page token received from a previous
  /// JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
  core.String? pageToken;

  /// The earliest timestamp of stats being generated.
  ///
  /// If not set, indicates fetching stats till the earliest possible one.
  core.String? startTime;

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest({
    this.deployedModelId,
    this.endTime,
    this.featureDisplayName,
    this.objectives,
    this.pageSize,
    this.pageToken,
    this.startTime,
  });

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest.fromJson(
      core.Map json_)
      : this(
          deployedModelId: json_['deployedModelId'] as core.String?,
          endTime: json_['endTime'] as core.String?,
          featureDisplayName: json_['featureDisplayName'] as core.String?,
          objectives: (json_['objectives'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          pageSize: json_['pageSize'] as core.int?,
          pageToken: json_['pageToken'] as core.String?,
          startTime: json_['startTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (endTime != null) 'endTime': endTime!,
        if (featureDisplayName != null)
          'featureDisplayName': featureDisplayName!,
        if (objectives != null) 'objectives': objectives!,
        if (pageSize != null) 'pageSize': pageSize!,
        if (pageToken != null) 'pageToken': pageToken!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Stats requested for specific objective.
class GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective {
  /// If set, all attribution scores between
  /// SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time and
  /// SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time are fetched,
  /// and page token doesn't take effect in this case.
  ///
  /// Only used to retrieve attribution score for the top Features which has the
  /// highest attribution score in the latest monitoring run.
  core.int? topFeatureCount;

  ///
  /// Possible string values are:
  /// - "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" : Default
  /// value, should not be set.
  /// - "RAW_FEATURE_SKEW" : Raw feature values' stats to detect skew between
  /// Training-Prediction datasets.
  /// - "RAW_FEATURE_DRIFT" : Raw feature values' stats to detect drift between
  /// Serving-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_SKEW" : Feature attribution scores to detect skew
  /// between Training-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_DRIFT" : Feature attribution scores to detect skew
  /// between Prediction datasets collected within different time windows.
  core.String? type;

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective({
    this.topFeatureCount,
    this.type,
  });

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective.fromJson(
      core.Map json_)
      : this(
          topFeatureCount: json_['topFeatureCount'] as core.int?,
          type: json_['type'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (topFeatureCount != null) 'topFeatureCount': topFeatureCount!,
        if (type != null) 'type': type!,
      };
}

/// Response message for
/// JobService.SearchModelDeploymentMonitoringStatsAnomalies.
class GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse {
  /// Stats retrieved for requested objectives.
  ///
  /// There are at most 1000
  /// ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats
  /// in the response.
  core.List<GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies>?
      monitoringStats;

  /// The page token that can be used by the next
  /// JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse({
    this.monitoringStats,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
      core.Map json_)
      : this(
          monitoringStats: (json_['monitoringStats'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (monitoringStats != null) 'monitoringStats': monitoringStats!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// The request message for FeatureOnlineStoreService.SearchNearestEntities.
class GoogleCloudAiplatformV1SearchNearestEntitiesRequest {
  /// The query.
  ///
  /// Required.
  GoogleCloudAiplatformV1NearestNeighborQuery? query;

  /// If set to true, the full entities (including all vector values and
  /// metadata) of the nearest neighbors are returned; otherwise only entity id
  /// of the nearest neighbors will be returned.
  ///
  /// Note that returning full entities will significantly increase the latency
  /// and cost of the query.
  ///
  /// Optional.
  core.bool? returnFullEntity;

  GoogleCloudAiplatformV1SearchNearestEntitiesRequest({
    this.query,
    this.returnFullEntity,
  });

  GoogleCloudAiplatformV1SearchNearestEntitiesRequest.fromJson(core.Map json_)
      : this(
          query: json_.containsKey('query')
              ? GoogleCloudAiplatformV1NearestNeighborQuery.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>)
              : null,
          returnFullEntity: json_['returnFullEntity'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (query != null) 'query': query!,
        if (returnFullEntity != null) 'returnFullEntity': returnFullEntity!,
      };
}

/// Response message for FeatureOnlineStoreService.SearchNearestEntities
class GoogleCloudAiplatformV1SearchNearestEntitiesResponse {
  /// The nearest neighbors of the query entity.
  GoogleCloudAiplatformV1NearestNeighbors? nearestNeighbors;

  GoogleCloudAiplatformV1SearchNearestEntitiesResponse({
    this.nearestNeighbors,
  });

  GoogleCloudAiplatformV1SearchNearestEntitiesResponse.fromJson(core.Map json_)
      : this(
          nearestNeighbors: json_.containsKey('nearestNeighbors')
              ? GoogleCloudAiplatformV1NearestNeighbors.fromJson(
                  json_['nearestNeighbors']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nearestNeighbors != null) 'nearestNeighbors': nearestNeighbors!,
      };
}

/// Represents an environment variable where the value is a secret in Cloud
/// Secret Manager.
class GoogleCloudAiplatformV1SecretEnvVar {
  /// Name of the secret environment variable.
  ///
  /// Required.
  core.String? name;

  /// Reference to a secret stored in the Cloud Secret Manager that will provide
  /// the value for this environment variable.
  ///
  /// Required.
  GoogleCloudAiplatformV1SecretRef? secretRef;

  GoogleCloudAiplatformV1SecretEnvVar({
    this.name,
    this.secretRef,
  });

  GoogleCloudAiplatformV1SecretEnvVar.fromJson(core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          secretRef: json_.containsKey('secretRef')
              ? GoogleCloudAiplatformV1SecretRef.fromJson(
                  json_['secretRef'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (secretRef != null) 'secretRef': secretRef!,
      };
}

/// Reference to a secret stored in the Cloud Secret Manager that will provide
/// the value for this environment variable.
typedef GoogleCloudAiplatformV1SecretRef = $Shared05;

/// Segment of the content.
class GoogleCloudAiplatformV1Segment {
  /// End index in the given Part, measured in bytes.
  ///
  /// Offset from the start of the Part, exclusive, starting at zero.
  ///
  /// Output only.
  core.int? endIndex;

  /// The index of a Part object within its parent Content object.
  ///
  /// Output only.
  core.int? partIndex;

  /// Start index in the given Part, measured in bytes.
  ///
  /// Offset from the start of the Part, inclusive, starting at zero.
  ///
  /// Output only.
  core.int? startIndex;

  /// The text corresponding to the segment from the response.
  ///
  /// Output only.
  core.String? text;

  GoogleCloudAiplatformV1Segment({
    this.endIndex,
    this.partIndex,
    this.startIndex,
    this.text,
  });

  GoogleCloudAiplatformV1Segment.fromJson(core.Map json_)
      : this(
          endIndex: json_['endIndex'] as core.int?,
          partIndex: json_['partIndex'] as core.int?,
          startIndex: json_['startIndex'] as core.int?,
          text: json_['text'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endIndex != null) 'endIndex': endIndex!,
        if (partIndex != null) 'partIndex': partIndex!,
        if (startIndex != null) 'startIndex': startIndex!,
        if (text != null) 'text': text!,
      };
}

/// Configuration for the use of custom service account to run the workloads.
class GoogleCloudAiplatformV1ServiceAccountSpec {
  /// If true, custom user-managed service account is enforced to run any
  /// workloads (for example, Vertex Jobs) on the resource.
  ///
  /// Otherwise, uses the
  /// [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  ///
  /// Required.
  core.bool? enableCustomServiceAccount;

  /// Required when all below conditions are met *
  /// `enable_custom_service_account` is true; * any runtime is specified via
  /// `ResourceRuntimeSpec` on creation time, for example, Ray The users must
  /// have `iam.serviceAccounts.actAs` permission on this service account and
  /// then the specified runtime containers will run as it.
  ///
  /// Do not set this field if you want to submit jobs using custom service
  /// account to this PersistentResource after creation, but only specify the
  /// `service_account` inside the job.
  ///
  /// Optional.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1ServiceAccountSpec({
    this.enableCustomServiceAccount,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1ServiceAccountSpec.fromJson(core.Map json_)
      : this(
          enableCustomServiceAccount:
              json_['enableCustomServiceAccount'] as core.bool?,
          serviceAccount: json_['serviceAccount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableCustomServiceAccount != null)
          'enableCustomServiceAccount': enableCustomServiceAccount!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
      };
}

/// The SharePointSources to pass to ImportRagFiles.
class GoogleCloudAiplatformV1SharePointSources {
  /// The SharePoint sources.
  core.List<GoogleCloudAiplatformV1SharePointSourcesSharePointSource>?
      sharePointSources;

  GoogleCloudAiplatformV1SharePointSources({
    this.sharePointSources,
  });

  GoogleCloudAiplatformV1SharePointSources.fromJson(core.Map json_)
      : this(
          sharePointSources: (json_['sharePointSources'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1SharePointSourcesSharePointSource
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sharePointSources != null) 'sharePointSources': sharePointSources!,
      };
}

/// An individual SharePointSource.
class GoogleCloudAiplatformV1SharePointSourcesSharePointSource {
  /// The Application ID for the app registered in Microsoft Azure Portal.
  ///
  /// The application must also be configured with MS Graph permissions
  /// "Files.ReadAll", "Sites.ReadAll" and BrowserSiteLists.Read.All.
  core.String? clientId;

  /// The application secret for the app registered in Azure.
  GoogleCloudAiplatformV1ApiAuthApiKeyConfig? clientSecret;

  /// The ID of the drive to download from.
  core.String? driveId;

  /// The name of the drive to download from.
  core.String? driveName;

  /// The SharePoint file id.
  ///
  /// Output only.
  ///
  /// Output only.
  core.String? fileId;

  /// The ID of the SharePoint folder to download from.
  core.String? sharepointFolderId;

  /// The path of the SharePoint folder to download from.
  core.String? sharepointFolderPath;

  /// The name of the SharePoint site to download from.
  ///
  /// This can be the site name or the site id.
  core.String? sharepointSiteName;

  /// Unique identifier of the Azure Active Directory Instance.
  core.String? tenantId;

  GoogleCloudAiplatformV1SharePointSourcesSharePointSource({
    this.clientId,
    this.clientSecret,
    this.driveId,
    this.driveName,
    this.fileId,
    this.sharepointFolderId,
    this.sharepointFolderPath,
    this.sharepointSiteName,
    this.tenantId,
  });

  GoogleCloudAiplatformV1SharePointSourcesSharePointSource.fromJson(
      core.Map json_)
      : this(
          clientId: json_['clientId'] as core.String?,
          clientSecret: json_.containsKey('clientSecret')
              ? GoogleCloudAiplatformV1ApiAuthApiKeyConfig.fromJson(
                  json_['clientSecret'] as core.Map<core.String, core.dynamic>)
              : null,
          driveId: json_['driveId'] as core.String?,
          driveName: json_['driveName'] as core.String?,
          fileId: json_['fileId'] as core.String?,
          sharepointFolderId: json_['sharepointFolderId'] as core.String?,
          sharepointFolderPath: json_['sharepointFolderPath'] as core.String?,
          sharepointSiteName: json_['sharepointSiteName'] as core.String?,
          tenantId: json_['tenantId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientId != null) 'clientId': clientId!,
        if (clientSecret != null) 'clientSecret': clientSecret!,
        if (driveId != null) 'driveId': driveId!,
        if (driveName != null) 'driveName': driveName!,
        if (fileId != null) 'fileId': fileId!,
        if (sharepointFolderId != null)
          'sharepointFolderId': sharepointFolderId!,
        if (sharepointFolderPath != null)
          'sharepointFolderPath': sharepointFolderPath!,
        if (sharepointSiteName != null)
          'sharepointSiteName': sharepointSiteName!,
        if (tenantId != null) 'tenantId': tenantId!,
      };
}

/// A set of Shielded Instance options.
///
/// See
/// [Images using supported Shielded VM features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
class GoogleCloudAiplatformV1ShieldedVmConfig {
  /// Defines whether the instance has
  /// [Secure Boot](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot)
  /// enabled.
  ///
  /// Secure Boot helps ensure that the system only runs authentic software by
  /// verifying the digital signature of all boot components, and halting the
  /// boot process if signature verification fails.
  core.bool? enableSecureBoot;

  GoogleCloudAiplatformV1ShieldedVmConfig({
    this.enableSecureBoot,
  });

  GoogleCloudAiplatformV1ShieldedVmConfig.fromJson(core.Map json_)
      : this(
          enableSecureBoot: json_['enableSecureBoot'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot!,
      };
}

/// The Slack source for the ImportRagFilesRequest.
class GoogleCloudAiplatformV1SlackSource {
  /// The Slack channels.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1SlackSourceSlackChannels>? channels;

  GoogleCloudAiplatformV1SlackSource({
    this.channels,
  });

  GoogleCloudAiplatformV1SlackSource.fromJson(core.Map json_)
      : this(
          channels: (json_['channels'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1SlackSourceSlackChannels.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (channels != null) 'channels': channels!,
      };
}

/// SlackChannels contains the Slack channels and corresponding access token.
class GoogleCloudAiplatformV1SlackSourceSlackChannels {
  /// The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the Slack
  /// channel access token that has access to the slack channel IDs.
  ///
  /// See: https://api.slack.com/tutorials/tracks/getting-a-token.
  ///
  /// Required.
  GoogleCloudAiplatformV1ApiAuthApiKeyConfig? apiKeyConfig;

  /// The Slack channel IDs.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1SlackSourceSlackChannelsSlackChannel>?
      channels;

  GoogleCloudAiplatformV1SlackSourceSlackChannels({
    this.apiKeyConfig,
    this.channels,
  });

  GoogleCloudAiplatformV1SlackSourceSlackChannels.fromJson(core.Map json_)
      : this(
          apiKeyConfig: json_.containsKey('apiKeyConfig')
              ? GoogleCloudAiplatformV1ApiAuthApiKeyConfig.fromJson(
                  json_['apiKeyConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          channels: (json_['channels'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1SlackSourceSlackChannelsSlackChannel
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!,
        if (channels != null) 'channels': channels!,
      };
}

/// SlackChannel contains the Slack channel ID and the time range to import.
class GoogleCloudAiplatformV1SlackSourceSlackChannelsSlackChannel {
  /// The Slack channel ID.
  ///
  /// Required.
  core.String? channelId;

  /// The ending timestamp for messages to import.
  ///
  /// Optional.
  core.String? endTime;

  /// The starting timestamp for messages to import.
  ///
  /// Optional.
  core.String? startTime;

  GoogleCloudAiplatformV1SlackSourceSlackChannelsSlackChannel({
    this.channelId,
    this.endTime,
    this.startTime,
  });

  GoogleCloudAiplatformV1SlackSourceSlackChannelsSlackChannel.fromJson(
      core.Map json_)
      : this(
          channelId: json_['channelId'] as core.String?,
          endTime: json_['endTime'] as core.String?,
          startTime: json_['startTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (channelId != null) 'channelId': channelId!,
        if (endTime != null) 'endTime': endTime!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// https://arxiv.org/pdf/1706.03825.pdf
class GoogleCloudAiplatformV1SmoothGradConfig {
  /// This is similar to noise_sigma, but provides additional flexibility.
  ///
  /// A separate noise sigma can be provided for each feature, which is useful
  /// if their distributions are different. No noise is added to features that
  /// are not set. If this field is unset, noise_sigma will be used for all
  /// features.
  GoogleCloudAiplatformV1FeatureNoiseSigma? featureNoiseSigma;

  /// This is a single float value and will be used to add noise to all the
  /// features.
  ///
  /// Use this field when all features are normalized to have the same
  /// distribution: scale to range \[0, 1\], \[-1, 1\] or z-scoring, where
  /// features are normalized to have 0-mean and 1-variance. Learn more about
  /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
  /// For best results the recommended value is about 10% - 20% of the standard
  /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
  /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the
  /// distribution is different per feature, set feature_noise_sigma instead for
  /// each feature.
  core.double? noiseSigma;

  /// The number of gradient samples to use for approximation.
  ///
  /// The higher this number, the more accurate the gradient is, but the runtime
  /// complexity increases by this factor as well. Valid range of its value is
  /// \[1, 50\]. Defaults to 3.
  core.int? noisySampleCount;

  GoogleCloudAiplatformV1SmoothGradConfig({
    this.featureNoiseSigma,
    this.noiseSigma,
    this.noisySampleCount,
  });

  GoogleCloudAiplatformV1SmoothGradConfig.fromJson(core.Map json_)
      : this(
          featureNoiseSigma: json_.containsKey('featureNoiseSigma')
              ? GoogleCloudAiplatformV1FeatureNoiseSigma.fromJson(
                  json_['featureNoiseSigma']
                      as core.Map<core.String, core.dynamic>)
              : null,
          noiseSigma: (json_['noiseSigma'] as core.num?)?.toDouble(),
          noisySampleCount: json_['noisySampleCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureNoiseSigma != null) 'featureNoiseSigma': featureNoiseSigma!,
        if (noiseSigma != null) 'noiseSigma': noiseSigma!,
        if (noisySampleCount != null) 'noisySampleCount': noisySampleCount!,
      };
}

/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs.
///
/// It includes a group of specialist managers and workers. Managers are
/// responsible for managing the workers in this pool as well as customers' data
/// labeling jobs associated with this pool. Customers create specialist pool as
/// well as start data labeling jobs on Cloud, managers and workers handle the
/// jobs using CrowdCompute console.
class GoogleCloudAiplatformV1SpecialistPool {
  /// The user-defined name of the SpecialistPool.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. This field should be unique on project-level.
  ///
  /// Required.
  core.String? displayName;

  /// The resource name of the SpecialistPool.
  ///
  /// Required.
  core.String? name;

  /// The resource name of the pending data labeling jobs.
  ///
  /// Output only.
  core.List<core.String>? pendingDataLabelingJobs;

  /// The email addresses of the managers in the SpecialistPool.
  core.List<core.String>? specialistManagerEmails;

  /// The number of managers in this SpecialistPool.
  ///
  /// Output only.
  core.int? specialistManagersCount;

  /// The email addresses of workers in the SpecialistPool.
  core.List<core.String>? specialistWorkerEmails;

  GoogleCloudAiplatformV1SpecialistPool({
    this.displayName,
    this.name,
    this.pendingDataLabelingJobs,
    this.specialistManagerEmails,
    this.specialistManagersCount,
    this.specialistWorkerEmails,
  });

  GoogleCloudAiplatformV1SpecialistPool.fromJson(core.Map json_)
      : this(
          displayName: json_['displayName'] as core.String?,
          name: json_['name'] as core.String?,
          pendingDataLabelingJobs:
              (json_['pendingDataLabelingJobs'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
          specialistManagerEmails:
              (json_['specialistManagerEmails'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
          specialistManagersCount:
              json_['specialistManagersCount'] as core.int?,
          specialistWorkerEmails:
              (json_['specialistWorkerEmails'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
        if (name != null) 'name': name!,
        if (pendingDataLabelingJobs != null)
          'pendingDataLabelingJobs': pendingDataLabelingJobs!,
        if (specialistManagerEmails != null)
          'specialistManagerEmails': specialistManagerEmails!,
        if (specialistManagersCount != null)
          'specialistManagersCount': specialistManagersCount!,
        if (specialistWorkerEmails != null)
          'specialistWorkerEmails': specialistWorkerEmails!,
      };
}

/// Configuration for Speculative Decoding.
class GoogleCloudAiplatformV1SpeculativeDecodingSpec {
  /// draft model speculation.
  GoogleCloudAiplatformV1SpeculativeDecodingSpecDraftModelSpeculation?
      draftModelSpeculation;

  /// N-Gram speculation.
  GoogleCloudAiplatformV1SpeculativeDecodingSpecNgramSpeculation?
      ngramSpeculation;

  /// The number of speculative tokens to generate at each step.
  core.int? speculativeTokenCount;

  GoogleCloudAiplatformV1SpeculativeDecodingSpec({
    this.draftModelSpeculation,
    this.ngramSpeculation,
    this.speculativeTokenCount,
  });

  GoogleCloudAiplatformV1SpeculativeDecodingSpec.fromJson(core.Map json_)
      : this(
          draftModelSpeculation: json_.containsKey('draftModelSpeculation')
              ? GoogleCloudAiplatformV1SpeculativeDecodingSpecDraftModelSpeculation
                  .fromJson(json_['draftModelSpeculation']
                      as core.Map<core.String, core.dynamic>)
              : null,
          ngramSpeculation: json_.containsKey('ngramSpeculation')
              ? GoogleCloudAiplatformV1SpeculativeDecodingSpecNgramSpeculation
                  .fromJson(json_['ngramSpeculation']
                      as core.Map<core.String, core.dynamic>)
              : null,
          speculativeTokenCount: json_['speculativeTokenCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (draftModelSpeculation != null)
          'draftModelSpeculation': draftModelSpeculation!,
        if (ngramSpeculation != null) 'ngramSpeculation': ngramSpeculation!,
        if (speculativeTokenCount != null)
          'speculativeTokenCount': speculativeTokenCount!,
      };
}

/// Draft model speculation works by using the smaller model to generate
/// candidate tokens for speculative decoding.
class GoogleCloudAiplatformV1SpeculativeDecodingSpecDraftModelSpeculation {
  /// The resource name of the draft model.
  ///
  /// Required.
  core.String? draftModel;

  GoogleCloudAiplatformV1SpeculativeDecodingSpecDraftModelSpeculation({
    this.draftModel,
  });

  GoogleCloudAiplatformV1SpeculativeDecodingSpecDraftModelSpeculation.fromJson(
      core.Map json_)
      : this(
          draftModel: json_['draftModel'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (draftModel != null) 'draftModel': draftModel!,
      };
}

/// N-Gram speculation works by trying to find matching tokens in the previous
/// prompt sequence and use those as speculation for generating new tokens.
class GoogleCloudAiplatformV1SpeculativeDecodingSpecNgramSpeculation {
  /// The number of last N input tokens used as ngram to search/match against
  /// the previous prompt sequence.
  ///
  /// This is equal to the N in N-Gram. The default value is 3 if not specified.
  core.int? ngramSize;

  GoogleCloudAiplatformV1SpeculativeDecodingSpecNgramSpeculation({
    this.ngramSize,
  });

  GoogleCloudAiplatformV1SpeculativeDecodingSpecNgramSpeculation.fromJson(
      core.Map json_)
      : this(
          ngramSize: json_['ngramSize'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ngramSize != null) 'ngramSize': ngramSize!,
      };
}

/// The speech generation config.
class GoogleCloudAiplatformV1SpeechConfig {
  /// The configuration for the speaker to use.
  GoogleCloudAiplatformV1VoiceConfig? voiceConfig;

  GoogleCloudAiplatformV1SpeechConfig({
    this.voiceConfig,
  });

  GoogleCloudAiplatformV1SpeechConfig.fromJson(core.Map json_)
      : this(
          voiceConfig: json_.containsKey('voiceConfig')
              ? GoogleCloudAiplatformV1VoiceConfig.fromJson(
                  json_['voiceConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (voiceConfig != null) 'voiceConfig': voiceConfig!,
      };
}

/// Request message for NotebookService.StartNotebookRuntime.
typedef GoogleCloudAiplatformV1StartNotebookRuntimeRequest = $Empty;

/// Request message for NotebookService.StopNotebookRuntime.
typedef GoogleCloudAiplatformV1StopNotebookRuntimeRequest = $Empty;

/// Request message for VizierService.StopTrial.
typedef GoogleCloudAiplatformV1StopTrialRequest = $Empty;

/// Assigns input data to the training, validation, and test sets so that the
/// distribution of values found in the categorical column (as specified by the
/// `key` field) is mirrored within each split.
///
/// The fraction values determine the relative sizes of the splits. For example,
/// if the specified column has three values, with 50% of the rows having value
/// "A", 25% value "B", and 25% value "C", and the split fractions are specified
/// as 80/10/10, then the training set will constitute 80% of the training data,
/// with about 50% of the training set rows having the value "A" for the
/// specified column, about 25% having the value "B", and about 25% having the
/// value "C". Only the top 500 occurring values are used; any values not in the
/// top 500 values are randomly assigned to a split. If less than three rows
/// contain a specific value, those rows are randomly assigned. Supported only
/// for tabular Datasets.
class GoogleCloudAiplatformV1StratifiedSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The key provided must be for a categorical column.
  ///
  /// Required.
  core.String? key;

  /// The fraction of the input data that is to be used to evaluate the Model.
  core.double? testFraction;

  /// The fraction of the input data that is to be used to train the Model.
  core.double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  core.double? validationFraction;

  GoogleCloudAiplatformV1StratifiedSplit({
    this.key,
    this.testFraction,
    this.trainingFraction,
    this.validationFraction,
  });

  GoogleCloudAiplatformV1StratifiedSplit.fromJson(core.Map json_)
      : this(
          key: json_['key'] as core.String?,
          testFraction: (json_['testFraction'] as core.num?)?.toDouble(),
          trainingFraction:
              (json_['trainingFraction'] as core.num?)?.toDouble(),
          validationFraction:
              (json_['validationFraction'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (testFraction != null) 'testFraction': testFraction!,
        if (trainingFraction != null) 'trainingFraction': trainingFraction!,
        if (validationFraction != null)
          'validationFraction': validationFraction!,
      };
}

/// Request message for ReasoningEngineExecutionService.StreamQuery.
class GoogleCloudAiplatformV1StreamQueryReasoningEngineRequest {
  /// Class method to be used for the stream query.
  ///
  /// It is optional and defaults to "stream_query" if unspecified.
  ///
  /// Optional.
  core.String? classMethod;

  /// Input content provided by users in JSON object format.
  ///
  /// Examples include text query, function calling parameters, media bytes,
  /// etc.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? input;

  GoogleCloudAiplatformV1StreamQueryReasoningEngineRequest({
    this.classMethod,
    this.input,
  });

  GoogleCloudAiplatformV1StreamQueryReasoningEngineRequest.fromJson(
      core.Map json_)
      : this(
          classMethod: json_['classMethod'] as core.String?,
          input: json_.containsKey('input')
              ? json_['input'] as core.Map<core.String, core.dynamic>
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (classMethod != null) 'classMethod': classMethod!,
        if (input != null) 'input': input!,
      };
}

/// Request message for PredictionService.StreamRawPredict.
class GoogleCloudAiplatformV1StreamRawPredictRequest {
  /// The prediction input.
  ///
  /// Supports HTTP headers and arbitrary data payload.
  GoogleApiHttpBody? httpBody;

  GoogleCloudAiplatformV1StreamRawPredictRequest({
    this.httpBody,
  });

  GoogleCloudAiplatformV1StreamRawPredictRequest.fromJson(core.Map json_)
      : this(
          httpBody: json_.containsKey('httpBody')
              ? GoogleApiHttpBody.fromJson(
                  json_['httpBody'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (httpBody != null) 'httpBody': httpBody!,
      };
}

/// Request message for PredictionService.StreamingPredict.
///
/// The first message must contain endpoint field and optionally input. The
/// subsequent messages must contain input.
class GoogleCloudAiplatformV1StreamingPredictRequest {
  /// The prediction input.
  core.List<GoogleCloudAiplatformV1Tensor>? inputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1Tensor? parameters;

  GoogleCloudAiplatformV1StreamingPredictRequest({
    this.inputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1StreamingPredictRequest.fromJson(core.Map json_)
      : this(
          inputs: (json_['inputs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputs != null) 'inputs': inputs!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Response message for PredictionService.StreamingPredict.
class GoogleCloudAiplatformV1StreamingPredictResponse {
  /// The prediction output.
  core.List<GoogleCloudAiplatformV1Tensor>? outputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1Tensor? parameters;

  GoogleCloudAiplatformV1StreamingPredictResponse({
    this.outputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1StreamingPredictResponse.fromJson(core.Map json_)
      : this(
          outputs: (json_['outputs'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputs != null) 'outputs': outputs!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Request message for
/// FeaturestoreOnlineServingService.StreamingReadFeatureValues.
class GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest {
  /// IDs of entities to read Feature values of.
  ///
  /// The maximum number of IDs is 100. For example, for a machine learning
  /// model predicting user clicks on a website, an entity ID could be
  /// `user_123`.
  ///
  /// Required.
  core.List<core.String>? entityIds;

  /// Selector choosing Features of the target EntityType.
  ///
  /// Feature IDs will be deduplicated.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest({
    this.entityIds,
    this.featureSelector,
  });

  GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest.fromJson(
      core.Map json_)
      : this(
          entityIds: (json_['entityIds'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityIds != null) 'entityIds': entityIds!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
      };
}

/// A list of string values.
class GoogleCloudAiplatformV1StringArray {
  /// A list of string values.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StringArray({
    this.values,
  });

  GoogleCloudAiplatformV1StringArray.fromJson(core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// One field of a Struct (or object) type feature value.
class GoogleCloudAiplatformV1StructFieldValue {
  /// Name of the field in the struct feature.
  core.String? name;

  /// The value for this field.
  GoogleCloudAiplatformV1FeatureValue? value;

  GoogleCloudAiplatformV1StructFieldValue({
    this.name,
    this.value,
  });

  GoogleCloudAiplatformV1StructFieldValue.fromJson(core.Map json_)
      : this(
          name: json_['name'] as core.String?,
          value: json_.containsKey('value')
              ? GoogleCloudAiplatformV1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// Struct (or object) type feature value.
class GoogleCloudAiplatformV1StructValue {
  /// A list of field values.
  core.List<GoogleCloudAiplatformV1StructFieldValue>? values;

  GoogleCloudAiplatformV1StructValue({
    this.values,
  });

  GoogleCloudAiplatformV1StructValue.fromJson(core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1StructFieldValue.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// A message representing a Study.
class GoogleCloudAiplatformV1Study {
  /// Time at which the study was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Describes the Study, default value is empty string.
  ///
  /// Required.
  core.String? displayName;

  /// A human readable reason why the Study is inactive.
  ///
  /// This should be empty if a study is ACTIVE or COMPLETED.
  ///
  /// Output only.
  core.String? inactiveReason;

  /// The name of a study.
  ///
  /// The study's globally unique identifier. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  ///
  /// Output only.
  core.String? name;

  /// The detailed state of a Study.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The study state is unspecified.
  /// - "ACTIVE" : The study is active.
  /// - "INACTIVE" : The study is stopped due to an internal error.
  /// - "COMPLETED" : The study is done when the service exhausts the parameter
  /// search space or max_trial_count is reached.
  core.String? state;

  /// Configuration of the Study.
  ///
  /// Required.
  GoogleCloudAiplatformV1StudySpec? studySpec;

  GoogleCloudAiplatformV1Study({
    this.createTime,
    this.displayName,
    this.inactiveReason,
    this.name,
    this.state,
    this.studySpec,
  });

  GoogleCloudAiplatformV1Study.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          inactiveReason: json_['inactiveReason'] as core.String?,
          name: json_['name'] as core.String?,
          state: json_['state'] as core.String?,
          studySpec: json_.containsKey('studySpec')
              ? GoogleCloudAiplatformV1StudySpec.fromJson(
                  json_['studySpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (inactiveReason != null) 'inactiveReason': inactiveReason!,
        if (name != null) 'name': name!,
        if (state != null) 'state': state!,
        if (studySpec != null) 'studySpec': studySpec!,
      };
}

/// Represents specification of a Study.
class GoogleCloudAiplatformV1StudySpec {
  /// The search algorithm specified for the Study.
  /// Possible string values are:
  /// - "ALGORITHM_UNSPECIFIED" : The default algorithm used by Vertex AI for
  /// [hyperparameter tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
  /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
  /// - "GRID_SEARCH" : Simple grid search within the feasible space. To use
  /// grid search, all parameters must be `INTEGER`, `CATEGORICAL`, or
  /// `DISCRETE`.
  /// - "RANDOM_SEARCH" : Simple random search within the feasible space.
  core.String? algorithm;

  /// The automated early stopping spec using convex stopping rule.
  GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec?
      convexAutomatedStoppingSpec;

  /// The automated early stopping spec using decay curve rule.
  GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec?
      decayCurveStoppingSpec;

  /// Describe which measurement selection type will be used
  /// Possible string values are:
  /// - "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED" : Will be treated as
  /// LAST_MEASUREMENT.
  /// - "LAST_MEASUREMENT" : Use the last measurement reported.
  /// - "BEST_MEASUREMENT" : Use the best measurement reported.
  core.String? measurementSelectionType;

  /// The automated early stopping spec using median rule.
  GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec?
      medianAutomatedStoppingSpec;

  /// Metric specs for the Study.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1StudySpecMetricSpec>? metrics;

  /// The observation noise level of the study.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  /// Possible string values are:
  /// - "OBSERVATION_NOISE_UNSPECIFIED" : The default noise level chosen by
  /// Vertex AI.
  /// - "LOW" : Vertex AI assumes that the objective function is (nearly)
  /// perfectly reproducible, and will never repeat the same Trial parameters.
  /// - "HIGH" : Vertex AI will estimate the amount of noise in metric
  /// evaluations, it may repeat the same Trial parameters more than once.
  core.String? observationNoise;

  /// The set of parameters to tune.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1StudySpecParameterSpec>? parameters;

  /// Conditions for automated stopping of a Study.
  ///
  /// Enable automated stopping by configuring at least one condition.
  GoogleCloudAiplatformV1StudySpecStudyStoppingConfig? studyStoppingConfig;

  GoogleCloudAiplatformV1StudySpec({
    this.algorithm,
    this.convexAutomatedStoppingSpec,
    this.decayCurveStoppingSpec,
    this.measurementSelectionType,
    this.medianAutomatedStoppingSpec,
    this.metrics,
    this.observationNoise,
    this.parameters,
    this.studyStoppingConfig,
  });

  GoogleCloudAiplatformV1StudySpec.fromJson(core.Map json_)
      : this(
          algorithm: json_['algorithm'] as core.String?,
          convexAutomatedStoppingSpec:
              json_.containsKey('convexAutomatedStoppingSpec')
                  ? GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
                      .fromJson(json_['convexAutomatedStoppingSpec']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          decayCurveStoppingSpec: json_.containsKey('decayCurveStoppingSpec')
              ? GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec
                  .fromJson(json_['decayCurveStoppingSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          measurementSelectionType:
              json_['measurementSelectionType'] as core.String?,
          medianAutomatedStoppingSpec:
              json_.containsKey('medianAutomatedStoppingSpec')
                  ? GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec
                      .fromJson(json_['medianAutomatedStoppingSpec']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          metrics: (json_['metrics'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1StudySpecMetricSpec.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          observationNoise: json_['observationNoise'] as core.String?,
          parameters: (json_['parameters'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1StudySpecParameterSpec.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          studyStoppingConfig: json_.containsKey('studyStoppingConfig')
              ? GoogleCloudAiplatformV1StudySpecStudyStoppingConfig.fromJson(
                  json_['studyStoppingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (algorithm != null) 'algorithm': algorithm!,
        if (convexAutomatedStoppingSpec != null)
          'convexAutomatedStoppingSpec': convexAutomatedStoppingSpec!,
        if (decayCurveStoppingSpec != null)
          'decayCurveStoppingSpec': decayCurveStoppingSpec!,
        if (measurementSelectionType != null)
          'measurementSelectionType': measurementSelectionType!,
        if (medianAutomatedStoppingSpec != null)
          'medianAutomatedStoppingSpec': medianAutomatedStoppingSpec!,
        if (metrics != null) 'metrics': metrics!,
        if (observationNoise != null) 'observationNoise': observationNoise!,
        if (parameters != null) 'parameters': parameters!,
        if (studyStoppingConfig != null)
          'studyStoppingConfig': studyStoppingConfig!,
      };
}

/// Configuration for ConvexAutomatedStoppingSpec.
///
/// When there are enough completed trials (configured by
/// min_measurement_count), for pending trials with enough measurements and
/// steps, the policy first computes an overestimate of the objective value at
/// max_num_steps according to the slope of the incomplete objective value
/// curve. No prediction can be made if the curve is completely flat. If the
/// overestimation is worse than the best objective value of the completed
/// trials, this pending trial will be early-stopped, but a last measurement
/// will be added to the pending trial with max_num_steps and predicted
/// objective value from the autoregression model.
class GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec {
  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate.
  ///
  /// Leave it blank if learning rate is not in a parameter in tuning. The
  /// learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  core.String? learningRateParameterName;

  /// Steps used in predicting the final objective for early stopped trials.
  ///
  /// In general, it's set to be the same as the defined steps in training /
  /// tuning. If not defined, it will learn it from the completed trials. When
  /// use_steps is false, this field is set to the maximum elapsed seconds.
  core.String? maxStepCount;

  /// The minimal number of measurements in a Trial.
  ///
  /// Early-stopping checks will not trigger if less than
  /// min_measurement_count+1 completed trials or pending trials with less than
  /// min_measurement_count measurements. If not defined, the default value is
  /// 5.
  core.String? minMeasurementCount;

  /// Minimum number of steps for a trial to complete.
  ///
  /// Trials which do not have a measurement with step_count \> min_step_count
  /// won't be considered for early stopping. It's ok to set it to 0, and a
  /// trial can be early stopped at any stage. By default, min_step_count is set
  /// to be one-tenth of the max_step_count. When use_elapsed_duration is true,
  /// this field is set to the minimum elapsed seconds.
  core.String? minStepCount;

  /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
  /// to be early stopped using a newly trained auto-regressive model.
  ///
  /// When this flag is set to True, all stopped trials from the beginning are
  /// potentially updated in terms of their `final_measurement`. Also, note that
  /// the training logic of autoregressive models is different in this case.
  /// Enabling this option has shown better results and this may be the default
  /// option in the future.
  core.bool? updateAllStoppedTrials;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps.
  ///
  /// If use_elapsed_duration==false, the early stopping decision is made
  /// according to the predicted objective values according to the target steps.
  /// If use_elapsed_duration==true, elapsed_secs is used instead of steps.
  /// Also, in this case, the parameters max_num_steps and min_num_steps are
  /// overloaded to contain max_elapsed_seconds and min_elapsed_seconds.
  core.bool? useElapsedDuration;

  GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec({
    this.learningRateParameterName,
    this.maxStepCount,
    this.minMeasurementCount,
    this.minStepCount,
    this.updateAllStoppedTrials,
    this.useElapsedDuration,
  });

  GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.fromJson(
      core.Map json_)
      : this(
          learningRateParameterName:
              json_['learningRateParameterName'] as core.String?,
          maxStepCount: json_['maxStepCount'] as core.String?,
          minMeasurementCount: json_['minMeasurementCount'] as core.String?,
          minStepCount: json_['minStepCount'] as core.String?,
          updateAllStoppedTrials: json_['updateAllStoppedTrials'] as core.bool?,
          useElapsedDuration: json_['useElapsedDuration'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (learningRateParameterName != null)
          'learningRateParameterName': learningRateParameterName!,
        if (maxStepCount != null) 'maxStepCount': maxStepCount!,
        if (minMeasurementCount != null)
          'minMeasurementCount': minMeasurementCount!,
        if (minStepCount != null) 'minStepCount': minStepCount!,
        if (updateAllStoppedTrials != null)
          'updateAllStoppedTrials': updateAllStoppedTrials!,
        if (useElapsedDuration != null)
          'useElapsedDuration': useElapsedDuration!,
      };
}

/// The decay curve automated stopping rule builds a Gaussian Process Regressor
/// to predict the final objective value of a Trial based on the already
/// completed Trials and the intermediate measurements of the current Trial.
///
/// Early stopping is requested for the current Trial if there is very low
/// probability to exceed the optimal value found so far.
class GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec {
  /// True if Measurement.elapsed_duration is used as the x-axis of each Trials
  /// Decay Curve.
  ///
  /// Otherwise, Measurement.step_count will be used as the x-axis.
  core.bool? useElapsedDuration;

  GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec({
    this.useElapsedDuration,
  });

  GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec.fromJson(
      core.Map json_)
      : this(
          useElapsedDuration: json_['useElapsedDuration'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useElapsedDuration != null)
          'useElapsedDuration': useElapsedDuration!,
      };
}

/// The median automated stopping rule stops a pending Trial if the Trial's best
/// objective_value is strictly below the median 'performance' of all completed
/// Trials reported up to the Trial's last measurement.
///
/// Currently, 'performance' refers to the running average of the objective
/// values reported by the Trial in each measurement.
class GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec {
  /// True if median automated stopping rule applies on
  /// Measurement.elapsed_duration.
  ///
  /// It means that elapsed_duration field of latest measurement of current
  /// Trial is used to compute median objective value for each completed Trials.
  core.bool? useElapsedDuration;

  GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec({
    this.useElapsedDuration,
  });

  GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec.fromJson(
      core.Map json_)
      : this(
          useElapsedDuration: json_['useElapsedDuration'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useElapsedDuration != null)
          'useElapsedDuration': useElapsedDuration!,
      };
}

/// Represents a metric to optimize.
class GoogleCloudAiplatformV1StudySpecMetricSpec {
  /// The optimization goal of the metric.
  ///
  /// Required.
  /// Possible string values are:
  /// - "GOAL_TYPE_UNSPECIFIED" : Goal Type will default to maximize.
  /// - "MAXIMIZE" : Maximize the goal metric.
  /// - "MINIMIZE" : Minimize the goal metric.
  core.String? goal;

  /// The ID of the metric.
  ///
  /// Must not contain whitespaces and must be unique amongst all MetricSpecs.
  ///
  /// Required.
  core.String? metricId;

  /// Used for safe search.
  ///
  /// In the case, the metric will be a safety metric. You must provide a
  /// separate metric for objective metric.
  GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig? safetyConfig;

  GoogleCloudAiplatformV1StudySpecMetricSpec({
    this.goal,
    this.metricId,
    this.safetyConfig,
  });

  GoogleCloudAiplatformV1StudySpecMetricSpec.fromJson(core.Map json_)
      : this(
          goal: json_['goal'] as core.String?,
          metricId: json_['metricId'] as core.String?,
          safetyConfig: json_.containsKey('safetyConfig')
              ? GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig
                  .fromJson(json_['safetyConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (goal != null) 'goal': goal!,
        if (metricId != null) 'metricId': metricId!,
        if (safetyConfig != null) 'safetyConfig': safetyConfig!,
      };
}

/// Used in safe optimization to specify threshold levels and risk tolerance.
class GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig {
  /// Desired minimum fraction of safe trials (over total number of trials) that
  /// should be targeted by the algorithm at any time during the study (best
  /// effort).
  ///
  /// This should be between 0.0 and 1.0 and a value of 0.0 means that there is
  /// no minimum and an algorithm proceeds without targeting any specific
  /// fraction. A value of 1.0 means that the algorithm attempts to only Suggest
  /// safe Trials.
  core.double? desiredMinSafeTrialsFraction;

  /// Safety threshold (boundary value between safe and unsafe).
  ///
  /// NOTE that if you leave SafetyMetricConfig unset, a default value of 0 will
  /// be used.
  core.double? safetyThreshold;

  GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig({
    this.desiredMinSafeTrialsFraction,
    this.safetyThreshold,
  });

  GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig.fromJson(
      core.Map json_)
      : this(
          desiredMinSafeTrialsFraction:
              (json_['desiredMinSafeTrialsFraction'] as core.num?)?.toDouble(),
          safetyThreshold: (json_['safetyThreshold'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (desiredMinSafeTrialsFraction != null)
          'desiredMinSafeTrialsFraction': desiredMinSafeTrialsFraction!,
        if (safetyThreshold != null) 'safetyThreshold': safetyThreshold!,
      };
}

/// Represents a single parameter to optimize.
class GoogleCloudAiplatformV1StudySpecParameterSpec {
  /// The value spec for a 'CATEGORICAL' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec?
      categoricalValueSpec;

  /// A conditional parameter node is active if the parameter's value matches
  /// the conditional node's parent_value_condition.
  ///
  /// If two items in conditional_parameter_specs have the same name, they must
  /// have disjoint parent_value_condition.
  core.List<
          GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec>?
      conditionalParameterSpecs;

  /// The value spec for a 'DISCRETE' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec?
      discreteValueSpec;

  /// The value spec for a 'DOUBLE' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec? doubleValueSpec;

  /// The value spec for an 'INTEGER' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec?
      integerValueSpec;

  /// The ID of the parameter.
  ///
  /// Must not contain whitespaces and must be unique amongst all
  /// ParameterSpecs.
  ///
  /// Required.
  core.String? parameterId;

  /// How the parameter should be scaled.
  ///
  /// Leave unset for `CATEGORICAL` parameters.
  /// Possible string values are:
  /// - "SCALE_TYPE_UNSPECIFIED" : By default, no scaling is applied.
  /// - "UNIT_LINEAR_SCALE" : Scales the feasible space to (0, 1) linearly.
  /// - "UNIT_LOG_SCALE" : Scales the feasible space logarithmically to (0, 1).
  /// The entire feasible space must be strictly positive.
  /// - "UNIT_REVERSE_LOG_SCALE" : Scales the feasible space "reverse"
  /// logarithmically to (0, 1). The result is that values close to the top of
  /// the feasible space are spread out more than points near the bottom. The
  /// entire feasible space must be strictly positive.
  core.String? scaleType;

  GoogleCloudAiplatformV1StudySpecParameterSpec({
    this.categoricalValueSpec,
    this.conditionalParameterSpecs,
    this.discreteValueSpec,
    this.doubleValueSpec,
    this.integerValueSpec,
    this.parameterId,
    this.scaleType,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpec.fromJson(core.Map json_)
      : this(
          categoricalValueSpec: json_.containsKey('categoricalValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec
                  .fromJson(json_['categoricalValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          conditionalParameterSpecs: (json_['conditionalParameterSpecs']
                  as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          discreteValueSpec: json_.containsKey('discreteValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec
                  .fromJson(json_['discreteValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          doubleValueSpec: json_.containsKey('doubleValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec
                  .fromJson(json_['doubleValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          integerValueSpec: json_.containsKey('integerValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec
                  .fromJson(json_['integerValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          parameterId: json_['parameterId'] as core.String?,
          scaleType: json_['scaleType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (categoricalValueSpec != null)
          'categoricalValueSpec': categoricalValueSpec!,
        if (conditionalParameterSpecs != null)
          'conditionalParameterSpecs': conditionalParameterSpecs!,
        if (discreteValueSpec != null) 'discreteValueSpec': discreteValueSpec!,
        if (doubleValueSpec != null) 'doubleValueSpec': doubleValueSpec!,
        if (integerValueSpec != null) 'integerValueSpec': integerValueSpec!,
        if (parameterId != null) 'parameterId': parameterId!,
        if (scaleType != null) 'scaleType': scaleType!,
      };
}

/// Value specification for a parameter in `CATEGORICAL` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec {
  /// A default value for a `CATEGORICAL` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.String? defaultValue;

  /// The list of possible categories.
  ///
  /// Required.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec({
    this.defaultValue,
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: json_['defaultValue'] as core.String?,
          values: (json_['values'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (values != null) 'values': values!,
      };
}

/// Represents a parameter spec with condition from its parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec {
  /// The spec for a conditional parameter.
  ///
  /// Required.
  GoogleCloudAiplatformV1StudySpecParameterSpec? parameterSpec;

  /// The spec for matching values from a parent parameter of `CATEGORICAL`
  /// type.
  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition?
      parentCategoricalValues;

  /// The spec for matching values from a parent parameter of `DISCRETE` type.
  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition?
      parentDiscreteValues;

  /// The spec for matching values from a parent parameter of `INTEGER` type.
  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition?
      parentIntValues;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec({
    this.parameterSpec,
    this.parentCategoricalValues,
    this.parentDiscreteValues,
    this.parentIntValues,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec.fromJson(
      core.Map json_)
      : this(
          parameterSpec: json_.containsKey('parameterSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpec.fromJson(
                  json_['parameterSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          parentCategoricalValues: json_.containsKey('parentCategoricalValues')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition
                  .fromJson(json_['parentCategoricalValues']
                      as core.Map<core.String, core.dynamic>)
              : null,
          parentDiscreteValues: json_.containsKey('parentDiscreteValues')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition
                  .fromJson(json_['parentDiscreteValues']
                      as core.Map<core.String, core.dynamic>)
              : null,
          parentIntValues: json_.containsKey('parentIntValues')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition
                  .fromJson(json_['parentIntValues']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parameterSpec != null) 'parameterSpec': parameterSpec!,
        if (parentCategoricalValues != null)
          'parentCategoricalValues': parentCategoricalValues!,
        if (parentDiscreteValues != null)
          'parentDiscreteValues': parentDiscreteValues!,
        if (parentIntValues != null) 'parentIntValues': parentIntValues!,
      };
}

/// Represents the spec to match categorical values from parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition {
  /// Matches values of the parent parameter of 'CATEGORICAL' type.
  ///
  /// All values must exist in `categorical_value_spec` of parent parameter.
  ///
  /// Required.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition({
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition.fromJson(
      core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Represents the spec to match discrete values from parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition {
  /// Matches values of the parent parameter of 'DISCRETE' type.
  ///
  /// All values must exist in `discrete_value_spec` of parent parameter. The
  /// Epsilon of the value matching is 1e-10.
  ///
  /// Required.
  core.List<core.double>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition({
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition.fromJson(
      core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Represents the spec to match integer values from parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition {
  /// Matches values of the parent parameter of 'INTEGER' type.
  ///
  /// All values must lie in `integer_value_spec` of parent parameter.
  ///
  /// Required.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition({
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition.fromJson(
      core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Value specification for a parameter in `DISCRETE` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec {
  /// A default value for a `DISCRETE` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. It
  /// automatically rounds to the nearest feasible discrete point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.double? defaultValue;

  /// A list of possible values.
  ///
  /// The list should be in increasing order and at least 1e-10 apart. For
  /// instance, this parameter might have possible settings of 1.5, 2.5, and
  /// 4.0. This list should not contain more than 1,000 values.
  ///
  /// Required.
  core.List<core.double>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec({
    this.defaultValue,
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: (json_['defaultValue'] as core.num?)?.toDouble(),
          values: (json_['values'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (values != null) 'values': values!,
      };
}

/// Value specification for a parameter in `DOUBLE` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec {
  /// A default value for a `DOUBLE` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.double? defaultValue;

  /// Inclusive maximum value of the parameter.
  ///
  /// Required.
  core.double? maxValue;

  /// Inclusive minimum value of the parameter.
  ///
  /// Required.
  core.double? minValue;

  GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec({
    this.defaultValue,
    this.maxValue,
    this.minValue,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: (json_['defaultValue'] as core.num?)?.toDouble(),
          maxValue: (json_['maxValue'] as core.num?)?.toDouble(),
          minValue: (json_['minValue'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (maxValue != null) 'maxValue': maxValue!,
        if (minValue != null) 'minValue': minValue!,
      };
}

/// Value specification for a parameter in `INTEGER` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec {
  /// A default value for an `INTEGER` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.String? defaultValue;

  /// Inclusive maximum value of the parameter.
  ///
  /// Required.
  core.String? maxValue;

  /// Inclusive minimum value of the parameter.
  ///
  /// Required.
  core.String? minValue;

  GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec({
    this.defaultValue,
    this.maxValue,
    this.minValue,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: json_['defaultValue'] as core.String?,
          maxValue: json_['maxValue'] as core.String?,
          minValue: json_['minValue'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (maxValue != null) 'maxValue': maxValue!,
        if (minValue != null) 'minValue': minValue!,
      };
}

/// The configuration (stopping conditions) for automated stopping of a Study.
///
/// Conditions include trial budgets, time budgets, and convergence detection.
class GoogleCloudAiplatformV1StudySpecStudyStoppingConfig {
  /// If the objective value has not improved for this much time, stop the
  /// study.
  ///
  /// WARNING: Effective only for single-objective studies.
  core.String? maxDurationNoProgress;

  /// If there are more than this many trials, stop the study.
  core.int? maxNumTrials;

  /// If the objective value has not improved for this many consecutive trials,
  /// stop the study.
  ///
  /// WARNING: Effective only for single-objective studies.
  core.int? maxNumTrialsNoProgress;

  /// If the specified time or duration has passed, stop the study.
  GoogleCloudAiplatformV1StudyTimeConstraint? maximumRuntimeConstraint;

  /// If there are fewer than this many COMPLETED trials, do not stop the study.
  core.int? minNumTrials;

  /// Each "stopping rule" in this proto specifies an "if" condition.
  ///
  /// Before Vizier would generate a new suggestion, it first checks each
  /// specified stopping rule, from top to bottom in this list. Note that the
  /// first few rules (e.g. minimum_runtime_constraint, min_num_trials) will
  /// prevent other stopping rules from being evaluated until they are met. For
  /// example, setting `min_num_trials=5` and `always_stop_after= 1 hour` means
  /// that the Study will ONLY stop after it has 5 COMPLETED trials, even if
  /// more than an hour has passed since its creation. It follows the first
  /// applicable rule (whose "if" condition is satisfied) to make a stopping
  /// decision. If none of the specified rules are applicable, then Vizier
  /// decides that the study should not stop. If Vizier decides that the study
  /// should stop, the study enters STOPPING state (or STOPPING_ASAP if
  /// should_stop_asap = true). IMPORTANT: The automatic study state transition
  /// happens precisely as described above; that is, deleting trials or updating
  /// StudyConfig NEVER automatically moves the study state back to ACTIVE. If
  /// you want to _resume_ a Study that was stopped, 1) change the stopping
  /// conditions if necessary, 2) activate the study, and then 3) ask for
  /// suggestions. If the specified time or duration has not passed, do not stop
  /// the study.
  GoogleCloudAiplatformV1StudyTimeConstraint? minimumRuntimeConstraint;

  /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
  /// STOPPING state.
  ///
  /// The bottom line is: set to true if you want to interrupt on-going
  /// evaluations of Trials as soon as the study stopping condition is met.
  /// (Please see Study.State documentation for the source of truth).
  core.bool? shouldStopAsap;

  GoogleCloudAiplatformV1StudySpecStudyStoppingConfig({
    this.maxDurationNoProgress,
    this.maxNumTrials,
    this.maxNumTrialsNoProgress,
    this.maximumRuntimeConstraint,
    this.minNumTrials,
    this.minimumRuntimeConstraint,
    this.shouldStopAsap,
  });

  GoogleCloudAiplatformV1StudySpecStudyStoppingConfig.fromJson(core.Map json_)
      : this(
          maxDurationNoProgress: json_['maxDurationNoProgress'] as core.String?,
          maxNumTrials: json_['maxNumTrials'] as core.int?,
          maxNumTrialsNoProgress: json_['maxNumTrialsNoProgress'] as core.int?,
          maximumRuntimeConstraint:
              json_.containsKey('maximumRuntimeConstraint')
                  ? GoogleCloudAiplatformV1StudyTimeConstraint.fromJson(
                      json_['maximumRuntimeConstraint']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          minNumTrials: json_['minNumTrials'] as core.int?,
          minimumRuntimeConstraint:
              json_.containsKey('minimumRuntimeConstraint')
                  ? GoogleCloudAiplatformV1StudyTimeConstraint.fromJson(
                      json_['minimumRuntimeConstraint']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          shouldStopAsap: json_['shouldStopAsap'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxDurationNoProgress != null)
          'maxDurationNoProgress': maxDurationNoProgress!,
        if (maxNumTrials != null) 'maxNumTrials': maxNumTrials!,
        if (maxNumTrialsNoProgress != null)
          'maxNumTrialsNoProgress': maxNumTrialsNoProgress!,
        if (maximumRuntimeConstraint != null)
          'maximumRuntimeConstraint': maximumRuntimeConstraint!,
        if (minNumTrials != null) 'minNumTrials': minNumTrials!,
        if (minimumRuntimeConstraint != null)
          'minimumRuntimeConstraint': minimumRuntimeConstraint!,
        if (shouldStopAsap != null) 'shouldStopAsap': shouldStopAsap!,
      };
}

/// Time-based Constraint for Study
class GoogleCloudAiplatformV1StudyTimeConstraint {
  /// Compares the wallclock time to this time.
  ///
  /// Must use UTC timezone.
  core.String? endTime;

  /// Counts the wallclock time passed since the creation of this Study.
  core.String? maxDuration;

  GoogleCloudAiplatformV1StudyTimeConstraint({
    this.endTime,
    this.maxDuration,
  });

  GoogleCloudAiplatformV1StudyTimeConstraint.fromJson(core.Map json_)
      : this(
          endTime: json_['endTime'] as core.String?,
          maxDuration: json_['maxDuration'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endTime != null) 'endTime': endTime!,
        if (maxDuration != null) 'maxDuration': maxDuration!,
      };
}

/// Request message for VizierService.SuggestTrials.
class GoogleCloudAiplatformV1SuggestTrialsRequest {
  /// The identifier of the client that is requesting the suggestion.
  ///
  /// If multiple SuggestTrialsRequests have the same `client_id`, the service
  /// will return the identical suggested Trial if the Trial is pending, and
  /// provide a new Trial if the last suggested Trial was completed.
  ///
  /// Required.
  core.String? clientId;

  /// This allows you to specify the "context" for a Trial; a context is a slice
  /// (a subspace) of the search space.
  ///
  /// Typical uses for contexts: 1) You are using Vizier to tune a server for
  /// best performance, but there's a strong weekly cycle. The context specifies
  /// the day-of-week. This allows Tuesday to generalize from Wednesday without
  /// assuming that everything is identical. 2) Imagine you're optimizing some
  /// medical treatment for people. As they walk in the door, you know certain
  /// facts about them (e.g. sex, weight, height, blood-pressure). Put that
  /// information in the context, and Vizier will adapt its suggestions to the
  /// patient. 3) You want to do a fair A/B test efficiently. Specify the "A"
  /// and "B" conditions as contexts, and Vizier will generalize between "A" and
  /// "B" conditions. If they are similar, this will allow Vizier to converge to
  /// the optimum faster than if "A" and "B" were separate Studies. NOTE: You
  /// can also enter contexts as REQUESTED Trials, e.g. via the CreateTrial()
  /// RPC; that's the asynchronous option where you don't need a close
  /// association between contexts and suggestions. NOTE: All the Parameters you
  /// set in a context MUST be defined in the Study. NOTE: You must supply 0 or
  /// $suggestion_count contexts. If you don't supply any contexts, Vizier will
  /// make suggestions from the full search space specified in the StudySpec; if
  /// you supply a full set of context, each suggestion will match the
  /// corresponding context. NOTE: A Context with no features set matches
  /// anything, and allows suggestions from the full search space. NOTE:
  /// Contexts MUST lie within the search space specified in the StudySpec. It's
  /// an error if they don't. NOTE: Contexts preferentially match ACTIVE then
  /// REQUESTED trials before new suggestions are generated. NOTE: Generation of
  /// suggestions involves a match between a Context and (optionally) a
  /// REQUESTED trial; if that match is not fully specified, a suggestion will
  /// be geneated in the merged subspace.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1TrialContext>? contexts;

  /// The number of suggestions requested.
  ///
  /// It must be positive.
  ///
  /// Required.
  core.int? suggestionCount;

  GoogleCloudAiplatformV1SuggestTrialsRequest({
    this.clientId,
    this.contexts,
    this.suggestionCount,
  });

  GoogleCloudAiplatformV1SuggestTrialsRequest.fromJson(core.Map json_)
      : this(
          clientId: json_['clientId'] as core.String?,
          contexts: (json_['contexts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TrialContext.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          suggestionCount: json_['suggestionCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientId != null) 'clientId': clientId!,
        if (contexts != null) 'contexts': contexts!,
        if (suggestionCount != null) 'suggestionCount': suggestionCount!,
      };
}

/// Input for summarization helpfulness metric.
class GoogleCloudAiplatformV1SummarizationHelpfulnessInput {
  /// Summarization helpfulness instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1SummarizationHelpfulnessInstance? instance;

  /// Spec for summarization helpfulness score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1SummarizationHelpfulnessSpec? metricSpec;

  GoogleCloudAiplatformV1SummarizationHelpfulnessInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1SummarizationHelpfulnessInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1SummarizationHelpfulnessInstance
                  .fromJson(
                      json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1SummarizationHelpfulnessSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for summarization helpfulness instance.
typedef GoogleCloudAiplatformV1SummarizationHelpfulnessInstance = $Instance04;

/// Spec for summarization helpfulness result.
class GoogleCloudAiplatformV1SummarizationHelpfulnessResult {
  /// Confidence for summarization helpfulness score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization helpfulness score.
  ///
  /// Output only.
  core.String? explanation;

  /// Summarization Helpfulness score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1SummarizationHelpfulnessResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1SummarizationHelpfulnessResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for summarization helpfulness score metric.
class GoogleCloudAiplatformV1SummarizationHelpfulnessSpec {
  /// Whether to use instance.reference to compute summarization helpfulness.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  GoogleCloudAiplatformV1SummarizationHelpfulnessSpec({
    this.useReference,
    this.version,
  });

  GoogleCloudAiplatformV1SummarizationHelpfulnessSpec.fromJson(core.Map json_)
      : this(
          useReference: json_['useReference'] as core.bool?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useReference != null) 'useReference': useReference!,
        if (version != null) 'version': version!,
      };
}

/// Input for summarization quality metric.
class GoogleCloudAiplatformV1SummarizationQualityInput {
  /// Summarization quality instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1SummarizationQualityInstance? instance;

  /// Spec for summarization quality score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1SummarizationQualitySpec? metricSpec;

  GoogleCloudAiplatformV1SummarizationQualityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1SummarizationQualityInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1SummarizationQualityInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1SummarizationQualitySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for summarization quality instance.
class GoogleCloudAiplatformV1SummarizationQualityInstance {
  /// Text to be summarized.
  ///
  /// Required.
  core.String? context;

  /// Summarization prompt for LLM.
  ///
  /// Required.
  core.String? instruction;

  /// Output of the evaluated model.
  ///
  /// Required.
  core.String? prediction;

  /// Ground truth used to compare against the prediction.
  ///
  /// Optional.
  core.String? reference;

  GoogleCloudAiplatformV1SummarizationQualityInstance({
    this.context,
    this.instruction,
    this.prediction,
    this.reference,
  });

  GoogleCloudAiplatformV1SummarizationQualityInstance.fromJson(core.Map json_)
      : this(
          context: json_['context'] as core.String?,
          instruction: json_['instruction'] as core.String?,
          prediction: json_['prediction'] as core.String?,
          reference: json_['reference'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (context != null) 'context': context!,
        if (instruction != null) 'instruction': instruction!,
        if (prediction != null) 'prediction': prediction!,
        if (reference != null) 'reference': reference!,
      };
}

/// Spec for summarization quality result.
class GoogleCloudAiplatformV1SummarizationQualityResult {
  /// Confidence for summarization quality score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization quality score.
  ///
  /// Output only.
  core.String? explanation;

  /// Summarization Quality score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1SummarizationQualityResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1SummarizationQualityResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for summarization quality score metric.
class GoogleCloudAiplatformV1SummarizationQualitySpec {
  /// Whether to use instance.reference to compute summarization quality.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  GoogleCloudAiplatformV1SummarizationQualitySpec({
    this.useReference,
    this.version,
  });

  GoogleCloudAiplatformV1SummarizationQualitySpec.fromJson(core.Map json_)
      : this(
          useReference: json_['useReference'] as core.bool?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useReference != null) 'useReference': useReference!,
        if (version != null) 'version': version!,
      };
}

/// Input for summarization verbosity metric.
class GoogleCloudAiplatformV1SummarizationVerbosityInput {
  /// Summarization verbosity instance.
  ///
  /// Required.
  GoogleCloudAiplatformV1SummarizationVerbosityInstance? instance;

  /// Spec for summarization verbosity score metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1SummarizationVerbositySpec? metricSpec;

  GoogleCloudAiplatformV1SummarizationVerbosityInput({
    this.instance,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1SummarizationVerbosityInput.fromJson(core.Map json_)
      : this(
          instance: json_.containsKey('instance')
              ? GoogleCloudAiplatformV1SummarizationVerbosityInstance.fromJson(
                  json_['instance'] as core.Map<core.String, core.dynamic>)
              : null,
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1SummarizationVerbositySpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instance != null) 'instance': instance!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for summarization verbosity instance.
typedef GoogleCloudAiplatformV1SummarizationVerbosityInstance = $Instance04;

/// Spec for summarization verbosity result.
class GoogleCloudAiplatformV1SummarizationVerbosityResult {
  /// Confidence for summarization verbosity score.
  ///
  /// Output only.
  core.double? confidence;

  /// Explanation for summarization verbosity score.
  ///
  /// Output only.
  core.String? explanation;

  /// Summarization Verbosity score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1SummarizationVerbosityResult({
    this.confidence,
    this.explanation,
    this.score,
  });

  GoogleCloudAiplatformV1SummarizationVerbosityResult.fromJson(core.Map json_)
      : this(
          confidence: (json_['confidence'] as core.num?)?.toDouble(),
          explanation: json_['explanation'] as core.String?,
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (confidence != null) 'confidence': confidence!,
        if (explanation != null) 'explanation': explanation!,
        if (score != null) 'score': score!,
      };
}

/// Spec for summarization verbosity score metric.
class GoogleCloudAiplatformV1SummarizationVerbositySpec {
  /// Whether to use instance.reference to compute summarization verbosity.
  ///
  /// Optional.
  core.bool? useReference;

  /// Which version to use for evaluation.
  ///
  /// Optional.
  core.int? version;

  GoogleCloudAiplatformV1SummarizationVerbositySpec({
    this.useReference,
    this.version,
  });

  GoogleCloudAiplatformV1SummarizationVerbositySpec.fromJson(core.Map json_)
      : this(
          useReference: json_['useReference'] as core.bool?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useReference != null) 'useReference': useReference!,
        if (version != null) 'version': version!,
      };
}

/// Hyperparameters for SFT.
class GoogleCloudAiplatformV1SupervisedHyperParameters {
  /// Adapter size for tuning.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ADAPTER_SIZE_UNSPECIFIED" : Adapter size is unspecified.
  /// - "ADAPTER_SIZE_ONE" : Adapter size 1.
  /// - "ADAPTER_SIZE_TWO" : Adapter size 2.
  /// - "ADAPTER_SIZE_FOUR" : Adapter size 4.
  /// - "ADAPTER_SIZE_EIGHT" : Adapter size 8.
  /// - "ADAPTER_SIZE_SIXTEEN" : Adapter size 16.
  /// - "ADAPTER_SIZE_THIRTY_TWO" : Adapter size 32.
  core.String? adapterSize;

  /// Number of complete passes the model makes over the entire training dataset
  /// during training.
  ///
  /// Optional.
  core.String? epochCount;

  /// Multiplier for adjusting the default learning rate.
  ///
  /// Optional.
  core.double? learningRateMultiplier;

  GoogleCloudAiplatformV1SupervisedHyperParameters({
    this.adapterSize,
    this.epochCount,
    this.learningRateMultiplier,
  });

  GoogleCloudAiplatformV1SupervisedHyperParameters.fromJson(core.Map json_)
      : this(
          adapterSize: json_['adapterSize'] as core.String?,
          epochCount: json_['epochCount'] as core.String?,
          learningRateMultiplier:
              (json_['learningRateMultiplier'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (adapterSize != null) 'adapterSize': adapterSize!,
        if (epochCount != null) 'epochCount': epochCount!,
        if (learningRateMultiplier != null)
          'learningRateMultiplier': learningRateMultiplier!,
      };
}

/// Tuning data statistics for Supervised Tuning.
class GoogleCloudAiplatformV1SupervisedTuningDataStats {
  /// For each index in `truncated_example_indices`, the user-facing reason why
  /// the example was dropped.
  ///
  /// Must not include example itself.
  ///
  /// Output only.
  core.List<core.String>? droppedExampleReasons;

  /// Number of billable characters in the tuning dataset.
  ///
  /// Output only.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? totalBillableCharacterCount;

  /// Number of billable tokens in the tuning dataset.
  ///
  /// Output only.
  core.String? totalBillableTokenCount;

  /// The number of examples in the dataset that have been dropped.
  ///
  /// An example can be dropped for reasons including: too many tokens, contains
  /// an invalid image, contains too many images, etc.
  ///
  /// Output only.
  core.String? totalTruncatedExampleCount;

  /// Number of tuning characters in the tuning dataset.
  ///
  /// Output only.
  core.String? totalTuningCharacterCount;

  /// A partial sample of the indices (starting from 1) of the dropped examples.
  ///
  /// Output only.
  core.List<core.String>? truncatedExampleIndices;

  /// Number of examples in the tuning dataset.
  ///
  /// Output only.
  core.String? tuningDatasetExampleCount;

  /// Number of tuning steps for this Tuning Job.
  ///
  /// Output only.
  core.String? tuningStepCount;

  /// Sample user messages in the training dataset uri.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Content>? userDatasetExamples;

  /// Dataset distributions for the user input tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution?
      userInputTokenDistribution;

  /// Dataset distributions for the messages per example.
  ///
  /// Output only.
  GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution?
      userMessagePerExampleDistribution;

  /// Dataset distributions for the user output tokens.
  ///
  /// Output only.
  GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution?
      userOutputTokenDistribution;

  GoogleCloudAiplatformV1SupervisedTuningDataStats({
    this.droppedExampleReasons,
    this.totalBillableCharacterCount,
    this.totalBillableTokenCount,
    this.totalTruncatedExampleCount,
    this.totalTuningCharacterCount,
    this.truncatedExampleIndices,
    this.tuningDatasetExampleCount,
    this.tuningStepCount,
    this.userDatasetExamples,
    this.userInputTokenDistribution,
    this.userMessagePerExampleDistribution,
    this.userOutputTokenDistribution,
  });

  GoogleCloudAiplatformV1SupervisedTuningDataStats.fromJson(core.Map json_)
      : this(
          droppedExampleReasons: (json_['droppedExampleReasons'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          totalBillableCharacterCount:
              json_['totalBillableCharacterCount'] as core.String?,
          totalBillableTokenCount:
              json_['totalBillableTokenCount'] as core.String?,
          totalTruncatedExampleCount:
              json_['totalTruncatedExampleCount'] as core.String?,
          totalTuningCharacterCount:
              json_['totalTuningCharacterCount'] as core.String?,
          truncatedExampleIndices:
              (json_['truncatedExampleIndices'] as core.List?)
                  ?.map((value) => value as core.String)
                  .toList(),
          tuningDatasetExampleCount:
              json_['tuningDatasetExampleCount'] as core.String?,
          tuningStepCount: json_['tuningStepCount'] as core.String?,
          userDatasetExamples: (json_['userDatasetExamples'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Content.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          userInputTokenDistribution:
              json_.containsKey('userInputTokenDistribution')
                  ? GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution
                      .fromJson(json_['userInputTokenDistribution']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          userMessagePerExampleDistribution:
              json_.containsKey('userMessagePerExampleDistribution')
                  ? GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution
                      .fromJson(json_['userMessagePerExampleDistribution']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          userOutputTokenDistribution:
              json_.containsKey('userOutputTokenDistribution')
                  ? GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution
                      .fromJson(json_['userOutputTokenDistribution']
                          as core.Map<core.String, core.dynamic>)
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (droppedExampleReasons != null)
          'droppedExampleReasons': droppedExampleReasons!,
        if (totalBillableCharacterCount != null)
          'totalBillableCharacterCount': totalBillableCharacterCount!,
        if (totalBillableTokenCount != null)
          'totalBillableTokenCount': totalBillableTokenCount!,
        if (totalTruncatedExampleCount != null)
          'totalTruncatedExampleCount': totalTruncatedExampleCount!,
        if (totalTuningCharacterCount != null)
          'totalTuningCharacterCount': totalTuningCharacterCount!,
        if (truncatedExampleIndices != null)
          'truncatedExampleIndices': truncatedExampleIndices!,
        if (tuningDatasetExampleCount != null)
          'tuningDatasetExampleCount': tuningDatasetExampleCount!,
        if (tuningStepCount != null) 'tuningStepCount': tuningStepCount!,
        if (userDatasetExamples != null)
          'userDatasetExamples': userDatasetExamples!,
        if (userInputTokenDistribution != null)
          'userInputTokenDistribution': userInputTokenDistribution!,
        if (userMessagePerExampleDistribution != null)
          'userMessagePerExampleDistribution':
              userMessagePerExampleDistribution!,
        if (userOutputTokenDistribution != null)
          'userOutputTokenDistribution': userOutputTokenDistribution!,
      };
}

/// Dataset distribution for Supervised Tuning.
class GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution {
  /// Sum of a given population of values that are billable.
  ///
  /// Output only.
  core.String? billableSum;

  /// Defines the histogram bucket.
  ///
  /// Output only.
  core.List<
          GoogleCloudAiplatformV1SupervisedTuningDatasetDistributionDatasetBucket>?
      buckets;

  /// The maximum of the population values.
  ///
  /// Output only.
  core.double? max;

  /// The arithmetic mean of the values in the population.
  ///
  /// Output only.
  core.double? mean;

  /// The median of the values in the population.
  ///
  /// Output only.
  core.double? median;

  /// The minimum of the population values.
  ///
  /// Output only.
  core.double? min;

  /// The 5th percentile of the values in the population.
  ///
  /// Output only.
  core.double? p5;

  /// The 95th percentile of the values in the population.
  ///
  /// Output only.
  core.double? p95;

  /// Sum of a given population of values.
  ///
  /// Output only.
  core.String? sum;

  GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution({
    this.billableSum,
    this.buckets,
    this.max,
    this.mean,
    this.median,
    this.min,
    this.p5,
    this.p95,
    this.sum,
  });

  GoogleCloudAiplatformV1SupervisedTuningDatasetDistribution.fromJson(
      core.Map json_)
      : this(
          billableSum: json_['billableSum'] as core.String?,
          buckets: (json_['buckets'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1SupervisedTuningDatasetDistributionDatasetBucket
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          max: (json_['max'] as core.num?)?.toDouble(),
          mean: (json_['mean'] as core.num?)?.toDouble(),
          median: (json_['median'] as core.num?)?.toDouble(),
          min: (json_['min'] as core.num?)?.toDouble(),
          p5: (json_['p5'] as core.num?)?.toDouble(),
          p95: (json_['p95'] as core.num?)?.toDouble(),
          sum: json_['sum'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (billableSum != null) 'billableSum': billableSum!,
        if (buckets != null) 'buckets': buckets!,
        if (max != null) 'max': max!,
        if (mean != null) 'mean': mean!,
        if (median != null) 'median': median!,
        if (min != null) 'min': min!,
        if (p5 != null) 'p5': p5!,
        if (p95 != null) 'p95': p95!,
        if (sum != null) 'sum': sum!,
      };
}

/// Dataset bucket used to create a histogram for the distribution given a
/// population of values.
class GoogleCloudAiplatformV1SupervisedTuningDatasetDistributionDatasetBucket {
  /// Number of values in the bucket.
  ///
  /// Output only.
  core.double? count;

  /// Left bound of the bucket.
  ///
  /// Output only.
  core.double? left;

  /// Right bound of the bucket.
  ///
  /// Output only.
  core.double? right;

  GoogleCloudAiplatformV1SupervisedTuningDatasetDistributionDatasetBucket({
    this.count,
    this.left,
    this.right,
  });

  GoogleCloudAiplatformV1SupervisedTuningDatasetDistributionDatasetBucket.fromJson(
      core.Map json_)
      : this(
          count: (json_['count'] as core.num?)?.toDouble(),
          left: (json_['left'] as core.num?)?.toDouble(),
          right: (json_['right'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (count != null) 'count': count!,
        if (left != null) 'left': left!,
        if (right != null) 'right': right!,
      };
}

/// Tuning Spec for Supervised Tuning for first party models.
class GoogleCloudAiplatformV1SupervisedTuningSpec {
  /// Hyperparameters for SFT.
  ///
  /// Optional.
  GoogleCloudAiplatformV1SupervisedHyperParameters? hyperParameters;

  /// Cloud Storage path to file containing training dataset for tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Required.
  core.String? trainingDatasetUri;

  /// Cloud Storage path to file containing validation dataset for tuning.
  ///
  /// The dataset must be formatted as a JSONL file.
  ///
  /// Optional.
  core.String? validationDatasetUri;

  GoogleCloudAiplatformV1SupervisedTuningSpec({
    this.hyperParameters,
    this.trainingDatasetUri,
    this.validationDatasetUri,
  });

  GoogleCloudAiplatformV1SupervisedTuningSpec.fromJson(core.Map json_)
      : this(
          hyperParameters: json_.containsKey('hyperParameters')
              ? GoogleCloudAiplatformV1SupervisedHyperParameters.fromJson(
                  json_['hyperParameters']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trainingDatasetUri: json_['trainingDatasetUri'] as core.String?,
          validationDatasetUri: json_['validationDatasetUri'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (hyperParameters != null) 'hyperParameters': hyperParameters!,
        if (trainingDatasetUri != null)
          'trainingDatasetUri': trainingDatasetUri!,
        if (validationDatasetUri != null)
          'validationDatasetUri': validationDatasetUri!,
      };
}

/// Request message for FeatureOnlineStoreAdminService.SyncFeatureView.
typedef GoogleCloudAiplatformV1SyncFeatureViewRequest = $Empty;

/// Response message for FeatureOnlineStoreAdminService.SyncFeatureView.
class GoogleCloudAiplatformV1SyncFeatureViewResponse {
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  core.String? featureViewSync;

  GoogleCloudAiplatformV1SyncFeatureViewResponse({
    this.featureViewSync,
  });

  GoogleCloudAiplatformV1SyncFeatureViewResponse.fromJson(core.Map json_)
      : this(
          featureViewSync: json_['featureViewSync'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureViewSync != null) 'featureViewSync': featureViewSync!,
      };
}

/// The storage details for TFRecord output content.
class GoogleCloudAiplatformV1TFRecordDestination {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1TFRecordDestination({
    this.gcsDestination,
  });

  GoogleCloudAiplatformV1TFRecordDestination.fromJson(core.Map json_)
      : this(
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
      };
}

/// A tensor value type.
class GoogleCloudAiplatformV1Tensor {
  /// Type specific representations that make it easy to create tensor protos in
  /// all languages.
  ///
  /// Only the representation corresponding to "dtype" can be set. The values
  /// hold the flattened representation of the tensor in row major order. BOOL
  core.List<core.bool>? boolVal;

  /// STRING
  core.List<core.String>? bytesVal;

  /// DOUBLE
  core.List<core.double>? doubleVal;

  /// The data type of tensor.
  /// Possible string values are:
  /// - "DATA_TYPE_UNSPECIFIED" : Not a legal value for DataType. Used to
  /// indicate a DataType field has not been set.
  /// - "BOOL" : Data types that all computation devices are expected to be
  /// capable to support.
  /// - "STRING"
  /// - "FLOAT"
  /// - "DOUBLE"
  /// - "INT8"
  /// - "INT16"
  /// - "INT32"
  /// - "INT64"
  /// - "UINT8"
  /// - "UINT16"
  /// - "UINT32"
  /// - "UINT64"
  core.String? dtype;

  /// FLOAT
  core.List<core.double>? floatVal;

  /// INT64
  core.List<core.String>? int64Val;

  /// INT_8 INT_16 INT_32
  core.List<core.int>? intVal;

  /// A list of tensor values.
  core.List<GoogleCloudAiplatformV1Tensor>? listVal;

  /// Shape of the tensor.
  core.List<core.String>? shape;

  /// STRING
  core.List<core.String>? stringVal;

  /// A map of string to tensor.
  core.Map<core.String, GoogleCloudAiplatformV1Tensor>? structVal;

  /// Serialized raw tensor content.
  core.String? tensorVal;
  core.List<core.int> get tensorValAsBytes => convert.base64.decode(tensorVal!);

  set tensorValAsBytes(core.List<core.int> bytes_) {
    tensorVal =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// UINT64
  core.List<core.String>? uint64Val;

  /// UINT8 UINT16 UINT32
  core.List<core.int>? uintVal;

  GoogleCloudAiplatformV1Tensor({
    this.boolVal,
    this.bytesVal,
    this.doubleVal,
    this.dtype,
    this.floatVal,
    this.int64Val,
    this.intVal,
    this.listVal,
    this.shape,
    this.stringVal,
    this.structVal,
    this.tensorVal,
    this.uint64Val,
    this.uintVal,
  });

  GoogleCloudAiplatformV1Tensor.fromJson(core.Map json_)
      : this(
          boolVal: (json_['boolVal'] as core.List?)
              ?.map((value) => value as core.bool)
              .toList(),
          bytesVal: (json_['bytesVal'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          doubleVal: (json_['doubleVal'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
          dtype: json_['dtype'] as core.String?,
          floatVal: (json_['floatVal'] as core.List?)
              ?.map((value) => (value as core.num).toDouble())
              .toList(),
          int64Val: (json_['int64Val'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          intVal: (json_['intVal'] as core.List?)
              ?.map((value) => value as core.int)
              .toList(),
          listVal: (json_['listVal'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          shape: (json_['shape'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          stringVal: (json_['stringVal'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          structVal:
              (json_['structVal'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1Tensor.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
          tensorVal: json_['tensorVal'] as core.String?,
          uint64Val: (json_['uint64Val'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          uintVal: (json_['uintVal'] as core.List?)
              ?.map((value) => value as core.int)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (boolVal != null) 'boolVal': boolVal!,
        if (bytesVal != null) 'bytesVal': bytesVal!,
        if (doubleVal != null) 'doubleVal': doubleVal!,
        if (dtype != null) 'dtype': dtype!,
        if (floatVal != null) 'floatVal': floatVal!,
        if (int64Val != null) 'int64Val': int64Val!,
        if (intVal != null) 'intVal': intVal!,
        if (listVal != null) 'listVal': listVal!,
        if (shape != null) 'shape': shape!,
        if (stringVal != null) 'stringVal': stringVal!,
        if (structVal != null) 'structVal': structVal!,
        if (tensorVal != null) 'tensorVal': tensorVal!,
        if (uint64Val != null) 'uint64Val': uint64Val!,
        if (uintVal != null) 'uintVal': uintVal!,
      };
}

/// Tensorboard is a physical database that stores users' training metrics.
///
/// A default Tensorboard is provided in each region of a Google Cloud project.
/// If needed users can also create extra Tensorboards in their projects.
class GoogleCloudAiplatformV1Tensorboard {
  /// Consumer project Cloud Storage path prefix used to store blob data, which
  /// can either be a bucket or directory.
  ///
  /// Does not end with a '/'.
  ///
  /// Output only.
  core.String? blobStoragePathPrefix;

  /// Timestamp when this Tensorboard was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this Tensorboard.
  core.String? description;

  /// User provided name of this Tensorboard.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Tensorboard.
  ///
  /// If set, this Tensorboard and all sub-resources of this Tensorboard will be
  /// secured by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Used to indicate if the TensorBoard instance is the default one.
  ///
  /// Each project & region can have at most one default TensorBoard instance.
  /// Creation of a default TensorBoard instance and updating an existing
  /// TensorBoard instance to be default will mark all other TensorBoard
  /// instances (if any) as non default.
  core.bool? isDefault;

  /// The labels with user-defined metadata to organize your Tensorboards.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Tensorboard (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  core.Map<core.String, core.String>? labels;

  /// Name of the Tensorboard.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  ///
  /// Output only.
  core.String? name;

  /// The number of Runs stored in this Tensorboard.
  ///
  /// Output only.
  core.int? runCount;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzi;

  /// Reserved for future use.
  ///
  /// Output only.
  core.bool? satisfiesPzs;

  /// Timestamp when this Tensorboard was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Tensorboard({
    this.blobStoragePathPrefix,
    this.createTime,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.isDefault,
    this.labels,
    this.name,
    this.runCount,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Tensorboard.fromJson(core.Map json_)
      : this(
          blobStoragePathPrefix: json_['blobStoragePathPrefix'] as core.String?,
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_['etag'] as core.String?,
          isDefault: json_['isDefault'] as core.bool?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          runCount: json_['runCount'] as core.int?,
          satisfiesPzi: json_['satisfiesPzi'] as core.bool?,
          satisfiesPzs: json_['satisfiesPzs'] as core.bool?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blobStoragePathPrefix != null)
          'blobStoragePathPrefix': blobStoragePathPrefix!,
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (isDefault != null) 'isDefault': isDefault!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (runCount != null) 'runCount': runCount!,
        if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi!,
        if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// One blob (e.g, image, graph) viewable on a blob metric plot.
class GoogleCloudAiplatformV1TensorboardBlob {
  /// The bytes of the blob is not present unless it's returned by the
  /// ReadTensorboardBlobData endpoint.
  ///
  /// Optional.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A URI safe key uniquely identifying a blob.
  ///
  /// Can be used to locate the blob stored in the Cloud Storage bucket of the
  /// consumer project.
  ///
  /// Output only.
  core.String? id;

  GoogleCloudAiplatformV1TensorboardBlob({
    this.data,
    this.id,
  });

  GoogleCloudAiplatformV1TensorboardBlob.fromJson(core.Map json_)
      : this(
          data: json_['data'] as core.String?,
          id: json_['id'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (data != null) 'data': data!,
        if (id != null) 'id': id!,
      };
}

/// One point viewable on a blob metric plot, but mostly just a wrapper message
/// to work around repeated fields can't be used directly within `oneof` fields.
class GoogleCloudAiplatformV1TensorboardBlobSequence {
  /// List of blobs contained within the sequence.
  core.List<GoogleCloudAiplatformV1TensorboardBlob>? values;

  GoogleCloudAiplatformV1TensorboardBlobSequence({
    this.values,
  });

  GoogleCloudAiplatformV1TensorboardBlobSequence.fromJson(core.Map json_)
      : this(
          values: (json_['values'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TensorboardBlob.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// A TensorboardExperiment is a group of TensorboardRuns, that are typically
/// the results of a training job run, in a Tensorboard.
class GoogleCloudAiplatformV1TensorboardExperiment {
  /// Timestamp when this TensorboardExperiment was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardExperiment.
  core.String? description;

  /// User provided name of this TensorboardExperiment.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your
  /// TensorboardExperiment.
  ///
  /// Label keys and values cannot be longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Dataset (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// `aiplatform.googleapis.com/` and are immutable. The following system
  /// labels exist for each Dataset: *
  /// `aiplatform.googleapis.com/dataset_metadata_schema`: output only. Its
  /// value is the metadata_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Name of the TensorboardExperiment.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  ///
  /// Output only.
  core.String? name;

  /// Source of the TensorboardExperiment.
  ///
  /// Example: a custom training job.
  ///
  /// Immutable.
  core.String? source;

  /// Timestamp when this TensorboardExperiment was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1TensorboardExperiment({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.name,
    this.source,
    this.updateTime,
  });

  GoogleCloudAiplatformV1TensorboardExperiment.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          source: json_['source'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (source != null) 'source': source!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// TensorboardRun maps to a specific execution of a training job with a given
/// set of hyperparameter values, model definition, dataset, etc
class GoogleCloudAiplatformV1TensorboardRun {
  /// Timestamp when this TensorboardRun was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardRun.
  core.String? description;

  /// User provided name of this TensorboardRun.
  ///
  /// This value must be unique among all TensorboardRuns belonging to the same
  /// parent TensorboardExperiment.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your TensorboardRuns.
  ///
  /// This field will be used to filter and visualize Runs in the Tensorboard
  /// UI. For example, a Vertex AI training job can set a label
  /// aiplatform.googleapis.com/training_job_id=xxxxx to all the runs created
  /// within that job. An end user can set a label experiment_id=xxxxx for all
  /// the runs produced in a Jupyter notebook. These runs can be grouped by a
  /// label value and visualized together in the Tensorboard UI. Label keys and
  /// values can be no longer than 64 characters (Unicode codepoints), can only
  /// contain lowercase letters, numeric characters, underscores and dashes.
  /// International characters are allowed. No more than 64 user labels can be
  /// associated with one TensorboardRun (System labels are excluded). See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? labels;

  /// Name of the TensorboardRun.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this TensorboardRun was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1TensorboardRun({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1TensorboardRun.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// One point viewable on a tensor metric plot.
class GoogleCloudAiplatformV1TensorboardTensor {
  /// Serialized form of
  /// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/tensor.proto
  ///
  /// Required.
  core.String? value;
  core.List<core.int> get valueAsBytes => convert.base64.decode(value!);

  set valueAsBytes(core.List<core.int> bytes_) {
    value =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Version number of TensorProto used to serialize value.
  ///
  /// Optional.
  core.int? versionNumber;

  GoogleCloudAiplatformV1TensorboardTensor({
    this.value,
    this.versionNumber,
  });

  GoogleCloudAiplatformV1TensorboardTensor.fromJson(core.Map json_)
      : this(
          value: json_['value'] as core.String?,
          versionNumber: json_['versionNumber'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
        if (versionNumber != null) 'versionNumber': versionNumber!,
      };
}

/// TensorboardTimeSeries maps to times series produced in training runs
class GoogleCloudAiplatformV1TensorboardTimeSeries {
  /// Timestamp when this TensorboardTimeSeries was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardTimeSeries.
  core.String? description;

  /// User provided name of this TensorboardTimeSeries.
  ///
  /// This value should be unique among all TensorboardTimeSeries resources
  /// belonging to the same TensorboardRun resource (parent resource).
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Scalar, Tensor, or Blob metadata for this TensorboardTimeSeries.
  ///
  /// Output only.
  GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata? metadata;

  /// Name of the TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? name;

  /// Data of the current plugin, with the size limited to 65KB.
  core.String? pluginData;
  core.List<core.int> get pluginDataAsBytes =>
      convert.base64.decode(pluginData!);

  set pluginDataAsBytes(core.List<core.int> bytes_) {
    pluginData =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Name of the plugin this time series pertain to.
  ///
  /// Such as Scalar, Tensor, Blob
  ///
  /// Immutable.
  core.String? pluginName;

  /// Timestamp when this TensorboardTimeSeries was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Type of TensorboardTimeSeries value.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "SCALAR" : Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  /// - "TENSOR" : Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  /// - "BLOB_SEQUENCE" : Used for TensorboardTimeSeries that is a list of blob
  /// sequences. E.g. set of sample images with labels over epochs/time.
  core.String? valueType;

  GoogleCloudAiplatformV1TensorboardTimeSeries({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.metadata,
    this.name,
    this.pluginData,
    this.pluginName,
    this.updateTime,
    this.valueType,
  });

  GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          etag: json_['etag'] as core.String?,
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          pluginData: json_['pluginData'] as core.String?,
          pluginName: json_['pluginName'] as core.String?,
          updateTime: json_['updateTime'] as core.String?,
          valueType: json_['valueType'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (pluginData != null) 'pluginData': pluginData!,
        if (pluginName != null) 'pluginName': pluginName!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (valueType != null) 'valueType': valueType!,
      };
}

/// Describes metadata for a TensorboardTimeSeries.
class GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata {
  /// The largest blob sequence length (number of blobs) of all data points in
  /// this time series, if its ValueType is BLOB_SEQUENCE.
  ///
  /// Output only.
  core.String? maxBlobSequenceLength;

  /// Max step index of all data points within a TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? maxStep;

  /// Max wall clock timestamp of all data points within a
  /// TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? maxWallTime;

  GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata({
    this.maxBlobSequenceLength,
    this.maxStep,
    this.maxWallTime,
  });

  GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata.fromJson(core.Map json_)
      : this(
          maxBlobSequenceLength: json_['maxBlobSequenceLength'] as core.String?,
          maxStep: json_['maxStep'] as core.String?,
          maxWallTime: json_['maxWallTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxBlobSequenceLength != null)
          'maxBlobSequenceLength': maxBlobSequenceLength!,
        if (maxStep != null) 'maxStep': maxStep!,
        if (maxWallTime != null) 'maxWallTime': maxWallTime!,
      };
}

/// The config for feature monitoring threshold.
class GoogleCloudAiplatformV1ThresholdConfig {
  /// Specify a threshold value that can trigger the alert.
  ///
  /// If this threshold config is for feature distribution distance: 1. For
  /// categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by JensenShannon divergence. Each feature must have a non-zero
  /// threshold if they need to be monitored. Otherwise no alert will be
  /// triggered for that feature.
  core.double? value;

  GoogleCloudAiplatformV1ThresholdConfig({
    this.value,
  });

  GoogleCloudAiplatformV1ThresholdConfig.fromJson(core.Map json_)
      : this(
          value: (json_['value'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
      };
}

/// All the data stored in a TensorboardTimeSeries.
class GoogleCloudAiplatformV1TimeSeriesData {
  /// The ID of the TensorboardTimeSeries, which will become the final component
  /// of the TensorboardTimeSeries' resource name
  ///
  /// Required.
  core.String? tensorboardTimeSeriesId;

  /// The value type of this time series.
  ///
  /// All the values in this time series data must match this value type.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "SCALAR" : Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  /// - "TENSOR" : Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  /// - "BLOB_SEQUENCE" : Used for TensorboardTimeSeries that is a list of blob
  /// sequences. E.g. set of sample images with labels over epochs/time.
  core.String? valueType;

  /// Data points in this time series.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TimeSeriesDataPoint>? values;

  GoogleCloudAiplatformV1TimeSeriesData({
    this.tensorboardTimeSeriesId,
    this.valueType,
    this.values,
  });

  GoogleCloudAiplatformV1TimeSeriesData.fromJson(core.Map json_)
      : this(
          tensorboardTimeSeriesId:
              json_['tensorboardTimeSeriesId'] as core.String?,
          valueType: json_['valueType'] as core.String?,
          values: (json_['values'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TimeSeriesDataPoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardTimeSeriesId != null)
          'tensorboardTimeSeriesId': tensorboardTimeSeriesId!,
        if (valueType != null) 'valueType': valueType!,
        if (values != null) 'values': values!,
      };
}

/// A TensorboardTimeSeries data point.
class GoogleCloudAiplatformV1TimeSeriesDataPoint {
  /// A blob sequence value.
  GoogleCloudAiplatformV1TensorboardBlobSequence? blobs;

  /// A scalar value.
  GoogleCloudAiplatformV1Scalar? scalar;

  /// Step index of this data point within the run.
  core.String? step;

  /// A tensor value.
  GoogleCloudAiplatformV1TensorboardTensor? tensor;

  /// Wall clock timestamp when this data point is generated by the end user.
  core.String? wallTime;

  GoogleCloudAiplatformV1TimeSeriesDataPoint({
    this.blobs,
    this.scalar,
    this.step,
    this.tensor,
    this.wallTime,
  });

  GoogleCloudAiplatformV1TimeSeriesDataPoint.fromJson(core.Map json_)
      : this(
          blobs: json_.containsKey('blobs')
              ? GoogleCloudAiplatformV1TensorboardBlobSequence.fromJson(
                  json_['blobs'] as core.Map<core.String, core.dynamic>)
              : null,
          scalar: json_.containsKey('scalar')
              ? GoogleCloudAiplatformV1Scalar.fromJson(
                  json_['scalar'] as core.Map<core.String, core.dynamic>)
              : null,
          step: json_['step'] as core.String?,
          tensor: json_.containsKey('tensor')
              ? GoogleCloudAiplatformV1TensorboardTensor.fromJson(
                  json_['tensor'] as core.Map<core.String, core.dynamic>)
              : null,
          wallTime: json_['wallTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blobs != null) 'blobs': blobs!,
        if (scalar != null) 'scalar': scalar!,
        if (step != null) 'step': step!,
        if (tensor != null) 'tensor': tensor!,
        if (wallTime != null) 'wallTime': wallTime!,
      };
}

/// Assigns input data to training, validation, and test sets based on a
/// provided timestamps.
///
/// The youngest data pieces are assigned to training set, next to validation
/// set, and the oldest to the test set. Supported only for tabular Datasets.
class GoogleCloudAiplatformV1TimestampSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The values of the key (the values in the column) must be in RFC 3339
  /// `date-time` format, where `time-offset` = `"Z"` (e.g.
  /// 1985-04-12T23:20:50.52Z). If for a piece of data the key is not present or
  /// has an invalid value, that piece is ignored by the pipeline.
  ///
  /// Required.
  core.String? key;

  /// The fraction of the input data that is to be used to evaluate the Model.
  core.double? testFraction;

  /// The fraction of the input data that is to be used to train the Model.
  core.double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  core.double? validationFraction;

  GoogleCloudAiplatformV1TimestampSplit({
    this.key,
    this.testFraction,
    this.trainingFraction,
    this.validationFraction,
  });

  GoogleCloudAiplatformV1TimestampSplit.fromJson(core.Map json_)
      : this(
          key: json_['key'] as core.String?,
          testFraction: (json_['testFraction'] as core.num?)?.toDouble(),
          trainingFraction:
              (json_['trainingFraction'] as core.num?)?.toDouble(),
          validationFraction:
              (json_['validationFraction'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (testFraction != null) 'testFraction': testFraction!,
        if (trainingFraction != null) 'trainingFraction': trainingFraction!,
        if (validationFraction != null)
          'validationFraction': validationFraction!,
      };
}

/// Tokens info with a list of tokens and the corresponding list of token ids.
class GoogleCloudAiplatformV1TokensInfo {
  /// Optional fields for the role from the corresponding Content.
  ///
  /// Optional.
  core.String? role;

  /// A list of token ids from the input.
  core.List<core.String>? tokenIds;

  /// A list of tokens from the input.
  core.List<core.String>? tokens;

  GoogleCloudAiplatformV1TokensInfo({
    this.role,
    this.tokenIds,
    this.tokens,
  });

  GoogleCloudAiplatformV1TokensInfo.fromJson(core.Map json_)
      : this(
          role: json_['role'] as core.String?,
          tokenIds: (json_['tokenIds'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          tokens: (json_['tokens'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (role != null) 'role': role!,
        if (tokenIds != null) 'tokenIds': tokenIds!,
        if (tokens != null) 'tokens': tokens!,
      };
}

/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with
/// external systems to perform an action, or set of actions, outside of
/// knowledge and scope of the model. A Tool object should contain exactly one
/// type of Tool (e.g FunctionDeclaration, Retrieval or GoogleSearchRetrieval).
class GoogleCloudAiplatformV1Tool {
  /// CodeExecution tool type.
  ///
  /// Enables the model to execute code as part of generation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ToolCodeExecution? codeExecution;

  /// Tool to support searching public web data, powered by Vertex AI Search and
  /// Sec4 compliance.
  ///
  /// Optional.
  GoogleCloudAiplatformV1EnterpriseWebSearch? enterpriseWebSearch;

  /// Function tool type.
  ///
  /// One or more function declarations to be passed to the model along with the
  /// current user query. Model may decide to call a subset of these functions
  /// by populating FunctionCall in the response. User should provide a
  /// FunctionResponse for each function call in the next turn. Based on the
  /// function responses, Model will generate the final response back to the
  /// user. Maximum 128 function declarations can be provided.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1FunctionDeclaration>? functionDeclarations;

  /// GoogleSearch tool type.
  ///
  /// Tool to support Google Search in Model. Powered by Google.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ToolGoogleSearch? googleSearch;

  /// GoogleSearchRetrieval tool type.
  ///
  /// Specialized retrieval tool that is powered by Google search.
  ///
  /// Optional.
  GoogleCloudAiplatformV1GoogleSearchRetrieval? googleSearchRetrieval;

  /// Retrieval tool type.
  ///
  /// System will always execute the provided retrieval tool(s) to get external
  /// knowledge to answer the prompt. Retrieval results are presented to the
  /// model for generation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1Retrieval? retrieval;

  GoogleCloudAiplatformV1Tool({
    this.codeExecution,
    this.enterpriseWebSearch,
    this.functionDeclarations,
    this.googleSearch,
    this.googleSearchRetrieval,
    this.retrieval,
  });

  GoogleCloudAiplatformV1Tool.fromJson(core.Map json_)
      : this(
          codeExecution: json_.containsKey('codeExecution')
              ? GoogleCloudAiplatformV1ToolCodeExecution.fromJson(
                  json_['codeExecution'] as core.Map<core.String, core.dynamic>)
              : null,
          enterpriseWebSearch: json_.containsKey('enterpriseWebSearch')
              ? GoogleCloudAiplatformV1EnterpriseWebSearch.fromJson(
                  json_['enterpriseWebSearch']
                      as core.Map<core.String, core.dynamic>)
              : null,
          functionDeclarations: (json_['functionDeclarations'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1FunctionDeclaration.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          googleSearch: json_.containsKey('googleSearch')
              ? GoogleCloudAiplatformV1ToolGoogleSearch.fromJson(
                  json_['googleSearch'] as core.Map<core.String, core.dynamic>)
              : null,
          googleSearchRetrieval: json_.containsKey('googleSearchRetrieval')
              ? GoogleCloudAiplatformV1GoogleSearchRetrieval.fromJson(
                  json_['googleSearchRetrieval']
                      as core.Map<core.String, core.dynamic>)
              : null,
          retrieval: json_.containsKey('retrieval')
              ? GoogleCloudAiplatformV1Retrieval.fromJson(
                  json_['retrieval'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (codeExecution != null) 'codeExecution': codeExecution!,
        if (enterpriseWebSearch != null)
          'enterpriseWebSearch': enterpriseWebSearch!,
        if (functionDeclarations != null)
          'functionDeclarations': functionDeclarations!,
        if (googleSearch != null) 'googleSearch': googleSearch!,
        if (googleSearchRetrieval != null)
          'googleSearchRetrieval': googleSearchRetrieval!,
        if (retrieval != null) 'retrieval': retrieval!,
      };
}

/// Spec for tool call.
class GoogleCloudAiplatformV1ToolCall {
  /// Spec for tool input
  ///
  /// Optional.
  core.String? toolInput;

  /// Spec for tool name
  ///
  /// Required.
  core.String? toolName;

  GoogleCloudAiplatformV1ToolCall({
    this.toolInput,
    this.toolName,
  });

  GoogleCloudAiplatformV1ToolCall.fromJson(core.Map json_)
      : this(
          toolInput: json_['toolInput'] as core.String?,
          toolName: json_['toolName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (toolInput != null) 'toolInput': toolInput!,
        if (toolName != null) 'toolName': toolName!,
      };
}

/// Input for tool call valid metric.
class GoogleCloudAiplatformV1ToolCallValidInput {
  /// Repeated tool call valid instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ToolCallValidInstance>? instances;

  /// Spec for tool call valid metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1ToolCallValidSpec? metricSpec;

  GoogleCloudAiplatformV1ToolCallValidInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1ToolCallValidInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ToolCallValidInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1ToolCallValidSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for tool call valid instance.
typedef GoogleCloudAiplatformV1ToolCallValidInstance = $Instance00;

/// Tool call valid metric value for an instance.
class GoogleCloudAiplatformV1ToolCallValidMetricValue {
  /// Tool call valid score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1ToolCallValidMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1ToolCallValidMetricValue.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for tool call valid metric.
class GoogleCloudAiplatformV1ToolCallValidResults {
  /// Tool call valid metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ToolCallValidMetricValue>?
      toolCallValidMetricValues;

  GoogleCloudAiplatformV1ToolCallValidResults({
    this.toolCallValidMetricValues,
  });

  GoogleCloudAiplatformV1ToolCallValidResults.fromJson(core.Map json_)
      : this(
          toolCallValidMetricValues:
              (json_['toolCallValidMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ToolCallValidMetricValue.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (toolCallValidMetricValues != null)
          'toolCallValidMetricValues': toolCallValidMetricValues!,
      };
}

/// Spec for tool call valid metric.
typedef GoogleCloudAiplatformV1ToolCallValidSpec = $Empty;

/// Tool that executes code generated by the model, and automatically returns
/// the result to the model.
///
/// See also \[ExecutableCode\]and \[CodeExecutionResult\] which are input and
/// output to this tool.
typedef GoogleCloudAiplatformV1ToolCodeExecution = $Empty;

/// Tool config.
///
/// This config is shared for all tools provided in the request.
class GoogleCloudAiplatformV1ToolConfig {
  /// Function calling config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FunctionCallingConfig? functionCallingConfig;

  /// Retrieval config.
  ///
  /// Optional.
  GoogleCloudAiplatformV1RetrievalConfig? retrievalConfig;

  GoogleCloudAiplatformV1ToolConfig({
    this.functionCallingConfig,
    this.retrievalConfig,
  });

  GoogleCloudAiplatformV1ToolConfig.fromJson(core.Map json_)
      : this(
          functionCallingConfig: json_.containsKey('functionCallingConfig')
              ? GoogleCloudAiplatformV1FunctionCallingConfig.fromJson(
                  json_['functionCallingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          retrievalConfig: json_.containsKey('retrievalConfig')
              ? GoogleCloudAiplatformV1RetrievalConfig.fromJson(
                  json_['retrievalConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (functionCallingConfig != null)
          'functionCallingConfig': functionCallingConfig!,
        if (retrievalConfig != null) 'retrievalConfig': retrievalConfig!,
      };
}

/// GoogleSearch tool type.
///
/// Tool to support Google Search in Model. Powered by Google.
typedef GoogleCloudAiplatformV1ToolGoogleSearch = $Empty;

/// Input for tool name match metric.
class GoogleCloudAiplatformV1ToolNameMatchInput {
  /// Repeated tool name match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ToolNameMatchInstance>? instances;

  /// Spec for tool name match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1ToolNameMatchSpec? metricSpec;

  GoogleCloudAiplatformV1ToolNameMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1ToolNameMatchInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ToolNameMatchInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1ToolNameMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for tool name match instance.
typedef GoogleCloudAiplatformV1ToolNameMatchInstance = $Instance00;

/// Tool name match metric value for an instance.
class GoogleCloudAiplatformV1ToolNameMatchMetricValue {
  /// Tool name match score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1ToolNameMatchMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1ToolNameMatchMetricValue.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for tool name match metric.
class GoogleCloudAiplatformV1ToolNameMatchResults {
  /// Tool name match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ToolNameMatchMetricValue>?
      toolNameMatchMetricValues;

  GoogleCloudAiplatformV1ToolNameMatchResults({
    this.toolNameMatchMetricValues,
  });

  GoogleCloudAiplatformV1ToolNameMatchResults.fromJson(core.Map json_)
      : this(
          toolNameMatchMetricValues:
              (json_['toolNameMatchMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ToolNameMatchMetricValue.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (toolNameMatchMetricValues != null)
          'toolNameMatchMetricValues': toolNameMatchMetricValues!,
      };
}

/// Spec for tool name match metric.
typedef GoogleCloudAiplatformV1ToolNameMatchSpec = $Empty;

/// Input for tool parameter key value match metric.
class GoogleCloudAiplatformV1ToolParameterKVMatchInput {
  /// Repeated tool parameter key value match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ToolParameterKVMatchInstance>? instances;

  /// Spec for tool parameter key value match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1ToolParameterKVMatchSpec? metricSpec;

  GoogleCloudAiplatformV1ToolParameterKVMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1ToolParameterKVMatchInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ToolParameterKVMatchInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1ToolParameterKVMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for tool parameter key value match instance.
typedef GoogleCloudAiplatformV1ToolParameterKVMatchInstance = $Instance00;

/// Tool parameter key value match metric value for an instance.
class GoogleCloudAiplatformV1ToolParameterKVMatchMetricValue {
  /// Tool parameter key value match score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1ToolParameterKVMatchMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1ToolParameterKVMatchMetricValue.fromJson(
      core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for tool parameter key value match metric.
class GoogleCloudAiplatformV1ToolParameterKVMatchResults {
  /// Tool parameter key value match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ToolParameterKVMatchMetricValue>?
      toolParameterKvMatchMetricValues;

  GoogleCloudAiplatformV1ToolParameterKVMatchResults({
    this.toolParameterKvMatchMetricValues,
  });

  GoogleCloudAiplatformV1ToolParameterKVMatchResults.fromJson(core.Map json_)
      : this(
          toolParameterKvMatchMetricValues:
              (json_['toolParameterKvMatchMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ToolParameterKVMatchMetricValue
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (toolParameterKvMatchMetricValues != null)
          'toolParameterKvMatchMetricValues': toolParameterKvMatchMetricValues!,
      };
}

/// Spec for tool parameter key value match metric.
class GoogleCloudAiplatformV1ToolParameterKVMatchSpec {
  /// Whether to use STRICT string match on parameter values.
  ///
  /// Optional.
  core.bool? useStrictStringMatch;

  GoogleCloudAiplatformV1ToolParameterKVMatchSpec({
    this.useStrictStringMatch,
  });

  GoogleCloudAiplatformV1ToolParameterKVMatchSpec.fromJson(core.Map json_)
      : this(
          useStrictStringMatch: json_['useStrictStringMatch'] as core.bool?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useStrictStringMatch != null)
          'useStrictStringMatch': useStrictStringMatch!,
      };
}

/// Input for tool parameter key match metric.
class GoogleCloudAiplatformV1ToolParameterKeyMatchInput {
  /// Repeated tool parameter key match instances.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ToolParameterKeyMatchInstance>? instances;

  /// Spec for tool parameter key match metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1ToolParameterKeyMatchSpec? metricSpec;

  GoogleCloudAiplatformV1ToolParameterKeyMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1ToolParameterKeyMatchInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1ToolParameterKeyMatchInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1ToolParameterKeyMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for tool parameter key match instance.
typedef GoogleCloudAiplatformV1ToolParameterKeyMatchInstance = $Instance00;

/// Tool parameter key match metric value for an instance.
class GoogleCloudAiplatformV1ToolParameterKeyMatchMetricValue {
  /// Tool parameter key match score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1ToolParameterKeyMatchMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1ToolParameterKeyMatchMetricValue.fromJson(
      core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for tool parameter key match metric.
class GoogleCloudAiplatformV1ToolParameterKeyMatchResults {
  /// Tool parameter key match metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ToolParameterKeyMatchMetricValue>?
      toolParameterKeyMatchMetricValues;

  GoogleCloudAiplatformV1ToolParameterKeyMatchResults({
    this.toolParameterKeyMatchMetricValues,
  });

  GoogleCloudAiplatformV1ToolParameterKeyMatchResults.fromJson(core.Map json_)
      : this(
          toolParameterKeyMatchMetricValues:
              (json_['toolParameterKeyMatchMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1ToolParameterKeyMatchMetricValue
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (toolParameterKeyMatchMetricValues != null)
          'toolParameterKeyMatchMetricValues':
              toolParameterKeyMatchMetricValues!,
      };
}

/// Spec for tool parameter key match metric.
typedef GoogleCloudAiplatformV1ToolParameterKeyMatchSpec = $Empty;

/// CMLE training config.
///
/// For every active learning labeling iteration, system will train a machine
/// learning model on CMLE. The trained model will be used by data sampling
/// algorithm to select DataItems.
class GoogleCloudAiplatformV1TrainingConfig {
  /// The timeout hours for the CMLE training job, expressed in milli hours i.e.
  /// 1,000 value in this field means 1 hour.
  core.String? timeoutTrainingMilliHours;

  GoogleCloudAiplatformV1TrainingConfig({
    this.timeoutTrainingMilliHours,
  });

  GoogleCloudAiplatformV1TrainingConfig.fromJson(core.Map json_)
      : this(
          timeoutTrainingMilliHours:
              json_['timeoutTrainingMilliHours'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (timeoutTrainingMilliHours != null)
          'timeoutTrainingMilliHours': timeoutTrainingMilliHours!,
      };
}

/// The TrainingPipeline orchestrates tasks associated with training a Model.
///
/// It always executes the training task, and optionally may also export data
/// from Vertex AI's Dataset which becomes the training input, upload the Model
/// to Vertex AI, and evaluate the Model.
class GoogleCloudAiplatformV1TrainingPipeline {
  /// Time when the TrainingPipeline was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of this TrainingPipeline.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a TrainingPipeline.
  ///
  /// If set, this TrainingPipeline will be secured by this key. Note: Model
  /// trained by this TrainingPipeline is also secured by this key if
  /// model_to_upload is not set separately.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the TrainingPipeline entered any of the following states:
  /// `PIPELINE_STATE_SUCCEEDED`, `PIPELINE_STATE_FAILED`,
  /// `PIPELINE_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when the pipeline's state is `PIPELINE_STATE_FAILED` or
  /// `PIPELINE_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Specifies Vertex AI owned input data that may be used for training the
  /// Model.
  ///
  /// The TrainingPipeline's training_task_definition should make clear whether
  /// this config is used and if there are any special requirements on how it
  /// should be filled. If nothing about this config is mentioned in the
  /// training_task_definition, then it should be assumed that the
  /// TrainingPipeline does not depend on this configuration.
  GoogleCloudAiplatformV1InputDataConfig? inputDataConfig;

  /// The labels with user-defined metadata to organize TrainingPipelines.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// Describes the Model that may be uploaded (via ModelService.UploadModel) by
  /// this TrainingPipeline.
  ///
  /// The TrainingPipeline's training_task_definition should make clear whether
  /// this Model description should be populated, and if there are any special
  /// requirements regarding how it should be filled. If nothing is mentioned in
  /// the training_task_definition, then it should be assumed that this field
  /// should not be filled and the training task either uploads the Model
  /// without a need of this information, or that training task does not support
  /// uploading a Model as part of the pipeline. When the Pipeline's state
  /// becomes `PIPELINE_STATE_SUCCEEDED` and the trained Model had been uploaded
  /// into Vertex AI, then the model_to_upload's resource name is populated. The
  /// Model is always uploaded into the Project and Location in which this
  /// pipeline is.
  GoogleCloudAiplatformV1Model? modelToUpload;

  /// Resource name of the TrainingPipeline.
  ///
  /// Output only.
  core.String? name;

  /// When specify this field, the `model_to_upload` will not be uploaded as a
  /// new model, instead, it will become a new version of this `parent_model`.
  ///
  /// Optional.
  core.String? parentModel;

  /// Time when the TrainingPipeline for the first time entered the
  /// `PIPELINE_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the pipeline.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PIPELINE_STATE_UNSPECIFIED" : The pipeline state is unspecified.
  /// - "PIPELINE_STATE_QUEUED" : The pipeline has been created or resumed, and
  /// processing has not yet begun.
  /// - "PIPELINE_STATE_PENDING" : The service is preparing to run the pipeline.
  /// - "PIPELINE_STATE_RUNNING" : The pipeline is in progress.
  /// - "PIPELINE_STATE_SUCCEEDED" : The pipeline completed successfully.
  /// - "PIPELINE_STATE_FAILED" : The pipeline failed.
  /// - "PIPELINE_STATE_CANCELLING" : The pipeline is being cancelled. From this
  /// state, the pipeline may only go to either PIPELINE_STATE_SUCCEEDED,
  /// PIPELINE_STATE_FAILED or PIPELINE_STATE_CANCELLED.
  /// - "PIPELINE_STATE_CANCELLED" : The pipeline has been cancelled.
  /// - "PIPELINE_STATE_PAUSED" : The pipeline has been stopped, and can be
  /// resumed.
  core.String? state;

  /// A Google Cloud Storage path to the YAML file that defines the training
  /// task which is responsible for producing the model artifact, and may also
  /// include additional auxiliary work.
  ///
  /// The definition files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/trainingjob/definition/. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Required.
  core.String? trainingTaskDefinition;

  /// The training task's parameter(s), as specified in the
  /// training_task_definition's `inputs`.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? trainingTaskInputs;

  /// The metadata information as specified in the training_task_definition's
  /// `metadata`.
  ///
  /// This metadata is an auxiliary runtime and final information about the
  /// training task. While the pipeline is running this information is populated
  /// only at a best effort basis. Only present if the pipeline's
  /// training_task_definition contains `metadata` object.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? trainingTaskMetadata;

  /// Time when the TrainingPipeline was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1TrainingPipeline({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.inputDataConfig,
    this.labels,
    this.modelId,
    this.modelToUpload,
    this.name,
    this.parentModel,
    this.startTime,
    this.state,
    this.trainingTaskDefinition,
    this.trainingTaskInputs,
    this.trainingTaskMetadata,
    this.updateTime,
  });

  GoogleCloudAiplatformV1TrainingPipeline.fromJson(core.Map json_)
      : this(
          createTime: json_['createTime'] as core.String?,
          displayName: json_['displayName'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          inputDataConfig: json_.containsKey('inputDataConfig')
              ? GoogleCloudAiplatformV1InputDataConfig.fromJson(
                  json_['inputDataConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          modelId: json_['modelId'] as core.String?,
          modelToUpload: json_.containsKey('modelToUpload')
              ? GoogleCloudAiplatformV1Model.fromJson(
                  json_['modelToUpload'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_['name'] as core.String?,
          parentModel: json_['parentModel'] as core.String?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          trainingTaskDefinition:
              json_['trainingTaskDefinition'] as core.String?,
          trainingTaskInputs: json_['trainingTaskInputs'],
          trainingTaskMetadata: json_['trainingTaskMetadata'],
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (inputDataConfig != null) 'inputDataConfig': inputDataConfig!,
        if (labels != null) 'labels': labels!,
        if (modelId != null) 'modelId': modelId!,
        if (modelToUpload != null) 'modelToUpload': modelToUpload!,
        if (name != null) 'name': name!,
        if (parentModel != null) 'parentModel': parentModel!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (trainingTaskDefinition != null)
          'trainingTaskDefinition': trainingTaskDefinition!,
        if (trainingTaskInputs != null)
          'trainingTaskInputs': trainingTaskInputs!,
        if (trainingTaskMetadata != null)
          'trainingTaskMetadata': trainingTaskMetadata!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Spec for trajectory.
class GoogleCloudAiplatformV1Trajectory {
  /// Tool calls in the trajectory.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ToolCall>? toolCalls;

  GoogleCloudAiplatformV1Trajectory({
    this.toolCalls,
  });

  GoogleCloudAiplatformV1Trajectory.fromJson(core.Map json_)
      : this(
          toolCalls: (json_['toolCalls'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1ToolCall.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (toolCalls != null) 'toolCalls': toolCalls!,
      };
}

/// Instances and metric spec for TrajectoryAnyOrderMatch metric.
class GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInput {
  /// Repeated TrajectoryAnyOrderMatch instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInstance>? instances;

  /// Spec for TrajectoryAnyOrderMatch metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchSpec? metricSpec;

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInstance
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1TrajectoryAnyOrderMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for TrajectoryAnyOrderMatch instance.
class GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchInstance.fromJson(
      core.Map json_)
      : this(
          predictedTrajectory: json_.containsKey('predictedTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
          referenceTrajectory: json_.containsKey('referenceTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (predictedTrajectory != null)
          'predictedTrajectory': predictedTrajectory!,
        if (referenceTrajectory != null)
          'referenceTrajectory': referenceTrajectory!,
      };
}

/// TrajectoryAnyOrderMatch metric value for an instance.
class GoogleCloudAiplatformV1TrajectoryAnyOrderMatchMetricValue {
  /// TrajectoryAnyOrderMatch score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchMetricValue.fromJson(
      core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for TrajectoryAnyOrderMatch metric.
class GoogleCloudAiplatformV1TrajectoryAnyOrderMatchResults {
  /// TrajectoryAnyOrderMatch metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrajectoryAnyOrderMatchMetricValue>?
      trajectoryAnyOrderMatchMetricValues;

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchResults({
    this.trajectoryAnyOrderMatchMetricValues,
  });

  GoogleCloudAiplatformV1TrajectoryAnyOrderMatchResults.fromJson(core.Map json_)
      : this(
          trajectoryAnyOrderMatchMetricValues:
              (json_['trajectoryAnyOrderMatchMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1TrajectoryAnyOrderMatchMetricValue
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (trajectoryAnyOrderMatchMetricValues != null)
          'trajectoryAnyOrderMatchMetricValues':
              trajectoryAnyOrderMatchMetricValues!,
      };
}

/// Spec for TrajectoryAnyOrderMatch metric - returns 1 if all tool calls in the
/// reference trajectory appear in the predicted trajectory in any order, else
/// 0.
typedef GoogleCloudAiplatformV1TrajectoryAnyOrderMatchSpec = $Empty;

/// Instances and metric spec for TrajectoryExactMatch metric.
class GoogleCloudAiplatformV1TrajectoryExactMatchInput {
  /// Repeated TrajectoryExactMatch instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TrajectoryExactMatchInstance>? instances;

  /// Spec for TrajectoryExactMatch metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1TrajectoryExactMatchSpec? metricSpec;

  GoogleCloudAiplatformV1TrajectoryExactMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1TrajectoryExactMatchInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TrajectoryExactMatchInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1TrajectoryExactMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for TrajectoryExactMatch instance.
class GoogleCloudAiplatformV1TrajectoryExactMatchInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1TrajectoryExactMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1TrajectoryExactMatchInstance.fromJson(core.Map json_)
      : this(
          predictedTrajectory: json_.containsKey('predictedTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
          referenceTrajectory: json_.containsKey('referenceTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (predictedTrajectory != null)
          'predictedTrajectory': predictedTrajectory!,
        if (referenceTrajectory != null)
          'referenceTrajectory': referenceTrajectory!,
      };
}

/// TrajectoryExactMatch metric value for an instance.
class GoogleCloudAiplatformV1TrajectoryExactMatchMetricValue {
  /// TrajectoryExactMatch score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1TrajectoryExactMatchMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1TrajectoryExactMatchMetricValue.fromJson(
      core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for TrajectoryExactMatch metric.
class GoogleCloudAiplatformV1TrajectoryExactMatchResults {
  /// TrajectoryExactMatch metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrajectoryExactMatchMetricValue>?
      trajectoryExactMatchMetricValues;

  GoogleCloudAiplatformV1TrajectoryExactMatchResults({
    this.trajectoryExactMatchMetricValues,
  });

  GoogleCloudAiplatformV1TrajectoryExactMatchResults.fromJson(core.Map json_)
      : this(
          trajectoryExactMatchMetricValues:
              (json_['trajectoryExactMatchMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1TrajectoryExactMatchMetricValue
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (trajectoryExactMatchMetricValues != null)
          'trajectoryExactMatchMetricValues': trajectoryExactMatchMetricValues!,
      };
}

/// Spec for TrajectoryExactMatch metric - returns 1 if tool calls in the
/// reference trajectory exactly match the predicted trajectory, else 0.
typedef GoogleCloudAiplatformV1TrajectoryExactMatchSpec = $Empty;

/// Instances and metric spec for TrajectoryInOrderMatch metric.
class GoogleCloudAiplatformV1TrajectoryInOrderMatchInput {
  /// Repeated TrajectoryInOrderMatch instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TrajectoryInOrderMatchInstance>? instances;

  /// Spec for TrajectoryInOrderMatch metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1TrajectoryInOrderMatchSpec? metricSpec;

  GoogleCloudAiplatformV1TrajectoryInOrderMatchInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1TrajectoryInOrderMatchInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TrajectoryInOrderMatchInstance
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1TrajectoryInOrderMatchSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for TrajectoryInOrderMatch instance.
class GoogleCloudAiplatformV1TrajectoryInOrderMatchInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1TrajectoryInOrderMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1TrajectoryInOrderMatchInstance.fromJson(core.Map json_)
      : this(
          predictedTrajectory: json_.containsKey('predictedTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
          referenceTrajectory: json_.containsKey('referenceTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (predictedTrajectory != null)
          'predictedTrajectory': predictedTrajectory!,
        if (referenceTrajectory != null)
          'referenceTrajectory': referenceTrajectory!,
      };
}

/// TrajectoryInOrderMatch metric value for an instance.
class GoogleCloudAiplatformV1TrajectoryInOrderMatchMetricValue {
  /// TrajectoryInOrderMatch score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1TrajectoryInOrderMatchMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1TrajectoryInOrderMatchMetricValue.fromJson(
      core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for TrajectoryInOrderMatch metric.
class GoogleCloudAiplatformV1TrajectoryInOrderMatchResults {
  /// TrajectoryInOrderMatch metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrajectoryInOrderMatchMetricValue>?
      trajectoryInOrderMatchMetricValues;

  GoogleCloudAiplatformV1TrajectoryInOrderMatchResults({
    this.trajectoryInOrderMatchMetricValues,
  });

  GoogleCloudAiplatformV1TrajectoryInOrderMatchResults.fromJson(core.Map json_)
      : this(
          trajectoryInOrderMatchMetricValues:
              (json_['trajectoryInOrderMatchMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1TrajectoryInOrderMatchMetricValue
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (trajectoryInOrderMatchMetricValues != null)
          'trajectoryInOrderMatchMetricValues':
              trajectoryInOrderMatchMetricValues!,
      };
}

/// Spec for TrajectoryInOrderMatch metric - returns 1 if tool calls in the
/// reference trajectory appear in the predicted trajectory in the same order,
/// else 0.
typedef GoogleCloudAiplatformV1TrajectoryInOrderMatchSpec = $Empty;

/// Instances and metric spec for TrajectoryPrecision metric.
class GoogleCloudAiplatformV1TrajectoryPrecisionInput {
  /// Repeated TrajectoryPrecision instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TrajectoryPrecisionInstance>? instances;

  /// Spec for TrajectoryPrecision metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1TrajectoryPrecisionSpec? metricSpec;

  GoogleCloudAiplatformV1TrajectoryPrecisionInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1TrajectoryPrecisionInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TrajectoryPrecisionInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1TrajectoryPrecisionSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for TrajectoryPrecision instance.
class GoogleCloudAiplatformV1TrajectoryPrecisionInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1TrajectoryPrecisionInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1TrajectoryPrecisionInstance.fromJson(core.Map json_)
      : this(
          predictedTrajectory: json_.containsKey('predictedTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
          referenceTrajectory: json_.containsKey('referenceTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (predictedTrajectory != null)
          'predictedTrajectory': predictedTrajectory!,
        if (referenceTrajectory != null)
          'referenceTrajectory': referenceTrajectory!,
      };
}

/// TrajectoryPrecision metric value for an instance.
class GoogleCloudAiplatformV1TrajectoryPrecisionMetricValue {
  /// TrajectoryPrecision score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1TrajectoryPrecisionMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1TrajectoryPrecisionMetricValue.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for TrajectoryPrecision metric.
class GoogleCloudAiplatformV1TrajectoryPrecisionResults {
  /// TrajectoryPrecision metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrajectoryPrecisionMetricValue>?
      trajectoryPrecisionMetricValues;

  GoogleCloudAiplatformV1TrajectoryPrecisionResults({
    this.trajectoryPrecisionMetricValues,
  });

  GoogleCloudAiplatformV1TrajectoryPrecisionResults.fromJson(core.Map json_)
      : this(
          trajectoryPrecisionMetricValues:
              (json_['trajectoryPrecisionMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1TrajectoryPrecisionMetricValue
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (trajectoryPrecisionMetricValues != null)
          'trajectoryPrecisionMetricValues': trajectoryPrecisionMetricValues!,
      };
}

/// Spec for TrajectoryPrecision metric - returns a float score based on average
/// precision of individual tool calls.
typedef GoogleCloudAiplatformV1TrajectoryPrecisionSpec = $Empty;

/// Instances and metric spec for TrajectoryRecall metric.
class GoogleCloudAiplatformV1TrajectoryRecallInput {
  /// Repeated TrajectoryRecall instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TrajectoryRecallInstance>? instances;

  /// Spec for TrajectoryRecall metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1TrajectoryRecallSpec? metricSpec;

  GoogleCloudAiplatformV1TrajectoryRecallInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1TrajectoryRecallInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TrajectoryRecallInstance.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1TrajectoryRecallSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for TrajectoryRecall instance.
class GoogleCloudAiplatformV1TrajectoryRecallInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? predictedTrajectory;

  /// Spec for reference tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? referenceTrajectory;

  GoogleCloudAiplatformV1TrajectoryRecallInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  });

  GoogleCloudAiplatformV1TrajectoryRecallInstance.fromJson(core.Map json_)
      : this(
          predictedTrajectory: json_.containsKey('predictedTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
          referenceTrajectory: json_.containsKey('referenceTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['referenceTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (predictedTrajectory != null)
          'predictedTrajectory': predictedTrajectory!,
        if (referenceTrajectory != null)
          'referenceTrajectory': referenceTrajectory!,
      };
}

/// TrajectoryRecall metric value for an instance.
class GoogleCloudAiplatformV1TrajectoryRecallMetricValue {
  /// TrajectoryRecall score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1TrajectoryRecallMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1TrajectoryRecallMetricValue.fromJson(core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for TrajectoryRecall metric.
class GoogleCloudAiplatformV1TrajectoryRecallResults {
  /// TrajectoryRecall metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrajectoryRecallMetricValue>?
      trajectoryRecallMetricValues;

  GoogleCloudAiplatformV1TrajectoryRecallResults({
    this.trajectoryRecallMetricValues,
  });

  GoogleCloudAiplatformV1TrajectoryRecallResults.fromJson(core.Map json_)
      : this(
          trajectoryRecallMetricValues: (json_['trajectoryRecallMetricValues']
                  as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TrajectoryRecallMetricValue.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (trajectoryRecallMetricValues != null)
          'trajectoryRecallMetricValues': trajectoryRecallMetricValues!,
      };
}

/// Spec for TrajectoryRecall metric - returns a float score based on average
/// recall of individual tool calls.
typedef GoogleCloudAiplatformV1TrajectoryRecallSpec = $Empty;

/// Instances and metric spec for TrajectorySingleToolUse metric.
class GoogleCloudAiplatformV1TrajectorySingleToolUseInput {
  /// Repeated TrajectorySingleToolUse instance.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TrajectorySingleToolUseInstance>? instances;

  /// Spec for TrajectorySingleToolUse metric.
  ///
  /// Required.
  GoogleCloudAiplatformV1TrajectorySingleToolUseSpec? metricSpec;

  GoogleCloudAiplatformV1TrajectorySingleToolUseInput({
    this.instances,
    this.metricSpec,
  });

  GoogleCloudAiplatformV1TrajectorySingleToolUseInput.fromJson(core.Map json_)
      : this(
          instances: (json_['instances'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1TrajectorySingleToolUseInstance
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
          metricSpec: json_.containsKey('metricSpec')
              ? GoogleCloudAiplatformV1TrajectorySingleToolUseSpec.fromJson(
                  json_['metricSpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (metricSpec != null) 'metricSpec': metricSpec!,
      };
}

/// Spec for TrajectorySingleToolUse instance.
class GoogleCloudAiplatformV1TrajectorySingleToolUseInstance {
  /// Spec for predicted tool call trajectory.
  ///
  /// Required.
  GoogleCloudAiplatformV1Trajectory? predictedTrajectory;

  GoogleCloudAiplatformV1TrajectorySingleToolUseInstance({
    this.predictedTrajectory,
  });

  GoogleCloudAiplatformV1TrajectorySingleToolUseInstance.fromJson(
      core.Map json_)
      : this(
          predictedTrajectory: json_.containsKey('predictedTrajectory')
              ? GoogleCloudAiplatformV1Trajectory.fromJson(
                  json_['predictedTrajectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (predictedTrajectory != null)
          'predictedTrajectory': predictedTrajectory!,
      };
}

/// TrajectorySingleToolUse metric value for an instance.
class GoogleCloudAiplatformV1TrajectorySingleToolUseMetricValue {
  /// TrajectorySingleToolUse score.
  ///
  /// Output only.
  core.double? score;

  GoogleCloudAiplatformV1TrajectorySingleToolUseMetricValue({
    this.score,
  });

  GoogleCloudAiplatformV1TrajectorySingleToolUseMetricValue.fromJson(
      core.Map json_)
      : this(
          score: (json_['score'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (score != null) 'score': score!,
      };
}

/// Results for TrajectorySingleToolUse metric.
class GoogleCloudAiplatformV1TrajectorySingleToolUseResults {
  /// TrajectorySingleToolUse metric values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrajectorySingleToolUseMetricValue>?
      trajectorySingleToolUseMetricValues;

  GoogleCloudAiplatformV1TrajectorySingleToolUseResults({
    this.trajectorySingleToolUseMetricValues,
  });

  GoogleCloudAiplatformV1TrajectorySingleToolUseResults.fromJson(core.Map json_)
      : this(
          trajectorySingleToolUseMetricValues:
              (json_['trajectorySingleToolUseMetricValues'] as core.List?)
                  ?.map((value) =>
                      GoogleCloudAiplatformV1TrajectorySingleToolUseMetricValue
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (trajectorySingleToolUseMetricValues != null)
          'trajectorySingleToolUseMetricValues':
              trajectorySingleToolUseMetricValues!,
      };
}

/// Spec for TrajectorySingleToolUse metric - returns 1 if tool is present in
/// the predicted trajectory, else 0.
class GoogleCloudAiplatformV1TrajectorySingleToolUseSpec {
  /// Spec for tool name to be checked for in the predicted trajectory.
  ///
  /// Required.
  core.String? toolName;

  GoogleCloudAiplatformV1TrajectorySingleToolUseSpec({
    this.toolName,
  });

  GoogleCloudAiplatformV1TrajectorySingleToolUseSpec.fromJson(core.Map json_)
      : this(
          toolName: json_['toolName'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (toolName != null) 'toolName': toolName!,
      };
}

/// A message representing a Trial.
///
/// A Trial contains a unique set of Parameters that has been or will be
/// evaluated, along with the objective metrics got by running the Trial.
class GoogleCloudAiplatformV1Trial {
  /// The identifier of the client that originally requested this Trial.
  ///
  /// Each client is identified by a unique client_id. When a client asks for a
  /// suggestion, Vertex AI Vizier will assign it a Trial. The client should
  /// evaluate the Trial, complete it, and report back to Vertex AI Vizier. If
  /// suggestion is asked again by same client_id before the Trial is completed,
  /// the same Trial will be returned. Multiple clients with different
  /// client_ids can ask for suggestions simultaneously, each of them will get
  /// their own Trial.
  ///
  /// Output only.
  core.String? clientId;

  /// The CustomJob name linked to the Trial.
  ///
  /// It's set for a HyperparameterTuningJob's Trial.
  ///
  /// Output only.
  core.String? customJob;

  /// Time when the Trial's status changed to `SUCCEEDED` or `INFEASIBLE`.
  ///
  /// Output only.
  core.String? endTime;

  /// The final measurement containing the objective value.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Measurement? finalMeasurement;

  /// The identifier of the Trial assigned by the service.
  ///
  /// Output only.
  core.String? id;

  /// A human readable string describing why the Trial is infeasible.
  ///
  /// This is set only if Trial state is `INFEASIBLE`.
  ///
  /// Output only.
  core.String? infeasibleReason;

  /// A list of measurements that are strictly lexicographically ordered by
  /// their induced tuples (steps, elapsed_duration).
  ///
  /// These are used for early stopping computations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Measurement>? measurements;

  /// Resource name of the Trial assigned by the service.
  ///
  /// Output only.
  core.String? name;

  /// The parameters of the Trial.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrialParameter>? parameters;

  /// Time when the Trial was started.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the Trial.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The Trial state is unspecified.
  /// - "REQUESTED" : Indicates that a specific Trial has been requested, but it
  /// has not yet been suggested by the service.
  /// - "ACTIVE" : Indicates that the Trial has been suggested.
  /// - "STOPPING" : Indicates that the Trial should stop according to the
  /// service.
  /// - "SUCCEEDED" : Indicates that the Trial is completed successfully.
  /// - "INFEASIBLE" : Indicates that the Trial should not be attempted again.
  /// The service will set a Trial to INFEASIBLE when it's done but missing the
  /// final_measurement.
  core.String? state;

  /// URIs for accessing
  /// [interactive shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node).
  ///
  /// Only available if this trial is part of a HyperparameterTuningJob and the
  /// job's trial_job_spec.enable_web_access field is `true`. The keys are names
  /// of each node used for the trial; for example, `workerpool0-0` for the
  /// primary node, `workerpool1-0` for the first node in the second worker
  /// pool, and `workerpool1-1` for the second node in the second worker pool.
  /// The values are the URIs for each node's interactive shell.
  ///
  /// Output only.
  core.Map<core.String, core.String>? webAccessUris;

  GoogleCloudAiplatformV1Trial({
    this.clientId,
    this.customJob,
    this.endTime,
    this.finalMeasurement,
    this.id,
    this.infeasibleReason,
    this.measurements,
    this.name,
    this.parameters,
    this.startTime,
    this.state,
    this.webAccessUris,
  });

  GoogleCloudAiplatformV1Trial.fromJson(core.Map json_)
      : this(
          clientId: json_['clientId'] as core.String?,
          customJob: json_['customJob'] as core.String?,
          endTime: json_['endTime'] as core.String?,
          finalMeasurement: json_.containsKey('finalMeasurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>)
              : null,
          id: json_['id'] as core.String?,
          infeasibleReason: json_['infeasibleReason'] as core.String?,
          measurements: (json_['measurements'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1Measurement.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          name: json_['name'] as core.String?,
          parameters: (json_['parameters'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TrialParameter.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          webAccessUris:
              (json_['webAccessUris'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientId != null) 'clientId': clientId!,
        if (customJob != null) 'customJob': customJob!,
        if (endTime != null) 'endTime': endTime!,
        if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
        if (id != null) 'id': id!,
        if (infeasibleReason != null) 'infeasibleReason': infeasibleReason!,
        if (measurements != null) 'measurements': measurements!,
        if (name != null) 'name': name!,
        if (parameters != null) 'parameters': parameters!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (webAccessUris != null) 'webAccessUris': webAccessUris!,
      };
}

class GoogleCloudAiplatformV1TrialContext {
  /// A human-readable field which can store a description of this context.
  ///
  /// This will become part of the resulting Trial's description field.
  core.String? description;

  /// If/when a Trial is generated or selected from this Context, its Parameters
  /// will match any parameters specified here.
  ///
  /// (I.e. if this context specifies parameter name:'a' int_value:3, then a
  /// resulting Trial will have int_value:3 for its parameter named 'a'.) Note
  /// that we first attempt to match existing REQUESTED Trials with contexts,
  /// and if there are no matches, we generate suggestions in the subspace
  /// defined by the parameters specified here. NOTE: a Context without any
  /// Parameters matches the entire feasible search space.
  core.List<GoogleCloudAiplatformV1TrialParameter>? parameters;

  GoogleCloudAiplatformV1TrialContext({
    this.description,
    this.parameters,
  });

  GoogleCloudAiplatformV1TrialContext.fromJson(core.Map json_)
      : this(
          description: json_['description'] as core.String?,
          parameters: (json_['parameters'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TrialParameter.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// A message representing a parameter to be tuned.
class GoogleCloudAiplatformV1TrialParameter {
  /// The ID of the parameter.
  ///
  /// The parameter should be defined in StudySpec's Parameters.
  ///
  /// Output only.
  core.String? parameterId;

  /// The value of the parameter.
  ///
  /// `number_value` will be set if a parameter defined in StudySpec is in type
  /// 'INTEGER', 'DOUBLE' or 'DISCRETE'. `string_value` will be set if a
  /// parameter defined in StudySpec is in type 'CATEGORICAL'.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? value;

  GoogleCloudAiplatformV1TrialParameter({
    this.parameterId,
    this.value,
  });

  GoogleCloudAiplatformV1TrialParameter.fromJson(core.Map json_)
      : this(
          parameterId: json_['parameterId'] as core.String?,
          value: json_['value'],
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parameterId != null) 'parameterId': parameterId!,
        if (value != null) 'value': value!,
      };
}

/// The Model Registry Model and Online Prediction Endpoint associated with this
/// TuningJob.
class GoogleCloudAiplatformV1TunedModel {
  /// A resource name of an Endpoint.
  ///
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`.
  ///
  /// Output only.
  core.String? endpoint;

  /// The resource name of the TunedModel.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  ///
  /// Output only.
  core.String? model;

  GoogleCloudAiplatformV1TunedModel({
    this.endpoint,
    this.model,
  });

  GoogleCloudAiplatformV1TunedModel.fromJson(core.Map json_)
      : this(
          endpoint: json_['endpoint'] as core.String?,
          model: json_['model'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
        if (model != null) 'model': model!,
      };
}

/// TunedModel Reference for legacy model migration.
class GoogleCloudAiplatformV1TunedModelRef {
  /// Support migration from tuning job list page, from bison model to gemini
  /// model.
  core.String? pipelineJob;

  /// Support migration from model registry.
  core.String? tunedModel;

  /// Support migration from tuning job list page, from gemini-1.0-pro-002 to
  /// 1.5 and above.
  core.String? tuningJob;

  GoogleCloudAiplatformV1TunedModelRef({
    this.pipelineJob,
    this.tunedModel,
    this.tuningJob,
  });

  GoogleCloudAiplatformV1TunedModelRef.fromJson(core.Map json_)
      : this(
          pipelineJob: json_['pipelineJob'] as core.String?,
          tunedModel: json_['tunedModel'] as core.String?,
          tuningJob: json_['tuningJob'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (pipelineJob != null) 'pipelineJob': pipelineJob!,
        if (tunedModel != null) 'tunedModel': tunedModel!,
        if (tuningJob != null) 'tuningJob': tuningJob!,
      };
}

/// The tuning data statistic values for TuningJob.
class GoogleCloudAiplatformV1TuningDataStats {
  /// The SFT Tuning data stats.
  GoogleCloudAiplatformV1SupervisedTuningDataStats? supervisedTuningDataStats;

  GoogleCloudAiplatformV1TuningDataStats({
    this.supervisedTuningDataStats,
  });

  GoogleCloudAiplatformV1TuningDataStats.fromJson(core.Map json_)
      : this(
          supervisedTuningDataStats:
              json_.containsKey('supervisedTuningDataStats')
                  ? GoogleCloudAiplatformV1SupervisedTuningDataStats.fromJson(
                      json_['supervisedTuningDataStats']
                          as core.Map<core.String, core.dynamic>)
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (supervisedTuningDataStats != null)
          'supervisedTuningDataStats': supervisedTuningDataStats!,
      };
}

/// Represents a TuningJob that runs with Google owned models.
class GoogleCloudAiplatformV1TuningJob {
  /// The base model that is being tuned, e.g., "gemini-1.0-pro-002".
  ///
  /// .
  core.String? baseModel;

  /// Time when the TuningJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the TuningJob.
  ///
  /// Optional.
  core.String? description;

  /// Customer-managed encryption key options for a TuningJob.
  ///
  /// If this is set, then all resources created by the TuningJob will be
  /// encrypted with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the TuningJob entered any of the following JobStates:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`,
  /// `JOB_STATE_EXPIRED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The Experiment associated with this TuningJob.
  ///
  /// Output only.
  core.String? experiment;

  /// The labels with user-defined metadata to organize TuningJob and generated
  /// resources such as Model and Endpoint.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Identifier.
  ///
  /// Resource name of a TuningJob. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  ///
  /// Output only.
  core.String? name;

  /// The service account that the tuningJob workload runs as.
  ///
  /// If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the
  /// project will be used. See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-secure-fine-tuning-service-agent
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  core.String? serviceAccount;

  /// Time when the TuningJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Tuning Spec for Supervised Fine Tuning.
  GoogleCloudAiplatformV1SupervisedTuningSpec? supervisedTuningSpec;

  /// The tuned model resources associated with this TuningJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1TunedModel? tunedModel;

  /// The display name of the TunedModel.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Optional.
  core.String? tunedModelDisplayName;

  /// The tuning data statistics associated with this TuningJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1TuningDataStats? tuningDataStats;

  /// Time when the TuningJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1TuningJob({
    this.baseModel,
    this.createTime,
    this.description,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.experiment,
    this.labels,
    this.name,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.supervisedTuningSpec,
    this.tunedModel,
    this.tunedModelDisplayName,
    this.tuningDataStats,
    this.updateTime,
  });

  GoogleCloudAiplatformV1TuningJob.fromJson(core.Map json_)
      : this(
          baseModel: json_['baseModel'] as core.String?,
          createTime: json_['createTime'] as core.String?,
          description: json_['description'] as core.String?,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_['endTime'] as core.String?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          experiment: json_['experiment'] as core.String?,
          labels:
              (json_['labels'] as core.Map<core.String, core.dynamic>?)?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.String,
            ),
          ),
          name: json_['name'] as core.String?,
          serviceAccount: json_['serviceAccount'] as core.String?,
          startTime: json_['startTime'] as core.String?,
          state: json_['state'] as core.String?,
          supervisedTuningSpec: json_.containsKey('supervisedTuningSpec')
              ? GoogleCloudAiplatformV1SupervisedTuningSpec.fromJson(
                  json_['supervisedTuningSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tunedModel: json_.containsKey('tunedModel')
              ? GoogleCloudAiplatformV1TunedModel.fromJson(
                  json_['tunedModel'] as core.Map<core.String, core.dynamic>)
              : null,
          tunedModelDisplayName: json_['tunedModelDisplayName'] as core.String?,
          tuningDataStats: json_.containsKey('tuningDataStats')
              ? GoogleCloudAiplatformV1TuningDataStats.fromJson(
                  json_['tuningDataStats']
                      as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_['updateTime'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baseModel != null) 'baseModel': baseModel!,
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (experiment != null) 'experiment': experiment!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (supervisedTuningSpec != null)
          'supervisedTuningSpec': supervisedTuningSpec!,
        if (tunedModel != null) 'tunedModel': tunedModel!,
        if (tunedModelDisplayName != null)
          'tunedModelDisplayName': tunedModelDisplayName!,
        if (tuningDataStats != null) 'tuningDataStats': tuningDataStats!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Request message for IndexEndpointService.UndeployIndex.
class GoogleCloudAiplatformV1UndeployIndexRequest {
  /// The ID of the DeployedIndex to be undeployed from the IndexEndpoint.
  ///
  /// Required.
  core.String? deployedIndexId;

  GoogleCloudAiplatformV1UndeployIndexRequest({
    this.deployedIndexId,
  });

  GoogleCloudAiplatformV1UndeployIndexRequest.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_['deployedIndexId'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
      };
}

/// Request message for EndpointService.UndeployModel.
class GoogleCloudAiplatformV1UndeployModelRequest {
  /// The ID of the DeployedModel to be undeployed from the Endpoint.
  ///
  /// Required.
  core.String? deployedModelId;

  /// If this field is provided, then the Endpoint's traffic_split will be
  /// overwritten with it.
  ///
  /// If last DeployedModel is being undeployed from the Endpoint, the
  /// \[Endpoint.traffic_split\] will always end up empty when this call
  /// returns. A DeployedModel will be successfully undeployed only if it
  /// doesn't have any traffic assigned to it when this method executes, or if
  /// this field unassigns any traffic to it.
  core.Map<core.String, core.int>? trafficSplit;

  GoogleCloudAiplatformV1UndeployModelRequest({
    this.deployedModelId,
    this.trafficSplit,
  });

  GoogleCloudAiplatformV1UndeployModelRequest.fromJson(core.Map json_)
      : this(
          deployedModelId: json_['deployedModelId'] as core.String?,
          trafficSplit:
              (json_['trafficSplit'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              value as core.int,
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (trafficSplit != null) 'trafficSplit': trafficSplit!,
      };
}

/// Contains model information necessary to perform batch prediction without
/// requiring a full model import.
class GoogleCloudAiplatformV1UnmanagedContainerModel {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  core.String? artifactUri;

  /// Input only.
  ///
  /// The specification of the container that is to be used when deploying this
  /// Model.
  GoogleCloudAiplatformV1ModelContainerSpec? containerSpec;

  /// Contains the schemata used in Model's predictions and explanations
  GoogleCloudAiplatformV1PredictSchemata? predictSchemata;

  GoogleCloudAiplatformV1UnmanagedContainerModel({
    this.artifactUri,
    this.containerSpec,
    this.predictSchemata,
  });

  GoogleCloudAiplatformV1UnmanagedContainerModel.fromJson(core.Map json_)
      : this(
          artifactUri: json_['artifactUri'] as core.String?,
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          predictSchemata: json_.containsKey('predictSchemata')
              ? GoogleCloudAiplatformV1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactUri != null) 'artifactUri': artifactUri!,
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (predictSchemata != null) 'predictSchemata': predictSchemata!,
      };
}

/// Request message for EndpointService.UpdateEndpointLongRunning.
class GoogleCloudAiplatformV1UpdateEndpointLongRunningRequest {
  /// The Endpoint which replaces the resource on the server.
  ///
  /// Currently we only support updating the `client_connection_config` field,
  /// all the other fields' update will be blocked.
  ///
  /// Required.
  GoogleCloudAiplatformV1Endpoint? endpoint;

  GoogleCloudAiplatformV1UpdateEndpointLongRunningRequest({
    this.endpoint,
  });

  GoogleCloudAiplatformV1UpdateEndpointLongRunningRequest.fromJson(
      core.Map json_)
      : this(
          endpoint: json_.containsKey('endpoint')
              ? GoogleCloudAiplatformV1Endpoint.fromJson(
                  json_['endpoint'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
      };
}

/// Request message for ModelService.UpdateExplanationDataset.
class GoogleCloudAiplatformV1UpdateExplanationDatasetRequest {
  /// The example config containing the location of the dataset.
  GoogleCloudAiplatformV1Examples? examples;

  GoogleCloudAiplatformV1UpdateExplanationDatasetRequest({
    this.examples,
  });

  GoogleCloudAiplatformV1UpdateExplanationDatasetRequest.fromJson(
      core.Map json_)
      : this(
          examples: json_.containsKey('examples')
              ? GoogleCloudAiplatformV1Examples.fromJson(
                  json_['examples'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (examples != null) 'examples': examples!,
      };
}

/// Request message for NotebookService.UpgradeNotebookRuntime.
typedef GoogleCloudAiplatformV1UpgradeNotebookRuntimeRequest = $Empty;

/// Request message for ModelService.UploadModel.
class GoogleCloudAiplatformV1UploadModelRequest {
  /// The Model to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1Model? model;

  /// The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// The resource name of the model into which to upload the version.
  ///
  /// Only specify this field when uploading a new version.
  ///
  /// Optional.
  core.String? parentModel;

  /// The user-provided custom service account to use to do the model upload.
  ///
  /// If empty,
  /// [Vertex AI Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used to access resources needed to upload the model. This account
  /// must belong to the target project where the model is uploaded to, i.e.,
  /// the project specified in the `parent` field of this request and have
  /// necessary read permissions (to Google Cloud Storage, Artifact Registry,
  /// etc.).
  ///
  /// Optional.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1UploadModelRequest({
    this.model,
    this.modelId,
    this.parentModel,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1UploadModelRequest.fromJson(core.Map json_)
      : this(
          model: json_.containsKey('model')
              ? GoogleCloudAiplatformV1Model.fromJson(
                  json_['model'] as core.Map<core.String, core.dynamic>)
              : null,
          modelId: json_['modelId'] as core.String?,
          parentModel: json_['parentModel'] as core.String?,
          serviceAccount: json_['serviceAccount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
        if (modelId != null) 'modelId': modelId!,
        if (parentModel != null) 'parentModel': parentModel!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
      };
}

/// Config for uploading RagFile.
class GoogleCloudAiplatformV1UploadRagFileConfig {
  /// Specifies the transformation config for RagFiles.
  GoogleCloudAiplatformV1RagFileTransformationConfig?
      ragFileTransformationConfig;

  GoogleCloudAiplatformV1UploadRagFileConfig({
    this.ragFileTransformationConfig,
  });

  GoogleCloudAiplatformV1UploadRagFileConfig.fromJson(core.Map json_)
      : this(
          ragFileTransformationConfig:
              json_.containsKey('ragFileTransformationConfig')
                  ? GoogleCloudAiplatformV1RagFileTransformationConfig.fromJson(
                      json_['ragFileTransformationConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragFileTransformationConfig != null)
          'ragFileTransformationConfig': ragFileTransformationConfig!,
      };
}

/// Request message for VertexRagDataService.UploadRagFile.
class GoogleCloudAiplatformV1UploadRagFileRequest {
  /// The RagFile to upload.
  ///
  /// Required.
  GoogleCloudAiplatformV1RagFile? ragFile;

  /// The config for the RagFiles to be uploaded into the RagCorpus.
  ///
  /// VertexRagDataService.UploadRagFile.
  ///
  /// Required.
  GoogleCloudAiplatformV1UploadRagFileConfig? uploadRagFileConfig;

  GoogleCloudAiplatformV1UploadRagFileRequest({
    this.ragFile,
    this.uploadRagFileConfig,
  });

  GoogleCloudAiplatformV1UploadRagFileRequest.fromJson(core.Map json_)
      : this(
          ragFile: json_.containsKey('ragFile')
              ? GoogleCloudAiplatformV1RagFile.fromJson(
                  json_['ragFile'] as core.Map<core.String, core.dynamic>)
              : null,
          uploadRagFileConfig: json_.containsKey('uploadRagFileConfig')
              ? GoogleCloudAiplatformV1UploadRagFileConfig.fromJson(
                  json_['uploadRagFileConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragFile != null) 'ragFile': ragFile!,
        if (uploadRagFileConfig != null)
          'uploadRagFileConfig': uploadRagFileConfig!,
      };
}

/// Response message for VertexRagDataService.UploadRagFile.
class GoogleCloudAiplatformV1UploadRagFileResponse {
  /// The error that occurred while processing the RagFile.
  GoogleRpcStatus? error;

  /// The RagFile that had been uploaded into the RagCorpus.
  GoogleCloudAiplatformV1RagFile? ragFile;

  GoogleCloudAiplatformV1UploadRagFileResponse({
    this.error,
    this.ragFile,
  });

  GoogleCloudAiplatformV1UploadRagFileResponse.fromJson(core.Map json_)
      : this(
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          ragFile: json_.containsKey('ragFile')
              ? GoogleCloudAiplatformV1RagFile.fromJson(
                  json_['ragFile'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (error != null) 'error': error!,
        if (ragFile != null) 'ragFile': ragFile!,
      };
}

/// Request message for IndexService.UpsertDatapoints
class GoogleCloudAiplatformV1UpsertDatapointsRequest {
  /// A list of datapoints to be created/updated.
  core.List<GoogleCloudAiplatformV1IndexDatapoint>? datapoints;

  /// Update mask is used to specify the fields to be overwritten in the
  /// datapoints by the update.
  ///
  /// The fields specified in the update_mask are relative to each
  /// IndexDatapoint inside datapoints, not the full request. Updatable fields:
  /// * Use `all_restricts` to update both restricts and numeric_restricts.
  ///
  /// Optional.
  core.String? updateMask;

  GoogleCloudAiplatformV1UpsertDatapointsRequest({
    this.datapoints,
    this.updateMask,
  });

  GoogleCloudAiplatformV1UpsertDatapointsRequest.fromJson(core.Map json_)
      : this(
          datapoints: (json_['datapoints'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          updateMask: json_['updateMask'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapoints != null) 'datapoints': datapoints!,
        if (updateMask != null) 'updateMask': updateMask!,
      };
}

/// Response message for IndexService.UpsertDatapoints
typedef GoogleCloudAiplatformV1UpsertDatapointsResponse = $Empty;

/// References an API call.
///
/// It contains more information about long running operation and Jobs that are
/// triggered by the API call.
class GoogleCloudAiplatformV1UserActionReference {
  /// For API calls that start a LabelingJob.
  ///
  /// Resource name of the LabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  core.String? dataLabelingJob;

  /// The method name of the API RPC call.
  ///
  /// For example,
  /// "/google.cloud.aiplatform.{apiVersion}.DatasetService.CreateDataset"
  core.String? method;

  /// For API calls that return a long running operation.
  ///
  /// Resource name of the long running operation. Format:
  /// `projects/{project}/locations/{location}/operations/{operation}`
  core.String? operation;

  GoogleCloudAiplatformV1UserActionReference({
    this.dataLabelingJob,
    this.method,
    this.operation,
  });

  GoogleCloudAiplatformV1UserActionReference.fromJson(core.Map json_)
      : this(
          dataLabelingJob: json_['dataLabelingJob'] as core.String?,
          method: json_['method'] as core.String?,
          operation: json_['operation'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataLabelingJob != null) 'dataLabelingJob': dataLabelingJob!,
        if (method != null) 'method': method!,
        if (operation != null) 'operation': operation!,
      };
}

/// Value is the value of the field.
class GoogleCloudAiplatformV1Value {
  /// A double value.
  core.double? doubleValue;

  /// An integer value.
  core.String? intValue;

  /// A string value.
  core.String? stringValue;

  GoogleCloudAiplatformV1Value({
    this.doubleValue,
    this.intValue,
    this.stringValue,
  });

  GoogleCloudAiplatformV1Value.fromJson(core.Map json_)
      : this(
          doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
          intValue: json_['intValue'] as core.String?,
          stringValue: json_['stringValue'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (doubleValue != null) 'doubleValue': doubleValue!,
        if (intValue != null) 'intValue': intValue!,
        if (stringValue != null) 'stringValue': stringValue!,
      };
}

/// Retrieve from Vertex AI Search datastore or engine for grounding.
///
/// datastore and engine are mutually exclusive. See
/// https://cloud.google.com/products/agent-builder
class GoogleCloudAiplatformV1VertexAISearch {
  /// Fully-qualified Vertex AI Search data store resource ID.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
  ///
  /// Optional.
  core.String? datastore;

  GoogleCloudAiplatformV1VertexAISearch({
    this.datastore,
  });

  GoogleCloudAiplatformV1VertexAISearch.fromJson(core.Map json_)
      : this(
          datastore: json_['datastore'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datastore != null) 'datastore': datastore!,
      };
}

/// Retrieve from Vertex RAG Store for grounding.
class GoogleCloudAiplatformV1VertexRagStore {
  /// The representation of the rag source.
  ///
  /// It can be used to specify corpus only or ragfiles. Currently only support
  /// one corpus or multiple files from one corpus. In the future we may open up
  /// multiple corpora support.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1VertexRagStoreRagResource>? ragResources;

  /// The retrieval config for the Rag query.
  ///
  /// Optional.
  GoogleCloudAiplatformV1RagRetrievalConfig? ragRetrievalConfig;

  /// Number of top k results to return from the selected corpora.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.int? similarityTopK;

  /// Only return results with vector distance smaller than the threshold.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? vectorDistanceThreshold;

  GoogleCloudAiplatformV1VertexRagStore({
    this.ragResources,
    this.ragRetrievalConfig,
    this.similarityTopK,
    this.vectorDistanceThreshold,
  });

  GoogleCloudAiplatformV1VertexRagStore.fromJson(core.Map json_)
      : this(
          ragResources: (json_['ragResources'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1VertexRagStoreRagResource.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
          ragRetrievalConfig: json_.containsKey('ragRetrievalConfig')
              ? GoogleCloudAiplatformV1RagRetrievalConfig.fromJson(
                  json_['ragRetrievalConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          similarityTopK: json_['similarityTopK'] as core.int?,
          vectorDistanceThreshold:
              (json_['vectorDistanceThreshold'] as core.num?)?.toDouble(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ragResources != null) 'ragResources': ragResources!,
        if (ragRetrievalConfig != null)
          'ragRetrievalConfig': ragRetrievalConfig!,
        if (similarityTopK != null) 'similarityTopK': similarityTopK!,
        if (vectorDistanceThreshold != null)
          'vectorDistanceThreshold': vectorDistanceThreshold!,
      };
}

/// The definition of the Rag resource.
typedef GoogleCloudAiplatformV1VertexRagStoreRagResource
    = $VertexRagStoreRagResource;

/// Metadata describes the input video content.
class GoogleCloudAiplatformV1VideoMetadata {
  /// The end offset of the video.
  ///
  /// Optional.
  core.String? endOffset;

  /// The start offset of the video.
  ///
  /// Optional.
  core.String? startOffset;

  GoogleCloudAiplatformV1VideoMetadata({
    this.endOffset,
    this.startOffset,
  });

  GoogleCloudAiplatformV1VideoMetadata.fromJson(core.Map json_)
      : this(
          endOffset: json_['endOffset'] as core.String?,
          startOffset: json_['startOffset'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endOffset != null) 'endOffset': endOffset!,
        if (startOffset != null) 'startOffset': startOffset!,
      };
}

/// The configuration for the voice to use.
class GoogleCloudAiplatformV1VoiceConfig {
  /// The configuration for the prebuilt voice to use.
  GoogleCloudAiplatformV1PrebuiltVoiceConfig? prebuiltVoiceConfig;

  GoogleCloudAiplatformV1VoiceConfig({
    this.prebuiltVoiceConfig,
  });

  GoogleCloudAiplatformV1VoiceConfig.fromJson(core.Map json_)
      : this(
          prebuiltVoiceConfig: json_.containsKey('prebuiltVoiceConfig')
              ? GoogleCloudAiplatformV1PrebuiltVoiceConfig.fromJson(
                  json_['prebuiltVoiceConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (prebuiltVoiceConfig != null)
          'prebuiltVoiceConfig': prebuiltVoiceConfig!,
      };
}

/// Represents the spec of a worker pool in a job.
class GoogleCloudAiplatformV1WorkerPoolSpec {
  /// The custom container task.
  GoogleCloudAiplatformV1ContainerSpec? containerSpec;

  /// Disk spec.
  GoogleCloudAiplatformV1DiskSpec? diskSpec;

  /// The specification of a single machine.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// List of NFS mount spec.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1NfsMount>? nfsMounts;

  /// The Python packaged task.
  GoogleCloudAiplatformV1PythonPackageSpec? pythonPackageSpec;

  /// The number of worker replicas to use for this worker pool.
  ///
  /// Optional.
  core.String? replicaCount;

  GoogleCloudAiplatformV1WorkerPoolSpec({
    this.containerSpec,
    this.diskSpec,
    this.machineSpec,
    this.nfsMounts,
    this.pythonPackageSpec,
    this.replicaCount,
  });

  GoogleCloudAiplatformV1WorkerPoolSpec.fromJson(core.Map json_)
      : this(
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          diskSpec: json_.containsKey('diskSpec')
              ? GoogleCloudAiplatformV1DiskSpec.fromJson(
                  json_['diskSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          nfsMounts: (json_['nfsMounts'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1NfsMount.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          pythonPackageSpec: json_.containsKey('pythonPackageSpec')
              ? GoogleCloudAiplatformV1PythonPackageSpec.fromJson(
                  json_['pythonPackageSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          replicaCount: json_['replicaCount'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (diskSpec != null) 'diskSpec': diskSpec!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (nfsMounts != null) 'nfsMounts': nfsMounts!,
        if (pythonPackageSpec != null) 'pythonPackageSpec': pythonPackageSpec!,
        if (replicaCount != null) 'replicaCount': replicaCount!,
      };
}

/// Contains Feature values to be written for a specific entity.
class GoogleCloudAiplatformV1WriteFeatureValuesPayload {
  /// The ID of the entity.
  ///
  /// Required.
  core.String? entityId;

  /// Feature values to be written, mapping from Feature ID to value.
  ///
  /// Up to 100,000 `feature_values` entries may be written across all payloads.
  /// The feature generation time, aligned by days, must be no older than five
  /// years (1825 days) and no later than one year (366 days) in the future.
  ///
  /// Required.
  core.Map<core.String, GoogleCloudAiplatformV1FeatureValue>? featureValues;

  GoogleCloudAiplatformV1WriteFeatureValuesPayload({
    this.entityId,
    this.featureValues,
  });

  GoogleCloudAiplatformV1WriteFeatureValuesPayload.fromJson(core.Map json_)
      : this(
          entityId: json_['entityId'] as core.String?,
          featureValues:
              (json_['featureValues'] as core.Map<core.String, core.dynamic>?)
                  ?.map(
            (key, value) => core.MapEntry(
              key,
              GoogleCloudAiplatformV1FeatureValue.fromJson(
                  value as core.Map<core.String, core.dynamic>),
            ),
          ),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityId != null) 'entityId': entityId!,
        if (featureValues != null) 'featureValues': featureValues!,
      };
}

/// Request message for FeaturestoreOnlineServingService.WriteFeatureValues.
class GoogleCloudAiplatformV1WriteFeatureValuesRequest {
  /// The entities to be written.
  ///
  /// Up to 100,000 feature values can be written across all `payloads`.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1WriteFeatureValuesPayload>? payloads;

  GoogleCloudAiplatformV1WriteFeatureValuesRequest({
    this.payloads,
  });

  GoogleCloudAiplatformV1WriteFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          payloads: (json_['payloads'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1WriteFeatureValuesPayload.fromJson(
                      value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (payloads != null) 'payloads': payloads!,
      };
}

/// Response message for FeaturestoreOnlineServingService.WriteFeatureValues.
typedef GoogleCloudAiplatformV1WriteFeatureValuesResponse = $Empty;

/// Request message for TensorboardService.WriteTensorboardExperimentData.
class GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest {
  /// Requests containing per-run TensorboardTimeSeries data to write.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1WriteTensorboardRunDataRequest>?
      writeRunDataRequests;

  GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest({
    this.writeRunDataRequests,
  });

  GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest.fromJson(
      core.Map json_)
      : this(
          writeRunDataRequests: (json_['writeRunDataRequests'] as core.List?)
              ?.map((value) =>
                  GoogleCloudAiplatformV1WriteTensorboardRunDataRequest
                      .fromJson(value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (writeRunDataRequests != null)
          'writeRunDataRequests': writeRunDataRequests!,
      };
}

/// Response message for TensorboardService.WriteTensorboardExperimentData.
typedef GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse = $Empty;

/// Request message for TensorboardService.WriteTensorboardRunData.
class GoogleCloudAiplatformV1WriteTensorboardRunDataRequest {
  /// The resource name of the TensorboardRun to write data to.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Required.
  core.String? tensorboardRun;

  /// The TensorboardTimeSeries data to write.
  ///
  /// Values with in a time series are indexed by their step value. Repeated
  /// writes to the same step will overwrite the existing value for that step.
  /// The upper limit of data points per write request is 5000.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TimeSeriesData>? timeSeriesData;

  GoogleCloudAiplatformV1WriteTensorboardRunDataRequest({
    this.tensorboardRun,
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1WriteTensorboardRunDataRequest.fromJson(core.Map json_)
      : this(
          tensorboardRun: json_['tensorboardRun'] as core.String?,
          timeSeriesData: (json_['timeSeriesData'] as core.List?)
              ?.map((value) => GoogleCloudAiplatformV1TimeSeriesData.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!,
        if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
      };
}

/// Response message for TensorboardService.WriteTensorboardRunData.
typedef GoogleCloudAiplatformV1WriteTensorboardRunDataResponse = $Empty;

/// An explanation method that redistributes Integrated Gradients attributions
/// to segmented regions, taking advantage of the model's fully differentiable
/// structure.
///
/// Refer to this paper for more details: https://arxiv.org/abs/1906.02825
/// Supported only by image Models.
class GoogleCloudAiplatformV1XraiAttribution {
  /// Config for XRAI with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image)
  /// is motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  GoogleCloudAiplatformV1BlurBaselineConfig? blurBaselineConfig;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding noise can help
  /// improve the computed gradients. Refer to this paper for more details:
  /// https://arxiv.org/pdf/1706.03825.pdf
  GoogleCloudAiplatformV1SmoothGradConfig? smoothGradConfig;

  /// The number of steps for approximating the path integral.
  ///
  /// A good value to start is 50 and gradually increase until the sum to diff
  /// property is met within the desired error range. Valid range of its value
  /// is \[1, 100\], inclusively.
  ///
  /// Required.
  core.int? stepCount;

  GoogleCloudAiplatformV1XraiAttribution({
    this.blurBaselineConfig,
    this.smoothGradConfig,
    this.stepCount,
  });

  GoogleCloudAiplatformV1XraiAttribution.fromJson(core.Map json_)
      : this(
          blurBaselineConfig: json_.containsKey('blurBaselineConfig')
              ? GoogleCloudAiplatformV1BlurBaselineConfig.fromJson(
                  json_['blurBaselineConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          smoothGradConfig: json_.containsKey('smoothGradConfig')
              ? GoogleCloudAiplatformV1SmoothGradConfig.fromJson(
                  json_['smoothGradConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          stepCount: json_['stepCount'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blurBaselineConfig != null)
          'blurBaselineConfig': blurBaselineConfig!,
        if (smoothGradConfig != null) 'smoothGradConfig': smoothGradConfig!,
        if (stepCount != null) 'stepCount': stepCount!,
      };
}

/// The response message for Locations.ListLocations.
class GoogleCloudLocationListLocationsResponse {
  /// A list of locations that matches the specified filter in the request.
  core.List<GoogleCloudLocationLocation>? locations;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudLocationListLocationsResponse({
    this.locations,
    this.nextPageToken,
  });

  GoogleCloudLocationListLocationsResponse.fromJson(core.Map json_)
      : this(
          locations: (json_['locations'] as core.List?)
              ?.map((value) => GoogleCloudLocationLocation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          nextPageToken: json_['nextPageToken'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (locations != null) 'locations': locations!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// A resource that represents a Google Cloud location.
typedef GoogleCloudLocationLocation = $Location00;

/// Associates `members`, or principals, with a `role`.
class GoogleIamV1Binding {
  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request. If the condition evaluates to `false`, then this binding
  /// does not apply to the current request. However, a different role binding
  /// might grant the same role to one or more of the principals in this
  /// binding. To learn which resources support conditions in their IAM
  /// policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  GoogleTypeExpr? condition;

  /// Specifies the principals requesting access for a Google Cloud resource.
  ///
  /// `members` can have the following values: * `allUsers`: A special
  /// identifier that represents anyone who is on the internet; with or without
  /// a Google account. * `allAuthenticatedUsers`: A special identifier that
  /// represents anyone who is authenticated with a Google account or a service
  /// account. Does not include identities that come from external identity
  /// providers (IdPs) through identity federation. * `user:{emailid}`: An email
  /// address that represents a specific Google account. For example,
  /// `alice@example.com` . * `serviceAccount:{emailid}`: An email address that
  /// represents a Google service account. For example,
  /// `my-other-app@appspot.gserviceaccount.com`. *
  /// `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
  /// identifier for a
  /// [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
  /// For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
  /// `group:{emailid}`: An email address that represents a Google group. For
  /// example, `admins@example.com`. * `domain:{domain}`: The G Suite domain
  /// (primary) that represents all the users of that domain. For example,
  /// `google.com` or `example.com`. *
  /// `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
  /// A single identity in a workforce identity pool. *
  /// `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
  /// All workforce identities in a group. *
  /// `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
  /// All workforce identities with a specific attribute value. *
  /// `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}
  /// / * `: All identities in a workforce identity pool. *
  /// `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
  /// A single identity in a workload identity pool. *
  /// `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
  /// A workload identity pool group. *
  /// `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
  /// All identities in a workload identity pool with a certain attribute. *
  /// `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}
  /// / * `: All identities in a workload identity pool. *
  /// `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  /// identifier) representing a user that has been recently deleted. For
  /// example, `alice@example.com?uid=123456789012345678901`. If the user is
  /// recovered, this value reverts to `user:{emailid}` and the recovered user
  /// retains the role in the binding. *
  /// `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
  /// unique identifier) representing a service account that has been recently
  /// deleted. For example,
  /// `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
  /// the service account is undeleted, this value reverts to
  /// `serviceAccount:{emailid}` and the undeleted service account retains the
  /// role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
  /// address (plus unique identifier) representing a Google group that has been
  /// recently deleted. For example,
  /// `admins@example.com?uid=123456789012345678901`. If the group is recovered,
  /// this value reverts to `group:{emailid}` and the recovered group retains
  /// the role in the binding. *
  /// `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
  /// Deleted single identity in a workforce identity pool. For example,
  /// `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
  core.List<core.String>? members;

  /// Role that is assigned to the list of `members`, or principals.
  ///
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an
  /// overview of the IAM roles and permissions, see the
  /// [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For
  /// a list of the available pre-defined roles, see
  /// [here](https://cloud.google.com/iam/docs/understanding-roles).
  core.String? role;

  GoogleIamV1Binding({
    this.condition,
    this.members,
    this.role,
  });

  GoogleIamV1Binding.fromJson(core.Map json_)
      : this(
          condition: json_.containsKey('condition')
              ? GoogleTypeExpr.fromJson(
                  json_['condition'] as core.Map<core.String, core.dynamic>)
              : null,
          members: (json_['members'] as core.List?)
              ?.map((value) => value as core.String)
              .toList(),
          role: json_['role'] as core.String?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (condition != null) 'condition': condition!,
        if (members != null) 'members': members!,
        if (role != null) 'role': role!,
      };
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role. For some types of Google Cloud
/// resources, a `binding` can also specify a `condition`, which is a logical
/// expression that allows access to a resource only if the expression evaluates
/// to `true`. A condition can add constraints based on attributes of the
/// request, the resource, or both. To learn which resources support conditions
/// in their IAM policies, see the
/// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
/// **JSON example:** ``` { "bindings": [ { "role":
/// "roles/resourcemanager.organizationAdmin", "members": [
/// "user:mike@example.com", "group:admins@example.com", "domain:google.com",
/// "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role":
/// "roles/resourcemanager.organizationViewer", "members": [
/// "user:eve@example.com" ], "condition": { "title": "expirable access",
/// "description": "Does not grant access after Sep 2020", "expression":
/// "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
/// "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
/// members: - user:mike@example.com - group:admins@example.com -
/// domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com
/// role: roles/resourcemanager.organizationAdmin - members: -
/// user:eve@example.com role: roles/resourcemanager.organizationViewer
/// condition: title: expirable access description: Does not grant access after
/// Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
/// etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features,
/// see the [IAM documentation](https://cloud.google.com/iam/docs/).
class GoogleIamV1Policy {
  /// Associates a list of `members`, or principals, with a `role`.
  ///
  /// Optionally, may specify a `condition` that determines how and when the
  /// `bindings` are applied. Each of the `bindings` must contain at least one
  /// principal. The `bindings` in a `Policy` can refer to up to 1,500
  /// principals; up to 250 of these principals can be Google groups. Each
  /// occurrence of a principal counts towards these limits. For example, if the
  /// `bindings` grant 50 different roles to `user:alice@example.com`, and not
  /// to any other principal, then you can add another 1,450 principals to the
  /// `bindings` in the `Policy`.
  core.List<GoogleIamV1Binding>? bindings;

  /// `etag` is used for optimistic concurrency control as a way to help prevent
  /// simultaneous updates of a policy from overwriting each other.
  ///
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the
  /// policy. **Important:** If you use IAM Conditions, you must include the
  /// `etag` field whenever you call `setIamPolicy`. If you omit this field,
  /// then IAM allows you to overwrite a version `3` policy with a version `1`
  /// policy, and all of the conditions in the version `3` policy are lost.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> bytes_) {
    etag =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected. Any operation that affects conditional role bindings must
  /// specify version `3`. This requirement applies to the following operations:
  /// * Getting a policy that includes a conditional role binding * Adding a
  /// conditional role binding to a policy * Changing a conditional role binding
  /// in a policy * Removing any role binding, with or without a condition, from
  /// a policy that includes conditions **Important:** If you use IAM
  /// Conditions, you must include the `etag` field whenever you call
  /// `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
  /// version `3` policy with a version `1` policy, and all of the conditions in
  /// the version `3` policy are lost. If a policy does not include any
  /// conditions, operations on that policy may specify any valid version or
  /// leave the field unset. To learn which resources support conditions in
  /// their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  core.int? version;

  GoogleIamV1Policy({
    this.bindings,
    this.etag,
    this.version,
  });

  GoogleIamV1Policy.fromJson(core.Map json_)
      : this(
          bindings: (json_['bindings'] as core.List?)
              ?.map((value) => GoogleIamV1Binding.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
          etag: json_['etag'] as core.String?,
          version: json_['version'] as core.int?,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null) 'bindings': bindings!,
        if (etag != null) 'etag': etag!,
        if (version != null) 'version': version!,
      };
}

/// Request message for `SetIamPolicy` method.
class GoogleIamV1SetIamPolicyRequest {
  /// REQUIRED: The complete policy to be applied to the `resource`.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is a
  /// valid policy but certain Google Cloud services (such as Projects) might
  /// reject them.
  GoogleIamV1Policy? policy;

  GoogleIamV1SetIamPolicyRequest({
    this.policy,
  });

  GoogleIamV1SetIamPolicyRequest.fromJson(core.Map json_)
      : this(
          policy: json_.containsKey('policy')
              ? GoogleIamV1Policy.fromJson(
                  json_['policy'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (policy != null) 'policy': policy!,
      };
}

/// Response message for `TestIamPermissions` method.
typedef GoogleIamV1TestIamPermissionsResponse = $PermissionsResponse;

/// The response message for Operations.ListOperations.
class GoogleLongrunningListOperationsResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of operations that matches the specified filter in the request.
  core.List<GoogleLongrunningOperation>? operations;

  GoogleLongrunningListOperationsResponse({
    this.nextPageToken,
    this.operations,
  });

  GoogleLongrunningListOperationsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_['nextPageToken'] as core.String?,
          operations: (json_['operations'] as core.List?)
              ?.map((value) => GoogleLongrunningOperation.fromJson(
                  value as core.Map<core.String, core.dynamic>))
              .toList(),
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (operations != null) 'operations': operations!,
      };
}

/// This resource represents a long-running operation that is the result of a
/// network API call.
class GoogleLongrunningOperation {
  /// If the value is `false`, it means the operation is still in progress.
  ///
  /// If `true`, the operation is completed, and either `error` or `response` is
  /// available.
  core.bool? done;

  /// The error result of the operation in case of failure or cancellation.
  GoogleRpcStatus? error;

  /// Service-specific metadata associated with the operation.
  ///
  /// It typically contains progress information and common metadata such as
  /// create time. Some services might not provide such metadata. Any method
  /// that returns a long-running operation should document the metadata type,
  /// if any.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The server-assigned name, which is only unique within the same service
  /// that originally returns it.
  ///
  /// If you use the default HTTP mapping, the `name` should be a resource name
  /// ending with `operations/{unique_id}`.
  core.String? name;

  /// The normal, successful response of the operation.
  ///
  /// If the original method returns no data on success, such as `Delete`, the
  /// response is `google.protobuf.Empty`. If the original method is standard
  /// `Get`/`Create`/`Update`, the response should be the resource. For other
  /// methods, the response should have the type `XxxResponse`, where `Xxx` is
  /// the original method name. For example, if the original method name is
  /// `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? response;

  GoogleLongrunningOperation({
    this.done,
    this.error,
    this.metadata,
    this.name,
    this.response,
  });

  GoogleLongrunningOperation.fromJson(core.Map json_)
      : this(
          done: json_['done'] as core.bool?,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_['name'] as core.String?,
          response: json_.containsKey('response')
              ? json_['response'] as core.Map<core.String, core.dynamic>
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (done != null) 'done': done!,
        if (error != null) 'error': error!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (response != null) 'response': response!,
      };
}

/// A generic empty message that you can re-use to avoid defining duplicated
/// empty messages in your APIs.
///
/// A typical example is to use it as the request or the response type of an API
/// method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns
/// (google.protobuf.Empty); }
typedef GoogleProtobufEmpty = $Empty;

/// The `Status` type defines a logical error model that is suitable for
/// different programming environments, including REST APIs and RPC APIs.
///
/// It is used by [gRPC](https://github.com/grpc). Each `Status` message
/// contains three pieces of data: error code, error message, and error details.
/// You can find out more about this error model and how to work with it in the
/// [API Design Guide](https://cloud.google.com/apis/design/errors).
typedef GoogleRpcStatus = $Status00;

/// Represents a whole or partial calendar date, such as a birthday.
///
/// The time of day and time zone are either specified elsewhere or are
/// insignificant. The date is relative to the Gregorian Calendar. This can
/// represent one of the following: * A full date, with non-zero year, month,
/// and day values. * A month and day, with a zero year (for example, an
/// anniversary). * A year on its own, with a zero month and a zero day. * A
/// year and month, with a zero day (for example, a credit card expiration
/// date). Related types: * google.type.TimeOfDay * google.type.DateTime *
/// google.protobuf.Timestamp
typedef GoogleTypeDate = $Date;

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax.
///
/// CEL is a C-like expression language. The syntax and semantics of CEL are
/// documented at https://github.com/google/cel-spec. Example (Comparison):
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() \< 100" Example
/// (Equality): title: "Requestor is owner" description: "Determines if
/// requestor is the document owner" expression: "document.owner ==
/// request.auth.claims.email" Example (Logic): title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// Example (Data Manipulation): title: "Notification string" description:
/// "Create a notification string with a timestamp." expression: "'New message
/// received at ' + string(document.create_time)" The exact variables and
/// functions that may be referenced within an expression are determined by the
/// service that evaluates it. See the service documentation for additional
/// information.
typedef GoogleTypeExpr = $Expr;

/// Represents a time interval, encoded as a Timestamp start (inclusive) and a
/// Timestamp end (exclusive).
///
/// The start must be less than or equal to the end. When the start equals the
/// end, the interval is empty (matches no time). When both start and end are
/// unspecified, the interval matches any time.
typedef GoogleTypeInterval = $Interval;

/// An object that represents a latitude/longitude pair.
///
/// This is expressed as a pair of doubles to represent degrees latitude and
/// degrees longitude. Unless specified otherwise, this object must conform to
/// the WGS84 standard. Values must be within normalized ranges.
typedef GoogleTypeLatLng = $LatLng;

/// Represents an amount of money with its currency type.
typedef GoogleTypeMoney = $Money;
