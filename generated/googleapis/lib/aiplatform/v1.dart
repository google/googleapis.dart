// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_library_directive
// ignore_for_file: unnecessary_string_interpolations

/// Vertex AI API - v1
///
/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
///
/// For more information, see <https://cloud.google.com/vertex-ai/>
///
/// Create an instance of [AiplatformApi] to access these resources:
///
/// - [ProjectsResource]
///   - [ProjectsLocationsResource]
///     - [ProjectsLocationsBatchPredictionJobsResource]
///     - [ProjectsLocationsCustomJobsResource]
///       - [ProjectsLocationsCustomJobsOperationsResource]
///     - [ProjectsLocationsDataLabelingJobsResource]
///       - [ProjectsLocationsDataLabelingJobsOperationsResource]
///     - [ProjectsLocationsDatasetsResource]
///       - [ProjectsLocationsDatasetsAnnotationSpecsResource]
///         - [ProjectsLocationsDatasetsAnnotationSpecsOperationsResource]
///       - [ProjectsLocationsDatasetsDataItemsResource]
///         - [ProjectsLocationsDatasetsDataItemsAnnotationsResource]
/// - [ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource]
///         - [ProjectsLocationsDatasetsDataItemsOperationsResource]
///       - [ProjectsLocationsDatasetsDatasetVersionsResource]
///       - [ProjectsLocationsDatasetsOperationsResource]
///       - [ProjectsLocationsDatasetsSavedQueriesResource]
///         - [ProjectsLocationsDatasetsSavedQueriesOperationsResource]
///     - [ProjectsLocationsDeploymentResourcePoolsResource]
///       - [ProjectsLocationsDeploymentResourcePoolsOperationsResource]
///     - [ProjectsLocationsEndpointsResource]
///       - [ProjectsLocationsEndpointsOperationsResource]
///     - [ProjectsLocationsFeaturestoresResource]
///       - [ProjectsLocationsFeaturestoresEntityTypesResource]
///         - [ProjectsLocationsFeaturestoresEntityTypesFeaturesResource]
/// - [ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource]
///         - [ProjectsLocationsFeaturestoresEntityTypesOperationsResource]
///       - [ProjectsLocationsFeaturestoresOperationsResource]
///     - [ProjectsLocationsHyperparameterTuningJobsResource]
///       - [ProjectsLocationsHyperparameterTuningJobsOperationsResource]
///     - [ProjectsLocationsIndexEndpointsResource]
///       - [ProjectsLocationsIndexEndpointsOperationsResource]
///     - [ProjectsLocationsIndexesResource]
///       - [ProjectsLocationsIndexesOperationsResource]
///     - [ProjectsLocationsMetadataStoresResource]
///       - [ProjectsLocationsMetadataStoresArtifactsResource]
///       - [ProjectsLocationsMetadataStoresContextsResource]
///       - [ProjectsLocationsMetadataStoresExecutionsResource]
///       - [ProjectsLocationsMetadataStoresMetadataSchemasResource]
///     - [ProjectsLocationsMigratableResourcesResource]
///       - [ProjectsLocationsMigratableResourcesOperationsResource]
///     - [ProjectsLocationsModelDeploymentMonitoringJobsResource]
///       - [ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource]
///     - [ProjectsLocationsModelsResource]
///       - [ProjectsLocationsModelsEvaluationsResource]
///         - [ProjectsLocationsModelsEvaluationsOperationsResource]
///         - [ProjectsLocationsModelsEvaluationsSlicesResource]
///       - [ProjectsLocationsModelsOperationsResource]
///     - [ProjectsLocationsNasJobsResource]
///       - [ProjectsLocationsNasJobsNasTrialDetailsResource]
///     - [ProjectsLocationsNotebookRuntimeTemplatesResource]
///     - [ProjectsLocationsNotebookRuntimesResource]
///     - [ProjectsLocationsOperationsResource]
///     - [ProjectsLocationsPipelineJobsResource]
///       - [ProjectsLocationsPipelineJobsOperationsResource]
///     - [ProjectsLocationsPublishersResource]
///       - [ProjectsLocationsPublishersModelsResource]
///     - [ProjectsLocationsSchedulesResource]
///       - [ProjectsLocationsSchedulesOperationsResource]
///     - [ProjectsLocationsSpecialistPoolsResource]
///       - [ProjectsLocationsSpecialistPoolsOperationsResource]
///     - [ProjectsLocationsStudiesResource]
///       - [ProjectsLocationsStudiesOperationsResource]
///       - [ProjectsLocationsStudiesTrialsResource]
///         - [ProjectsLocationsStudiesTrialsOperationsResource]
///     - [ProjectsLocationsTensorboardsResource]
///       - [ProjectsLocationsTensorboardsExperimentsResource]
///         - [ProjectsLocationsTensorboardsExperimentsOperationsResource]
///         - [ProjectsLocationsTensorboardsExperimentsRunsResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsOperationsResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource]
/// - [ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource]
///       - [ProjectsLocationsTensorboardsOperationsResource]
///     - [ProjectsLocationsTrainingPipelinesResource]
///       - [ProjectsLocationsTrainingPipelinesOperationsResource]
/// - [PublishersResource]
///   - [PublishersModelsResource]
library aiplatform_v1;

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

import '../shared.dart';
import '../src/user_agent.dart';

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show ApiRequestError, DetailedApiRequestError;

/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
class AiplatformApi {
  /// See, edit, configure, and delete your Google Cloud data and see the email
  /// address for your Google Account.
  static const cloudPlatformScope =
      'https://www.googleapis.com/auth/cloud-platform';

  /// View your data across Google Cloud services and see the email address of
  /// your Google Account
  static const cloudPlatformReadOnlyScope =
      'https://www.googleapis.com/auth/cloud-platform.read-only';

  final commons.ApiRequester _requester;

  ProjectsResource get projects => ProjectsResource(_requester);
  PublishersResource get publishers => PublishersResource(_requester);

  AiplatformApi(http.Client client,
      {core.String rootUrl = 'https://aiplatform.googleapis.com/',
      core.String servicePath = ''})
      : _requester =
            commons.ApiRequester(client, rootUrl, servicePath, requestHeaders);
}

class ProjectsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsResource get locations =>
      ProjectsLocationsResource(_requester);

  ProjectsResource(commons.ApiRequester client) : _requester = client;
}

class ProjectsLocationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsBatchPredictionJobsResource get batchPredictionJobs =>
      ProjectsLocationsBatchPredictionJobsResource(_requester);
  ProjectsLocationsCustomJobsResource get customJobs =>
      ProjectsLocationsCustomJobsResource(_requester);
  ProjectsLocationsDataLabelingJobsResource get dataLabelingJobs =>
      ProjectsLocationsDataLabelingJobsResource(_requester);
  ProjectsLocationsDatasetsResource get datasets =>
      ProjectsLocationsDatasetsResource(_requester);
  ProjectsLocationsDeploymentResourcePoolsResource
      get deploymentResourcePools =>
          ProjectsLocationsDeploymentResourcePoolsResource(_requester);
  ProjectsLocationsEndpointsResource get endpoints =>
      ProjectsLocationsEndpointsResource(_requester);
  ProjectsLocationsFeaturestoresResource get featurestores =>
      ProjectsLocationsFeaturestoresResource(_requester);
  ProjectsLocationsHyperparameterTuningJobsResource
      get hyperparameterTuningJobs =>
          ProjectsLocationsHyperparameterTuningJobsResource(_requester);
  ProjectsLocationsIndexEndpointsResource get indexEndpoints =>
      ProjectsLocationsIndexEndpointsResource(_requester);
  ProjectsLocationsIndexesResource get indexes =>
      ProjectsLocationsIndexesResource(_requester);
  ProjectsLocationsMetadataStoresResource get metadataStores =>
      ProjectsLocationsMetadataStoresResource(_requester);
  ProjectsLocationsMigratableResourcesResource get migratableResources =>
      ProjectsLocationsMigratableResourcesResource(_requester);
  ProjectsLocationsModelDeploymentMonitoringJobsResource
      get modelDeploymentMonitoringJobs =>
          ProjectsLocationsModelDeploymentMonitoringJobsResource(_requester);
  ProjectsLocationsModelsResource get models =>
      ProjectsLocationsModelsResource(_requester);
  ProjectsLocationsNasJobsResource get nasJobs =>
      ProjectsLocationsNasJobsResource(_requester);
  ProjectsLocationsNotebookRuntimeTemplatesResource
      get notebookRuntimeTemplates =>
          ProjectsLocationsNotebookRuntimeTemplatesResource(_requester);
  ProjectsLocationsNotebookRuntimesResource get notebookRuntimes =>
      ProjectsLocationsNotebookRuntimesResource(_requester);
  ProjectsLocationsOperationsResource get operations =>
      ProjectsLocationsOperationsResource(_requester);
  ProjectsLocationsPipelineJobsResource get pipelineJobs =>
      ProjectsLocationsPipelineJobsResource(_requester);
  ProjectsLocationsPublishersResource get publishers =>
      ProjectsLocationsPublishersResource(_requester);
  ProjectsLocationsSchedulesResource get schedules =>
      ProjectsLocationsSchedulesResource(_requester);
  ProjectsLocationsSpecialistPoolsResource get specialistPools =>
      ProjectsLocationsSpecialistPoolsResource(_requester);
  ProjectsLocationsStudiesResource get studies =>
      ProjectsLocationsStudiesResource(_requester);
  ProjectsLocationsTensorboardsResource get tensorboards =>
      ProjectsLocationsTensorboardsResource(_requester);
  ProjectsLocationsTrainingPipelinesResource get trainingPipelines =>
      ProjectsLocationsTrainingPipelinesResource(_requester);

  ProjectsLocationsResource(commons.ApiRequester client) : _requester = client;

  /// Gets information about a location.
  ///
  /// Request parameters:
  ///
  /// [name] - Resource name for the location.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudLocationLocation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudLocationLocation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudLocationLocation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource that owns the locations collection, if applicable.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [filter] - A filter to narrow down results to a preferred subset. The
  /// filtering language accepts strings like `"displayName=tokyo"`, and is
  /// documented in more detail in \[AIP-160\](https://google.aip.dev/160).
  ///
  /// [pageSize] - The maximum number of results to return. If not set, the
  /// service selects a default.
  ///
  /// [pageToken] - A page token received from the `next_page_token` field in
  /// the response. Send that page token to receive the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudLocationListLocationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudLocationListLocationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/locations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudLocationListLocationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsBatchPredictionJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsBatchPredictionJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a BatchPredictionJob.
  ///
  /// Starts asynchronous cancellation on the BatchPredictionJob. The server
  /// makes the best effort to cancel the job, but success is not guaranteed.
  /// Clients can use JobService.GetBatchPredictionJob or other methods to check
  /// whether the cancellation succeeded or whether the job completed despite
  /// cancellation. On a successful cancellation, the BatchPredictionJob is not
  /// deleted;instead its BatchPredictionJob.state is set to `CANCELLED`. Any
  /// files already outputted by the job are not deleted.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob to cancel. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelBatchPredictionJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a BatchPredictionJob.
  ///
  /// A BatchPredictionJob once created will right away be attempted to start.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchPredictionJob> create(
    GoogleCloudAiplatformV1BatchPredictionJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a BatchPredictionJob.
  ///
  /// Can only be called on jobs that already finished.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a BatchPredictionJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the BatchPredictionJob resource. Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/batchPredictionJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1BatchPredictionJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchPredictionJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists BatchPredictionJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// BatchPredictionJobs from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. *
  /// \`model_display_name\` supports \`=\`, \`!=\` comparisons. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListBatchPredictionJobsResponse.next_page_token of the previous
  /// JobService.ListBatchPredictionJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListBatchPredictionJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListBatchPredictionJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/batchPredictionJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListBatchPredictionJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsCustomJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCustomJobsOperationsResource get operations =>
      ProjectsLocationsCustomJobsOperationsResource(_requester);

  ProjectsLocationsCustomJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a CustomJob.
  ///
  /// Starts asynchronous cancellation on the CustomJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// JobService.GetCustomJob or other methods to check whether the cancellation
  /// succeeded or whether the job completed despite cancellation. On successful
  /// cancellation, the CustomJob is not deleted; instead it becomes a job with
  /// a CustomJob.error value with a google.rpc.Status.code of 1, corresponding
  /// to `Code.CANCELLED`, and CustomJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob to cancel. Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelCustomJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a CustomJob.
  ///
  /// A created CustomJob right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// CustomJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CustomJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CustomJob> create(
    GoogleCloudAiplatformV1CustomJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/customJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CustomJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a CustomJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a CustomJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CustomJob resource. Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1CustomJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1CustomJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1CustomJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists CustomJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// CustomJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListCustomJobsResponse.next_page_token of the previous
  /// JobService.ListCustomJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListCustomJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListCustomJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/customJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListCustomJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsCustomJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCustomJobsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/customJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDataLabelingJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataLabelingJobsOperationsResource get operations =>
      ProjectsLocationsDataLabelingJobsOperationsResource(_requester);

  ProjectsLocationsDataLabelingJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a DataLabelingJob.
  ///
  /// Success of cancellation is not guaranteed.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelDataLabelingJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a DataLabelingJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DataLabelingJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DataLabelingJob> create(
    GoogleCloudAiplatformV1DataLabelingJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/dataLabelingJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DataLabelingJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a DataLabelingJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob to be deleted. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a DataLabelingJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DataLabelingJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DataLabelingJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DataLabelingJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists DataLabelingJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order by default. Use `desc` after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read. FieldMask represents a
  /// set of symbolic field paths. For example, the mask can be `paths: "name"`.
  /// The "name" here is a field in DataLabelingJob. If this field is not set,
  /// all fields of the DataLabelingJob are returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDataLabelingJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDataLabelingJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/dataLabelingJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDataLabelingJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDataLabelingJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataLabelingJobsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataLabelingJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsResource get annotationSpecs =>
      ProjectsLocationsDatasetsAnnotationSpecsResource(_requester);
  ProjectsLocationsDatasetsDataItemsResource get dataItems =>
      ProjectsLocationsDatasetsDataItemsResource(_requester);
  ProjectsLocationsDatasetsDatasetVersionsResource get datasetVersions =>
      ProjectsLocationsDatasetsDatasetVersionsResource(_requester);
  ProjectsLocationsDatasetsOperationsResource get operations =>
      ProjectsLocationsDatasetsOperationsResource(_requester);
  ProjectsLocationsDatasetsSavedQueriesResource get savedQueries =>
      ProjectsLocationsDatasetsSavedQueriesResource(_requester);

  ProjectsLocationsDatasetsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Dataset in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Dataset request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasets';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports data from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> export(
    GoogleCloudAiplatformV1ExportDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':export';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Dataset.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Dataset> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Dataset.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Imports data into a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudAiplatformV1ImportDataRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Datasets in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset's parent resource. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. *
  /// \`display_name\`: supports = and != * \`metadata_schema_uri\`: supports =
  /// and != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. Some examples: * \`displayName="myDisplayName"\` *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDatasetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDatasetsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasets';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDatasetsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Dataset.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask. Updatable fields: *
  /// `display_name` * `description` * `labels`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Dataset].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Dataset> patch(
    GoogleCloudAiplatformV1Dataset request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Dataset.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches DataItems in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [dataset] - Required. The resource name of the Dataset from which to
  /// search DataItems. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [annotationFilters] - An expression that specifies what Annotations will
  /// be returned per DataItem. Annotations satisfied either of the conditions
  /// will be returned. * `annotation_spec_id` - for = or !=. Must specify
  /// `saved_query_id=` - saved query id that annotations should belong to.
  ///
  /// [annotationsFilter] - An expression for filtering the Annotations that
  /// will be returned per DataItem. * `annotation_spec_id` - for = or !=.
  ///
  /// [annotationsLimit] - If set, only up to this many of Annotations will be
  /// returned per DataItemView. The maximum value is 1000. If not set, the
  /// maximum value will be used.
  ///
  /// [dataItemFilter] - An expression for filtering the DataItem that will be
  /// returned. * `data_item_id` - for = or !=. * `labeled` - for = or !=. *
  /// `has_annotation(ANNOTATION_SPEC_ID)` - true only for DataItem that have at
  /// least one annotation with annotation_spec_id = `ANNOTATION_SPEC_ID` in the
  /// context of SavedQuery or DataLabelingJob. For example: * `data_item=1` *
  /// `has_annotation(5)`
  ///
  /// [dataLabelingJob] - The resource name of a DataLabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// If this field is set, all of the search will be done in the context of
  /// this DataLabelingJob.
  ///
  /// [fieldMask] - Mask specifying which fields of DataItemView to read.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [orderByAnnotation_orderBy] - A comma-separated list of annotation fields
  /// to order by, sorted in ascending order. Use "desc" after a field name for
  /// descending. Must also specify saved_query.
  ///
  /// [orderByAnnotation_savedQuery] - Required. Saved query of the Annotation.
  /// Only Annotations belong to this saved query will be considered for
  /// ordering.
  ///
  /// [orderByDataItem] - A comma-separated list of data item fields to order
  /// by, sorted in ascending order. Use "desc" after a field name for
  /// descending.
  ///
  /// [pageSize] - Requested page size. Server may return fewer results than
  /// requested. Default and maximum page size is 100.
  ///
  /// [pageToken] - A token identifying a page of results for the server to
  /// return Typically obtained via SearchDataItemsResponse.next_page_token of
  /// the previous DatasetService.SearchDataItems call.
  ///
  /// [savedQuery] - The resource name of a SavedQuery(annotation set in UI).
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// All of the search will be done in the context of this SavedQuery.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SearchDataItemsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SearchDataItemsResponse> searchDataItems(
    core.String dataset, {
    core.List<core.String>? annotationFilters,
    core.String? annotationsFilter,
    core.int? annotationsLimit,
    core.String? dataItemFilter,
    core.String? dataLabelingJob,
    core.String? fieldMask,
    core.String? orderBy,
    core.String? orderByAnnotation_orderBy,
    core.String? orderByAnnotation_savedQuery,
    core.String? orderByDataItem,
    core.int? pageSize,
    core.String? pageToken,
    core.String? savedQuery,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (annotationFilters != null) 'annotationFilters': annotationFilters,
      if (annotationsFilter != null) 'annotationsFilter': [annotationsFilter],
      if (annotationsLimit != null) 'annotationsLimit': ['${annotationsLimit}'],
      if (dataItemFilter != null) 'dataItemFilter': [dataItemFilter],
      if (dataLabelingJob != null) 'dataLabelingJob': [dataLabelingJob],
      if (fieldMask != null) 'fieldMask': [fieldMask],
      if (orderBy != null) 'orderBy': [orderBy],
      if (orderByAnnotation_orderBy != null)
        'orderByAnnotation.orderBy': [orderByAnnotation_orderBy],
      if (orderByAnnotation_savedQuery != null)
        'orderByAnnotation.savedQuery': [orderByAnnotation_savedQuery],
      if (orderByDataItem != null) 'orderByDataItem': [orderByDataItem],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (savedQuery != null) 'savedQuery': [savedQuery],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$dataset') + ':searchDataItems';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchDataItemsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsAnnotationSpecsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsOperationsResource get operations =>
      ProjectsLocationsDatasetsAnnotationSpecsOperationsResource(_requester);

  ProjectsLocationsDatasetsAnnotationSpecsResource(commons.ApiRequester client)
      : _requester = client;

  /// Gets an AnnotationSpec.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the AnnotationSpec resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1AnnotationSpec].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AnnotationSpec> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AnnotationSpec.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsAnnotationSpecsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsAnnotationSpecsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/annotationSpecs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsResource get annotations =>
      ProjectsLocationsDatasetsDataItemsAnnotationsResource(_requester);
  ProjectsLocationsDatasetsDataItemsOperationsResource get operations =>
      ProjectsLocationsDatasetsDataItemsOperationsResource(_requester);

  ProjectsLocationsDatasetsDataItemsResource(commons.ApiRequester client)
      : _requester = client;

  /// Lists DataItems in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list DataItems
  /// from. Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDataItemsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDataItemsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/dataItems';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDataItemsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsAnnotationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource
      get operations =>
          ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource(
              _requester);

  ProjectsLocationsDatasetsDataItemsAnnotationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Lists Annotations belongs to a dataitem
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the DataItem to list Annotations
  /// from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListAnnotationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListAnnotationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/annotations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListAnnotationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsAnnotationsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/annotations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDataItemsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDataItemsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/dataItems/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsDatasetVersionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsDatasetVersionsResource(commons.ApiRequester client)
      : _requester = client;

  /// Create a version from a Dataset.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Dataset resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1DatasetVersion request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1DatasetVersion].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1DatasetVersion> get(
    core.String name, {
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1DatasetVersion.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists DatasetVersions in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list
  /// DatasetVersions from. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - Optional. The standard list filter.
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListDatasetVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListDatasetVersionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/datasetVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListDatasetVersionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Restores a dataset version.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the DatasetVersion resource. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/datasetVersions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> restore(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':restore';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsSavedQueriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsSavedQueriesOperationsResource get operations =>
      ProjectsLocationsDatasetsSavedQueriesOperationsResource(_requester);

  ProjectsLocationsDatasetsSavedQueriesResource(commons.ApiRequester client)
      : _requester = client;

  /// Deletes a SavedQuery.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SavedQuery to delete. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists SavedQueries in a Dataset.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Dataset to list SavedQueries
  /// from. Format: `projects/{project}/locations/{location}/datasets/{dataset}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListSavedQueriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListSavedQueriesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/savedQueries';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListSavedQueriesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDatasetsSavedQueriesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDatasetsSavedQueriesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/datasets/\[^/\]+/savedQueries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsDeploymentResourcePoolsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDeploymentResourcePoolsOperationsResource get operations =>
      ProjectsLocationsDeploymentResourcePoolsOperationsResource(_requester);

  ProjectsLocationsDeploymentResourcePoolsResource(commons.ApiRequester client)
      : _requester = client;
}

class ProjectsLocationsDeploymentResourcePoolsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDeploymentResourcePoolsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/deploymentResourcePools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsEndpointsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsOperationsResource get operations =>
      ProjectsLocationsEndpointsOperationsResource(_requester);

  ProjectsLocationsEndpointsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates an Endpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Endpoint in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [endpointId] - Immutable. The ID to use for endpoint, which will become
  /// the final component of the endpoint resource name. If not provided, Vertex
  /// AI will generate a value for this ID. If the first character is a letter,
  /// this value may be up to 63 characters, and valid characters are
  /// `[a-z0-9-]`. The last character must be a letter or number. If the first
  /// character is a number, this value may be up to 9 characters, and valid
  /// characters are `[0-9]` with no leading zeros. When using HTTP/JSON, this
  /// field is populated based on a query string argument, such as
  /// `?endpoint_id=12345`. This is the fallback for fields that are not
  /// included in either the URI or the body.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Endpoint request,
    core.String parent, {
    core.String? endpointId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (endpointId != null) 'endpointId': [endpointId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/endpoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Endpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Endpoint resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deploys a Model into this Endpoint, creating a DeployedModel within it.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource into which to
  /// deploy a Model. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deployModel(
    GoogleCloudAiplatformV1DeployModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':deployModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online explanation.
  ///
  /// If deployed_model_id is specified, the corresponding DeployModel must have
  /// explanation_spec populated. If deployed_model_id is not specified, all
  /// DeployedModels must have explanation_spec populated.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// explanation. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ExplainResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ExplainResponse> explain(
    GoogleCloudAiplatformV1ExplainRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':explain';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ExplainResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets an Endpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Endpoint resource. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Endpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Endpoint> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Endpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Endpoints in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the Endpoints. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// \`endpoint\` supports = and !=. \`endpoint\` represents the Endpoint ID,
  /// i.e. the last segment of the Endpoint's resource name. * \`display_name\`
  /// supports = and, != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. Some examples: * \`endpoint=1\` * \`displayName="myDisplayName"\`
  /// * \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time` Example:
  /// `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListEndpointsResponse.next_page_token of the previous
  /// EndpointService.ListEndpoints call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListEndpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListEndpointsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/endpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListEndpointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an existing deployed model.
  ///
  /// Updatable fields include `min_replica_count`, `max_replica_count`,
  /// `autoscaling_metric_specs`, `disable_container_logging` (v1 only), and
  /// `enable_container_logging` (v1beta1 only).
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource into which to
  /// mutate a DeployedModel. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> mutateDeployedModel(
    GoogleCloudAiplatformV1MutateDeployedModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':mutateDeployedModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an Endpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Endpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Endpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Endpoint> patch(
    GoogleCloudAiplatformV1Endpoint request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Endpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PredictResponse> predict(
    GoogleCloudAiplatformV1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers: *
  /// `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction.
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's DeployedModel that
  /// served this prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> rawPredict(
    GoogleCloudAiplatformV1RawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':rawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a server-side streaming online prediction request for Vertex LLM
  /// streaming.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1StreamingPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1StreamingPredictResponse>
      serverStreamingPredict(
    GoogleCloudAiplatformV1StreamingPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':serverStreamingPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1StreamingPredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Undeploys a Model from an Endpoint, removing a DeployedModel from it, and
  /// freeing all resources it's using.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint resource from which to
  /// undeploy a Model. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> undeployModel(
    GoogleCloudAiplatformV1UndeployModelRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':undeployModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsEndpointsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEndpointsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/endpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesResource get entityTypes =>
      ProjectsLocationsFeaturestoresEntityTypesResource(_requester);
  ProjectsLocationsFeaturestoresOperationsResource get operations =>
      ProjectsLocationsFeaturestoresOperationsResource(_requester);

  ProjectsLocationsFeaturestoresResource(commons.ApiRequester client)
      : _requester = client;

  /// Batch reads Feature values from a Featurestore.
  ///
  /// This API enables batch reading Feature values, where each read instance in
  /// the batch may read Feature values of entities from one or more
  /// EntityTypes. Point-in-time correctness is guaranteed for Feature values of
  /// each read instance as of each instance's read timestamp.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [featurestore] - Required. The resource name of the Featurestore from
  /// which to query Feature values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchReadFeatureValues(
    GoogleCloudAiplatformV1BatchReadFeatureValuesRequest request,
    core.String featurestore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$featurestore') +
        ':batchReadFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new Featurestore in a given project and location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create
  /// Featurestores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [featurestoreId] - Required. The ID to use for this Featurestore, which
  /// will become the final component of the Featurestore's resource name. This
  /// value may be up to 60 characters, and valid characters are `[a-z0-9_]`.
  /// The first character cannot be a number. The value must be unique within
  /// the project and location.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Featurestore request,
    core.String parent, {
    core.String? featurestoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featurestoreId != null) 'featurestoreId': [featurestoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featurestores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single Featurestore.
  ///
  /// The Featurestore must not contain any EntityTypes or `force` must be set
  /// to true for the request to succeed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Featurestore to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [force] - If set to true, any EntityTypes and Features for this
  /// Featurestore will also be deleted. (Otherwise, the request will only work
  /// if the Featurestore has no EntityTypes.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single Featurestore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Featurestore resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Featurestore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Featurestore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Featurestore.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Featurestores in a given project and location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// Featurestores. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the featurestores that match the filter expression. The
  /// following fields are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. *
  /// `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
  /// `<=`, and `>=` comparisons. * `labels`: Supports key-value equality and
  /// key presence. Examples: * `create_time > "2020-01-01" OR update_time >
  /// "2020-01-01"` Featurestores created or updated after 2020-01-01. *
  /// `labels.env = "prod"` Featurestores with label "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// Fields: * `create_time` * `update_time` *
  /// `online_serving_config.fixed_node_count`
  ///
  /// [pageSize] - The maximum number of Featurestores to return. The service
  /// may return fewer than this value. If unspecified, at most 100
  /// Featurestores will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeaturestores call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeaturestores must match the call that provided
  /// the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeaturestoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeaturestoresResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/featurestores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeaturestoresResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single Featurestore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the Featurestore. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Featurestore resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `labels` * `online_serving_config.fixed_node_count` *
  /// `online_serving_config.scaling` * `online_storage_ttl_days`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1Featurestore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches Features matching a query in a given project.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The resource name of the Location to search
  /// Features. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Features will be
  /// returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.SearchFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.SearchFeatures, except `page_size`, must match the
  /// call that provided the page token.
  ///
  /// [query] - Query string that is a conjunction of field-restricted queries
  /// and/or field-restricted filters. Field-restricted queries and filters can
  /// be combined using `AND` to form a conjunction. A field query is in the
  /// form FIELD:QUERY. This implicitly checks if QUERY exists as a substring
  /// within Feature's FIELD. The QUERY and the FIELD are converted to a
  /// sequence of words (i.e. tokens) for comparison. This is done by: *
  /// Removing leading/trailing whitespace and tokenizing the search value.
  /// Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore `_`,
  /// or asterisk `*` are treated as delimiters for tokens. `*` is treated as a
  /// wildcard that matches characters within a token. * Ignoring case. *
  /// Prepending an asterisk to the first and appending an asterisk to the last
  /// token in QUERY. A QUERY must be either a singular token or a phrase. A
  /// phrase is one or multiple words enclosed in double quotation marks (").
  /// With phrases, the order of the words is important. Words in the phrase
  /// must be matching in order and consecutively. Supported FIELDs for
  /// field-restricted queries: * `feature_id` * `description` *
  /// `entity_type_id` Examples: * `feature_id: foo` --\> Matches a Feature with
  /// ID containing the substring `foo` (eg. `foo`, `foofeature`, `barfoo`). *
  /// `feature_id: foo*feature` --\> Matches a Feature with ID containing the
  /// substring `foo*feature` (eg. `foobarfeature`). * `feature_id: foo AND
  /// description: bar` --\> Matches a Feature with ID containing the substring
  /// `foo` and description containing the substring `bar`. Besides field
  /// queries, the following exact-match filters are supported. The exact-match
  /// filters do not support wildcards. Unlike field-restricted queries,
  /// exact-match filters are case-sensitive. * `feature_id`: Supports =
  /// comparisons. * `description`: Supports = comparisons. Multi-token filters
  /// should be enclosed in quotes. * `entity_type_id`: Supports = comparisons.
  /// * `value_type`: Supports = and != comparisons. * `labels`: Supports
  /// key-value equality as well as key presence. * `featurestore_id`: Supports
  /// = comparisons. Examples: * `description = "foo bar"` --\> Any Feature with
  /// description exactly equal to `foo bar` * `value_type = DOUBLE` --\>
  /// Features whose type is DOUBLE. * `labels.active = yes AND labels.env =
  /// prod` --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with `env` as the key.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SearchFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SearchFeaturesResponse> searchFeatures(
    core.String location, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? query,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (query != null) 'query': [query],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$location') +
        '/featurestores:searchFeatures';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchFeaturesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesResource get features =>
      ProjectsLocationsFeaturestoresEntityTypesFeaturesResource(_requester);
  ProjectsLocationsFeaturestoresEntityTypesOperationsResource get operations =>
      ProjectsLocationsFeaturestoresEntityTypesOperationsResource(_requester);

  ProjectsLocationsFeaturestoresEntityTypesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a new EntityType in a given Featurestore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Featurestore to create
  /// EntityTypes. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [entityTypeId] - Required. The ID to use for the EntityType, which will
  /// become the final component of the EntityType's resource name. This value
  /// may be up to 60 characters, and valid characters are `[a-z0-9_]`. The
  /// first character cannot be a number. The value must be unique within a
  /// featurestore.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1EntityType request,
    core.String parent, {
    core.String? entityTypeId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (entityTypeId != null) 'entityTypeId': [entityTypeId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/entityTypes';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single EntityType.
  ///
  /// The EntityType must not have any Features or `force` must be set to true
  /// for the request to succeed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the EntityType to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [force] - If set to true, any Features for this EntityType will also be
  /// deleted. (Otherwise, the request will only work if the EntityType has no
  /// Features.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Delete Feature values from Featurestore.
  ///
  /// The progress of the deletion is tracked by the returned operation. The
  /// deleted feature values are guaranteed to be invisible to subsequent read
  /// operations after the operation is marked as successfully done. If a delete
  /// feature values operation fails, the feature values returned from reads and
  /// exports may be inconsistent. If consistency is required, the caller must
  /// retry the same delete request again and wait till the new operation
  /// returned is marked as successfully done.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType grouping the
  /// Features for which values are being deleted from. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deleteFeatureValues(
    GoogleCloudAiplatformV1DeleteFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':deleteFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports Feature values from all the entities of a target EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType from which to
  /// export Feature values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> exportFeatureValues(
    GoogleCloudAiplatformV1ExportFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':exportFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single EntityType.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the EntityType resource. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1EntityType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1EntityType> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1EntityType.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Imports Feature values into the Featurestore from a source storage.
  ///
  /// The progress of the import is tracked by the returned operation. The
  /// imported features are guaranteed to be visible to subsequent read
  /// operations after the operation is marked as successfully done. If an
  /// import operation fails, the Feature values returned from reads and exports
  /// may be inconsistent. If consistency is required, the caller must retry the
  /// same import request again and wait till the new operation returned is
  /// marked as successfully done. There are also scenarios where the caller can
  /// cause inconsistency. - Source data for import contains multiple distinct
  /// Feature values for the same entity ID and timestamp. - Source is modified
  /// during an import. This includes adding, updating, or removing source data
  /// and/or metadata. Examples of updating metadata include but are not limited
  /// to changing storage location, storage class, or retention policy. - Online
  /// serving cluster is under-provisioned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType grouping the
  /// Features for which values are being imported. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> importFeatureValues(
    GoogleCloudAiplatformV1ImportFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':importFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists EntityTypes in a given Featurestore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Featurestore to list
  /// EntityTypes. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [filter] - Lists the EntityTypes that match the filter expression. The
  /// following filters are supported: * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `>=`, and `<=` comparisons. Values must be in RFC 3339 format. *
  /// `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format. * `labels`: Supports key-value equality
  /// as well as key presence. Examples: * `create_time >
  /// \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> EntityTypes having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any EntityType which has a label with 'env' as the
  /// key.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `entity_type_id` * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of EntityTypes to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 EntityTypes
  /// will be returned. The maximum value is 1000; any value greater than 1000
  /// will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListEntityTypes call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListEntityTypes must match the call that provided the
  /// page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListEntityTypesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListEntityTypesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/entityTypes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListEntityTypesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the EntityType. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// The last part entity_type is assigned by the client. The entity_type can
  /// be up to 64 characters long and can consist only of ASCII Latin letters
  /// A-Z and a-z and underscore(_), and ASCII digits 0-9 starting with a
  /// letter. The value will be unique given a featurestore.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the EntityType resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` *
  /// `monitoring_config.snapshot_analysis.disabled` *
  /// `monitoring_config.snapshot_analysis.monitoring_interval_days` *
  /// `monitoring_config.snapshot_analysis.staleness_days` *
  /// `monitoring_config.import_features_analysis.state` *
  /// `monitoring_config.import_features_analysis.anomaly_detection_baseline` *
  /// `monitoring_config.numerical_threshold_config.value` *
  /// `monitoring_config.categorical_threshold_config.value` *
  /// `offline_storage_ttl_days`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1EntityType].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1EntityType> patch(
    GoogleCloudAiplatformV1EntityType request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1EntityType.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads Feature values of a specific entity of an EntityType.
  ///
  /// For reading feature values of multiple entities of an EntityType, please
  /// use StreamingReadFeatureValues.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType for the
  /// entity being read. Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadFeatureValuesResponse>
      readFeatureValues(
    GoogleCloudAiplatformV1ReadFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':readFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadFeatureValuesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads Feature values for multiple entities.
  ///
  /// Depending on their size, data for different entities may be broken up
  /// across multiple responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the entities' type. Value
  /// format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadFeatureValuesResponse>
      streamingReadFeatureValues(
    GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$entityType') +
        ':streamingReadFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadFeatureValuesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Writes Feature values of one or more entities of an EntityType.
  ///
  /// The Feature values are merged into existing entities if any. The Feature
  /// values to be written must have timestamp within the online storage
  /// retention.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [entityType] - Required. The resource name of the EntityType for the
  /// entities being written. Value format:
  /// `projects/{project}/locations/{location}/featurestores/
  /// {featurestore}/entityTypes/{entityType}`. For example, for a machine
  /// learning model predicting user clicks on a website, an EntityType ID could
  /// be `user`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1WriteFeatureValuesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1WriteFeatureValuesResponse>
      writeFeatureValues(
    GoogleCloudAiplatformV1WriteFeatureValuesRequest request,
    core.String entityType, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$entityType') + ':writeFeatureValues';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1WriteFeatureValuesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesFeaturesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource
      get operations =>
          ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource(
              _requester);

  ProjectsLocationsFeaturestoresEntityTypesFeaturesResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a batch of Features in a given EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType to create the
  /// batch of Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCreate(
    GoogleCloudAiplatformV1BatchCreateFeaturesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/features:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a new Feature in a given EntityType.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the EntityType or FeatureGroup
  /// to create a Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [featureId] - Required. The ID to use for the Feature, which will become
  /// the final component of the Feature's resource name. This value may be up
  /// to 128 characters, and valid characters are `[a-z0-9_]`. The first
  /// character cannot be a number. The value must be unique within an
  /// EntityType/FeatureGroup.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Feature request,
    core.String parent, {
    core.String? featureId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (featureId != null) 'featureId': [featureId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Features to be deleted. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets details of a single Feature.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Feature resource. Format for
  /// entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Feature> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Feature.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Features in a given EntityType.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [filter] - Lists the Features that match the filter expression. The
  /// following filters are supported: * `value_type`: Supports = and !=
  /// comparisons. * `create_time`: Supports =, !=, \<, \>, \>=, and \<=
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// =, !=, \<, \>, \>=, and \<= comparisons. Values must be in RFC 3339
  /// format. * `labels`: Supports key-value equality as well as key presence.
  /// Examples: * `value_type = DOUBLE` --\> Features whose type is DOUBLE. *
  /// `create_time > \"2020-01-31T15:30:00.000000Z\" OR update_time >
  /// \"2020-01-31T15:30:00.000000Z\"` --\> EntityTypes created or updated after
  /// 2020-01-31T15:30:00.000000Z. * `labels.active = yes AND labels.env = prod`
  /// --\> Features having both (active: yes) and (env: prod) labels. *
  /// `labels.env: *` --\> Any Feature which has a label with 'env' as the key.
  ///
  /// [latestStatsCount] - Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent ListFeaturesRequest.latest_stats_count of
  /// stats for each Feature in response. Valid value is \[0, 10\]. If number of
  /// stats exists \< ListFeaturesRequest.latest_stats_count, return all
  /// existing stats.
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `feature_id` * `value_type` (Not supported for FeatureRegistry
  /// Feature) * `create_time` * `update_time`
  ///
  /// [pageSize] - The maximum number of Features to return. The service may
  /// return fewer than this value. If unspecified, at most 1000 Features will
  /// be returned. The maximum value is 1000; any value greater than 1000 will
  /// be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// FeaturestoreService.ListFeatures call or
  /// FeatureRegistryService.ListFeatures call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// FeaturestoreService.ListFeatures or or FeatureRegistryService.ListFeatures
  /// must match the call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListFeaturesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListFeaturesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? latestStatsCount,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (latestStatsCount != null) 'latestStatsCount': ['${latestStatsCount}'],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/features';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListFeaturesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates the parameters of a single Feature.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Name of the Feature. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [updateMask] - Field mask is used to specify the fields to be overwritten
  /// in the Features resource by the update. The fields specified in the
  /// update_mask are relative to the resource, not the full request. A field
  /// will be overwritten if it is in the mask. If the user does not provide a
  /// mask then only the non-empty fields present in the request will be
  /// overwritten. Set the update_mask to `*` to override all fields. Updatable
  /// fields: * `description` * `labels` * `disable_monitoring` (Not supported
  /// for FeatureRegistry Feature)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Feature].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Feature> patch(
    GoogleCloudAiplatformV1Feature request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Feature.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesFeaturesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/features/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresEntityTypesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresEntityTypesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/entityTypes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsFeaturestoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsFeaturestoresOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/featurestores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsHyperparameterTuningJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsHyperparameterTuningJobsOperationsResource get operations =>
      ProjectsLocationsHyperparameterTuningJobsOperationsResource(_requester);

  ProjectsLocationsHyperparameterTuningJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a HyperparameterTuningJob.
  ///
  /// Starts asynchronous cancellation on the HyperparameterTuningJob. The
  /// server makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use JobService.GetHyperparameterTuningJob or other
  /// methods to check whether the cancellation succeeded or whether the job
  /// completed despite cancellation. On successful cancellation, the
  /// HyperparameterTuningJob is not deleted; instead it becomes a job with a
  /// HyperparameterTuningJob.error value with a google.rpc.Status.code of 1,
  /// corresponding to `Code.CANCELLED`, and HyperparameterTuningJob.state is
  /// set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a HyperparameterTuningJob
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// HyperparameterTuningJob in. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1HyperparameterTuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1HyperparameterTuningJob> create(
    GoogleCloudAiplatformV1HyperparameterTuningJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/hyperparameterTuningJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a HyperparameterTuningJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a HyperparameterTuningJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the HyperparameterTuningJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1HyperparameterTuningJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1HyperparameterTuningJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists HyperparameterTuningJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// HyperparameterTuningJobs from. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListHyperparameterTuningJobsResponse.next_page_token of the previous
  /// JobService.ListHyperparameterTuningJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse>
      list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/hyperparameterTuningJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsHyperparameterTuningJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsHyperparameterTuningJobsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/hyperparameterTuningJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexEndpointsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexEndpointsOperationsResource get operations =>
      ProjectsLocationsIndexEndpointsOperationsResource(_requester);

  ProjectsLocationsIndexEndpointsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// IndexEndpoint in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1IndexEndpoint request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexEndpoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an IndexEndpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the IndexEndpoint resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deploys an Index into this IndexEndpoint, creating a DeployedIndex within
  /// it.
  ///
  /// Only non-empty Indexes can be deployed.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource into
  /// which to deploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deployIndex(
    GoogleCloudAiplatformV1DeployIndexRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':deployIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Finds the nearest neighbors of each vector within the request.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the index endpoint. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1FindNeighborsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1FindNeighborsResponse> findNeighbors(
    GoogleCloudAiplatformV1FindNeighborsRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':findNeighbors';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1FindNeighborsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets an IndexEndpoint.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the IndexEndpoint resource. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1IndexEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1IndexEndpoint> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1IndexEndpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists IndexEndpoints in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the IndexEndpoints. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `index_endpoint` supports = and !=. `index_endpoint` represents the
  /// IndexEndpoint ID, ie. the last segment of the IndexEndpoint's
  /// resourcename. * `display_name` supports =, != and regex() (uses
  /// [re2](https://github.com/google/re2/wiki/Syntax) syntax) * `labels`
  /// supports general map functions that is: `labels.key=value` - key:value
  /// equality `labels.key:* or labels:key - key existence A key including a
  /// space must be quoted. `labels."a key"`. Some examples: *
  /// `index_endpoint="1"` * `display_name="myDisplayName"` *
  /// `regex(display_name, "^A") -\> The display name starts with an A. *
  /// `labels.myKey="myValue"`
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListIndexEndpointsResponse.next_page_token of the previous
  /// IndexEndpointService.ListIndexEndpoints call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListIndexEndpointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListIndexEndpointsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexEndpoints';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListIndexEndpointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Update an existing DeployedIndex under an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource into
  /// which to deploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> mutateDeployedIndex(
    GoogleCloudAiplatformV1DeployedIndex request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':mutateDeployedIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an IndexEndpoint.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the IndexEndpoint.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1IndexEndpoint].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1IndexEndpoint> patch(
    GoogleCloudAiplatformV1IndexEndpoint request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1IndexEndpoint.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads the datapoints/vectors of the given IDs.
  ///
  /// A maximum of 1000 datapoints can be retrieved in a batch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the index endpoint. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadIndexDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadIndexDatapointsResponse>
      readIndexDatapoints(
    GoogleCloudAiplatformV1ReadIndexDatapointsRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':readIndexDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadIndexDatapointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Undeploys an Index from an IndexEndpoint, removing a DeployedIndex from
  /// it, and freeing all resources it's using.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [indexEndpoint] - Required. The name of the IndexEndpoint resource from
  /// which to undeploy an Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> undeployIndex(
    GoogleCloudAiplatformV1UndeployIndexRequest request,
    core.String indexEndpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$indexEndpoint') + ':undeployIndex';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexEndpointsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexEndpointsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexEndpoints/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexesOperationsResource get operations =>
      ProjectsLocationsIndexesOperationsResource(_requester);

  ProjectsLocationsIndexesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the Index
  /// in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Index request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexes';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Index.
  ///
  /// An Index can only be deleted when all its DeployedIndexes had been
  /// undeployed.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Index resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets an Index.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Index resource. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Index].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Index> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Index.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Indexes in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the Indexes. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListIndexesResponse.next_page_token of the previous
  /// IndexService.ListIndexes call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListIndexesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListIndexesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/indexes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListIndexesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Index.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [updateMask] - The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1Index request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Remove Datapoints from an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [index] - Required. The name of the Index resource to be updated. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1RemoveDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1RemoveDatapointsResponse>
      removeDatapoints(
    GoogleCloudAiplatformV1RemoveDatapointsRequest request,
    core.String index, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$index') + ':removeDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1RemoveDatapointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Add/update Datapoints into an Index.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [index] - Required. The name of the Index resource to be updated. Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1UpsertDatapointsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1UpsertDatapointsResponse>
      upsertDatapoints(
    GoogleCloudAiplatformV1UpsertDatapointsRequest request,
    core.String index, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$index') + ':upsertDatapoints';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1UpsertDatapointsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsIndexesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIndexesOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/indexes/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsResource get artifacts =>
      ProjectsLocationsMetadataStoresArtifactsResource(_requester);
  ProjectsLocationsMetadataStoresContextsResource get contexts =>
      ProjectsLocationsMetadataStoresContextsResource(_requester);
  ProjectsLocationsMetadataStoresExecutionsResource get executions =>
      ProjectsLocationsMetadataStoresExecutionsResource(_requester);
  ProjectsLocationsMetadataStoresMetadataSchemasResource get metadataSchemas =>
      ProjectsLocationsMetadataStoresMetadataSchemasResource(_requester);

  ProjectsLocationsMetadataStoresResource(commons.ApiRequester client)
      : _requester = client;

  /// Initializes a MetadataStore, including allocation of resources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location where the
  /// MetadataStore should be created. Format:
  /// `projects/{project}/locations/{location}/`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [metadataStoreId] - The {metadatastore} portion of the resource name with
  /// the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all MetadataStores in the parent Location.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting MetadataStore.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1MetadataStore request,
    core.String parent, {
    core.String? metadataStoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (metadataStoreId != null) 'metadataStoreId': [metadataStoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a single MetadataStore and all its child resources (Artifacts,
  /// Executions, and Contexts).
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataStore to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [force] - Deprecated: Field is no longer supported.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataStore to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1MetadataStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1MetadataStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1MetadataStore.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists MetadataStores for a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The Location whose MetadataStores should be listed.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Metadata Stores to return. The service
  /// may return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListMetadataStores call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListMetadataStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListMetadataStoresResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListMetadataStoresResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresArtifactsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresArtifactsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates an Artifact associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Artifact should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [artifactId] - The {artifact} portion of the resource name with the
  /// format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// If not provided, the Artifact's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all Artifacts in the parent MetadataStore.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting Artifact.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Artifact> create(
    GoogleCloudAiplatformV1Artifact request,
    core.String parent, {
    core.String? artifactId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (artifactId != null) 'artifactId': [artifactId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/artifacts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Artifact.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Artifact.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Artifact to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Artifact to delete. If this is
  /// provided, it must match the server's etag. Otherwise, the request will
  /// fail with a FAILED_PRECONDITION.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific Artifact.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Artifact to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Artifact> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Artifact.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Artifacts in the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Artifacts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Artifacts to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. The supported set of filters
  /// include the following: * **Attribute filtering**: For example:
  /// `display_name = "test"`. Supported fields include: `name`, `display_name`,
  /// `uri`, `state`, `schema_title`, `create_time`, and `update_time`. Time
  /// fields, such as `create_time` and `update_time`, require values specified
  /// in RFC-3339 format. For example: `create_time =
  /// "2020-11-19T11:30:00-04:00"` * **Metadata field**: To filter on metadata
  /// fields use traversal operation as follows: `metadata..`. For example:
  /// `metadata.field_1.number_value = 10.0` In case the field name contains
  /// special characters (such as colon), one can embed it inside double quote.
  /// For example: `metadata."field:1".number_value = 10.0` * **Context based
  /// filtering**: To filter Artifacts based on the contexts to which they
  /// belong, use the function operator with the full resource name
  /// `in_context()`. For example:
  /// `in_context("projects//locations//metadataStores//contexts/")` Each of the
  /// above supported filter types can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Artifacts to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListArtifacts call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListArtifactsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListArtifactsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/artifacts';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListArtifactsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a stored Artifact.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Artifact.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Artifact is not found, a new
  /// Artifact is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Artifact].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Artifact> patch(
    GoogleCloudAiplatformV1Artifact request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Artifact.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Purges Artifacts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Artifacts from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1PurgeArtifactsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/artifacts:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves lineage of an Artifact represented through Artifacts and
  /// Executions connected by Event edges and returned as a LineageSubgraph.
  ///
  /// Request parameters:
  ///
  /// [artifact] - Required. The resource name of the Artifact whose Lineage
  /// needs to be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/artifacts/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Artifacts to
  /// satisfy in order to be part of the Lineage Subgraph. The syntax to define
  /// filter query is based on https://google.aip.dev/160. The supported set of
  /// filters include the following: * **Attribute filtering**: For example:
  /// `display_name = "test"` Supported fields include: `name`, `display_name`,
  /// `uri`, `state`, `schema_title`, `create_time`, and `update_time`. Time
  /// fields, such as `create_time` and `update_time`, require values specified
  /// in RFC-3339 format. For example: `create_time =
  /// "2020-11-19T11:30:00-04:00"` * **Metadata field**: To filter on metadata
  /// fields use traversal operation as follows: `metadata..`. For example:
  /// `metadata.field_1.number_value = 10.0` In case the field name contains
  /// special characters (such as colon), one can embed it inside double quote.
  /// For example: `metadata."field:1".number_value = 10.0` Each of the above
  /// supported filter types can be combined together using logical operators
  /// (`AND` & `OR`). Maximum nested expression depth allowed is 5. For example:
  /// `display_name = "test" AND metadata.field1.bool_value = true`.
  ///
  /// [maxHops] - Specifies the size of the lineage graph in terms of number of
  /// hops from the specified artifact. Negative Value: INVALID_ARGUMENT error
  /// is returned 0: Only input artifact is returned. No value: Transitive
  /// closure is performed to return the complete graph.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1LineageSubgraph>
      queryArtifactLineageSubgraph(
    core.String artifact, {
    core.String? filter,
    core.int? maxHops,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxHops != null) 'maxHops': ['${maxHops}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$artifact') +
        ':queryArtifactLineageSubgraph';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1LineageSubgraph.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresContextsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresContextsResource(commons.ApiRequester client)
      : _requester = client;

  /// Adds a set of Artifacts and Executions to a Context.
  ///
  /// If any of the Artifacts or Executions have already been added to a
  /// Context, they are simply skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the Context that the Artifacts
  /// and Executions belong to. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse>
      addContextArtifactsAndExecutions(
    GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$context') +
        ':addContextArtifactsAndExecutions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Adds a set of Contexts as children to a parent Context.
  ///
  /// If any of the child Contexts have already been added to the parent
  /// Context, they are simply skipped. If this call would create a cycle or
  /// cause any Context to have more than 10 parents, the request will fail with
  /// an INVALID_ARGUMENT error.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the parent Context. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1AddContextChildrenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AddContextChildrenResponse>
      addContextChildren(
    GoogleCloudAiplatformV1AddContextChildrenRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$context') + ':addContextChildren';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AddContextChildrenResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a Context associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Context should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [contextId] - The {context} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`.
  /// If not provided, the Context's ID will be a UUID generated by the service.
  /// Must be 4-128 characters in length. Valid characters are `/a-z-/`. Must be
  /// unique across all Contexts in the parent MetadataStore. (Otherwise the
  /// request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the caller
  /// can't view the preexisting Context.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Context> create(
    GoogleCloudAiplatformV1Context request,
    core.String parent, {
    core.String? contextId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (contextId != null) 'contextId': [contextId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/contexts';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Context.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a stored Context.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Context to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Context to delete. If this is provided,
  /// it must match the server's etag. Otherwise, the request will fail with a
  /// FAILED_PRECONDITION.
  ///
  /// [force] - The force deletion semantics is still undefined. Users should
  /// not use this field.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific Context.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Context to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Context> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Context.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Contexts on the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Contexts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Contexts to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. Following are the supported
  /// set of filters: * **Attribute filtering**: For example: `display_name =
  /// "test"`. Supported fields include: `name`, `display_name`, `schema_title`,
  /// `create_time`, and `update_time`. Time fields, such as `create_time` and
  /// `update_time`, require values specified in RFC-3339 format. For example:
  /// `create_time = "2020-11-19T11:30:00-04:00"`. * **Metadata field**: To
  /// filter on metadata fields use traversal operation as follows:
  /// `metadata..`. For example: `metadata.field_1.number_value = 10.0`. In case
  /// the field name contains special characters (such as colon), one can embed
  /// it inside double quote. For example: `metadata."field:1".number_value =
  /// 10.0` * **Parent Child filtering**: To filter Contexts based on
  /// parent-child relationship use the HAS operator as follows: ```
  /// parent_contexts: "projects//locations//metadataStores//contexts/"
  /// child_contexts: "projects//locations//metadataStores//contexts/" ``` Each
  /// of the above supported filters can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Contexts to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListContexts call. Provide this to retrieve the subsequent
  /// page. When paginating, all other provided parameters must match the call
  /// that provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListContextsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListContextsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/contexts';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListContextsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a stored Context.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the Context.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Context is not found, a new
  /// Context is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Context].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Context> patch(
    GoogleCloudAiplatformV1Context request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Context.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Purges Contexts.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Contexts from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1PurgeContextsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/contexts:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves Artifacts and Executions within the specified Context, connected
  /// by Event edges and returned as a LineageSubgraph.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the Context whose Artifacts and
  /// Executions should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1LineageSubgraph>
      queryContextLineageSubgraph(
    core.String context, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$context') +
        ':queryContextLineageSubgraph';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1LineageSubgraph.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Remove a set of children contexts from a parent Context.
  ///
  /// If any of the child Contexts were NOT added to the parent Context, they
  /// are simply skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [context] - Required. The resource name of the parent Context. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/contexts/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1RemoveContextChildrenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1RemoveContextChildrenResponse>
      removeContextChildren(
    GoogleCloudAiplatformV1RemoveContextChildrenRequest request,
    core.String context, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$context') + ':removeContextChildren';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1RemoveContextChildrenResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresExecutionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresExecutionsResource(commons.ApiRequester client)
      : _requester = client;

  /// Adds Events to the specified Execution.
  ///
  /// An Event indicates whether an Artifact was used as an input or output for
  /// an Execution. If an Event already exists between the Execution and the
  /// Artifact, the Event is skipped.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [execution] - Required. The resource name of the Execution that the Events
  /// connect Artifacts with. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1AddExecutionEventsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1AddExecutionEventsResponse>
      addExecutionEvents(
    GoogleCloudAiplatformV1AddExecutionEventsRequest request,
    core.String execution, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$execution') + ':addExecutionEvents';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1AddExecutionEventsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates an Execution associated with a MetadataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// Execution should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [executionId] - The {execution} portion of the resource name with the
  /// format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// If not provided, the Execution's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all Executions in the parent
  /// MetadataStore. (Otherwise the request will fail with ALREADY_EXISTS, or
  /// PERMISSION_DENIED if the caller can't view the preexisting Execution.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Execution> create(
    GoogleCloudAiplatformV1Execution request,
    core.String parent, {
    core.String? executionId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (executionId != null) 'executionId': [executionId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/executions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Execution.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes an Execution.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Execution to delete. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [etag] - Optional. The etag of the Execution to delete. If this is
  /// provided, it must match the server's etag. Otherwise, the request will
  /// fail with a FAILED_PRECONDITION.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? etag,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (etag != null) 'etag': [etag],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific Execution.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Execution to retrieve. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Execution> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Execution.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Executions in the MetadataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose Executions should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - Filter specifying the boolean condition for the Executions to
  /// satisfy in order to be part of the result set. The syntax to define filter
  /// query is based on https://google.aip.dev/160. Following are the supported
  /// set of filters: * **Attribute filtering**: For example: `display_name =
  /// "test"`. Supported fields include: `name`, `display_name`, `state`,
  /// `schema_title`, `create_time`, and `update_time`. Time fields, such as
  /// `create_time` and `update_time`, require values specified in RFC-3339
  /// format. For example: `create_time = "2020-11-19T11:30:00-04:00"`. *
  /// **Metadata field**: To filter on metadata fields use traversal operation
  /// as follows: `metadata..` For example: `metadata.field_1.number_value =
  /// 10.0` In case the field name contains special characters (such as colon),
  /// one can embed it inside double quote. For example:
  /// `metadata."field:1".number_value = 10.0` * **Context based filtering**: To
  /// filter Executions based on the contexts to which they belong use the
  /// function operator with the full resource name: `in_context()`. For
  /// example: `in_context("projects//locations//metadataStores//contexts/")`
  /// Each of the above supported filters can be combined together using logical
  /// operators (`AND` & `OR`). Maximum nested expression depth allowed is 5.
  /// For example: `display_name = "test" AND metadata.field1.bool_value =
  /// true`.
  ///
  /// [orderBy] - How the list of messages is ordered. Specify the values to
  /// order by and an ordering operation. The default sorting order is
  /// ascending. To specify descending order for a field, users append a " desc"
  /// suffix; for example: "foo desc, bar". Subfields are specified with a `.`
  /// character, such as foo.bar. see https://google.aip.dev/132#ordering for
  /// more details.
  ///
  /// [pageSize] - The maximum number of Executions to return. The service may
  /// return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListExecutions call. Provide this to retrieve the
  /// subsequent page. When paginating, all other provided parameters must match
  /// the call that provided the page token. (Otherwise the request will fail
  /// with an INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListExecutionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListExecutionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/executions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListExecutionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a stored Execution.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The resource name of the Execution.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Execution is not found, a new
  /// Execution is created.
  ///
  /// [updateMask] - Optional. A FieldMask indicating which fields should be
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Execution].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Execution> patch(
    GoogleCloudAiplatformV1Execution request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Execution.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Purges Executions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The metadata store to purge Executions from. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudAiplatformV1PurgeExecutionsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/executions:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Obtains the set of input and output Artifacts for this Execution, in the
  /// form of LineageSubgraph that also contains the Execution and connecting
  /// Events.
  ///
  /// Request parameters:
  ///
  /// [execution] - Required. The resource name of the Execution whose input and
  /// output Artifacts should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/executions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1LineageSubgraph].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1LineageSubgraph>
      queryExecutionInputsAndOutputs(
    core.String execution, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$execution') +
        ':queryExecutionInputsAndOutputs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1LineageSubgraph.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMetadataStoresMetadataSchemasResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMetadataStoresMetadataSchemasResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a MetadataSchema.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the MetadataStore where the
  /// MetadataSchema should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [metadataSchemaId] - The {metadata_schema} portion of the resource name
  /// with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service. Must be 4-128 characters in length. Valid characters are
  /// `/a-z-/`. Must be unique across all MetadataSchemas in the parent
  /// Location. (Otherwise the request will fail with ALREADY_EXISTS, or
  /// PERMISSION_DENIED if the caller can't view the preexisting
  /// MetadataSchema.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1MetadataSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1MetadataSchema> create(
    GoogleCloudAiplatformV1MetadataSchema request,
    core.String parent, {
    core.String? metadataSchemaId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (metadataSchemaId != null) 'metadataSchemaId': [metadataSchemaId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataSchemas';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1MetadataSchema.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Retrieves a specific MetadataSchema.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the MetadataSchema to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+/metadataSchemas/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1MetadataSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1MetadataSchema> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1MetadataSchema.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists MetadataSchemas.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The MetadataStore whose MetadataSchemas should be
  /// listed. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/metadataStores/\[^/\]+$`.
  ///
  /// [filter] - A query to filter available MetadataSchemas for matching
  /// results.
  ///
  /// [pageSize] - The maximum number of MetadataSchemas to return. The service
  /// may return fewer. Must be in range 1-1000, inclusive. Defaults to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// MetadataService.ListMetadataSchemas call. Provide this to retrieve the
  /// next page. When paginating, all other provided parameters must match the
  /// call that provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListMetadataSchemasResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListMetadataSchemasResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/metadataSchemas';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListMetadataSchemasResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMigratableResourcesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMigratableResourcesOperationsResource get operations =>
      ProjectsLocationsMigratableResourcesOperationsResource(_requester);

  ProjectsLocationsMigratableResourcesResource(commons.ApiRequester client)
      : _requester = client;

  /// Batch migrates resources from ml.googleapis.com, automl.googleapis.com,
  /// and datalabeling.googleapis.com to Vertex AI.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The location of the migrated resource will live in.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchMigrate(
    GoogleCloudAiplatformV1BatchMigrateResourcesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$parent') +
        '/migratableResources:batchMigrate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches all of the resources in automl.googleapis.com,
  /// datalabeling.googleapis.com and ml.googleapis.com that can be migrated to
  /// Vertex AI's given location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The location that the migratable resources should be
  /// searched from. It's the Vertex AI location that the resources can be
  /// migrated to, not the resources' original location. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1SearchMigratableResourcesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SearchMigratableResourcesResponse> search(
    GoogleCloudAiplatformV1SearchMigratableResourcesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/migratableResources:search';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchMigratableResourcesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsMigratableResourcesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsMigratableResourcesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/migratableResources/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelDeploymentMonitoringJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource
      get operations =>
          ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource(
              _requester);

  ProjectsLocationsModelDeploymentMonitoringJobsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Creates a ModelDeploymentMonitoringJob.
  ///
  /// It will run periodically on a configured interval.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelDeploymentMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelDeploymentMonitoringJob> create(
    GoogleCloudAiplatformV1ModelDeploymentMonitoringJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$parent') +
        '/modelDeploymentMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a ModelDeploymentMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the model monitoring job to
  /// delete. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a ModelDeploymentMonitoringJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelDeploymentMonitoringJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelDeploymentMonitoringJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists ModelDeploymentMonitoringJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [readMask] - Mask specifying which fields to read
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse>
      list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$parent') +
        '/modelDeploymentMonitoringJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a ModelDeploymentMonitoringJob.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Resource name of a ModelDeploymentMonitoringJob.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask is used to specify the fields to
  /// be overwritten in the ModelDeploymentMonitoringJob resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields. For the objective config, the user can either provide the update
  /// mask for model_deployment_monitoring_objective_configs or any combination
  /// of its nested fields, such as:
  /// model_deployment_monitoring_objective_configs.objective_config.training_dataset.
  /// Updatable fields: * `display_name` *
  /// `model_deployment_monitoring_schedule_config` *
  /// `model_monitoring_alert_config` * `logging_sampling_strategy` * `labels` *
  /// `log_ttl` * `enable_monitoring_pipeline_logs` . and *
  /// `model_deployment_monitoring_objective_configs` . or *
  /// `model_deployment_monitoring_objective_configs.objective_config.training_dataset`
  /// *
  /// `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config`
  /// *
  /// `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1ModelDeploymentMonitoringJob request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Pauses a ModelDeploymentMonitoringJob.
  ///
  /// If the job is running, the server makes a best effort to cancel the job.
  /// Will mark ModelDeploymentMonitoringJob.state to 'PAUSED'.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob
  /// to pause. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> pause(
    GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':pause';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Resumes a paused ModelDeploymentMonitoringJob.
  ///
  /// It will start to run from next scheduled time. A deleted
  /// ModelDeploymentMonitoringJob can't be resumed.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ModelDeploymentMonitoringJob
  /// to resume. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> resume(
    GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':resume';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Searches Model Monitoring Statistics generated within a given time window.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [modelDeploymentMonitoringJob] - Required. ModelDeploymentMonitoring Job
  /// resource name. Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
          GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse>
      searchModelDeploymentMonitoringStatsAnomalies(
    GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest
        request,
    core.String modelDeploymentMonitoringJob, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$modelDeploymentMonitoringJob') +
        ':searchModelDeploymentMonitoringStatsAnomalies';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelDeploymentMonitoringJobsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/modelDeploymentMonitoringJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsResource get evaluations =>
      ProjectsLocationsModelsEvaluationsResource(_requester);
  ProjectsLocationsModelsOperationsResource get operations =>
      ProjectsLocationsModelsOperationsResource(_requester);

  ProjectsLocationsModelsResource(commons.ApiRequester client)
      : _requester = client;

  /// Copies an already existing Vertex AI Model into the specified Location.
  ///
  /// The source Model must exist in the same Project. When copying custom
  /// Models, the users themselves are responsible for Model.metadata content to
  /// be region-agnostic, as well as making sure that any resources (e.g. files)
  /// it depends on remain accessible.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to copy
  /// the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> copy(
    GoogleCloudAiplatformV1CopyModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/models:copy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Model.
  ///
  /// A model cannot be deleted if any Endpoint resource has a DeployedModel
  /// based on the model in its deployed_models field.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Model resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Model version.
  ///
  /// Model version can only be deleted if there are no DeployedModels created
  /// from it. Deleting the only version in the Model is not allowed. Use
  /// DeleteModel for deleting the Model instead.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to be deleted, with a
  /// version ID explicitly included. Example:
  /// `projects/{project}/locations/{location}/models/{model}@1234`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> deleteVersion(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':deleteVersion';

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports a trained, exportable Model to a location specified by the user.
  ///
  /// A Model is considered to be exportable if it has at least one supported
  /// export format.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Model to export. The resource
  /// name may contain version id or version alias to specify the version, if no
  /// version is specified, the default version will be exported.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> export(
    GoogleCloudAiplatformV1ExportModelRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':export';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Model resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}` In order to
  /// retrieve a specific version of the model, also provide the version ID or
  /// version alias. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` If no
  /// version ID or alias is specified, the "default" version will be returned.
  /// The "default" version alias is created for the first version of the model,
  /// and can be moved to other versions later on. There will be exactly one
  /// default version.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Model> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Model.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Models in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the Models
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. * \`model\`
  /// supports = and !=. \`model\` represents the Model ID, i.e. the last
  /// segment of the Model's resource name. * \`display_name\` supports = and !=
  /// * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. Some examples: * \`model=1234\` * \`displayName="myDisplayName"\`
  /// * \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `display_name` * `create_time` * `update_time` Example:
  /// `display_name, create_time desc`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelsResponse.next_page_token of the previous ModelService.ListModels
  /// call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListModelsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/models';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists versions of the specified model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model to list versions for.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - An expression for filtering the results of the request. For
  /// field names both snake_case and camelCase are supported. * \`labels\`
  /// supports general map functions that is: * \`labels.key=value\` - key:value
  /// equality * \`labels.key:* or labels:key - key existence * A key including
  /// a space must be quoted. \`labels."a key"\`. Some examples: *
  /// \`labels.myKey="myValue"\`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `create_time` * `update_time` Example: `update_time asc,
  /// create_time desc`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// next_page_token of the previous ListModelVersions call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListModelVersionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelVersionsResponse> listVersions(
    core.String name, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':listVersions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelVersionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Merges a set of aliases for a Model version.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the model version to merge aliases, with a
  /// version ID explicitly included. Example:
  /// `projects/{project}/locations/{location}/models/{model}@1234`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Model> mergeVersionAliases(
    GoogleCloudAiplatformV1MergeVersionAliasesRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':mergeVersionAliases';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Model.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a Model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The resource name of the Model.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. For the
  /// `FieldMask` definition, see google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Model].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Model> patch(
    GoogleCloudAiplatformV1Model request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Model.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Incrementally update the dataset used for an examples model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [model] - Required. The resource name of the Model to update. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> updateExplanationDataset(
    GoogleCloudAiplatformV1UpdateExplanationDatasetRequest request,
    core.String model, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$model') + ':updateExplanationDataset';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Uploads a Model artifact into Vertex AI.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location into which to
  /// upload the Model. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> upload(
    GoogleCloudAiplatformV1UploadModelRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/models:upload';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsEvaluationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsOperationsResource get operations =>
      ProjectsLocationsModelsEvaluationsOperationsResource(_requester);
  ProjectsLocationsModelsEvaluationsSlicesResource get slices =>
      ProjectsLocationsModelsEvaluationsSlicesResource(_requester);

  ProjectsLocationsModelsEvaluationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Gets a ModelEvaluation.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelEvaluation resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelEvaluation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelEvaluation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelEvaluation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Imports an externally generated ModelEvaluation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the parent model resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelEvaluation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelEvaluation> import(
    GoogleCloudAiplatformV1ImportModelEvaluationRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/evaluations:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelEvaluation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists ModelEvaluations in a Model.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Model to list the
  /// ModelEvaluations from. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelEvaluationsResponse.next_page_token of the previous
  /// ModelService.ListModelEvaluations call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListModelEvaluationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelEvaluationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/evaluations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelEvaluationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsEvaluationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsEvaluationsSlicesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsEvaluationsSlicesResource(commons.ApiRequester client)
      : _requester = client;

  /// Imports a list of externally generated EvaluatedAnnotations.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the parent ModelEvaluationSlice resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/slices/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse>
      batchImport(
    GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + ':batchImport';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a ModelEvaluationSlice.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the ModelEvaluationSlice resource. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+/slices/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ModelEvaluationSlice].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ModelEvaluationSlice> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ModelEvaluationSlice.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists ModelEvaluationSlices in a ModelEvaluation.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the ModelEvaluation to list the
  /// ModelEvaluationSlices from. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. * `slice.dimension` - for =.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListModelEvaluationSlicesResponse.next_page_token of the previous
  /// ModelService.ListModelEvaluationSlices call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/slices';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsModelsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsModelsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNasJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNasJobsNasTrialDetailsResource get nasTrialDetails =>
      ProjectsLocationsNasJobsNasTrialDetailsResource(_requester);

  ProjectsLocationsNasJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a NasJob.
  ///
  /// Starts asynchronous cancellation on the NasJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// JobService.GetNasJob or other methods to check whether the cancellation
  /// succeeded or whether the job completed despite cancellation. On successful
  /// cancellation, the NasJob is not deleted; instead it becomes a job with a
  /// NasJob.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`, and NasJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob to cancel. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelNasJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a NasJob
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NasJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NasJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NasJob> create(
    GoogleCloudAiplatformV1NasJob request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/nasJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NasJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a NasJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a NasJob
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasJob resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NasJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NasJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NasJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists NasJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the NasJobs
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"\` *
  /// \`state!="JOB_STATE_FAILED" OR display_name="my_job"\` * \`NOT
  /// display_name="my_job"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`labels.keyA=valueA\` * \`labels.keyB:*\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListNasJobsResponse.next_page_token of the previous JobService.ListNasJobs
  /// call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListNasJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNasJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/nasJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNasJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNasJobsNasTrialDetailsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNasJobsNasTrialDetailsResource(commons.ApiRequester client)
      : _requester = client;

  /// Gets a NasTrialDetail.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NasTrialDetail resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}/nasTrialDetails/{nas_trial_detail}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+/nasTrialDetails/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NasTrialDetail].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NasTrialDetail> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NasTrialDetail.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// List top NasTrialDetails of a NasJob.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the NasJob resource. Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/nasJobs/\[^/\]+$`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListNasTrialDetailsResponse.next_page_token of the previous
  /// JobService.ListNasTrialDetails call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListNasTrialDetailsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNasTrialDetailsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/nasTrialDetails';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNasTrialDetailsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookRuntimeTemplatesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimeTemplatesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a NotebookRuntimeTemplate.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// NotebookRuntimeTemplate. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [notebookRuntimeTemplateId] - Optional. User specified ID for the notebook
  /// runtime template.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1NotebookRuntimeTemplate request,
    core.String parent, {
    core.String? notebookRuntimeTemplateId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (notebookRuntimeTemplateId != null)
        'notebookRuntimeTemplateId': [notebookRuntimeTemplateId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimeTemplates';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a NotebookRuntimeTemplate.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntimeTemplate resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a NotebookRuntimeTemplate.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntimeTemplate resource.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NotebookRuntimeTemplate].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NotebookRuntimeTemplate> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the access control policy for a resource.
  ///
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [options_requestedPolicyVersion] - Optional. The maximum policy version
  /// that will be used to format the policy. Valid values are 0, 1, and 3.
  /// Requests specifying an invalid value will be rejected. Requests for
  /// policies with any conditional role bindings must specify version 3.
  /// Policies with no conditional role bindings may specify any valid value or
  /// leave the field unset. The policy in the response might use the policy
  /// version that you specified, or it might use a lower policy version. For
  /// example, if you specify version 3, but the policy has no conditional role
  /// bindings, the response uses version 1. To learn which resources support
  /// conditions in their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> getIamPolicy(
    core.String resource, {
    core.int? options_requestedPolicyVersion,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (options_requestedPolicyVersion != null)
        'options.requestedPolicyVersion': ['${options_requestedPolicyVersion}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':getIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists NotebookRuntimeTemplates in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookRuntimeTemplates. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// \`notebookRuntimeTemplate\` supports = and !=. \`notebookRuntimeTemplate\`
  /// represents the NotebookRuntimeTemplate ID, i.e. the last segment of the
  /// NotebookRuntimeTemplate's resource name. * \`display_name\` supports = and
  /// != * \`labels\` supports general map functions that is: *
  /// \`labels.key=value\` - key:value equality * \`labels.key:* or labels:key -
  /// key existence * A key including a space must be quoted. \`labels."a
  /// key"\`. * \`notebookRuntimeType\` supports = and !=. notebookRuntimeType
  /// enum: \[USER_DEFINED, ONE_CLICK\]. Some examples: *
  /// \`notebookRuntimeTemplate=notebookRuntimeTemplate123\` *
  /// \`displayName="myDisplayName"\` * \`labels.myKey="myValue"\` *
  /// \`notebookRuntimeType=USER_DEFINED\`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookRuntimeTemplatesResponse.next_page_token of the previous
  /// NotebookService.ListNotebookRuntimeTemplates call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse>
      list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimeTemplates';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Sets the access control policy on the specified resource.
  ///
  /// Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`,
  /// and `PERMISSION_DENIED` errors.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy is being
  /// specified. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1Policy].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1Policy> setIamPolicy(
    GoogleIamV1SetIamPolicyRequest request,
    core.String resource, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$resource') + ':setIamPolicy';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleIamV1Policy.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns permissions that a caller has on the specified resource.
  ///
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error. Note: This operation is designed to
  /// be used for building permission-aware UIs and command-line tools, not for
  /// authorization checking. This operation may "fail open" without warning.
  ///
  /// Request parameters:
  ///
  /// [resource] - REQUIRED: The resource for which the policy detail is being
  /// requested. See
  /// [Resource names](https://cloud.google.com/apis/design/resource_names) for
  /// the appropriate value for this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimeTemplates/\[^/\]+$`.
  ///
  /// [permissions] - The set of permissions to check for the `resource`.
  /// Permissions with wildcards (such as `*` or `storage.*`) are not allowed.
  /// For more information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleIamV1TestIamPermissionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleIamV1TestIamPermissionsResponse> testIamPermissions(
    core.String resource, {
    core.List<core.String>? permissions,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (permissions != null) 'permissions': permissions,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$resource') + ':testIamPermissions';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleIamV1TestIamPermissionsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsNotebookRuntimesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebookRuntimesResource(commons.ApiRequester client)
      : _requester = client;

  /// Assigns a NotebookRuntime to a user for a particular Notebook file.
  ///
  /// This method will either returns an existing assignment or generates a new
  /// one.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to get the
  /// NotebookRuntime assignment. Format:
  /// `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> assign(
    GoogleCloudAiplatformV1AssignNotebookRuntimeRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimes:assign';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a NotebookRuntime.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be deleted.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a NotebookRuntime.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource. Instead of
  /// checking whether the name is in valid NotebookRuntime resource name
  /// format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1NotebookRuntime].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1NotebookRuntime> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1NotebookRuntime.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists NotebookRuntimes in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location from which to list
  /// the NotebookRuntimes. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Optional. An expression for filtering the results of the
  /// request. For field names both snake_case and camelCase are supported. *
  /// `notebookRuntime` supports = and !=. `notebookRuntime` represents the
  /// NotebookRuntime ID, i.e. the last segment of the NotebookRuntime's
  /// resource name. * `displayName` supports = and != and regex. *
  /// `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
  /// represents the NotebookRuntimeTemplate ID, i.e. the last segment of the
  /// NotebookRuntimeTemplate's resource name. * `healthState` supports = and
  /// !=. healthState enum: \[HEALTHY, UNHEALTHY, HEALTH_STATE_UNSPECIFIED\]. *
  /// `runtimeState` supports = and !=. runtimeState enum:
  /// \[RUNTIME_STATE_UNSPECIFIED, RUNNING, BEING_STARTED, BEING_STOPPED,
  /// STOPPED, BEING_UPGRADED\]. * `runtimeUser` supports = and !=. * API
  /// version is UI only: `uiState` supports = and !=. uiState enum:
  /// \[UI_RESOURCE_STATE_UNSPECIFIED, UI_RESOURCE_STATE_BEING_CREATED,
  /// UI_RESOURCE_STATE_ACTIVE, UI_RESOURCE_STATE_BEING_DELETED,
  /// UI_RESOURCE_STATE_CREATION_FAILED\]. * `notebookRuntimeType` supports =
  /// and !=. notebookRuntimeType enum: \[USER_DEFINED, ONE_CLICK\]. Some
  /// examples: * `notebookRuntime="notebookRuntime123"` *
  /// `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"` *
  /// `notebookRuntimeTemplate="notebookRuntimeTemplate321"` *
  /// `healthState=HEALTHY` * `runtimeState=RUNNING` *
  /// `runtimeUser="test@google.com"` *
  /// `uiState=UI_RESOURCE_STATE_BEING_DELETED` *
  /// `notebookRuntimeType=USER_DEFINED`
  ///
  /// [orderBy] - Optional. A comma-separated list of fields to order by, sorted
  /// in ascending order. Use "desc" after a field name for descending.
  /// Supported fields: * `display_name` * `create_time` * `update_time`
  /// Example: `display_name, create_time desc`.
  ///
  /// [pageSize] - Optional. The standard list page size.
  ///
  /// [pageToken] - Optional. The standard list page token. Typically obtained
  /// via ListNotebookRuntimesResponse.next_page_token of the previous
  /// NotebookService.ListNotebookRuntimes call.
  ///
  /// [readMask] - Optional. Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListNotebookRuntimesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListNotebookRuntimesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/notebookRuntimes';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListNotebookRuntimesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Starts a NotebookRuntime.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the NotebookRuntime resource to be started.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebookRuntimes/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> start(
    GoogleCloudAiplatformV1StartNotebookRuntimeRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':start';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPipelineJobsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPipelineJobsOperationsResource get operations =>
      ProjectsLocationsPipelineJobsOperationsResource(_requester);

  ProjectsLocationsPipelineJobsResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a PipelineJob.
  ///
  /// Starts asynchronous cancellation on the PipelineJob. The server makes a
  /// best effort to cancel the pipeline, but success is not guaranteed. Clients
  /// can use PipelineService.GetPipelineJob or other methods to check whether
  /// the cancellation succeeded or whether the pipeline completed despite
  /// cancellation. On successful cancellation, the PipelineJob is not deleted;
  /// instead it becomes a pipeline with a PipelineJob.error value with a
  /// google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`, and
  /// PipelineJob.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob to cancel. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelPipelineJobRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a PipelineJob.
  ///
  /// A PipelineJob will run immediately when created.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// PipelineJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pipelineJobId] - The ID to use for the PipelineJob, which will become the
  /// final component of the PipelineJob name. If not provided, an ID will be
  /// automatically generated. This value should be less than 128 characters,
  /// and valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PipelineJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PipelineJob> create(
    GoogleCloudAiplatformV1PipelineJob request,
    core.String parent, {
    core.String? pipelineJobId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pipelineJobId != null) 'pipelineJobId': [pipelineJobId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PipelineJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a PipelineJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a PipelineJob.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PipelineJob resource. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PipelineJob].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PipelineJob> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PipelineJob.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists PipelineJobs in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// PipelineJobs from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the PipelineJobs that match the filter expression. The
  /// following fields are supported: * `pipeline_name`: Supports `=` and `!=`
  /// comparisons. * `display_name`: Supports `=`, `!=` comparisons, and `:`
  /// wildcard. * `pipeline_job_user_id`: Supports `=`, `!=` comparisons, and
  /// `:` wildcard. for example, can check if pipeline's display_name contains
  /// *step* by doing display_name:\"*step*\" * `state`: Supports `=` and `!=`
  /// comparisons. * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  /// comparisons. Values must be in RFC 3339 format. * `update_time`: Supports
  /// `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons. Values must be in RFC
  /// 3339 format. * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  /// comparisons. Values must be in RFC 3339 format. * `labels`: Supports
  /// key-value equality and key presence. * `template_uri`: Supports `=`, `!=`
  /// comparisons, and `:` wildcard. * `template_metadata.version`: Supports
  /// `=`, `!=` comparisons, and `:` wildcard. Filter expressions can be
  /// combined together using logical operators (`AND` & `OR`). For example:
  /// `pipeline_name="test" AND create_time>"2020-05-18T13:30:00Z"`. The syntax
  /// to define filter expression is based on https://google.aip.dev/160.
  /// Examples: * `create_time>"2021-05-18T00:00:00Z" OR
  /// update_time>"2020-05-18T00:00:00Z"` PipelineJobs created or updated after
  /// 2020-05-18 00:00:00 UTC. * `labels.env = "prod"` PipelineJobs with label
  /// "env" set to "prod".
  ///
  /// [orderBy] - A comma-separated list of fields to order by. The default sort
  /// order is in ascending order. Use "desc" after a field name for descending.
  /// You can have multiple order_by fields provided e.g. "create_time desc,
  /// end_time", "end_time, start_time, update_time" For example, using
  /// "create_time desc, end_time" will order results by create time in
  /// descending order, and if there are multiple jobs having the same create
  /// time, order them by the end time in ascending order. if order_by is not
  /// specified, it will order by default order is create time in descending
  /// order. Supported fields: * `create_time` * `update_time` * `end_time` *
  /// `start_time`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListPipelineJobsResponse.next_page_token of the previous
  /// PipelineService.ListPipelineJobs call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListPipelineJobsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListPipelineJobsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/pipelineJobs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListPipelineJobsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPipelineJobsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPipelineJobsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/pipelineJobs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsPublishersResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPublishersModelsResource get models =>
      ProjectsLocationsPublishersModelsResource(_requester);

  ProjectsLocationsPublishersResource(commons.ApiRequester client)
      : _requester = client;
}

class ProjectsLocationsPublishersModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPublishersModelsResource(commons.ApiRequester client)
      : _requester = client;

  /// Perform an online prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PredictResponse> predict(
    GoogleCloudAiplatformV1PredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':predict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers: *
  /// `X-Vertex-AI-Endpoint-Id`: ID of the Endpoint that served this prediction.
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's DeployedModel that
  /// served this prediction.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> rawPredict(
    GoogleCloudAiplatformV1RawPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$endpoint') + ':rawPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Perform a server-side streaming online prediction request for Vertex LLM
  /// streaming.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [endpoint] - Required. The name of the Endpoint requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1StreamingPredictResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1StreamingPredictResponse>
      serverStreamingPredict(
    GoogleCloudAiplatformV1StreamingPredictRequest request,
    core.String endpoint, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$endpoint') + ':serverStreamingPredict';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1StreamingPredictResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSchedulesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSchedulesOperationsResource get operations =>
      ProjectsLocationsSchedulesOperationsResource(_requester);

  ProjectsLocationsSchedulesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a Schedule.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Schedule in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Schedule> create(
    GoogleCloudAiplatformV1Schedule request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/schedules';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Schedule.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Schedule.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Schedule.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource. Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Schedule> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Schedule.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Schedules in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// Schedules from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the Schedules that match the filter expression. The
  /// following fields are supported: * `display_name`: Supports `=`, `!=`
  /// comparisons, and `:` wildcard. * `state`: Supports `=` and `!=`
  /// comparisons. * `request`: Supports existence of the check. (e.g.
  /// `create_pipeline_job_request:*` --\> Schedule has
  /// create_pipeline_job_request). * `create_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, and `>=` comparisons. Values must be in RFC 3339 format. *
  /// `start_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be in RFC 3339 format. * `end_time`: Supports `=`, `!=`, `<`,
  /// `>`, `<=`, `>=` comparisons and `:*` existence check. Values must be in
  /// RFC 3339 format. * `next_run_time`: Supports `=`, `!=`, `<`, `>`, `<=`,
  /// and `>=` comparisons. Values must be in RFC 3339 format. Filter
  /// expressions can be combined together using logical operators (`NOT`, `AND`
  /// & `OR`). The syntax to define filter expression is based on
  /// https://google.aip.dev/160. Examples: * `state="ACTIVE" AND
  /// display_name:"my_schedule_*"` * `NOT display_name="my_schedule"` *
  /// `create_time>"2021-05-18T00:00:00Z"` * `end_time>"2021-05-18T00:00:00Z" OR
  /// NOT end_time:*` * `create_pipeline_job_request:*`
  ///
  /// [orderBy] - A comma-separated list of fields to order by. The default sort
  /// order is in ascending order. Use "desc" after a field name for descending.
  /// You can have multiple order_by fields provided. For example, using
  /// "create_time desc, end_time" will order results by create time in
  /// descending order, and if there are multiple schedules having the same
  /// create time, order them by the end time in ascending order. If order_by is
  /// not specified, it will order by default with create_time in descending
  /// order. Supported fields: * `create_time` * `start_time` * `end_time` *
  /// `next_run_time`
  ///
  /// [pageSize] - The standard list page size. Default to 100 if not specified.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListSchedulesResponse.next_page_token of the previous
  /// ScheduleService.ListSchedules call.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListSchedulesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListSchedulesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/schedules';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListSchedulesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates an active or paused Schedule.
  ///
  /// When the Schedule is updated, new runs will be scheduled starting from the
  /// updated next execution time after the update time based on the
  /// time_specification in the updated Schedule. All unstarted runs before the
  /// update time will be skipped while already created runs will NOT be paused
  /// or canceled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The resource name of the Schedule.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource. See
  /// google.protobuf.FieldMask.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Schedule].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Schedule> patch(
    GoogleCloudAiplatformV1Schedule request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Schedule.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Pauses a Schedule.
  ///
  /// Will mark Schedule.state to 'PAUSED'. If the schedule is paused, no new
  /// runs will be created. Already created runs will NOT be paused or canceled.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be paused. Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> pause(
    GoogleCloudAiplatformV1PauseScheduleRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':pause';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Resumes a paused Schedule to start scheduling new runs.
  ///
  /// Will mark Schedule.state to 'ACTIVE'. Only paused Schedule can be resumed.
  /// When the Schedule is resumed, new runs will be scheduled starting from the
  /// next execution time after the current time based on the time_specification
  /// in the Schedule. If Schedule.catchUp is set up true, all missed runs will
  /// be scheduled for backfill first.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Schedule resource to be resumed.
  /// Format: `projects/{project}/locations/{location}/schedules/{schedule}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> resume(
    GoogleCloudAiplatformV1ResumeScheduleRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':resume';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSchedulesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSchedulesOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/schedules/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSpecialistPoolsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSpecialistPoolsOperationsResource get operations =>
      ProjectsLocationsSpecialistPoolsOperationsResource(_requester);

  ProjectsLocationsSpecialistPoolsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a SpecialistPool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent Project name for the new SpecialistPool.
  /// The form is `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1SpecialistPool request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/specialistPools';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a SpecialistPool as well as all Specialists in the pool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SpecialistPool to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [force] - If set to true, any specialist managers in this SpecialistPool
  /// will also be deleted. (Otherwise, the request will only work if the
  /// SpecialistPool has no specialist managers.)
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.bool? force,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (force != null) 'force': ['${force}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a SpecialistPool.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the SpecialistPool resource. The form is
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1SpecialistPool].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1SpecialistPool> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1SpecialistPool.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists SpecialistPools in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the SpecialistPool's parent resource.
  /// Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained by
  /// ListSpecialistPoolsResponse.next_page_token of the previous
  /// SpecialistPoolService.ListSpecialistPools call. Return first page if
  /// empty.
  ///
  /// [readMask] - Mask specifying which fields to read. FieldMask represents a
  /// set of
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListSpecialistPoolsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListSpecialistPoolsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/specialistPools';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListSpecialistPoolsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a SpecialistPool.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the SpecialistPool.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [updateMask] - Required. The update mask applies to the resource.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1SpecialistPool request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsSpecialistPoolsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSpecialistPoolsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/specialistPools/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesOperationsResource get operations =>
      ProjectsLocationsStudiesOperationsResource(_requester);
  ProjectsLocationsStudiesTrialsResource get trials =>
      ProjectsLocationsStudiesTrialsResource(_requester);

  ProjectsLocationsStudiesResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a Study.
  ///
  /// A resource name will be generated after creation of the Study.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// CustomJob in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Study> create(
    GoogleCloudAiplatformV1Study request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/studies';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Study.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Study.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Study resource to be deleted. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Study by name.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Study resource. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Study> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Study.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists all the studies in a region for an associated project.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the Study
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The maximum number of studies to return per "page"
  /// of results. If unspecified, service will pick an appropriate default.
  ///
  /// [pageToken] - Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListStudiesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListStudiesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/studies';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListStudiesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Looks a study up using the user-defined display_name field instead of the
  /// fully qualified resource name.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to get the Study
  /// from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Study].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Study> lookup(
    GoogleCloudAiplatformV1LookupStudyRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/studies:lookup';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Study.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesTrialsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesTrialsOperationsResource get operations =>
      ProjectsLocationsStudiesTrialsOperationsResource(_requester);

  ProjectsLocationsStudiesTrialsResource(commons.ApiRequester client)
      : _requester = client;

  /// Adds a measurement of the objective metrics to a Trial.
  ///
  /// This measurement is assumed to have been taken before the Trial is
  /// complete.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [trialName] - Required. The name of the trial to add measurement. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> addTrialMeasurement(
    GoogleCloudAiplatformV1AddTrialMeasurementRequest request,
    core.String trialName, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$trialName') + ':addTrialMeasurement';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Checks whether a Trial should stop or not.
  ///
  /// Returns a long-running operation. When the operation is successful, it
  /// will contain a CheckTrialEarlyStoppingStateResponse.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [trialName] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> checkTrialEarlyStoppingState(
    GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest request,
    core.String trialName, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$trialName') +
        ':checkTrialEarlyStoppingState';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Marks a Trial as complete.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> complete(
    GoogleCloudAiplatformV1CompleteTrialRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':complete';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Adds a user provided Trial to a Study.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Study to create the Trial
  /// in. Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> create(
    GoogleCloudAiplatformV1Trial request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trials';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Trial.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Trial.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Trial resource. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists the Trials associated with a Study.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Study to list the Trial
  /// from. Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. The number of Trials to retrieve per "page" of
  /// results. If unspecified, the service will pick an appropriate default.
  ///
  /// [pageToken] - Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTrialsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTrialsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trials';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTrialsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists the pareto-optimal Trials for multi-objective Study or the optimal
  /// Trials for single-objective Study.
  ///
  /// The definition of pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The name of the Study that the optimal Trial belongs
  /// to.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListOptimalTrialsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListOptimalTrialsResponse>
      listOptimalTrials(
    GoogleCloudAiplatformV1ListOptimalTrialsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$parent') + '/trials:listOptimalTrials';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListOptimalTrialsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Stops a Trial.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The Trial's name. Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Trial].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Trial> stop(
    GoogleCloudAiplatformV1StopTrialRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':stop';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Trial.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Adds one or more Trials to a Study, with parameter values suggested by
  /// Vertex AI Vizier.
  ///
  /// Returns a long-running operation associated with the generation of Trial
  /// suggestions. When this long-running operation succeeds, it will contain a
  /// SuggestTrialsResponse.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The project and location that the Study belongs to.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> suggest(
    GoogleCloudAiplatformV1SuggestTrialsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trials:suggest';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsStudiesTrialsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsStudiesTrialsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/studies/\[^/\]+/trials/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsResource get experiments =>
      ProjectsLocationsTensorboardsExperimentsResource(_requester);
  ProjectsLocationsTensorboardsOperationsResource get operations =>
      ProjectsLocationsTensorboardsOperationsResource(_requester);

  ProjectsLocationsTensorboardsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a Tensorboard.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// Tensorboard in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudAiplatformV1Tensorboard request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/tensorboards';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a Tensorboard.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Tensorboard to be deleted. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a Tensorboard.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1Tensorboard].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1Tensorboard> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1Tensorboard.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists Tensorboards in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list
  /// Tensorboards. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Lists the Tensorboards that match the filter expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of Tensorboards to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Tensorboards are
  /// returned. The maximum value is 100; values above 100 are coerced to 100.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboards call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// TensorboardService.ListTensorboards must match the call that provided the
  /// page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTensorboardsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/tensorboards';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a Tensorboard.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the Tensorboard. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the Tensorboard resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field is overwritten if it's in the mask. If the user does not
  /// provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudAiplatformV1Tensorboard request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns the storage size for a given TensorBoard instance.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadTensorboardSizeResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardSizeResponse> readSize(
    core.String tensorboard, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$tensorboard') + ':readSize';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardSizeResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Returns a list of monthly active users for a given TensorBoard instance.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The name of the Tensorboard resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadTensorboardUsageResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardUsageResponse> readUsage(
    core.String tensorboard, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$tensorboard') + ':readUsage';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardUsageResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsOperationsResource get operations =>
      ProjectsLocationsTensorboardsExperimentsOperationsResource(_requester);
  ProjectsLocationsTensorboardsExperimentsRunsResource get runs =>
      ProjectsLocationsTensorboardsExperimentsRunsResource(_requester);

  ProjectsLocationsTensorboardsExperimentsResource(commons.ApiRequester client)
      : _requester = client;

  /// Creates a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Tensorboard to create the
  /// TensorboardExperiment in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [tensorboardExperimentId] - Required. The ID to use for the Tensorboard
  /// experiment, which becomes the final component of the Tensorboard
  /// experiment's resource name. This value should be 1-128 characters, and
  /// valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardExperiment> create(
    GoogleCloudAiplatformV1TensorboardExperiment request,
    core.String parent, {
    core.String? tensorboardExperimentId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardExperimentId != null)
        'tensorboardExperimentId': [tensorboardExperimentId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/experiments';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TensorboardExperiment.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardExperiment to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TensorboardExperiment.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardExperiment resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardExperiment> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TensorboardExperiments in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Tensorboard to list
  /// TensorboardExperiments. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardExperiments that match the filter
  /// expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardExperiments to return. The
  /// service may return fewer than this value. If unspecified, at most 50
  /// TensorboardExperiments are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardExperiments call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to TensorboardService.ListTensorboardExperiments must match the
  /// call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListTensorboardExperimentsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardExperimentsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/experiments';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardExperimentsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardExperiment. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardExperiment resource by the update. The
  /// fields specified in the update_mask are relative to the resource, not the
  /// full request. A field is overwritten if it's in the mask. If the user does
  /// not provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardExperiment].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardExperiment> patch(
    GoogleCloudAiplatformV1TensorboardExperiment request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Write time series data points of multiple TensorboardTimeSeries in
  /// multiple TensorboardRun's.
  ///
  /// If any data fail to be ingested, an error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardExperiment] - Required. The resource name of the
  /// TensorboardExperiment to write data to. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse>
      write(
    GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest request,
    core.String tensorboardExperiment, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$tensorboardExperiment') + ':write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsOperationsResource
      get operations =>
          ProjectsLocationsTensorboardsExperimentsRunsOperationsResource(
              _requester);
  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource
      get timeSeries =>
          ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource(
              _requester);

  ProjectsLocationsTensorboardsExperimentsRunsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Batch create TensorboardRuns.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardRuns in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The parent field in the CreateTensorboardRunRequest messages must match
  /// this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse>
      batchCreate(
    GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/runs:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TensorboardRun.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardRun in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [tensorboardRunId] - Required. The ID to use for the Tensorboard run,
  /// which becomes the final component of the Tensorboard run's resource name.
  /// This value should be 1-128 characters, and valid characters are `/a-z-/`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardRun> create(
    GoogleCloudAiplatformV1TensorboardRun request,
    core.String parent, {
    core.String? tensorboardRunId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardRunId != null) 'tensorboardRunId': [tensorboardRunId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/runs';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardRun.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TensorboardRun.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardRun to be deleted. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TensorboardRun.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardRun resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardRun> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardRun.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TensorboardRuns in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// list TensorboardRuns. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardRuns that match the filter expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardRuns to return. The service
  /// may return fewer than this value. If unspecified, at most 50
  /// TensorboardRuns are returned. The maximum value is 1000; values above 1000
  /// are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardRuns call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// TensorboardService.ListTensorboardRuns must match the call that provided
  /// the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTensorboardRunsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardRunsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/runs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardRunsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a TensorboardRun.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardRun. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardRun resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field is overwritten if it's in the mask. If the user does not
  /// provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardRun> patch(
    GoogleCloudAiplatformV1TensorboardRun request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardRun.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Write time series data points into multiple TensorboardTimeSeries under a
  /// TensorboardRun.
  ///
  /// If any data fail to be ingested, an error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardRun] - Required. The resource name of the TensorboardRun to
  /// write data to. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1WriteTensorboardRunDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1WriteTensorboardRunDataResponse> write(
    GoogleCloudAiplatformV1WriteTensorboardRunDataRequest request,
    core.String tensorboardRun, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$tensorboardRun') + ':write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1WriteTensorboardRunDataResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource
      get operations =>
          ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource(
              _requester);

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Batch create TensorboardTimeSeries that belong to a TensorboardExperiment.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardExperiment to
  /// create the TensorboardTimeSeries in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The TensorboardRuns referenced by the parent fields in the
  /// CreateTensorboardTimeSeriesRequest messages must be sub resources of this
  /// TensorboardExperiment.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+$`.
  ///
  /// [runsId] - null
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse>
      batchCreate(
    GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest request,
    core.String parent,
    core.String runsId, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$parent') +
        '/runs/' +
        commons.escapeVariable('$runsId') +
        '/timeSeries:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads multiple TensorboardTimeSeries' data.
  ///
  /// The data point number limit is 1000 for scalars, 100 for tensors and blob
  /// references. If the number of data points stored is less than the limit,
  /// all data is returned. Otherwise, the number limit of data points is
  /// randomly selected from this time series and returned.
  ///
  /// Request parameters:
  ///
  /// [tensorboard] - Required. The resource name of the Tensorboard containing
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`. The
  /// TensorboardTimeSeries referenced by time_series must be sub resources of
  /// this Tensorboard.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [experimentsId] - null
  ///
  /// [runsId] - null
  ///
  /// [timeSeries] - Required. The resource names of the TensorboardTimeSeries
  /// to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async
      .Future<GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse>
      batchRead(
    core.String tensorboard,
    core.String experimentsId,
    core.String runsId, {
    core.List<core.String>? timeSeries,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeSeries != null) 'timeSeries': timeSeries,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$tensorboard') +
        '/experiments/' +
        commons.escapeVariable('$experimentsId') +
        '/runs/' +
        commons.escapeVariable('$runsId') +
        '/timeSeries:batchRead';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TensorboardTimeSeries.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [tensorboardTimeSeriesId] - Optional. The user specified unique ID to use
  /// for the TensorboardTimeSeries, which becomes the final component of the
  /// TensorboardTimeSeries's resource name. This value should match "a-z0-9{0,
  /// 127}"
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardTimeSeries> create(
    GoogleCloudAiplatformV1TensorboardTimeSeries request,
    core.String parent, {
    core.String? tensorboardTimeSeriesId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId': [tensorboardTimeSeriesId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/timeSeries';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TensorboardTimeSeries.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardTimeSeries to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Exports a TensorboardTimeSeries' data.
  ///
  /// Data is returned in paginated responses.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [tensorboardTimeSeries] - Required. The resource name of the
  /// TensorboardTimeSeries to export data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse>
      exportTensorboardTimeSeries(
    GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest request,
    core.String tensorboardTimeSeries, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' +
        core.Uri.encodeFull('$tensorboardTimeSeries') +
        ':exportTensorboardTimeSeries';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TensorboardTimeSeries.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TensorboardTimeSeries resource. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardTimeSeries> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TensorboardTimeSeries in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the TensorboardRun to list
  /// TensorboardTimeSeries. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+$`.
  ///
  /// [filter] - Lists the TensorboardTimeSeries that match the filter
  /// expression.
  ///
  /// [orderBy] - Field to use to sort the list.
  ///
  /// [pageSize] - The maximum number of TensorboardTimeSeries to return. The
  /// service may return fewer than this value. If unspecified, at most 50
  /// TensorboardTimeSeries are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// TensorboardService.ListTensorboardTimeSeries call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to TensorboardService.ListTensorboardTimeSeries must match the
  /// call that provided the page token.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/timeSeries';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Updates a TensorboardTimeSeries.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. Name of the TensorboardTimeSeries.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [updateMask] - Required. Field mask is used to specify the fields to be
  /// overwritten in the TensorboardTimeSeries resource by the update. The
  /// fields specified in the update_mask are relative to the resource, not the
  /// full request. A field is overwritten if it's in the mask. If the user does
  /// not provide a mask then all fields are overwritten if new values are
  /// specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TensorboardTimeSeries].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TensorboardTimeSeries> patch(
    GoogleCloudAiplatformV1TensorboardTimeSeries request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Reads a TensorboardTimeSeries' data.
  ///
  /// By default, if the number of data points stored is less than 1000, all
  /// data is returned. Otherwise, 1000 data points is randomly selected from
  /// this time series and returned. This value can be changed by changing
  /// max_data_points, which can't be greater than 10k.
  ///
  /// Request parameters:
  ///
  /// [tensorboardTimeSeries] - Required. The resource name of the
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [filter] - Reads the TensorboardTimeSeries' data that match the filter
  /// expression.
  ///
  /// [maxDataPoints] - The maximum number of TensorboardTimeSeries' data to
  /// return. This value should be a positive integer. This value can be set to
  /// -1 to return all data.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse>
      read(
    core.String tensorboardTimeSeries, {
    core.String? filter,
    core.int? maxDataPoints,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (maxDataPoints != null) 'maxDataPoints': ['${maxDataPoints}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1/' + core.Uri.encodeFull('$tensorboardTimeSeries') + ':read';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse
        .fromJson(response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets bytes of TensorboardBlobs.
  ///
  /// This is to allow reading blob data stored in consumer project's Cloud
  /// Storage bucket without users having to obtain Cloud Storage access
  /// permission.
  ///
  /// Request parameters:
  ///
  /// [timeSeries] - Required. The resource name of the TensorboardTimeSeries to
  /// list Blobs. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [blobIds] - IDs of the blobs to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse>
      readBlobData(
    core.String timeSeries, {
    core.List<core.String>? blobIds,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (blobIds != null) 'blobIds': blobIds,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$timeSeries') + ':readBlobData';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsExperimentsRunsTimeSeriesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/experiments/\[^/\]+/runs/\[^/\]+/timeSeries/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTensorboardsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTensorboardsOperationsResource(commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/tensorboards/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTrainingPipelinesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTrainingPipelinesOperationsResource get operations =>
      ProjectsLocationsTrainingPipelinesOperationsResource(_requester);

  ProjectsLocationsTrainingPipelinesResource(commons.ApiRequester client)
      : _requester = client;

  /// Cancels a TrainingPipeline.
  ///
  /// Starts asynchronous cancellation on the TrainingPipeline. The server makes
  /// a best effort to cancel the pipeline, but success is not guaranteed.
  /// Clients can use PipelineService.GetTrainingPipeline or other methods to
  /// check whether the cancellation succeeded or whether the pipeline completed
  /// despite cancellation. On successful cancellation, the TrainingPipeline is
  /// not deleted; instead it becomes a pipeline with a TrainingPipeline.error
  /// value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`, and TrainingPipeline.state is set to `CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline to cancel. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleCloudAiplatformV1CancelTrainingPipelineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Creates a TrainingPipeline.
  ///
  /// A created TrainingPipeline right away will be attempted to be run.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to create the
  /// TrainingPipeline in. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TrainingPipeline].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TrainingPipeline> create(
    GoogleCloudAiplatformV1TrainingPipeline request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trainingPipelines';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TrainingPipeline.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a TrainingPipeline.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline resource to be
  /// deleted. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets a TrainingPipeline.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the TrainingPipeline resource. Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1TrainingPipeline].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1TrainingPipeline> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1TrainingPipeline.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists TrainingPipelines in a Location.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Location to list the
  /// TrainingPipelines from. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter. Supported fields: * \`display_name\`
  /// supports \`=\`, \`!=\` comparisons, and \`:\` wildcard. * \`state\`
  /// supports \`=\`, \`!=\` comparisons. * \`training_task_definition\` \`=\`,
  /// \`!=\` comparisons, and \`:\` wildcard. * \`create_time\` supports \`=\`,
  /// \`!=\`,\`\<\`, \`\<=\`,\`\>\`, \`\>=\` comparisons. \`create_time\` must
  /// be in RFC 3339 format. * \`labels\` supports general map functions that
  /// is: \`labels.key=value\` - key:value equality \`labels.key:* - key
  /// existence Some examples of using the filter are: *
  /// \`state="PIPELINE_STATE_SUCCEEDED" AND display_name:"my_pipeline_*"\` *
  /// \`state!="PIPELINE_STATE_FAILED" OR display_name="my_pipeline"\` * \`NOT
  /// display_name="my_pipeline"\` * \`create_time\>"2021-05-18T00:00:00Z"\` *
  /// \`training_task_definition:"*automl_text_classification*"\`
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token. Typically obtained via
  /// ListTrainingPipelinesResponse.next_page_token of the previous
  /// PipelineService.ListTrainingPipelines call.
  ///
  /// [readMask] - Mask specifying which fields to read.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1ListTrainingPipelinesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1ListTrainingPipelinesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? readMask,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if (readMask != null) 'readMask': [readMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$parent') + '/trainingPipelines';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1ListTrainingPipelinesResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class ProjectsLocationsTrainingPipelinesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsTrainingPipelinesOperationsResource(
      commons.ApiRequester client)
      : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of 1, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Deletes a long-running operation.
  ///
  /// This method indicates that the client is no longer interested in the
  /// operation result. It does not cancel the operation. If the server doesn't
  /// support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be deleted.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }

  /// Waits until the specified long-running operation is done or reaches at
  /// most a specified timeout, returning the latest state.
  ///
  /// If the operation is already done, the latest state is immediately
  /// returned. If the timeout specified is greater than the default HTTP/RPC
  /// timeout, the HTTP/RPC timeout is used. If the server does not support this
  /// method, it returns `google.rpc.Code.UNIMPLEMENTED`. Note that this method
  /// is on a best-effort basis. It may return the latest state before the
  /// specified timeout (including immediately), meaning even an immediate
  /// response is no guarantee that the operation is done.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to wait on.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/trainingPipelines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [timeout] - The maximum duration to wait before timing out. If left blank,
  /// the wait will be at most the time permitted by the underlying HTTP/RPC
  /// protocol. If RPC context deadline is also specified, the shorter one will
  /// be used.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> wait(
    core.String name, {
    core.String? timeout,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (timeout != null) 'timeout': [timeout],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name') + ':wait';

    final response_ = await _requester.request(
      url_,
      'POST',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

class PublishersResource {
  final commons.ApiRequester _requester;

  PublishersModelsResource get models => PublishersModelsResource(_requester);

  PublishersResource(commons.ApiRequester client) : _requester = client;
}

class PublishersModelsResource {
  final commons.ApiRequester _requester;

  PublishersModelsResource(commons.ApiRequester client) : _requester = client;

  /// Gets a Model Garden publisher model.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the PublisherModel resource. Format:
  /// `publishers/{publisher}/models/{publisher_model}`
  /// Value must have pattern `^publishers/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [languageCode] - Optional. The IETF BCP-47 language code representing the
  /// language in which the publisher model's text information should be written
  /// in (see go/bcp47).
  ///
  /// [view] - Optional. PublisherModel view specifying which fields to read.
  /// Possible string values are:
  /// - "PUBLISHER_MODEL_VIEW_UNSPECIFIED" : The default / unset value. The API
  /// will default to the BASIC view.
  /// - "PUBLISHER_MODEL_VIEW_BASIC" : Include basic metadata about the
  /// publisher model, but not the full contents.
  /// - "PUBLISHER_MODEL_VIEW_FULL" : Include everything.
  /// - "PUBLISHER_MODEL_VERSION_VIEW_BASIC" : Include: VersionId,
  /// ModelVersionExternalName, and SupportedActions.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudAiplatformV1PublisherModel].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudAiplatformV1PublisherModel> get(
    core.String name, {
    core.String? languageCode,
    core.String? view,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (languageCode != null) 'languageCode': [languageCode],
      if (view != null) 'view': [view],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudAiplatformV1PublisherModel.fromJson(
        response_ as core.Map<core.String, core.dynamic>);
  }
}

/// Message that represents an arbitrary HTTP body.
///
/// It should only be used for payload formats that can't be represented as
/// JSON, such as raw binary or an HTML page. This message can be used both in
/// streaming and non-streaming API methods in the request as well as the
/// response. It can be used as a top-level request field, which is convenient
/// if one wants to extract parameters from either the URL or HTTP template into
/// the request fields and also want access to the raw HTTP body. Example:
/// message GetResourceRequest { // A unique request id. string request_id = 1;
/// // The raw HTTP body is bound to this field. google.api.HttpBody http_body =
/// 2; } service ResourceService { rpc GetResource(GetResourceRequest) returns
/// (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns
/// (google.protobuf.Empty); } Example with streaming methods: service
/// CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream
/// google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
/// (stream google.api.HttpBody); } Use of this type only changes how the
/// request and response bodies are handled, all other features will continue to
/// work unchanged.
typedef GoogleApiHttpBody = $HttpBody;

/// Parameters that configure the active learning pipeline.
///
/// Active learning will label the data incrementally by several iterations. For
/// every iteration, it will select a batch of data based on the sampling
/// strategy.
class GoogleCloudAiplatformV1ActiveLearningConfig {
  /// Max number of human labeled DataItems.
  core.String? maxDataItemCount;

  /// Max percent of total DataItems for human labeling.
  core.int? maxDataItemPercentage;

  /// Active learning data sampling config.
  ///
  /// For every active learning labeling iteration, it will select a batch of
  /// data based on the sampling strategy.
  GoogleCloudAiplatformV1SampleConfig? sampleConfig;

  /// CMLE training config.
  ///
  /// For every active learning labeling iteration, system will train a machine
  /// learning model on CMLE. The trained model will be used by data sampling
  /// algorithm to select DataItems.
  GoogleCloudAiplatformV1TrainingConfig? trainingConfig;

  GoogleCloudAiplatformV1ActiveLearningConfig({
    this.maxDataItemCount,
    this.maxDataItemPercentage,
    this.sampleConfig,
    this.trainingConfig,
  });

  GoogleCloudAiplatformV1ActiveLearningConfig.fromJson(core.Map json_)
      : this(
          maxDataItemCount: json_.containsKey('maxDataItemCount')
              ? json_['maxDataItemCount'] as core.String
              : null,
          maxDataItemPercentage: json_.containsKey('maxDataItemPercentage')
              ? json_['maxDataItemPercentage'] as core.int
              : null,
          sampleConfig: json_.containsKey('sampleConfig')
              ? GoogleCloudAiplatformV1SampleConfig.fromJson(
                  json_['sampleConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          trainingConfig: json_.containsKey('trainingConfig')
              ? GoogleCloudAiplatformV1TrainingConfig.fromJson(
                  json_['trainingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxDataItemCount != null) 'maxDataItemCount': maxDataItemCount!,
        if (maxDataItemPercentage != null)
          'maxDataItemPercentage': maxDataItemPercentage!,
        if (sampleConfig != null) 'sampleConfig': sampleConfig!,
        if (trainingConfig != null) 'trainingConfig': trainingConfig!,
      };
}

/// Request message for MetadataService.AddContextArtifactsAndExecutions.
class GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest {
  /// The resource names of the Artifacts to attribute to the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  core.List<core.String>? artifacts;

  /// The resource names of the Executions to associate with the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  core.List<core.String>? executions;

  GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest({
    this.artifacts,
    this.executions,
  });

  GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsRequest.fromJson(
      core.Map json_)
      : this(
          artifacts: json_.containsKey('artifacts')
              ? (json_['artifacts'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          executions: json_.containsKey('executions')
              ? (json_['executions'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
        if (executions != null) 'executions': executions!,
      };
}

/// Response message for MetadataService.AddContextArtifactsAndExecutions.
typedef GoogleCloudAiplatformV1AddContextArtifactsAndExecutionsResponse
    = $Empty;

/// Request message for MetadataService.AddContextChildren.
typedef GoogleCloudAiplatformV1AddContextChildrenRequest
    = $ContextChildrenRequest;

/// Response message for MetadataService.AddContextChildren.
typedef GoogleCloudAiplatformV1AddContextChildrenResponse = $Empty;

/// Request message for MetadataService.AddExecutionEvents.
class GoogleCloudAiplatformV1AddExecutionEventsRequest {
  /// The Events to create and add.
  core.List<GoogleCloudAiplatformV1Event>? events;

  GoogleCloudAiplatformV1AddExecutionEventsRequest({
    this.events,
  });

  GoogleCloudAiplatformV1AddExecutionEventsRequest.fromJson(core.Map json_)
      : this(
          events: json_.containsKey('events')
              ? (json_['events'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Event.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (events != null) 'events': events!,
      };
}

/// Response message for MetadataService.AddExecutionEvents.
typedef GoogleCloudAiplatformV1AddExecutionEventsResponse = $Empty;

/// Request message for VizierService.AddTrialMeasurement.
class GoogleCloudAiplatformV1AddTrialMeasurementRequest {
  /// The measurement to be added to a Trial.
  ///
  /// Required.
  GoogleCloudAiplatformV1Measurement? measurement;

  GoogleCloudAiplatformV1AddTrialMeasurementRequest({
    this.measurement,
  });

  GoogleCloudAiplatformV1AddTrialMeasurementRequest.fromJson(core.Map json_)
      : this(
          measurement: json_.containsKey('measurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['measurement'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (measurement != null) 'measurement': measurement!,
      };
}

/// Used to assign specific AnnotationSpec to a particular area of a DataItem or
/// the whole part of the DataItem.
class GoogleCloudAiplatformV1Annotation {
  /// The source of the Annotation.
  ///
  /// Output only.
  GoogleCloudAiplatformV1UserActionReference? annotationSource;

  /// Timestamp when this Annotation was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Annotations.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Annotation(System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for each Annotation: *
  /// "aiplatform.googleapis.com/annotation_set_name": optional, name of the
  /// UI's annotation set this Annotation belongs to. If not set, the Annotation
  /// is not visible in the UI. * "aiplatform.googleapis.com/payload_schema":
  /// output only, its value is the payload_schema's title.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the Annotation.
  ///
  /// Output only.
  core.String? name;

  /// The schema of the payload can be found in payload_schema.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? payload;

  /// Google Cloud Storage URI points to a YAML file describing payload.
  ///
  /// The schema is defined as an
  /// [OpenAPI 3.0.2 Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
  /// chosen schema must be consistent with the parent Dataset's metadata.
  ///
  /// Required.
  core.String? payloadSchemaUri;

  /// Timestamp when this Annotation was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Annotation({
    this.annotationSource,
    this.createTime,
    this.etag,
    this.labels,
    this.name,
    this.payload,
    this.payloadSchemaUri,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Annotation.fromJson(core.Map json_)
      : this(
          annotationSource: json_.containsKey('annotationSource')
              ? GoogleCloudAiplatformV1UserActionReference.fromJson(
                  json_['annotationSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          payload: json_.containsKey('payload') ? json_['payload'] : null,
          payloadSchemaUri: json_.containsKey('payloadSchemaUri')
              ? json_['payloadSchemaUri'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationSource != null) 'annotationSource': annotationSource!,
        if (createTime != null) 'createTime': createTime!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (payload != null) 'payload': payload!,
        if (payloadSchemaUri != null) 'payloadSchemaUri': payloadSchemaUri!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Identifies a concept with which DataItems may be annotated with.
class GoogleCloudAiplatformV1AnnotationSpec {
  /// Timestamp when this AnnotationSpec was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the AnnotationSpec.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// Resource name of the AnnotationSpec.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when AnnotationSpec was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1AnnotationSpec({
    this.createTime,
    this.displayName,
    this.etag,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1AnnotationSpec.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Instance of a general artifact.
class GoogleCloudAiplatformV1Artifact {
  /// Timestamp when this Artifact was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Artifact
  core.String? description;

  /// User provided display name of the Artifact.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Artifacts.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Artifact (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Artifact.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Artifact.
  ///
  /// Output only.
  core.String? name;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// The state of this Artifact.
  ///
  /// This is a property of the Artifact, and does not imply or capture any
  /// ongoing process. This property is managed by clients (such as Vertex AI
  /// Pipelines), and the system does not prescribe or check the validity of
  /// state transitions.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified state for the Artifact.
  /// - "PENDING" : A state used by systems like Vertex AI Pipelines to indicate
  /// that the underlying data item represented by this Artifact is being
  /// created.
  /// - "LIVE" : A state indicating that the Artifact should exist, unless
  /// something external to the system deletes it.
  core.String? state;

  /// Timestamp when this Artifact was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The uniform resource identifier of the artifact file.
  ///
  /// May be empty if there is no actual artifact file.
  core.String? uri;

  GoogleCloudAiplatformV1Artifact({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.schemaTitle,
    this.schemaVersion,
    this.state,
    this.updateTime,
    this.uri,
  });

  GoogleCloudAiplatformV1Artifact.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          schemaTitle: json_.containsKey('schemaTitle')
              ? json_['schemaTitle'] as core.String
              : null,
          schemaVersion: json_.containsKey('schemaVersion')
              ? json_['schemaVersion'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
          uri: json_.containsKey('uri') ? json_['uri'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (schemaTitle != null) 'schemaTitle': schemaTitle!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (uri != null) 'uri': uri!,
      };
}

/// Request message for NotebookService.AssignNotebookRuntime.
class GoogleCloudAiplatformV1AssignNotebookRuntimeRequest {
  /// Provide runtime specific information (e.g. runtime owner, notebook id)
  /// used for NotebookRuntime assignment.
  ///
  /// Required.
  GoogleCloudAiplatformV1NotebookRuntime? notebookRuntime;

  /// User specified ID for the notebook runtime.
  ///
  /// Optional.
  core.String? notebookRuntimeId;

  /// The resource name of the NotebookRuntimeTemplate based on which a
  /// NotebookRuntime will be assigned (reuse or create a new one).
  ///
  /// Required.
  core.String? notebookRuntimeTemplate;

  GoogleCloudAiplatformV1AssignNotebookRuntimeRequest({
    this.notebookRuntime,
    this.notebookRuntimeId,
    this.notebookRuntimeTemplate,
  });

  GoogleCloudAiplatformV1AssignNotebookRuntimeRequest.fromJson(core.Map json_)
      : this(
          notebookRuntime: json_.containsKey('notebookRuntime')
              ? GoogleCloudAiplatformV1NotebookRuntime.fromJson(
                  json_['notebookRuntime']
                      as core.Map<core.String, core.dynamic>)
              : null,
          notebookRuntimeId: json_.containsKey('notebookRuntimeId')
              ? json_['notebookRuntimeId'] as core.String
              : null,
          notebookRuntimeTemplate: json_.containsKey('notebookRuntimeTemplate')
              ? json_['notebookRuntimeTemplate'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (notebookRuntime != null) 'notebookRuntime': notebookRuntime!,
        if (notebookRuntimeId != null) 'notebookRuntimeId': notebookRuntimeId!,
        if (notebookRuntimeTemplate != null)
          'notebookRuntimeTemplate': notebookRuntimeTemplate!,
      };
}

/// Attribution that explains a particular prediction output.
class GoogleCloudAiplatformV1Attribution {
  /// Error of feature_attributions caused by approximation used in the
  /// explanation method.
  ///
  /// Lower value means more precise attributions. * For Sampled Shapley
  /// attribution, increasing path_count might reduce the error. * For
  /// Integrated Gradients attribution, increasing step_count might reduce the
  /// error. * For XRAI attribution, increasing step_count might reduce the
  /// error. See \[this introduction\](/vertex-ai/docs/explainable-ai/overview)
  /// for more information.
  ///
  /// Output only.
  core.double? approximationError;

  /// Model predicted output if the input instance is constructed from the
  /// baselines of all the features defined in ExplanationMetadata.inputs.
  ///
  /// The field name of the output is determined by the key in
  /// ExplanationMetadata.outputs. If the Model's predicted output has multiple
  /// dimensions (rank \> 1), this is the value in the output located by
  /// output_index. If there are multiple baselines, their output values are
  /// averaged.
  ///
  /// Output only.
  core.double? baselineOutputValue;

  /// Attributions of each explained feature.
  ///
  /// Features are extracted from the prediction instances according to
  /// explanation metadata for inputs. The value is a struct, whose keys are the
  /// name of the feature. The values are how much the feature in the instance
  /// contributed to the predicted result. The format of the value is determined
  /// by the feature's input format: * If the feature is a scalar value, the
  /// attribution value is a floating number. * If the feature is an array of
  /// scalar values, the attribution value is an array. * If the feature is a
  /// struct, the attribution value is a struct. The keys in the attribution
  /// value struct are the same as the keys in the feature struct. The formats
  /// of the values in the attribution struct are determined by the formats of
  /// the values in the feature struct. The
  /// ExplanationMetadata.feature_attributions_schema_uri field, pointed to by
  /// the ExplanationSpec field of the Endpoint.deployed_models object, points
  /// to the schema file that describes the features and their attribution
  /// values (if it is populated).
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? featureAttributions;

  /// Model predicted output on the corresponding explanation instance.
  ///
  /// The field name of the output is determined by the key in
  /// ExplanationMetadata.outputs. If the Model predicted output has multiple
  /// dimensions, this is the value in the output located by output_index.
  ///
  /// Output only.
  core.double? instanceOutputValue;

  /// The display name of the output identified by output_index.
  ///
  /// For example, the predicted class name by a multi-classification Model.
  /// This field is only populated iff the Model predicts display names as a
  /// separate field along with the explained output. The predicted display name
  /// must has the same shape of the explained output, and can be located using
  /// output_index.
  ///
  /// Output only.
  core.String? outputDisplayName;

  /// The index that locates the explained prediction output.
  ///
  /// If the prediction output is a scalar value, output_index is not populated.
  /// If the prediction output has multiple dimensions, the length of the
  /// output_index list is the same as the number of dimensions of the output.
  /// The i-th element in output_index is the element index of the i-th
  /// dimension of the output vector. Indices start from 0.
  ///
  /// Output only.
  core.List<core.int>? outputIndex;

  /// Name of the explain output.
  ///
  /// Specified as the key in ExplanationMetadata.outputs.
  ///
  /// Output only.
  core.String? outputName;

  GoogleCloudAiplatformV1Attribution({
    this.approximationError,
    this.baselineOutputValue,
    this.featureAttributions,
    this.instanceOutputValue,
    this.outputDisplayName,
    this.outputIndex,
    this.outputName,
  });

  GoogleCloudAiplatformV1Attribution.fromJson(core.Map json_)
      : this(
          approximationError: json_.containsKey('approximationError')
              ? (json_['approximationError'] as core.num).toDouble()
              : null,
          baselineOutputValue: json_.containsKey('baselineOutputValue')
              ? (json_['baselineOutputValue'] as core.num).toDouble()
              : null,
          featureAttributions: json_.containsKey('featureAttributions')
              ? json_['featureAttributions']
              : null,
          instanceOutputValue: json_.containsKey('instanceOutputValue')
              ? (json_['instanceOutputValue'] as core.num).toDouble()
              : null,
          outputDisplayName: json_.containsKey('outputDisplayName')
              ? json_['outputDisplayName'] as core.String
              : null,
          outputIndex: json_.containsKey('outputIndex')
              ? (json_['outputIndex'] as core.List)
                  .map((value) => value as core.int)
                  .toList()
              : null,
          outputName: json_.containsKey('outputName')
              ? json_['outputName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (approximationError != null)
          'approximationError': approximationError!,
        if (baselineOutputValue != null)
          'baselineOutputValue': baselineOutputValue!,
        if (featureAttributions != null)
          'featureAttributions': featureAttributions!,
        if (instanceOutputValue != null)
          'instanceOutputValue': instanceOutputValue!,
        if (outputDisplayName != null) 'outputDisplayName': outputDisplayName!,
        if (outputIndex != null) 'outputIndex': outputIndex!,
        if (outputName != null) 'outputName': outputName!,
      };
}

/// A description of resources that to large degree are decided by Vertex AI,
/// and require only a modest additional configuration.
///
/// Each Model supporting these resources documents its specific guidelines.
class GoogleCloudAiplatformV1AutomaticResources {
  /// The maximum number of replicas this DeployedModel may be deployed on when
  /// the traffic against it increases.
  ///
  /// If the requested value is too large, the deployment will error, but if
  /// deployment succeeds then the ability to scale the model to that many
  /// replicas is guaranteed (barring service outages). If traffic against the
  /// DeployedModel increases beyond what its replicas at maximum may handle, a
  /// portion of the traffic will be dropped. If this value is not provided, a
  /// no upper bound for scaling under heavy traffic will be assume, though
  /// Vertex AI may be unable to scale beyond certain replica number.
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The minimum number of replicas this DeployedModel will be always deployed
  /// on.
  ///
  /// If traffic against it increases, it may dynamically be deployed onto more
  /// replicas up to max_replica_count, and as traffic decreases, some of these
  /// extra replicas may be freed. If the requested value is too large, the
  /// deployment will error.
  ///
  /// Immutable.
  core.int? minReplicaCount;

  GoogleCloudAiplatformV1AutomaticResources({
    this.maxReplicaCount,
    this.minReplicaCount,
  });

  GoogleCloudAiplatformV1AutomaticResources.fromJson(core.Map json_)
      : this(
          maxReplicaCount: json_.containsKey('maxReplicaCount')
              ? json_['maxReplicaCount'] as core.int
              : null,
          minReplicaCount: json_.containsKey('minReplicaCount')
              ? json_['minReplicaCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
        if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
      };
}

/// The metric specification that defines the target resource utilization (CPU
/// utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
class GoogleCloudAiplatformV1AutoscalingMetricSpec {
  /// The resource metric name.
  ///
  /// Supported metrics: * For Online Prediction: *
  /// `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle` *
  /// `aiplatform.googleapis.com/prediction/online/cpu/utilization`
  ///
  /// Required.
  core.String? metricName;

  /// The target resource utilization in percentage (1% - 100%) for the given
  /// metric; once the real usage deviates from the target by a certain
  /// percentage, the machine replicas change.
  ///
  /// The default value is 60 (representing 60%) if not provided.
  core.int? target;

  GoogleCloudAiplatformV1AutoscalingMetricSpec({
    this.metricName,
    this.target,
  });

  GoogleCloudAiplatformV1AutoscalingMetricSpec.fromJson(core.Map json_)
      : this(
          metricName: json_.containsKey('metricName')
              ? json_['metricName'] as core.String
              : null,
          target:
              json_.containsKey('target') ? json_['target'] as core.int : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metricName != null) 'metricName': metricName!,
        if (target != null) 'target': target!,
      };
}

/// The storage details for Avro input content.
class GoogleCloudAiplatformV1AvroSource {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  GoogleCloudAiplatformV1AvroSource({
    this.gcsSource,
  });

  GoogleCloudAiplatformV1AvroSource.fromJson(core.Map json_)
      : this(
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsSource != null) 'gcsSource': gcsSource!,
      };
}

/// Request message for FeaturestoreService.BatchCreateFeatures.
class GoogleCloudAiplatformV1BatchCreateFeaturesRequest {
  /// The request message specifying the Features to create.
  ///
  /// All Features must be created under the same parent EntityType. The
  /// `parent` field in each child request message can be omitted. If `parent`
  /// is set in a child request, then the value must match the `parent` value in
  /// this request message.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1CreateFeatureRequest>? requests;

  GoogleCloudAiplatformV1BatchCreateFeaturesRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1BatchCreateFeaturesRequest.fromJson(core.Map json_)
      : this(
          requests: json_.containsKey('requests')
              ? (json_['requests'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1CreateFeatureRequest.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (requests != null) 'requests': requests!,
      };
}

/// Request message for TensorboardService.BatchCreateTensorboardRuns.
class GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest {
  /// The request message specifying the TensorboardRuns to create.
  ///
  /// A maximum of 1000 TensorboardRuns can be created in a batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1CreateTensorboardRunRequest>? requests;

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsRequest.fromJson(
      core.Map json_)
      : this(
          requests: json_.containsKey('requests')
              ? (json_['requests'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1CreateTensorboardRunRequest
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (requests != null) 'requests': requests!,
      };
}

/// Response message for TensorboardService.BatchCreateTensorboardRuns.
class GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse {
  /// The created TensorboardRuns.
  core.List<GoogleCloudAiplatformV1TensorboardRun>? tensorboardRuns;

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse({
    this.tensorboardRuns,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardRunsResponse.fromJson(
      core.Map json_)
      : this(
          tensorboardRuns: json_.containsKey('tensorboardRuns')
              ? (json_['tensorboardRuns'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TensorboardRun.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardRuns != null) 'tensorboardRuns': tensorboardRuns!,
      };
}

/// Request message for TensorboardService.BatchCreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest {
  /// The request message specifying the TensorboardTimeSeries to create.
  ///
  /// A maximum of 1000 TensorboardTimeSeries can be created in a batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest>?
      requests;

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest({
    this.requests,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesRequest.fromJson(
      core.Map json_)
      : this(
          requests: json_.containsKey('requests')
              ? (json_['requests'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (requests != null) 'requests': requests!,
      };
}

/// Response message for TensorboardService.BatchCreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse {
  /// The created TensorboardTimeSeries.
  core.List<GoogleCloudAiplatformV1TensorboardTimeSeries>?
      tensorboardTimeSeries;

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse({
    this.tensorboardTimeSeries,
  });

  GoogleCloudAiplatformV1BatchCreateTensorboardTimeSeriesResponse.fromJson(
      core.Map json_)
      : this(
          tensorboardTimeSeries: json_.containsKey('tensorboardTimeSeries')
              ? (json_['tensorboardTimeSeries'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardTimeSeries != null)
          'tensorboardTimeSeries': tensorboardTimeSeries!,
      };
}

/// A description of resources that are used for performing batch operations,
/// are dedicated to a Model, and need manual configuration.
class GoogleCloudAiplatformV1BatchDedicatedResources {
  /// The specification of a single machine.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The maximum number of machine replicas the batch operation may be scaled
  /// to.
  ///
  /// The default value is 10.
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The number of machine replicas used at the start of the batch operation.
  ///
  /// If not set, Vertex AI decides starting number, not greater than
  /// max_replica_count
  ///
  /// Immutable.
  core.int? startingReplicaCount;

  GoogleCloudAiplatformV1BatchDedicatedResources({
    this.machineSpec,
    this.maxReplicaCount,
    this.startingReplicaCount,
  });

  GoogleCloudAiplatformV1BatchDedicatedResources.fromJson(core.Map json_)
      : this(
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          maxReplicaCount: json_.containsKey('maxReplicaCount')
              ? json_['maxReplicaCount'] as core.int
              : null,
          startingReplicaCount: json_.containsKey('startingReplicaCount')
              ? json_['startingReplicaCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
        if (startingReplicaCount != null)
          'startingReplicaCount': startingReplicaCount!,
      };
}

/// Request message for ModelService.BatchImportEvaluatedAnnotations
class GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest {
  /// Evaluated annotations resource to be imported.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1EvaluatedAnnotation>? evaluatedAnnotations;

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest({
    this.evaluatedAnnotations,
  });

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsRequest.fromJson(
      core.Map json_)
      : this(
          evaluatedAnnotations: json_.containsKey('evaluatedAnnotations')
              ? (json_['evaluatedAnnotations'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1EvaluatedAnnotation.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (evaluatedAnnotations != null)
          'evaluatedAnnotations': evaluatedAnnotations!,
      };
}

/// Response message for ModelService.BatchImportEvaluatedAnnotations
class GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse {
  /// Number of EvaluatedAnnotations imported.
  ///
  /// Output only.
  core.int? importedEvaluatedAnnotationsCount;

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse({
    this.importedEvaluatedAnnotationsCount,
  });

  GoogleCloudAiplatformV1BatchImportEvaluatedAnnotationsResponse.fromJson(
      core.Map json_)
      : this(
          importedEvaluatedAnnotationsCount:
              json_.containsKey('importedEvaluatedAnnotationsCount')
                  ? json_['importedEvaluatedAnnotationsCount'] as core.int
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (importedEvaluatedAnnotationsCount != null)
          'importedEvaluatedAnnotationsCount':
              importedEvaluatedAnnotationsCount!,
      };
}

/// Request message for MigrationService.BatchMigrateResources.
class GoogleCloudAiplatformV1BatchMigrateResourcesRequest {
  /// The request messages specifying the resources to migrate.
  ///
  /// They must be in the same location as the destination. Up to 50 resources
  /// can be migrated in one batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1MigrateResourceRequest>?
      migrateResourceRequests;

  GoogleCloudAiplatformV1BatchMigrateResourcesRequest({
    this.migrateResourceRequests,
  });

  GoogleCloudAiplatformV1BatchMigrateResourcesRequest.fromJson(core.Map json_)
      : this(
          migrateResourceRequests: json_.containsKey('migrateResourceRequests')
              ? (json_['migrateResourceRequests'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1MigrateResourceRequest.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (migrateResourceRequests != null)
          'migrateResourceRequests': migrateResourceRequests!,
      };
}

/// A job that uses a Model to produce predictions on multiple input instances.
///
/// If predictions for significant portion of the instances fail, the job may
/// finish without attempting predictions for all remaining instances.
class GoogleCloudAiplatformV1BatchPredictionJob {
  /// Statistics on completed and failed prediction instances.
  ///
  /// Output only.
  GoogleCloudAiplatformV1CompletionStats? completionStats;

  /// Time when the BatchPredictionJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The config of resources used by the Model during the batch prediction.
  ///
  /// If the Model supports DEDICATED_RESOURCES this config may be provided (and
  /// the job will use these resources), if the Model doesn't support
  /// AUTOMATIC_RESOURCES, this config must be provided.
  GoogleCloudAiplatformV1BatchDedicatedResources? dedicatedResources;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to Cloud
  /// Logging by default.
  ///
  /// Please note that the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging/pricing). User
  /// can disable container logging by setting this flag to true.
  core.bool? disableContainerLogging;

  /// The user-defined name of this BatchPredictionJob.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a BatchPredictionJob.
  ///
  /// If this is set, then all resources created by the BatchPredictionJob will
  /// be encrypted with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the BatchPredictionJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when the job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Explanation configuration for this BatchPredictionJob.
  ///
  /// Can be specified only if generate_explanation is set to `true`. This value
  /// overrides the value of Model.explanation_spec. All fields of
  /// explanation_spec are optional in the request. If a field of the
  /// explanation_spec object is not populated, the corresponding field of the
  /// Model.explanation_spec object is inherited.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// Generate explanation with the batch prediction results.
  ///
  /// When set to `true`, the batch prediction output changes based on the
  /// `predictions_format` field of the BatchPredictionJob.output_config object:
  /// * `bigquery`: output includes a column named `explanation`. The value is a
  /// struct that conforms to the Explanation object. * `jsonl`: The JSON
  /// objects on each line include an additional entry keyed `explanation`. The
  /// value of the entry is a JSON object that conforms to the Explanation
  /// object. * `csv`: Generating explanations for CSV format is not supported.
  /// If this field is set to true, either the Model.explanation_spec or
  /// explanation_spec must be populated.
  core.bool? generateExplanation;

  /// Input configuration of the instances on which predictions are performed.
  ///
  /// The schema of any single instance may be specified via the Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  GoogleCloudAiplatformV1BatchPredictionJobInputConfig? inputConfig;

  /// Configuration for how to convert batch prediction input instances to the
  /// prediction instances that are sent to the Model.
  GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig? instanceConfig;

  /// The labels with user-defined metadata to organize BatchPredictionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Parameters configuring the batch behavior.
  ///
  /// Currently only applicable when dedicated_resources are used (in other
  /// cases Vertex AI does the tuning itself).
  ///
  /// Immutable.
  GoogleCloudAiplatformV1ManualBatchTuningParameters?
      manualBatchTuningParameters;

  /// The name of the Model resource that produces the predictions via this job,
  /// must share the same ancestor Location.
  ///
  /// Starting this job has no impact on any existing deployments of the Model
  /// and their resources. Exactly one of model and unmanaged_container_model
  /// must be set. The model resource name may contain version id or version
  /// alias to specify the version. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` if no
  /// version is specified, the default version will be deployed. The model
  /// resource could also be a publisher model. Example:
  /// `publishers/{publisher}/models/{model}` or
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  core.String? model;

  /// The parameters that govern the predictions.
  ///
  /// The schema of the parameters may be specified via the Model's
  /// PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? modelParameters;

  /// The version ID of the Model that produces the predictions via this job.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// Resource name of the BatchPredictionJob.
  ///
  /// Output only.
  core.String? name;

  /// The Configuration specifying where output predictions should be written.
  ///
  /// The schema of any single prediction may be specified as a concatenation of
  /// Model's PredictSchemata's instance_schema_uri and prediction_schema_uri.
  ///
  /// Required.
  GoogleCloudAiplatformV1BatchPredictionJobOutputConfig? outputConfig;

  /// Information further describing the output of this job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1BatchPredictionJobOutputInfo? outputInfo;

  /// Partial failures encountered.
  ///
  /// For example, single files that can't be read. This field never exceeds 20
  /// entries. Status details fields contain standard Google Cloud error
  /// details.
  ///
  /// Output only.
  core.List<GoogleRpcStatus>? partialFailures;

  /// Information about resources that had been consumed by this job.
  ///
  /// Provided in real time at best effort basis, as well as a final value once
  /// the job completes. Note: This field currently may be not populated for
  /// batch predictions that use AutoML Models.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ResourcesConsumed? resourcesConsumed;

  /// The service account that the DeployedModel's container runs as.
  ///
  /// If not specified, a system generated one will be used, which has minimal
  /// permissions and the custom container, if used, may not have enough
  /// permission to access other Google Cloud resources. Users deploying the
  /// Model must have the `iam.serviceAccounts.actAs` permission on this service
  /// account.
  core.String? serviceAccount;

  /// Time when the BatchPredictionJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Contains model information necessary to perform batch prediction without
  /// requiring uploading to model registry.
  ///
  /// Exactly one of model and unmanaged_container_model must be set.
  GoogleCloudAiplatformV1UnmanagedContainerModel? unmanagedContainerModel;

  /// Time when the BatchPredictionJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1BatchPredictionJob({
    this.completionStats,
    this.createTime,
    this.dedicatedResources,
    this.disableContainerLogging,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.explanationSpec,
    this.generateExplanation,
    this.inputConfig,
    this.instanceConfig,
    this.labels,
    this.manualBatchTuningParameters,
    this.model,
    this.modelParameters,
    this.modelVersionId,
    this.name,
    this.outputConfig,
    this.outputInfo,
    this.partialFailures,
    this.resourcesConsumed,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.unmanagedContainerModel,
    this.updateTime,
  });

  GoogleCloudAiplatformV1BatchPredictionJob.fromJson(core.Map json_)
      : this(
          completionStats: json_.containsKey('completionStats')
              ? GoogleCloudAiplatformV1CompletionStats.fromJson(
                  json_['completionStats']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1BatchDedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          disableContainerLogging: json_.containsKey('disableContainerLogging')
              ? json_['disableContainerLogging'] as core.bool
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          generateExplanation: json_.containsKey('generateExplanation')
              ? json_['generateExplanation'] as core.bool
              : null,
          inputConfig: json_.containsKey('inputConfig')
              ? GoogleCloudAiplatformV1BatchPredictionJobInputConfig.fromJson(
                  json_['inputConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          instanceConfig: json_.containsKey('instanceConfig')
              ? GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig
                  .fromJson(json_['instanceConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          manualBatchTuningParameters:
              json_.containsKey('manualBatchTuningParameters')
                  ? GoogleCloudAiplatformV1ManualBatchTuningParameters.fromJson(
                      json_['manualBatchTuningParameters']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          model:
              json_.containsKey('model') ? json_['model'] as core.String : null,
          modelParameters: json_.containsKey('modelParameters')
              ? json_['modelParameters']
              : null,
          modelVersionId: json_.containsKey('modelVersionId')
              ? json_['modelVersionId'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          outputConfig: json_.containsKey('outputConfig')
              ? GoogleCloudAiplatformV1BatchPredictionJobOutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          outputInfo: json_.containsKey('outputInfo')
              ? GoogleCloudAiplatformV1BatchPredictionJobOutputInfo.fromJson(
                  json_['outputInfo'] as core.Map<core.String, core.dynamic>)
              : null,
          partialFailures: json_.containsKey('partialFailures')
              ? (json_['partialFailures'] as core.List)
                  .map((value) => GoogleRpcStatus.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          resourcesConsumed: json_.containsKey('resourcesConsumed')
              ? GoogleCloudAiplatformV1ResourcesConsumed.fromJson(
                  json_['resourcesConsumed']
                      as core.Map<core.String, core.dynamic>)
              : null,
          serviceAccount: json_.containsKey('serviceAccount')
              ? json_['serviceAccount'] as core.String
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          unmanagedContainerModel: json_.containsKey('unmanagedContainerModel')
              ? GoogleCloudAiplatformV1UnmanagedContainerModel.fromJson(
                  json_['unmanagedContainerModel']
                      as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (completionStats != null) 'completionStats': completionStats!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (disableContainerLogging != null)
          'disableContainerLogging': disableContainerLogging!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (generateExplanation != null)
          'generateExplanation': generateExplanation!,
        if (inputConfig != null) 'inputConfig': inputConfig!,
        if (instanceConfig != null) 'instanceConfig': instanceConfig!,
        if (labels != null) 'labels': labels!,
        if (manualBatchTuningParameters != null)
          'manualBatchTuningParameters': manualBatchTuningParameters!,
        if (model != null) 'model': model!,
        if (modelParameters != null) 'modelParameters': modelParameters!,
        if (modelVersionId != null) 'modelVersionId': modelVersionId!,
        if (name != null) 'name': name!,
        if (outputConfig != null) 'outputConfig': outputConfig!,
        if (outputInfo != null) 'outputInfo': outputInfo!,
        if (partialFailures != null) 'partialFailures': partialFailures!,
        if (resourcesConsumed != null) 'resourcesConsumed': resourcesConsumed!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (unmanagedContainerModel != null)
          'unmanagedContainerModel': unmanagedContainerModel!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Configures the input to BatchPredictionJob.
///
/// See Model.supported_input_storage_formats for Model's supported input
/// formats, and how instances should be expressed via any of them.
class GoogleCloudAiplatformV1BatchPredictionJobInputConfig {
  /// The BigQuery location of the input table.
  ///
  /// The schema of the table should be in the format described by the given
  /// context OpenAPI Schema, if one is provided. The table may contain
  /// additional columns that are not described by the schema, and they will be
  /// ignored.
  GoogleCloudAiplatformV1BigQuerySource? bigquerySource;

  /// The Cloud Storage location for the input instances.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// The format in which instances are given, must be one of the Model's
  /// supported_input_storage_formats.
  ///
  /// Required.
  core.String? instancesFormat;

  GoogleCloudAiplatformV1BatchPredictionJobInputConfig({
    this.bigquerySource,
    this.gcsSource,
    this.instancesFormat,
  });

  GoogleCloudAiplatformV1BatchPredictionJobInputConfig.fromJson(core.Map json_)
      : this(
          bigquerySource: json_.containsKey('bigquerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          instancesFormat: json_.containsKey('instancesFormat')
              ? json_['instancesFormat'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigquerySource != null) 'bigquerySource': bigquerySource!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (instancesFormat != null) 'instancesFormat': instancesFormat!,
      };
}

/// Configuration defining how to transform batch prediction input instances to
/// the instances that the Model accepts.
class GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig {
  /// Fields that will be excluded in the prediction instance that is sent to
  /// the Model.
  ///
  /// Excluded will be attached to the batch prediction output if key_field is
  /// not specified. When excluded_fields is populated, included_fields must be
  /// empty. The input must be JSONL with objects at each line, CSV, BigQuery or
  /// TfRecord.
  core.List<core.String>? excludedFields;

  /// Fields that will be included in the prediction instance that is sent to
  /// the Model.
  ///
  /// If instance_type is `array`, the order of field names in included_fields
  /// also determines the order of the values in the array. When included_fields
  /// is populated, excluded_fields must be empty. The input must be JSONL with
  /// objects at each line, CSV, BigQuery or TfRecord.
  core.List<core.String>? includedFields;

  /// The format of the instance that the Model accepts.
  ///
  /// Vertex AI will convert compatible batch prediction input instance formats
  /// to the specified format. Supported values are: * `object`: Each input is
  /// converted to JSON object format. * For `bigquery`, each row is converted
  /// to an object. * For `jsonl`, each line of the JSONL input must be an
  /// object. * Does not apply to `csv`, `file-list`, `tf-record`, or
  /// `tf-record-gzip`. * `array`: Each input is converted to JSON array format.
  /// * For `bigquery`, each row is converted to an array. The order of columns
  /// is determined by the BigQuery column order, unless included_fields is
  /// populated. included_fields must be populated for specifying field orders.
  /// * For `jsonl`, if each line of the JSONL input is an object,
  /// included_fields must be populated for specifying field orders. * Does not
  /// apply to `csv`, `file-list`, `tf-record`, or `tf-record-gzip`. If not
  /// specified, Vertex AI converts the batch prediction input as follows: * For
  /// `bigquery` and `csv`, the behavior is the same as `array`. The order of
  /// columns is the same as defined in the file or table, unless
  /// included_fields is populated. * For `jsonl`, the prediction instance
  /// format is determined by each line of the input. * For
  /// `tf-record`/`tf-record-gzip`, each record will be converted to an object
  /// in the format of `{"b64": }`, where `` is the Base64-encoded string of the
  /// content of the record. * For `file-list`, each file in the list will be
  /// converted to an object in the format of `{"b64": }`, where `` is the
  /// Base64-encoded string of the content of the file.
  core.String? instanceType;

  /// The name of the field that is considered as a key.
  ///
  /// The values identified by the key field is not included in the transformed
  /// instances that is sent to the Model. This is similar to specifying this
  /// name of the field in excluded_fields. In addition, the batch prediction
  /// output will not include the instances. Instead the output will only
  /// include the value of the key field, in a field named `key` in the output:
  /// * For `jsonl` output format, the output will have a `key` field instead of
  /// the `instance` field. * For `csv`/`bigquery` output format, the output
  /// will have have a `key` column instead of the instance feature columns. The
  /// input must be JSONL with objects at each line, CSV, BigQuery or TfRecord.
  core.String? keyField;

  GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig({
    this.excludedFields,
    this.includedFields,
    this.instanceType,
    this.keyField,
  });

  GoogleCloudAiplatformV1BatchPredictionJobInstanceConfig.fromJson(
      core.Map json_)
      : this(
          excludedFields: json_.containsKey('excludedFields')
              ? (json_['excludedFields'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          includedFields: json_.containsKey('includedFields')
              ? (json_['includedFields'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          instanceType: json_.containsKey('instanceType')
              ? json_['instanceType'] as core.String
              : null,
          keyField: json_.containsKey('keyField')
              ? json_['keyField'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (excludedFields != null) 'excludedFields': excludedFields!,
        if (includedFields != null) 'includedFields': includedFields!,
        if (instanceType != null) 'instanceType': instanceType!,
        if (keyField != null) 'keyField': keyField!,
      };
}

/// Configures the output of BatchPredictionJob.
///
/// See Model.supported_output_storage_formats for supported output formats, and
/// how predictions are expressed via any of them.
class GoogleCloudAiplatformV1BatchPredictionJobOutputConfig {
  /// The BigQuery project or dataset location where the output is to be written
  /// to.
  ///
  /// If project is provided, a new dataset is created with name `prediction__`
  /// where is made BigQuery-dataset-name compatible (for example, most special
  /// characters become underscores), and timestamp is in
  /// YYYY_MM_DDThh_mm_ss_sssZ "based on ISO-8601" format. In the dataset two
  /// tables will be created, `predictions`, and `errors`. If the Model has both
  /// instance and prediction schemata defined then the tables have columns as
  /// follows: The `predictions` table contains instances for which the
  /// prediction succeeded, it has columns as per a concatenation of the Model's
  /// instance and prediction schemata. The `errors` table contains rows for
  /// which the prediction has failed, it has instance columns, as per the
  /// instance schema, followed by a single "errors" column, which as values has
  /// google.rpc.Status represented as a STRUCT, and containing only `code` and
  /// `message`.
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// The Cloud Storage location of the directory where the output is to be
  /// written to.
  ///
  /// In the given directory a new directory is created. Its name is
  /// `prediction--`, where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601
  /// format. Inside of it files `predictions_0001.`, `predictions_0002.`, ...,
  /// `predictions_N.` are created where `` depends on chosen
  /// predictions_format, and N may equal 0001 and depends on the total number
  /// of successfully predicted instances. If the Model has both instance and
  /// prediction schemata defined then each such file contains predictions as
  /// per the predictions_format. If prediction for any instance failed
  /// (partially or completely), then an additional `errors_0001.`,
  /// `errors_0002.`,..., `errors_N.` files are created (N depends on total
  /// number of failed predictions). These files contain the failed instances,
  /// as per their schema, followed by an additional `error` field which as
  /// value has google.rpc.Status containing only `code` and `message` fields.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  /// The format in which Vertex AI gives the predictions, must be one of the
  /// Model's supported_output_storage_formats.
  ///
  /// Required.
  core.String? predictionsFormat;

  GoogleCloudAiplatformV1BatchPredictionJobOutputConfig({
    this.bigqueryDestination,
    this.gcsDestination,
    this.predictionsFormat,
  });

  GoogleCloudAiplatformV1BatchPredictionJobOutputConfig.fromJson(core.Map json_)
      : this(
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          predictionsFormat: json_.containsKey('predictionsFormat')
              ? json_['predictionsFormat'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
        if (predictionsFormat != null) 'predictionsFormat': predictionsFormat!,
      };
}

/// Further describes this job's output.
///
/// Supplements output_config.
class GoogleCloudAiplatformV1BatchPredictionJobOutputInfo {
  /// The path of the BigQuery dataset created, in `bq://projectId.bqDatasetId`
  /// format, into which the prediction output is written.
  ///
  /// Output only.
  core.String? bigqueryOutputDataset;

  /// The name of the BigQuery table created, in `predictions_` format, into
  /// which the prediction output is written.
  ///
  /// Can be used by UI to generate the BigQuery output path, for example.
  ///
  /// Output only.
  core.String? bigqueryOutputTable;

  /// The full path of the Cloud Storage directory created, into which the
  /// prediction output is written.
  ///
  /// Output only.
  core.String? gcsOutputDirectory;

  GoogleCloudAiplatformV1BatchPredictionJobOutputInfo({
    this.bigqueryOutputDataset,
    this.bigqueryOutputTable,
    this.gcsOutputDirectory,
  });

  GoogleCloudAiplatformV1BatchPredictionJobOutputInfo.fromJson(core.Map json_)
      : this(
          bigqueryOutputDataset: json_.containsKey('bigqueryOutputDataset')
              ? json_['bigqueryOutputDataset'] as core.String
              : null,
          bigqueryOutputTable: json_.containsKey('bigqueryOutputTable')
              ? json_['bigqueryOutputTable'] as core.String
              : null,
          gcsOutputDirectory: json_.containsKey('gcsOutputDirectory')
              ? json_['gcsOutputDirectory'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryOutputDataset != null)
          'bigqueryOutputDataset': bigqueryOutputDataset!,
        if (bigqueryOutputTable != null)
          'bigqueryOutputTable': bigqueryOutputTable!,
        if (gcsOutputDirectory != null)
          'gcsOutputDirectory': gcsOutputDirectory!,
      };
}

/// Request message for FeaturestoreService.BatchReadFeatureValues.
class GoogleCloudAiplatformV1BatchReadFeatureValuesRequest {
  /// Similar to csv_read_instances, but from BigQuery source.
  GoogleCloudAiplatformV1BigQuerySource? bigqueryReadInstances;

  /// Each read instance consists of exactly one read timestamp and one or more
  /// entity IDs identifying entities of the corresponding EntityTypes whose
  /// Features are requested.
  ///
  /// Each output instance contains Feature values of requested entities
  /// concatenated together as of the read time. An example read instance may be
  /// `foo_entity_id, bar_entity_id, 2020-01-01T10:00:00.123Z`. An example
  /// output instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
  /// bar_entity_feature2_value`. Timestamp in each read instance must be
  /// millisecond-aligned. `csv_read_instances` are read instances stored in a
  /// plain-text CSV file. The header should be: \[ENTITY_TYPE_ID1\],
  /// \[ENTITY_TYPE_ID2\], ..., timestamp The columns can be in any order.
  /// Values in the timestamp column must use the RFC 3339 format, e.g.
  /// `2012-07-30T10:43:17.123Z`.
  GoogleCloudAiplatformV1CsvSource? csvReadInstances;

  /// Specifies output location and format.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureValueDestination? destination;

  /// Specifies EntityType grouping Features to read values of and settings.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec>?
      entityTypeSpecs;

  /// When not empty, the specified fields in the *_read_instances source will
  /// be joined as-is in the output, in addition to those fields from the
  /// Featurestore Entity.
  ///
  /// For BigQuery source, the type of the pass-through values will be
  /// automatically inferred. For CSV source, the pass-through values will be
  /// passed as opaque bytes.
  core.List<
          GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField>?
      passThroughFields;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  ///
  /// Optional.
  core.String? startTime;

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequest({
    this.bigqueryReadInstances,
    this.csvReadInstances,
    this.destination,
    this.entityTypeSpecs,
    this.passThroughFields,
    this.startTime,
  });

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          bigqueryReadInstances: json_.containsKey('bigqueryReadInstances')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigqueryReadInstances']
                      as core.Map<core.String, core.dynamic>)
              : null,
          csvReadInstances: json_.containsKey('csvReadInstances')
              ? GoogleCloudAiplatformV1CsvSource.fromJson(
                  json_['csvReadInstances']
                      as core.Map<core.String, core.dynamic>)
              : null,
          destination: json_.containsKey('destination')
              ? GoogleCloudAiplatformV1FeatureValueDestination.fromJson(
                  json_['destination'] as core.Map<core.String, core.dynamic>)
              : null,
          entityTypeSpecs: json_.containsKey('entityTypeSpecs')
              ? (json_['entityTypeSpecs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          passThroughFields: json_.containsKey('passThroughFields')
              ? (json_['passThroughFields'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryReadInstances != null)
          'bigqueryReadInstances': bigqueryReadInstances!,
        if (csvReadInstances != null) 'csvReadInstances': csvReadInstances!,
        if (destination != null) 'destination': destination!,
        if (entityTypeSpecs != null) 'entityTypeSpecs': entityTypeSpecs!,
        if (passThroughFields != null) 'passThroughFields': passThroughFields!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Selects Features of an EntityType to read values of and specifies read
/// settings.
class GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec {
  /// ID of the EntityType to select Features.
  ///
  /// The EntityType id is the entity_type_id specified during EntityType
  /// creation.
  ///
  /// Required.
  core.String? entityTypeId;

  /// Selectors choosing which Feature values to read from the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  /// Per-Feature settings for the batch read.
  core.List<GoogleCloudAiplatformV1DestinationFeatureSetting>? settings;

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec({
    this.entityTypeId,
    this.featureSelector,
    this.settings,
  });

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestEntityTypeSpec.fromJson(
      core.Map json_)
      : this(
          entityTypeId: json_.containsKey('entityTypeId')
              ? json_['entityTypeId'] as core.String
              : null,
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
          settings: json_.containsKey('settings')
              ? (json_['settings'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1DestinationFeatureSetting.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityTypeId != null) 'entityTypeId': entityTypeId!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
        if (settings != null) 'settings': settings!,
      };
}

/// Describe pass-through fields in read_instance source.
class GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField {
  /// The name of the field in the CSV header or the name of the column in
  /// BigQuery table.
  ///
  /// The naming restriction is the same as Feature.name.
  ///
  /// Required.
  core.String? fieldName;

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField({
    this.fieldName,
  });

  GoogleCloudAiplatformV1BatchReadFeatureValuesRequestPassThroughField.fromJson(
      core.Map json_)
      : this(
          fieldName: json_.containsKey('fieldName')
              ? json_['fieldName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fieldName != null) 'fieldName': fieldName!,
      };
}

/// Response message for TensorboardService.BatchReadTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse {
  /// The returned time series data.
  core.List<GoogleCloudAiplatformV1TimeSeriesData>? timeSeriesData;

  GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse({
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1BatchReadTensorboardTimeSeriesDataResponse.fromJson(
      core.Map json_)
      : this(
          timeSeriesData: json_.containsKey('timeSeriesData')
              ? (json_['timeSeriesData'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TimeSeriesData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
      };
}

/// The BigQuery location for the output content.
class GoogleCloudAiplatformV1BigQueryDestination {
  /// BigQuery URI to a project or table, up to 2000 characters long.
  ///
  /// When only the project is specified, the Dataset and Table is created. When
  /// the full table reference is specified, the Dataset must exist and table
  /// must not exist. Accepted forms: * BigQuery path. For example:
  /// `bq://projectId` or `bq://projectId.bqDatasetId` or
  /// `bq://projectId.bqDatasetId.bqTableId`.
  ///
  /// Required.
  core.String? outputUri;

  GoogleCloudAiplatformV1BigQueryDestination({
    this.outputUri,
  });

  GoogleCloudAiplatformV1BigQueryDestination.fromJson(core.Map json_)
      : this(
          outputUri: json_.containsKey('outputUri')
              ? json_['outputUri'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputUri != null) 'outputUri': outputUri!,
      };
}

/// The BigQuery location for the input content.
class GoogleCloudAiplatformV1BigQuerySource {
  /// BigQuery URI to a table, up to 2000 characters long.
  ///
  /// Accepted forms: * BigQuery path. For example:
  /// `bq://projectId.bqDatasetId.bqTableId`.
  ///
  /// Required.
  core.String? inputUri;

  GoogleCloudAiplatformV1BigQuerySource({
    this.inputUri,
  });

  GoogleCloudAiplatformV1BigQuerySource.fromJson(core.Map json_)
      : this(
          inputUri: json_.containsKey('inputUri')
              ? json_['inputUri'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputUri != null) 'inputUri': inputUri!,
      };
}

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// https://arxiv.org/abs/2004.03383
class GoogleCloudAiplatformV1BlurBaselineConfig {
  /// The standard deviation of the blur kernel for the blurred baseline.
  ///
  /// The same blurring parameter is used for both the height and the width
  /// dimension. If not set, the method defaults to the zero (i.e. black for
  /// images) baseline.
  core.double? maxBlurSigma;

  GoogleCloudAiplatformV1BlurBaselineConfig({
    this.maxBlurSigma,
  });

  GoogleCloudAiplatformV1BlurBaselineConfig.fromJson(core.Map json_)
      : this(
          maxBlurSigma: json_.containsKey('maxBlurSigma')
              ? (json_['maxBlurSigma'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxBlurSigma != null) 'maxBlurSigma': maxBlurSigma!,
      };
}

/// A list of boolean values.
class GoogleCloudAiplatformV1BoolArray {
  /// A list of bool values.
  core.List<core.bool>? values;

  GoogleCloudAiplatformV1BoolArray({
    this.values,
  });

  GoogleCloudAiplatformV1BoolArray.fromJson(core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => value as core.bool)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Request message for JobService.CancelBatchPredictionJob.
typedef GoogleCloudAiplatformV1CancelBatchPredictionJobRequest = $Empty;

/// Request message for JobService.CancelCustomJob.
typedef GoogleCloudAiplatformV1CancelCustomJobRequest = $Empty;

/// Request message for JobService.CancelDataLabelingJob.
typedef GoogleCloudAiplatformV1CancelDataLabelingJobRequest = $Empty;

/// Request message for JobService.CancelHyperparameterTuningJob.
typedef GoogleCloudAiplatformV1CancelHyperparameterTuningJobRequest = $Empty;

/// Request message for JobService.CancelNasJob.
typedef GoogleCloudAiplatformV1CancelNasJobRequest = $Empty;

/// Request message for PipelineService.CancelPipelineJob.
typedef GoogleCloudAiplatformV1CancelPipelineJobRequest = $Empty;

/// Request message for PipelineService.CancelTrainingPipeline.
typedef GoogleCloudAiplatformV1CancelTrainingPipelineRequest = $Empty;

/// Request message for VizierService.CheckTrialEarlyStoppingState.
typedef GoogleCloudAiplatformV1CheckTrialEarlyStoppingStateRequest = $Empty;

/// Request message for VizierService.CompleteTrial.
class GoogleCloudAiplatformV1CompleteTrialRequest {
  /// If provided, it will be used as the completed Trial's final_measurement;
  /// Otherwise, the service will auto-select a previously reported measurement
  /// as the final-measurement
  ///
  /// Optional.
  GoogleCloudAiplatformV1Measurement? finalMeasurement;

  /// A human readable reason why the trial was infeasible.
  ///
  /// This should only be provided if `trial_infeasible` is true.
  ///
  /// Optional.
  core.String? infeasibleReason;

  /// True if the Trial cannot be run with the given Parameter, and
  /// final_measurement will be ignored.
  ///
  /// Optional.
  core.bool? trialInfeasible;

  GoogleCloudAiplatformV1CompleteTrialRequest({
    this.finalMeasurement,
    this.infeasibleReason,
    this.trialInfeasible,
  });

  GoogleCloudAiplatformV1CompleteTrialRequest.fromJson(core.Map json_)
      : this(
          finalMeasurement: json_.containsKey('finalMeasurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>)
              : null,
          infeasibleReason: json_.containsKey('infeasibleReason')
              ? json_['infeasibleReason'] as core.String
              : null,
          trialInfeasible: json_.containsKey('trialInfeasible')
              ? json_['trialInfeasible'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
        if (infeasibleReason != null) 'infeasibleReason': infeasibleReason!,
        if (trialInfeasible != null) 'trialInfeasible': trialInfeasible!,
      };
}

/// Success and error statistics of processing multiple entities (for example,
/// DataItems or structured data rows) in batch.
class GoogleCloudAiplatformV1CompletionStats {
  /// The number of entities for which any error was encountered.
  ///
  /// Output only.
  core.String? failedCount;

  /// In cases when enough errors are encountered a job, pipeline, or operation
  /// may be failed as a whole.
  ///
  /// Below is the number of entities for which the processing had not been
  /// finished (either in successful or failed state). Set to -1 if the number
  /// is unknown (for example, the operation failed before the total entity
  /// number could be collected).
  ///
  /// Output only.
  core.String? incompleteCount;

  /// The number of entities that had been processed successfully.
  ///
  /// Output only.
  core.String? successfulCount;

  /// The number of the successful forecast points that are generated by the
  /// forecasting model.
  ///
  /// This is ONLY used by the forecasting batch prediction.
  ///
  /// Output only.
  core.String? successfulForecastPointCount;

  GoogleCloudAiplatformV1CompletionStats({
    this.failedCount,
    this.incompleteCount,
    this.successfulCount,
    this.successfulForecastPointCount,
  });

  GoogleCloudAiplatformV1CompletionStats.fromJson(core.Map json_)
      : this(
          failedCount: json_.containsKey('failedCount')
              ? json_['failedCount'] as core.String
              : null,
          incompleteCount: json_.containsKey('incompleteCount')
              ? json_['incompleteCount'] as core.String
              : null,
          successfulCount: json_.containsKey('successfulCount')
              ? json_['successfulCount'] as core.String
              : null,
          successfulForecastPointCount:
              json_.containsKey('successfulForecastPointCount')
                  ? json_['successfulForecastPointCount'] as core.String
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failedCount != null) 'failedCount': failedCount!,
        if (incompleteCount != null) 'incompleteCount': incompleteCount!,
        if (successfulCount != null) 'successfulCount': successfulCount!,
        if (successfulForecastPointCount != null)
          'successfulForecastPointCount': successfulForecastPointCount!,
      };
}

/// The Container Registry location for the container image.
class GoogleCloudAiplatformV1ContainerRegistryDestination {
  /// Container Registry URI of a container image.
  ///
  /// Only Google Container Registry and Artifact Registry are supported now.
  /// Accepted forms: * Google Container Registry path. For example:
  /// `gcr.io/projectId/imageName:tag`. * Artifact Registry path. For example:
  /// `us-central1-docker.pkg.dev/projectId/repoName/imageName:tag`. If a tag is
  /// not specified, "latest" will be used as the default tag.
  ///
  /// Required.
  core.String? outputUri;

  GoogleCloudAiplatformV1ContainerRegistryDestination({
    this.outputUri,
  });

  GoogleCloudAiplatformV1ContainerRegistryDestination.fromJson(core.Map json_)
      : this(
          outputUri: json_.containsKey('outputUri')
              ? json_['outputUri'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputUri != null) 'outputUri': outputUri!,
      };
}

/// The spec of a Container.
class GoogleCloudAiplatformV1ContainerSpec {
  /// The arguments to be passed when starting the container.
  core.List<core.String>? args;

  /// The command to be invoked when the container is started.
  ///
  /// It overrides the entrypoint instruction in Dockerfile when provided.
  core.List<core.String>? command;

  /// Environment variables to be passed to the container.
  ///
  /// Maximum limit is 100.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// The URI of a container image in the Container Registry that is to be run
  /// on each worker replica.
  ///
  /// Required.
  core.String? imageUri;

  GoogleCloudAiplatformV1ContainerSpec({
    this.args,
    this.command,
    this.env,
    this.imageUri,
  });

  GoogleCloudAiplatformV1ContainerSpec.fromJson(core.Map json_)
      : this(
          args: json_.containsKey('args')
              ? (json_['args'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          command: json_.containsKey('command')
              ? (json_['command'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          env: json_.containsKey('env')
              ? (json_['env'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          imageUri: json_.containsKey('imageUri')
              ? json_['imageUri'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (args != null) 'args': args!,
        if (command != null) 'command': command!,
        if (env != null) 'env': env!,
        if (imageUri != null) 'imageUri': imageUri!,
      };
}

/// Instance of a general context.
class GoogleCloudAiplatformV1Context {
  /// Timestamp when this Context was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Context
  core.String? description;

  /// User provided display name of the Context.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Contexts.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Context (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Context.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Context.
  ///
  /// Immutable.
  core.String? name;

  /// A list of resource names of Contexts that are parents of this Context.
  ///
  /// A Context may have at most 10 parent_contexts.
  ///
  /// Output only.
  core.List<core.String>? parentContexts;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// Timestamp when this Context was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Context({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.parentContexts,
    this.schemaTitle,
    this.schemaVersion,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Context.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          parentContexts: json_.containsKey('parentContexts')
              ? (json_['parentContexts'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          schemaTitle: json_.containsKey('schemaTitle')
              ? json_['schemaTitle'] as core.String
              : null,
          schemaVersion: json_.containsKey('schemaVersion')
              ? json_['schemaVersion'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (parentContexts != null) 'parentContexts': parentContexts!,
        if (schemaTitle != null) 'schemaTitle': schemaTitle!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Request message for ModelService.CopyModel.
class GoogleCloudAiplatformV1CopyModelRequest {
  /// Customer-managed encryption key options.
  ///
  /// If this is set, then the Model copy will be encrypted with the provided
  /// encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Copy source_model into a new Model with this ID.
  ///
  /// The ID will become the final component of the model resource name. This
  /// value may be up to 63 characters, and valid characters are `[a-z0-9_-]`.
  /// The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// Specify this field to copy source_model into this existing Model as a new
  /// version.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Optional.
  core.String? parentModel;

  /// The resource name of the Model to copy.
  ///
  /// That Model must be in the same Project. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  ///
  /// Required.
  core.String? sourceModel;

  GoogleCloudAiplatformV1CopyModelRequest({
    this.encryptionSpec,
    this.modelId,
    this.parentModel,
    this.sourceModel,
  });

  GoogleCloudAiplatformV1CopyModelRequest.fromJson(core.Map json_)
      : this(
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelId: json_.containsKey('modelId')
              ? json_['modelId'] as core.String
              : null,
          parentModel: json_.containsKey('parentModel')
              ? json_['parentModel'] as core.String
              : null,
          sourceModel: json_.containsKey('sourceModel')
              ? json_['sourceModel'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (modelId != null) 'modelId': modelId!,
        if (parentModel != null) 'parentModel': parentModel!,
        if (sourceModel != null) 'sourceModel': sourceModel!,
      };
}

/// Request message for FeaturestoreService.CreateFeature.
///
/// Request message for FeatureRegistryService.CreateFeature.
class GoogleCloudAiplatformV1CreateFeatureRequest {
  /// The Feature to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1Feature? feature;

  /// The ID to use for the Feature, which will become the final component of
  /// the Feature's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number. The value must be
  /// unique within an EntityType/FeatureGroup.
  ///
  /// Required.
  core.String? featureId;

  /// The resource name of the EntityType or FeatureGroup to create a Feature.
  ///
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  ///
  /// Required.
  core.String? parent;

  GoogleCloudAiplatformV1CreateFeatureRequest({
    this.feature,
    this.featureId,
    this.parent,
  });

  GoogleCloudAiplatformV1CreateFeatureRequest.fromJson(core.Map json_)
      : this(
          feature: json_.containsKey('feature')
              ? GoogleCloudAiplatformV1Feature.fromJson(
                  json_['feature'] as core.Map<core.String, core.dynamic>)
              : null,
          featureId: json_.containsKey('featureId')
              ? json_['featureId'] as core.String
              : null,
          parent: json_.containsKey('parent')
              ? json_['parent'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (feature != null) 'feature': feature!,
        if (featureId != null) 'featureId': featureId!,
        if (parent != null) 'parent': parent!,
      };
}

/// Request message for PipelineService.CreatePipelineJob.
class GoogleCloudAiplatformV1CreatePipelineJobRequest {
  /// The resource name of the Location to create the PipelineJob in.
  ///
  /// Format: `projects/{project}/locations/{location}`
  ///
  /// Required.
  core.String? parent;

  /// The PipelineJob to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1PipelineJob? pipelineJob;

  /// The ID to use for the PipelineJob, which will become the final component
  /// of the PipelineJob name.
  ///
  /// If not provided, an ID will be automatically generated. This value should
  /// be less than 128 characters, and valid characters are `/a-z-/`.
  core.String? pipelineJobId;

  GoogleCloudAiplatformV1CreatePipelineJobRequest({
    this.parent,
    this.pipelineJob,
    this.pipelineJobId,
  });

  GoogleCloudAiplatformV1CreatePipelineJobRequest.fromJson(core.Map json_)
      : this(
          parent: json_.containsKey('parent')
              ? json_['parent'] as core.String
              : null,
          pipelineJob: json_.containsKey('pipelineJob')
              ? GoogleCloudAiplatformV1PipelineJob.fromJson(
                  json_['pipelineJob'] as core.Map<core.String, core.dynamic>)
              : null,
          pipelineJobId: json_.containsKey('pipelineJobId')
              ? json_['pipelineJobId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parent != null) 'parent': parent!,
        if (pipelineJob != null) 'pipelineJob': pipelineJob!,
        if (pipelineJobId != null) 'pipelineJobId': pipelineJobId!,
      };
}

/// Request message for TensorboardService.CreateTensorboardRun.
class GoogleCloudAiplatformV1CreateTensorboardRunRequest {
  /// The resource name of the TensorboardExperiment to create the
  /// TensorboardRun in.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  ///
  /// Required.
  core.String? parent;

  /// The TensorboardRun to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1TensorboardRun? tensorboardRun;

  /// The ID to use for the Tensorboard run, which becomes the final component
  /// of the Tensorboard run's resource name.
  ///
  /// This value should be 1-128 characters, and valid characters are `/a-z-/`.
  ///
  /// Required.
  core.String? tensorboardRunId;

  GoogleCloudAiplatformV1CreateTensorboardRunRequest({
    this.parent,
    this.tensorboardRun,
    this.tensorboardRunId,
  });

  GoogleCloudAiplatformV1CreateTensorboardRunRequest.fromJson(core.Map json_)
      : this(
          parent: json_.containsKey('parent')
              ? json_['parent'] as core.String
              : null,
          tensorboardRun: json_.containsKey('tensorboardRun')
              ? GoogleCloudAiplatformV1TensorboardRun.fromJson(
                  json_['tensorboardRun']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tensorboardRunId: json_.containsKey('tensorboardRunId')
              ? json_['tensorboardRunId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parent != null) 'parent': parent!,
        if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!,
        if (tensorboardRunId != null) 'tensorboardRunId': tensorboardRunId!,
      };
}

/// Request message for TensorboardService.CreateTensorboardTimeSeries.
class GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest {
  /// The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Required.
  core.String? parent;

  /// The TensorboardTimeSeries to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1TensorboardTimeSeries? tensorboardTimeSeries;

  /// The user specified unique ID to use for the TensorboardTimeSeries, which
  /// becomes the final component of the TensorboardTimeSeries's resource name.
  ///
  /// This value should match "a-z0-9{0, 127}"
  ///
  /// Optional.
  core.String? tensorboardTimeSeriesId;

  GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest({
    this.parent,
    this.tensorboardTimeSeries,
    this.tensorboardTimeSeriesId,
  });

  GoogleCloudAiplatformV1CreateTensorboardTimeSeriesRequest.fromJson(
      core.Map json_)
      : this(
          parent: json_.containsKey('parent')
              ? json_['parent'] as core.String
              : null,
          tensorboardTimeSeries: json_.containsKey('tensorboardTimeSeries')
              ? GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
                  json_['tensorboardTimeSeries']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tensorboardTimeSeriesId: json_.containsKey('tensorboardTimeSeriesId')
              ? json_['tensorboardTimeSeriesId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parent != null) 'parent': parent!,
        if (tensorboardTimeSeries != null)
          'tensorboardTimeSeries': tensorboardTimeSeries!,
        if (tensorboardTimeSeriesId != null)
          'tensorboardTimeSeriesId': tensorboardTimeSeriesId!,
      };
}

/// The storage details for CSV output content.
class GoogleCloudAiplatformV1CsvDestination {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1CsvDestination({
    this.gcsDestination,
  });

  GoogleCloudAiplatformV1CsvDestination.fromJson(core.Map json_)
      : this(
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
      };
}

/// The storage details for CSV input content.
class GoogleCloudAiplatformV1CsvSource {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  GoogleCloudAiplatformV1CsvSource({
    this.gcsSource,
  });

  GoogleCloudAiplatformV1CsvSource.fromJson(core.Map json_)
      : this(
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsSource != null) 'gcsSource': gcsSource!,
      };
}

/// Represents a job that runs custom workloads such as a Docker container or a
/// Python package.
///
/// A CustomJob can have multiple worker pools and each worker pool can have its
/// own machine and input spec. A CustomJob will be cleaned up once the job
/// enters terminal state (failed or succeeded).
class GoogleCloudAiplatformV1CustomJob {
  /// Time when the CustomJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the CustomJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a CustomJob.
  ///
  /// If this is set, then all resources created by the CustomJob will be
  /// encrypted with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the CustomJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Job spec.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? jobSpec;

  /// The labels with user-defined metadata to organize CustomJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of a CustomJob.
  ///
  /// Output only.
  core.String? name;

  /// Time when the CustomJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Time when the CustomJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// URIs for accessing
  /// [interactive shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node).
  ///
  /// Only available if job_spec.enable_web_access is `true`. The keys are names
  /// of each node in the training job; for example, `workerpool0-0` for the
  /// primary node, `workerpool1-0` for the first node in the second worker
  /// pool, and `workerpool1-1` for the second node in the second worker pool.
  /// The values are the URIs for each node's interactive shell.
  ///
  /// Output only.
  core.Map<core.String, core.String>? webAccessUris;

  GoogleCloudAiplatformV1CustomJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.jobSpec,
    this.labels,
    this.name,
    this.startTime,
    this.state,
    this.updateTime,
    this.webAccessUris,
  });

  GoogleCloudAiplatformV1CustomJob.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          jobSpec: json_.containsKey('jobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['jobSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
          webAccessUris: json_.containsKey('webAccessUris')
              ? (json_['webAccessUris'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (jobSpec != null) 'jobSpec': jobSpec!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (webAccessUris != null) 'webAccessUris': webAccessUris!,
      };
}

/// Represents the spec of a CustomJob.
class GoogleCloudAiplatformV1CustomJobSpec {
  /// The Cloud Storage location to store the output of this CustomJob or
  /// HyperparameterTuningJob.
  ///
  /// For HyperparameterTuningJob, the baseOutputDirectory of each child
  /// CustomJob backing a Trial is set to a subdirectory of name id under its
  /// parent HyperparameterTuningJob's baseOutputDirectory. The following Vertex
  /// AI environment variables will be passed to containers or python modules
  /// when this field is set: For CustomJob: * AIP_MODEL_DIR = `/model/` *
  /// AIP_CHECKPOINT_DIR = `/checkpoints/` * AIP_TENSORBOARD_LOG_DIR = `/logs/`
  /// For CustomJob backing a Trial of HyperparameterTuningJob: * AIP_MODEL_DIR
  /// = `//model/` * AIP_CHECKPOINT_DIR = `//checkpoints/` *
  /// AIP_TENSORBOARD_LOG_DIR = `//logs/`
  GoogleCloudAiplatformV1GcsDestination? baseOutputDirectory;

  /// Whether you want Vertex AI to enable access to the customized dashboard in
  /// training chief container.
  ///
  /// If set to `true`, you can access the dashboard at the URIs given by
  /// CustomJob.web_access_uris or Trial.web_access_uris (within
  /// HyperparameterTuningJob.trials).
  ///
  /// Optional.
  core.bool? enableDashboardAccess;

  /// Whether you want Vertex AI to enable
  /// [interactive shell access](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// to training containers.
  ///
  /// If set to `true`, you can access interactive shells at the URIs given by
  /// CustomJob.web_access_uris or Trial.web_access_uris (within
  /// HyperparameterTuningJob.trials).
  ///
  /// Optional.
  core.bool? enableWebAccess;

  /// The Experiment associated with this job.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}`
  ///
  /// Optional.
  core.String? experiment;

  /// The Experiment Run associated with this job.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}-{experiment-run-name}`
  ///
  /// Optional.
  core.String? experimentRun;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to which the
  /// Job should be peered.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. To specify
  /// this field, you must have already
  /// [configured VPC Network Peering for Vertex AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  /// If this field is left unspecified, the job is not peered with any network.
  ///
  /// Optional.
  core.String? network;

  /// The ID of the location to store protected artifacts.
  ///
  /// e.g. us-central1. Populate only when the location is different than
  /// CustomJob location. List of supported locations:
  /// https://cloud.google.com/vertex-ai/docs/general/locations
  core.String? protectedArtifactLocationId;

  /// A list of names for the reserved ip ranges under the VPC network that can
  /// be used for this job.
  ///
  /// If set, we will deploy the job within the provided ip ranges. Otherwise,
  /// the job will be deployed to any ip ranges under the provided VPC network.
  /// Example: \['vertex-ai-ip-range'\].
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  /// Scheduling options for a CustomJob.
  GoogleCloudAiplatformV1Scheduling? scheduling;

  /// Specifies the service account for workload run-as account.
  ///
  /// Users submitting jobs must have act-as permission on this run-as account.
  /// If unspecified, the
  /// [Vertex AI Custom Code Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// for the CustomJob's project is used.
  core.String? serviceAccount;

  /// The name of a Vertex AI Tensorboard resource to which this CustomJob will
  /// upload Tensorboard logs.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  ///
  /// Optional.
  core.String? tensorboard;

  /// The spec of the worker pools including machine type and Docker image.
  ///
  /// All worker pools except the first one are optional and can be skipped by
  /// providing an empty value.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1WorkerPoolSpec>? workerPoolSpecs;

  GoogleCloudAiplatformV1CustomJobSpec({
    this.baseOutputDirectory,
    this.enableDashboardAccess,
    this.enableWebAccess,
    this.experiment,
    this.experimentRun,
    this.network,
    this.protectedArtifactLocationId,
    this.reservedIpRanges,
    this.scheduling,
    this.serviceAccount,
    this.tensorboard,
    this.workerPoolSpecs,
  });

  GoogleCloudAiplatformV1CustomJobSpec.fromJson(core.Map json_)
      : this(
          baseOutputDirectory: json_.containsKey('baseOutputDirectory')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['baseOutputDirectory']
                      as core.Map<core.String, core.dynamic>)
              : null,
          enableDashboardAccess: json_.containsKey('enableDashboardAccess')
              ? json_['enableDashboardAccess'] as core.bool
              : null,
          enableWebAccess: json_.containsKey('enableWebAccess')
              ? json_['enableWebAccess'] as core.bool
              : null,
          experiment: json_.containsKey('experiment')
              ? json_['experiment'] as core.String
              : null,
          experimentRun: json_.containsKey('experimentRun')
              ? json_['experimentRun'] as core.String
              : null,
          network: json_.containsKey('network')
              ? json_['network'] as core.String
              : null,
          protectedArtifactLocationId:
              json_.containsKey('protectedArtifactLocationId')
                  ? json_['protectedArtifactLocationId'] as core.String
                  : null,
          reservedIpRanges: json_.containsKey('reservedIpRanges')
              ? (json_['reservedIpRanges'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          scheduling: json_.containsKey('scheduling')
              ? GoogleCloudAiplatformV1Scheduling.fromJson(
                  json_['scheduling'] as core.Map<core.String, core.dynamic>)
              : null,
          serviceAccount: json_.containsKey('serviceAccount')
              ? json_['serviceAccount'] as core.String
              : null,
          tensorboard: json_.containsKey('tensorboard')
              ? json_['tensorboard'] as core.String
              : null,
          workerPoolSpecs: json_.containsKey('workerPoolSpecs')
              ? (json_['workerPoolSpecs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1WorkerPoolSpec.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (baseOutputDirectory != null)
          'baseOutputDirectory': baseOutputDirectory!,
        if (enableDashboardAccess != null)
          'enableDashboardAccess': enableDashboardAccess!,
        if (enableWebAccess != null) 'enableWebAccess': enableWebAccess!,
        if (experiment != null) 'experiment': experiment!,
        if (experimentRun != null) 'experimentRun': experimentRun!,
        if (network != null) 'network': network!,
        if (protectedArtifactLocationId != null)
          'protectedArtifactLocationId': protectedArtifactLocationId!,
        if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
        if (scheduling != null) 'scheduling': scheduling!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (tensorboard != null) 'tensorboard': tensorboard!,
        if (workerPoolSpecs != null) 'workerPoolSpecs': workerPoolSpecs!,
      };
}

/// A piece of data in a Dataset.
///
/// Could be an image, a video, a document or plain text.
class GoogleCloudAiplatformV1DataItem {
  /// Timestamp when this DataItem was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your DataItems.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one DataItem(System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the DataItem.
  ///
  /// Output only.
  core.String? name;

  /// The data that the DataItem represents (for example, an image or a text
  /// snippet).
  ///
  /// The schema of the payload is stored in the parent Dataset's metadata
  /// schema's dataItemSchemaUri field.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? payload;

  /// Timestamp when this DataItem was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1DataItem({
    this.createTime,
    this.etag,
    this.labels,
    this.name,
    this.payload,
    this.updateTime,
  });

  GoogleCloudAiplatformV1DataItem.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          payload: json_.containsKey('payload') ? json_['payload'] : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (payload != null) 'payload': payload!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A container for a single DataItem and Annotations on it.
class GoogleCloudAiplatformV1DataItemView {
  /// The Annotations on the DataItem.
  ///
  /// If too many Annotations should be returned for the DataItem, this field
  /// will be truncated per annotations_limit in request. If it was, then the
  /// has_truncated_annotations will be set to true.
  core.List<GoogleCloudAiplatformV1Annotation>? annotations;

  /// The DataItem.
  GoogleCloudAiplatformV1DataItem? dataItem;

  /// True if and only if the Annotations field has been truncated.
  ///
  /// It happens if more Annotations for this DataItem met the request's
  /// annotation_filter than are allowed to be returned by annotations_limit.
  /// Note that if Annotations field is not being returned due to field mask,
  /// then this field will not be set to true no matter how many Annotations are
  /// there.
  core.bool? hasTruncatedAnnotations;

  GoogleCloudAiplatformV1DataItemView({
    this.annotations,
    this.dataItem,
    this.hasTruncatedAnnotations,
  });

  GoogleCloudAiplatformV1DataItemView.fromJson(core.Map json_)
      : this(
          annotations: json_.containsKey('annotations')
              ? (json_['annotations'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Annotation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          dataItem: json_.containsKey('dataItem')
              ? GoogleCloudAiplatformV1DataItem.fromJson(
                  json_['dataItem'] as core.Map<core.String, core.dynamic>)
              : null,
          hasTruncatedAnnotations: json_.containsKey('hasTruncatedAnnotations')
              ? json_['hasTruncatedAnnotations'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (dataItem != null) 'dataItem': dataItem!,
        if (hasTruncatedAnnotations != null)
          'hasTruncatedAnnotations': hasTruncatedAnnotations!,
      };
}

/// DataLabelingJob is used to trigger a human labeling job on unlabeled data
/// from the following Dataset:
class GoogleCloudAiplatformV1DataLabelingJob {
  /// Parameters that configure the active learning pipeline.
  ///
  /// Active learning will label the data incrementally via several iterations.
  /// For every iteration, it will select a batch of data based on the sampling
  /// strategy.
  GoogleCloudAiplatformV1ActiveLearningConfig? activeLearningConfig;

  /// Labels to assign to annotations generated by this DataLabelingJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? annotationLabels;

  /// Timestamp when this DataLabelingJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Estimated cost(in US dollars) that the DataLabelingJob has incurred to
  /// date.
  ///
  /// Output only.
  GoogleTypeMoney? currentSpend;

  /// Dataset resource names.
  ///
  /// Right now we only support labeling from a single Dataset. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  ///
  /// Required.
  core.List<core.String>? datasets;

  /// The user-defined name of the DataLabelingJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. Display name of a DataLabelingJob.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a DataLabelingJob.
  ///
  /// If set, this DataLabelingJob will be secured by this key. Note:
  /// Annotations created in the DataLabelingJob are associated with the
  /// EncryptionSpec of the Dataset they are exported to.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// DataLabelingJob errors.
  ///
  /// It is only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Input config parameters for the DataLabelingJob.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? inputs;

  /// Points to a YAML file stored on Google Cloud Storage describing the config
  /// for a specific type of DataLabelingJob.
  ///
  /// The schema files that can be used here are found in the
  /// https://storage.googleapis.com/google-cloud-aiplatform bucket in the
  /// /schema/datalabelingjob/inputs/ folder.
  ///
  /// Required.
  core.String? inputsSchemaUri;

  /// The Google Cloud Storage location of the instruction pdf.
  ///
  /// This pdf is shared with labelers, and provides detailed description on how
  /// to label DataItems in Datasets.
  ///
  /// Required.
  core.String? instructionUri;

  /// Number of labelers to work on each DataItem.
  ///
  /// Required.
  core.int? labelerCount;

  /// Current labeling job progress percentage scaled in interval \[0, 100\],
  /// indicating the percentage of DataItems that has been finished.
  ///
  /// Output only.
  core.int? labelingProgress;

  /// The labels with user-defined metadata to organize your DataLabelingJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable. Following system labels exist for each DataLabelingJob: *
  /// "aiplatform.googleapis.com/schema": output only, its value is the
  /// inputs_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the DataLabelingJob.
  ///
  /// Output only.
  core.String? name;

  /// The SpecialistPools' resource names associated with this job.
  core.List<core.String>? specialistPools;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Timestamp when this DataLabelingJob was updated most recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1DataLabelingJob({
    this.activeLearningConfig,
    this.annotationLabels,
    this.createTime,
    this.currentSpend,
    this.datasets,
    this.displayName,
    this.encryptionSpec,
    this.error,
    this.inputs,
    this.inputsSchemaUri,
    this.instructionUri,
    this.labelerCount,
    this.labelingProgress,
    this.labels,
    this.name,
    this.specialistPools,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1DataLabelingJob.fromJson(core.Map json_)
      : this(
          activeLearningConfig: json_.containsKey('activeLearningConfig')
              ? GoogleCloudAiplatformV1ActiveLearningConfig.fromJson(
                  json_['activeLearningConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          annotationLabels: json_.containsKey('annotationLabels')
              ? (json_['annotationLabels']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          currentSpend: json_.containsKey('currentSpend')
              ? GoogleTypeMoney.fromJson(
                  json_['currentSpend'] as core.Map<core.String, core.dynamic>)
              : null,
          datasets: json_.containsKey('datasets')
              ? (json_['datasets'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          inputs: json_.containsKey('inputs') ? json_['inputs'] : null,
          inputsSchemaUri: json_.containsKey('inputsSchemaUri')
              ? json_['inputsSchemaUri'] as core.String
              : null,
          instructionUri: json_.containsKey('instructionUri')
              ? json_['instructionUri'] as core.String
              : null,
          labelerCount: json_.containsKey('labelerCount')
              ? json_['labelerCount'] as core.int
              : null,
          labelingProgress: json_.containsKey('labelingProgress')
              ? json_['labelingProgress'] as core.int
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          specialistPools: json_.containsKey('specialistPools')
              ? (json_['specialistPools'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (activeLearningConfig != null)
          'activeLearningConfig': activeLearningConfig!,
        if (annotationLabels != null) 'annotationLabels': annotationLabels!,
        if (createTime != null) 'createTime': createTime!,
        if (currentSpend != null) 'currentSpend': currentSpend!,
        if (datasets != null) 'datasets': datasets!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (error != null) 'error': error!,
        if (inputs != null) 'inputs': inputs!,
        if (inputsSchemaUri != null) 'inputsSchemaUri': inputsSchemaUri!,
        if (instructionUri != null) 'instructionUri': instructionUri!,
        if (labelerCount != null) 'labelerCount': labelerCount!,
        if (labelingProgress != null) 'labelingProgress': labelingProgress!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (specialistPools != null) 'specialistPools': specialistPools!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A collection of DataItems and Annotations on them.
class GoogleCloudAiplatformV1Dataset {
  /// Timestamp when this Dataset was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The number of DataItems in this Dataset.
  ///
  /// Only apply for non-structured Dataset.
  ///
  /// Output only.
  core.String? dataItemCount;

  /// The description of the Dataset.
  core.String? description;

  /// The user-defined name of the Dataset.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Dataset.
  ///
  /// If set, this Dataset and all sub-resources of this Dataset will be secured
  /// by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Datasets.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Dataset (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for each Dataset: *
  /// "aiplatform.googleapis.com/dataset_metadata_schema": output only, its
  /// value is the metadata_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Additional information about the Dataset.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Artifact that was created in MetadataStore when
  /// creating the Dataset.
  ///
  /// The Artifact resource name pattern is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  ///
  /// Output only.
  core.String? metadataArtifact;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Dataset.
  ///
  /// The schema is defined as an OpenAPI 3.0.2 Schema Object. The schema files
  /// that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/metadata/.
  ///
  /// Required.
  core.String? metadataSchemaUri;

  /// The resource name of the Dataset.
  ///
  /// Output only.
  core.String? name;

  /// All SavedQueries belong to the Dataset will be returned in List/Get
  /// Dataset response.
  ///
  /// The annotation_specs field will not be populated except for UI cases which
  /// will only use annotation_spec_count. In CreateDataset request, a
  /// SavedQuery is created together if this field is set, up to one SavedQuery
  /// can be set in CreateDatasetRequest. The SavedQuery should not contain any
  /// AnnotationSpec.
  core.List<GoogleCloudAiplatformV1SavedQuery>? savedQueries;

  /// Timestamp when this Dataset was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Dataset({
    this.createTime,
    this.dataItemCount,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.metadata,
    this.metadataArtifact,
    this.metadataSchemaUri,
    this.name,
    this.savedQueries,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Dataset.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          dataItemCount: json_.containsKey('dataItemCount')
              ? json_['dataItemCount'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          metadata: json_.containsKey('metadata') ? json_['metadata'] : null,
          metadataArtifact: json_.containsKey('metadataArtifact')
              ? json_['metadataArtifact'] as core.String
              : null,
          metadataSchemaUri: json_.containsKey('metadataSchemaUri')
              ? json_['metadataSchemaUri'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          savedQueries: json_.containsKey('savedQueries')
              ? (json_['savedQueries'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1SavedQuery.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (dataItemCount != null) 'dataItemCount': dataItemCount!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataArtifact != null) 'metadataArtifact': metadataArtifact!,
        if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
        if (name != null) 'name': name!,
        if (savedQueries != null) 'savedQueries': savedQueries!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Describes the dataset version.
class GoogleCloudAiplatformV1DatasetVersion {
  /// Name of the associated BigQuery dataset.
  ///
  /// Output only.
  core.String? bigQueryDatasetName;

  /// Timestamp when this DatasetVersion was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The resource name of the DatasetVersion.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this DatasetVersion was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1DatasetVersion({
    this.bigQueryDatasetName,
    this.createTime,
    this.etag,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1DatasetVersion.fromJson(core.Map json_)
      : this(
          bigQueryDatasetName: json_.containsKey('bigQueryDatasetName')
              ? json_['bigQueryDatasetName'] as core.String
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigQueryDatasetName != null)
          'bigQueryDatasetName': bigQueryDatasetName!,
        if (createTime != null) 'createTime': createTime!,
        if (etag != null) 'etag': etag!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A description of resources that are dedicated to a DeployedModel, and that
/// need a higher degree of manual configuration.
class GoogleCloudAiplatformV1DedicatedResources {
  /// The metric specifications that overrides a resource utilization metric
  /// (CPU utilization, accelerator's duty cycle, and so on) target value
  /// (default to 60 if not set).
  ///
  /// At most one entry is allowed per metric. If machine_spec.accelerator_count
  /// is above 0, the autoscaling will be based on both CPU utilization and
  /// accelerator's duty cycle metrics and scale up when either metrics exceeds
  /// its target value while scale down if both metrics are under their target
  /// value. The default target value is 60 for both metrics. If
  /// machine_spec.accelerator_count is 0, the autoscaling will be based on CPU
  /// utilization metric only with default target value 60 if not explicitly
  /// set. For example, in the case of Online Prediction, if you want to
  /// override target CPU utilization to 80, you should set
  /// autoscaling_metric_specs.metric_name to
  /// `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
  /// autoscaling_metric_specs.target to `80`.
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1AutoscalingMetricSpec>?
      autoscalingMetricSpecs;

  /// The specification of a single machine used by the prediction.
  ///
  /// Required. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The maximum number of replicas this DeployedModel may be deployed on when
  /// the traffic against it increases.
  ///
  /// If the requested value is too large, the deployment will error, but if
  /// deployment succeeds then the ability to scale the model to that many
  /// replicas is guaranteed (barring service outages). If traffic against the
  /// DeployedModel increases beyond what its replicas at maximum may handle, a
  /// portion of the traffic will be dropped. If this value is not provided,
  /// will use min_replica_count as the default value. The value of this field
  /// impacts the charge against Vertex CPU and GPU quotas. Specifically, you
  /// will be charged for (max_replica_count * number of cores in the selected
  /// machine type) and (max_replica_count * number of GPUs per replica in the
  /// selected machine type).
  ///
  /// Immutable.
  core.int? maxReplicaCount;

  /// The minimum number of machine replicas this DeployedModel will be always
  /// deployed on.
  ///
  /// This value must be greater than or equal to 1. If traffic against the
  /// DeployedModel increases, it may dynamically be deployed onto more
  /// replicas, and as traffic decreases, some of these extra replicas may be
  /// freed.
  ///
  /// Required. Immutable.
  core.int? minReplicaCount;

  GoogleCloudAiplatformV1DedicatedResources({
    this.autoscalingMetricSpecs,
    this.machineSpec,
    this.maxReplicaCount,
    this.minReplicaCount,
  });

  GoogleCloudAiplatformV1DedicatedResources.fromJson(core.Map json_)
      : this(
          autoscalingMetricSpecs: json_.containsKey('autoscalingMetricSpecs')
              ? (json_['autoscalingMetricSpecs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1AutoscalingMetricSpec.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          maxReplicaCount: json_.containsKey('maxReplicaCount')
              ? json_['maxReplicaCount'] as core.int
              : null,
          minReplicaCount: json_.containsKey('minReplicaCount')
              ? json_['minReplicaCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (autoscalingMetricSpecs != null)
          'autoscalingMetricSpecs': autoscalingMetricSpecs!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount!,
        if (minReplicaCount != null) 'minReplicaCount': minReplicaCount!,
      };
}

/// Request message for FeaturestoreService.DeleteFeatureValues.
class GoogleCloudAiplatformV1DeleteFeatureValuesRequest {
  /// Select feature values to be deleted by specifying entities.
  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity? selectEntity;

  /// Select feature values to be deleted by specifying time range and features.
  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature?
      selectTimeRangeAndFeature;

  GoogleCloudAiplatformV1DeleteFeatureValuesRequest({
    this.selectEntity,
    this.selectTimeRangeAndFeature,
  });

  GoogleCloudAiplatformV1DeleteFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          selectEntity: json_.containsKey('selectEntity')
              ? GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity
                  .fromJson(json_['selectEntity']
                      as core.Map<core.String, core.dynamic>)
              : null,
          selectTimeRangeAndFeature: json_
                  .containsKey('selectTimeRangeAndFeature')
              ? GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature
                  .fromJson(json_['selectTimeRangeAndFeature']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (selectEntity != null) 'selectEntity': selectEntity!,
        if (selectTimeRangeAndFeature != null)
          'selectTimeRangeAndFeature': selectTimeRangeAndFeature!,
      };
}

/// Message to select entity.
///
/// If an entity id is selected, all the feature values corresponding to the
/// entity id will be deleted, including the entityId.
class GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity {
  /// Selectors choosing feature values of which entity id to be deleted from
  /// the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1EntityIdSelector? entityIdSelector;

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity({
    this.entityIdSelector,
  });

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectEntity.fromJson(
      core.Map json_)
      : this(
          entityIdSelector: json_.containsKey('entityIdSelector')
              ? GoogleCloudAiplatformV1EntityIdSelector.fromJson(
                  json_['entityIdSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityIdSelector != null) 'entityIdSelector': entityIdSelector!,
      };
}

/// Message to select time range and feature.
///
/// Values of the selected feature generated within an inclusive time range will
/// be deleted. Using this option permanently deletes the feature values from
/// the specified feature IDs within the specified time range. This might
/// include data from the online storage. If you want to retain any deleted
/// historical data in the online storage, you must re-ingest it.
class GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature {
  /// Selectors choosing which feature values to be deleted from the EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  /// If set, data will not be deleted from online storage.
  ///
  /// When time range is older than the data in online storage, setting this to
  /// be true will make the deletion have no impact on online serving.
  core.bool? skipOnlineStorageDelete;

  /// Select feature generated within a half-inclusive time range.
  ///
  /// The time range is lower inclusive and upper exclusive.
  ///
  /// Required.
  GoogleTypeInterval? timeRange;

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature({
    this.featureSelector,
    this.skipOnlineStorageDelete,
    this.timeRange,
  });

  GoogleCloudAiplatformV1DeleteFeatureValuesRequestSelectTimeRangeAndFeature.fromJson(
      core.Map json_)
      : this(
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
          skipOnlineStorageDelete: json_.containsKey('skipOnlineStorageDelete')
              ? json_['skipOnlineStorageDelete'] as core.bool
              : null,
          timeRange: json_.containsKey('timeRange')
              ? GoogleTypeInterval.fromJson(
                  json_['timeRange'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureSelector != null) 'featureSelector': featureSelector!,
        if (skipOnlineStorageDelete != null)
          'skipOnlineStorageDelete': skipOnlineStorageDelete!,
        if (timeRange != null) 'timeRange': timeRange!,
      };
}

/// Request message for IndexEndpointService.DeployIndex.
class GoogleCloudAiplatformV1DeployIndexRequest {
  /// The DeployedIndex to be created within the IndexEndpoint.
  ///
  /// Required.
  GoogleCloudAiplatformV1DeployedIndex? deployedIndex;

  GoogleCloudAiplatformV1DeployIndexRequest({
    this.deployedIndex,
  });

  GoogleCloudAiplatformV1DeployIndexRequest.fromJson(core.Map json_)
      : this(
          deployedIndex: json_.containsKey('deployedIndex')
              ? GoogleCloudAiplatformV1DeployedIndex.fromJson(
                  json_['deployedIndex'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndex != null) 'deployedIndex': deployedIndex!,
      };
}

/// Request message for EndpointService.DeployModel.
class GoogleCloudAiplatformV1DeployModelRequest {
  /// The DeployedModel to be created within the Endpoint.
  ///
  /// Note that Endpoint.traffic_split must be updated for the DeployedModel to
  /// start receiving traffic, either as part of this call, or via
  /// EndpointService.UpdateEndpoint.
  ///
  /// Required.
  GoogleCloudAiplatformV1DeployedModel? deployedModel;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If this field is non-empty, then the Endpoint's traffic_split will be
  /// overwritten with it. To refer to the ID of the just being deployed Model,
  /// a "0" should be used, and the actual ID of the new DeployedModel will be
  /// filled in its place by this method. The traffic percentage values must add
  /// up to 100. If this field is empty, then the Endpoint's traffic_split is
  /// not updated.
  core.Map<core.String, core.int>? trafficSplit;

  GoogleCloudAiplatformV1DeployModelRequest({
    this.deployedModel,
    this.trafficSplit,
  });

  GoogleCloudAiplatformV1DeployModelRequest.fromJson(core.Map json_)
      : this(
          deployedModel: json_.containsKey('deployedModel')
              ? GoogleCloudAiplatformV1DeployedModel.fromJson(
                  json_['deployedModel'] as core.Map<core.String, core.dynamic>)
              : null,
          trafficSplit: json_.containsKey('trafficSplit')
              ? (json_['trafficSplit'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.int,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModel != null) 'deployedModel': deployedModel!,
        if (trafficSplit != null) 'trafficSplit': trafficSplit!,
      };
}

/// A deployment of an Index.
///
/// IndexEndpoints contain one or more DeployedIndexes.
class GoogleCloudAiplatformV1DeployedIndex {
  /// A description of resources that the DeployedIndex uses, which to large
  /// degree are decided by Vertex AI, and optionally allows only a modest
  /// additional configuration.
  ///
  /// If min_replica_count is not set, the default value is 2 (we don't provide
  /// SLA when min_replica_count=1). If max_replica_count is not set, the
  /// default value is min_replica_count. The max allowed replica count is 1000.
  ///
  /// Optional.
  GoogleCloudAiplatformV1AutomaticResources? automaticResources;

  /// Timestamp when the DeployedIndex was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of resources that are dedicated to the DeployedIndex, and
  /// that need a higher degree of manual configuration.
  ///
  /// If min_replica_count is not set, the default value is 2 (we don't provide
  /// SLA when min_replica_count=1). If max_replica_count is not set, the
  /// default value is min_replica_count. The max allowed replica count is 1000.
  /// Available machine types for SMALL shard: e2-standard-2 and all machine
  /// types available for MEDIUM and LARGE shard. Available machine types for
  /// MEDIUM shard: e2-standard-16 and all machine types available for LARGE
  /// shard. Available machine types for LARGE shard: e2-highmem-16,
  /// n2d-standard-32. n1-standard-16 and n1-standard-32 are still available,
  /// but we recommend e2-standard-16 and e2-highmem-16 for cost efficiency.
  ///
  /// Optional.
  GoogleCloudAiplatformV1DedicatedResources? dedicatedResources;

  /// If set, the authentication is enabled for the private endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1DeployedIndexAuthConfig? deployedIndexAuthConfig;

  /// The deployment group can be no longer than 64 characters (eg: 'test',
  /// 'prod').
  ///
  /// If not set, we will use the 'default' deployment group. Creating
  /// `deployment_groups` with `reserved_ip_ranges` is a recommended practice
  /// when the peered network has multiple peering ranges. This creates your
  /// deployments from predictable IP spaces for easier traffic administration.
  /// Also, one deployment_group (except 'default') can only be used with the
  /// same reserved_ip_ranges which means if the deployment_group has been used
  /// with reserved_ip_ranges: \[a, b, c\], using it with \[a, b\] or \[d, e\]
  /// is disallowed. Note: we only support up to 5 deployment groups(not
  /// including 'default').
  ///
  /// Optional.
  core.String? deploymentGroup;

  /// The display name of the DeployedIndex.
  ///
  /// If not provided upon creation, the Index's display_name is used.
  core.String? displayName;

  /// If true, private endpoint's access logs are sent to Cloud Logging.
  ///
  /// These logs are like standard server access logs, containing information
  /// like timestamp and latency for each MatchRequest. Note that logs may incur
  /// a cost, especially if the deployed index receives a high queries per
  /// second rate (QPS). Estimate your costs before enabling this option.
  ///
  /// Optional.
  core.bool? enableAccessLogging;

  /// The user specified ID of the DeployedIndex.
  ///
  /// The ID can be up to 128 characters long and must start with a letter and
  /// only contain letters, numbers, and underscores. The ID must be unique
  /// within the project it is created in.
  ///
  /// Required.
  core.String? id;

  /// The name of the Index this is the deployment of.
  ///
  /// We may refer to this Index as the DeployedIndex's "original" Index.
  ///
  /// Required.
  core.String? index;

  /// The DeployedIndex may depend on various data on its original Index.
  ///
  /// Additionally when certain changes to the original Index are being done
  /// (e.g. when what the Index contains is being changed) the DeployedIndex may
  /// be asynchronously updated in the background to reflect these changes. If
  /// this timestamp's value is at least the Index.update_time of the original
  /// Index, it means that this DeployedIndex and the original Index are in
  /// sync. If this timestamp is older, then to see which updates this
  /// DeployedIndex already contains (and which it does not), one must list the
  /// operations that are running on the original Index. Only the successfully
  /// completed Operations with update_time equal or before this sync time are
  /// contained in this DeployedIndex.
  ///
  /// Output only.
  core.String? indexSyncTime;

  /// Provides paths for users to send requests directly to the deployed index
  /// services running on Cloud via private services access.
  ///
  /// This field is populated if network is configured.
  ///
  /// Output only.
  GoogleCloudAiplatformV1IndexPrivateEndpoints? privateEndpoints;

  /// A list of reserved ip ranges under the VPC network that can be used for
  /// this DeployedIndex.
  ///
  /// If set, we will deploy the index within the provided ip ranges. Otherwise,
  /// the index might be deployed to any ip ranges under the provided VPC
  /// network. The value should be the name of the address
  /// (https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
  /// Example: \['vertex-ai-ip-range'\]. For more information about subnets and
  /// network IP ranges, please see
  /// https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
  ///
  /// Optional.
  core.List<core.String>? reservedIpRanges;

  GoogleCloudAiplatformV1DeployedIndex({
    this.automaticResources,
    this.createTime,
    this.dedicatedResources,
    this.deployedIndexAuthConfig,
    this.deploymentGroup,
    this.displayName,
    this.enableAccessLogging,
    this.id,
    this.index,
    this.indexSyncTime,
    this.privateEndpoints,
    this.reservedIpRanges,
  });

  GoogleCloudAiplatformV1DeployedIndex.fromJson(core.Map json_)
      : this(
          automaticResources: json_.containsKey('automaticResources')
              ? GoogleCloudAiplatformV1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deployedIndexAuthConfig: json_.containsKey('deployedIndexAuthConfig')
              ? GoogleCloudAiplatformV1DeployedIndexAuthConfig.fromJson(
                  json_['deployedIndexAuthConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deploymentGroup: json_.containsKey('deploymentGroup')
              ? json_['deploymentGroup'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          enableAccessLogging: json_.containsKey('enableAccessLogging')
              ? json_['enableAccessLogging'] as core.bool
              : null,
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
          index:
              json_.containsKey('index') ? json_['index'] as core.String : null,
          indexSyncTime: json_.containsKey('indexSyncTime')
              ? json_['indexSyncTime'] as core.String
              : null,
          privateEndpoints: json_.containsKey('privateEndpoints')
              ? GoogleCloudAiplatformV1IndexPrivateEndpoints.fromJson(
                  json_['privateEndpoints']
                      as core.Map<core.String, core.dynamic>)
              : null,
          reservedIpRanges: json_.containsKey('reservedIpRanges')
              ? (json_['reservedIpRanges'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automaticResources != null)
          'automaticResources': automaticResources!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (deployedIndexAuthConfig != null)
          'deployedIndexAuthConfig': deployedIndexAuthConfig!,
        if (deploymentGroup != null) 'deploymentGroup': deploymentGroup!,
        if (displayName != null) 'displayName': displayName!,
        if (enableAccessLogging != null)
          'enableAccessLogging': enableAccessLogging!,
        if (id != null) 'id': id!,
        if (index != null) 'index': index!,
        if (indexSyncTime != null) 'indexSyncTime': indexSyncTime!,
        if (privateEndpoints != null) 'privateEndpoints': privateEndpoints!,
        if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
      };
}

/// Used to set up the auth on the DeployedIndex's private endpoint.
class GoogleCloudAiplatformV1DeployedIndexAuthConfig {
  /// Defines the authentication provider that the DeployedIndex uses.
  GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider? authProvider;

  GoogleCloudAiplatformV1DeployedIndexAuthConfig({
    this.authProvider,
  });

  GoogleCloudAiplatformV1DeployedIndexAuthConfig.fromJson(core.Map json_)
      : this(
          authProvider: json_.containsKey('authProvider')
              ? GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider
                  .fromJson(json_['authProvider']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (authProvider != null) 'authProvider': authProvider!,
      };
}

/// Configuration for an authentication provider, including support for \[JSON
/// Web Token
/// (JWT)\](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
class GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider {
  /// A list of allowed JWT issuers.
  ///
  /// Each entry must be a valid Google service account, in the following
  /// format: `service-account-name@project-id.iam.gserviceaccount.com`
  core.List<core.String>? allowedIssuers;

  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  ///
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted.
  core.List<core.String>? audiences;

  GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider({
    this.allowedIssuers,
    this.audiences,
  });

  GoogleCloudAiplatformV1DeployedIndexAuthConfigAuthProvider.fromJson(
      core.Map json_)
      : this(
          allowedIssuers: json_.containsKey('allowedIssuers')
              ? (json_['allowedIssuers'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          audiences: json_.containsKey('audiences')
              ? (json_['audiences'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowedIssuers != null) 'allowedIssuers': allowedIssuers!,
        if (audiences != null) 'audiences': audiences!,
      };
}

/// Points to a DeployedIndex.
class GoogleCloudAiplatformV1DeployedIndexRef {
  /// The ID of the DeployedIndex in the above IndexEndpoint.
  ///
  /// Immutable.
  core.String? deployedIndexId;

  /// A resource name of the IndexEndpoint.
  ///
  /// Immutable.
  core.String? indexEndpoint;

  GoogleCloudAiplatformV1DeployedIndexRef({
    this.deployedIndexId,
    this.indexEndpoint,
  });

  GoogleCloudAiplatformV1DeployedIndexRef.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_.containsKey('deployedIndexId')
              ? json_['deployedIndexId'] as core.String
              : null,
          indexEndpoint: json_.containsKey('indexEndpoint')
              ? json_['indexEndpoint'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
        if (indexEndpoint != null) 'indexEndpoint': indexEndpoint!,
      };
}

/// A deployment of a Model.
///
/// Endpoints contain one or more DeployedModels.
class GoogleCloudAiplatformV1DeployedModel {
  /// A description of resources that to large degree are decided by Vertex AI,
  /// and require only a modest additional configuration.
  GoogleCloudAiplatformV1AutomaticResources? automaticResources;

  /// Timestamp when the DeployedModel was created.
  ///
  /// Output only.
  core.String? createTime;

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  GoogleCloudAiplatformV1DedicatedResources? dedicatedResources;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to Cloud
  /// Logging by default.
  ///
  /// Please note that the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging/pricing). User
  /// can disable container logging by setting this flag to true.
  core.bool? disableContainerLogging;

  /// The display name of the DeployedModel.
  ///
  /// If not provided upon creation, the Model's display_name is used.
  core.String? displayName;

  /// If true, online prediction access logs are sent to Cloud Logging.
  ///
  /// These logs are like standard server access logs, containing information
  /// like timestamp and latency for each prediction request. Note that logs may
  /// incur a cost, especially if your project receives prediction requests at a
  /// high queries per second rate (QPS). Estimate your costs before enabling
  /// this option.
  core.bool? enableAccessLogging;

  /// Explanation configuration for this DeployedModel.
  ///
  /// When deploying a Model using EndpointService.DeployModel, this value
  /// overrides the value of Model.explanation_spec. All fields of
  /// explanation_spec are optional in the request. If a field of
  /// explanation_spec is not populated, the value of the same field of
  /// Model.explanation_spec is inherited. If the corresponding
  /// Model.explanation_spec is not populated, all fields of the
  /// explanation_spec will be used for the explanation configuration.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// The ID of the DeployedModel.
  ///
  /// If not provided upon deployment, Vertex AI will generate a value for this
  /// ID. This value should be 1-10 characters, and valid characters are
  /// `/[0-9]/`.
  ///
  /// Immutable.
  core.String? id;

  /// The resource name of the Model that this is the deployment of.
  ///
  /// Note that the Model may be in a different location than the
  /// DeployedModel's Endpoint. The resource name may contain version id or
  /// version alias to specify the version. Example:
  /// `projects/{project}/locations/{location}/models/{model}@2` or
  /// `projects/{project}/locations/{location}/models/{model}@golden` if no
  /// version is specified, the default version will be deployed.
  ///
  /// Required.
  core.String? model;

  /// The version ID of the model that is deployed.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// Provide paths for users to send predict/explain/health requests directly
  /// to the deployed model services running on Cloud via private services
  /// access.
  ///
  /// This field is populated if network is configured.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PrivateEndpoints? privateEndpoints;

  /// The service account that the DeployedModel's container runs as.
  ///
  /// Specify the email address of the service account. If this service account
  /// is not specified, the container runs as a service account that doesn't
  /// have access to the resource project. Users deploying the Model must have
  /// the `iam.serviceAccounts.actAs` permission on this service account.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1DeployedModel({
    this.automaticResources,
    this.createTime,
    this.dedicatedResources,
    this.disableContainerLogging,
    this.displayName,
    this.enableAccessLogging,
    this.explanationSpec,
    this.id,
    this.model,
    this.modelVersionId,
    this.privateEndpoints,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1DeployedModel.fromJson(core.Map json_)
      : this(
          automaticResources: json_.containsKey('automaticResources')
              ? GoogleCloudAiplatformV1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          disableContainerLogging: json_.containsKey('disableContainerLogging')
              ? json_['disableContainerLogging'] as core.bool
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          enableAccessLogging: json_.containsKey('enableAccessLogging')
              ? json_['enableAccessLogging'] as core.bool
              : null,
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
          model:
              json_.containsKey('model') ? json_['model'] as core.String : null,
          modelVersionId: json_.containsKey('modelVersionId')
              ? json_['modelVersionId'] as core.String
              : null,
          privateEndpoints: json_.containsKey('privateEndpoints')
              ? GoogleCloudAiplatformV1PrivateEndpoints.fromJson(
                  json_['privateEndpoints']
                      as core.Map<core.String, core.dynamic>)
              : null,
          serviceAccount: json_.containsKey('serviceAccount')
              ? json_['serviceAccount'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automaticResources != null)
          'automaticResources': automaticResources!,
        if (createTime != null) 'createTime': createTime!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (disableContainerLogging != null)
          'disableContainerLogging': disableContainerLogging!,
        if (displayName != null) 'displayName': displayName!,
        if (enableAccessLogging != null)
          'enableAccessLogging': enableAccessLogging!,
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (id != null) 'id': id!,
        if (model != null) 'model': model!,
        if (modelVersionId != null) 'modelVersionId': modelVersionId!,
        if (privateEndpoints != null) 'privateEndpoints': privateEndpoints!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
      };
}

/// Points to a DeployedModel.
class GoogleCloudAiplatformV1DeployedModelRef {
  /// An ID of a DeployedModel in the above Endpoint.
  ///
  /// Immutable.
  core.String? deployedModelId;

  /// A resource name of an Endpoint.
  ///
  /// Immutable.
  core.String? endpoint;

  GoogleCloudAiplatformV1DeployedModelRef({
    this.deployedModelId,
    this.endpoint,
  });

  GoogleCloudAiplatformV1DeployedModelRef.fromJson(core.Map json_)
      : this(
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          endpoint: json_.containsKey('endpoint')
              ? json_['endpoint'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (endpoint != null) 'endpoint': endpoint!,
      };
}

class GoogleCloudAiplatformV1DestinationFeatureSetting {
  /// Specify the field name in the export destination.
  ///
  /// If not specified, Feature ID is used.
  core.String? destinationField;

  /// The ID of the Feature to apply the setting to.
  ///
  /// Required.
  core.String? featureId;

  GoogleCloudAiplatformV1DestinationFeatureSetting({
    this.destinationField,
    this.featureId,
  });

  GoogleCloudAiplatformV1DestinationFeatureSetting.fromJson(core.Map json_)
      : this(
          destinationField: json_.containsKey('destinationField')
              ? json_['destinationField'] as core.String
              : null,
          featureId: json_.containsKey('featureId')
              ? json_['featureId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destinationField != null) 'destinationField': destinationField!,
        if (featureId != null) 'featureId': featureId!,
      };
}

/// Represents the spec of disk options.
typedef GoogleCloudAiplatformV1DiskSpec = $Shared03;

/// A list of double values.
class GoogleCloudAiplatformV1DoubleArray {
  /// A list of double values.
  core.List<core.double>? values;

  GoogleCloudAiplatformV1DoubleArray({
    this.values,
  });

  GoogleCloudAiplatformV1DoubleArray.fromJson(core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => (value as core.num).toDouble())
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Represents a customer-managed encryption key spec that can be applied to a
/// top-level resource.
class GoogleCloudAiplatformV1EncryptionSpec {
  /// The Cloud KMS resource identifier of the customer managed encryption key
  /// used to protect a resource.
  ///
  /// Has the form:
  /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
  /// The key needs to be in the same region as where the compute resource is
  /// created.
  ///
  /// Required.
  core.String? kmsKeyName;

  GoogleCloudAiplatformV1EncryptionSpec({
    this.kmsKeyName,
  });

  GoogleCloudAiplatformV1EncryptionSpec.fromJson(core.Map json_)
      : this(
          kmsKeyName: json_.containsKey('kmsKeyName')
              ? json_['kmsKeyName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
      };
}

/// Models are deployed into it, and afterwards Endpoint is called to obtain
/// predictions and explanations.
class GoogleCloudAiplatformV1Endpoint {
  /// Timestamp when this Endpoint was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The models deployed in this Endpoint.
  ///
  /// To add or remove DeployedModels use EndpointService.DeployModel and
  /// EndpointService.UndeployModel respectively.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedModel>? deployedModels;

  /// The description of the Endpoint.
  core.String? description;

  /// The display name of the Endpoint.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Deprecated: If true, expose the Endpoint via private service connect.
  ///
  /// Only one of the fields, network or enable_private_service_connect, can be
  /// set.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enablePrivateServiceConnect;

  /// Customer-managed encryption key spec for an Endpoint.
  ///
  /// If set, this Endpoint and all sub-resources of this Endpoint will be
  /// secured by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Endpoints.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the Model Monitoring job associated with this Endpoint if
  /// monitoring is enabled by JobService.CreateModelDeploymentMonitoringJob.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  ///
  /// Output only.
  core.String? modelDeploymentMonitoringJob;

  /// The resource name of the Endpoint.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  /// to which the Endpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If
  /// left unspecified, the Endpoint is not peered with any network. Only one of
  /// the fields, network or enable_private_service_connect, can be set.
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`. Where `{project}` is a
  /// project number, as in `12345`, and `{network}` is network name.
  ///
  /// Optional.
  core.String? network;

  /// Configures the request-response logging for online prediction.
  GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig?
      predictRequestResponseLoggingConfig;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If a DeployedModel's ID is not listed in this map, then it receives no
  /// traffic. The traffic percentage values must add up to 100, or map must be
  /// empty if the Endpoint is to not accept any traffic at a moment.
  core.Map<core.String, core.int>? trafficSplit;

  /// Timestamp when this Endpoint was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Endpoint({
    this.createTime,
    this.deployedModels,
    this.description,
    this.displayName,
    this.enablePrivateServiceConnect,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.modelDeploymentMonitoringJob,
    this.name,
    this.network,
    this.predictRequestResponseLoggingConfig,
    this.trafficSplit,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Endpoint.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          deployedModels: json_.containsKey('deployedModels')
              ? (json_['deployedModels'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1DeployedModel.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          enablePrivateServiceConnect:
              json_.containsKey('enablePrivateServiceConnect')
                  ? json_['enablePrivateServiceConnect'] as core.bool
                  : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          modelDeploymentMonitoringJob:
              json_.containsKey('modelDeploymentMonitoringJob')
                  ? json_['modelDeploymentMonitoringJob'] as core.String
                  : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          network: json_.containsKey('network')
              ? json_['network'] as core.String
              : null,
          predictRequestResponseLoggingConfig:
              json_.containsKey('predictRequestResponseLoggingConfig')
                  ? GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig
                      .fromJson(json_['predictRequestResponseLoggingConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          trafficSplit: json_.containsKey('trafficSplit')
              ? (json_['trafficSplit'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.int,
                  ),
                )
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (deployedModels != null) 'deployedModels': deployedModels!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (enablePrivateServiceConnect != null)
          'enablePrivateServiceConnect': enablePrivateServiceConnect!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (modelDeploymentMonitoringJob != null)
          'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (predictRequestResponseLoggingConfig != null)
          'predictRequestResponseLoggingConfig':
              predictRequestResponseLoggingConfig!,
        if (trafficSplit != null) 'trafficSplit': trafficSplit!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Selector for entityId.
///
/// Getting ids from the given source.
class GoogleCloudAiplatformV1EntityIdSelector {
  /// Source of Csv
  GoogleCloudAiplatformV1CsvSource? csvSource;

  /// Source column that holds entity IDs.
  ///
  /// If not provided, entity IDs are extracted from the column named entity_id.
  core.String? entityIdField;

  GoogleCloudAiplatformV1EntityIdSelector({
    this.csvSource,
    this.entityIdField,
  });

  GoogleCloudAiplatformV1EntityIdSelector.fromJson(core.Map json_)
      : this(
          csvSource: json_.containsKey('csvSource')
              ? GoogleCloudAiplatformV1CsvSource.fromJson(
                  json_['csvSource'] as core.Map<core.String, core.dynamic>)
              : null,
          entityIdField: json_.containsKey('entityIdField')
              ? json_['entityIdField'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (csvSource != null) 'csvSource': csvSource!,
        if (entityIdField != null) 'entityIdField': entityIdField!,
      };
}

/// An entity type is a type of object in a system that needs to be modeled and
/// have stored information about.
///
/// For example, driver is an entity type, and driver0 is an instance of an
/// entity type driver.
class GoogleCloudAiplatformV1EntityType {
  /// Timestamp when this EntityType was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the EntityType.
  ///
  /// Optional.
  core.String? description;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your EntityTypes.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one EntityType (System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// The default monitoring configuration for all Features with value type
  /// (Feature.ValueType) BOOL, STRING, DOUBLE or INT64 under this EntityType.
  ///
  /// If this is populated with
  /// \[FeaturestoreMonitoringConfig.monitoring_interval\] specified, snapshot
  /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is
  /// disabled.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfig? monitoringConfig;

  /// Name of the EntityType.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// The last part entity_type is assigned by the client. The entity_type can
  /// be up to 64 characters long and can consist only of ASCII Latin letters
  /// A-Z and a-z and underscore(_), and ASCII digits 0-9 starting with a
  /// letter. The value will be unique given a featurestore.
  ///
  /// Immutable.
  core.String? name;

  /// Config for data retention policy in offline storage.
  ///
  /// TTL in days for feature values that will be stored in offline storage. The
  /// Feature Store offline storage periodically removes obsolete feature values
  /// older than `offline_storage_ttl_days` since the feature generation time.
  /// If unset (or explicitly set to 0), default to 4000 days TTL.
  ///
  /// Optional.
  core.int? offlineStorageTtlDays;

  /// Timestamp when this EntityType was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1EntityType({
    this.createTime,
    this.description,
    this.etag,
    this.labels,
    this.monitoringConfig,
    this.name,
    this.offlineStorageTtlDays,
    this.updateTime,
  });

  GoogleCloudAiplatformV1EntityType.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          monitoringConfig: json_.containsKey('monitoringConfig')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfig.fromJson(
                  json_['monitoringConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          offlineStorageTtlDays: json_.containsKey('offlineStorageTtlDays')
              ? json_['offlineStorageTtlDays'] as core.int
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (monitoringConfig != null) 'monitoringConfig': monitoringConfig!,
        if (name != null) 'name': name!,
        if (offlineStorageTtlDays != null)
          'offlineStorageTtlDays': offlineStorageTtlDays!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Represents an environment variable present in a Container or Python Module.
class GoogleCloudAiplatformV1EnvVar {
  /// Name of the environment variable.
  ///
  /// Must be a valid C identifier.
  ///
  /// Required.
  core.String? name;

  /// Variables that reference a $(VAR_NAME) are expanded using the previous
  /// defined environment variables in the container and any service environment
  /// variables.
  ///
  /// If a variable cannot be resolved, the reference in the input string will
  /// be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie:
  /// $$(VAR_NAME). Escaped references will never be expanded, regardless of
  /// whether the variable exists or not.
  ///
  /// Required.
  core.String? value;

  GoogleCloudAiplatformV1EnvVar({
    this.name,
    this.value,
  });

  GoogleCloudAiplatformV1EnvVar.fromJson(core.Map json_)
      : this(
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          value:
              json_.containsKey('value') ? json_['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (value != null) 'value': value!,
      };
}

/// Model error analysis for each annotation.
class GoogleCloudAiplatformV1ErrorAnalysisAnnotation {
  /// Attributed items for a given annotation, typically representing neighbors
  /// from the training sets constrained by the query type.
  core.List<GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem>?
      attributedItems;

  /// The outlier score of this annotated item.
  ///
  /// Usually defined as the min of all distances from attributed items.
  core.double? outlierScore;

  /// The threshold used to determine if this annotation is an outlier or not.
  core.double? outlierThreshold;

  /// The query type used for finding the attributed items.
  /// Possible string values are:
  /// - "QUERY_TYPE_UNSPECIFIED" : Unspecified query type for model error
  /// analysis.
  /// - "ALL_SIMILAR" : Query similar samples across all classes in the dataset.
  /// - "SAME_CLASS_SIMILAR" : Query similar samples from the same class of the
  /// input sample.
  /// - "SAME_CLASS_DISSIMILAR" : Query dissimilar samples from the same class
  /// of the input sample.
  core.String? queryType;

  GoogleCloudAiplatformV1ErrorAnalysisAnnotation({
    this.attributedItems,
    this.outlierScore,
    this.outlierThreshold,
    this.queryType,
  });

  GoogleCloudAiplatformV1ErrorAnalysisAnnotation.fromJson(core.Map json_)
      : this(
          attributedItems: json_.containsKey('attributedItems')
              ? (json_['attributedItems'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          outlierScore: json_.containsKey('outlierScore')
              ? (json_['outlierScore'] as core.num).toDouble()
              : null,
          outlierThreshold: json_.containsKey('outlierThreshold')
              ? (json_['outlierThreshold'] as core.num).toDouble()
              : null,
          queryType: json_.containsKey('queryType')
              ? json_['queryType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributedItems != null) 'attributedItems': attributedItems!,
        if (outlierScore != null) 'outlierScore': outlierScore!,
        if (outlierThreshold != null) 'outlierThreshold': outlierThreshold!,
        if (queryType != null) 'queryType': queryType!,
      };
}

/// Attributed items for a given annotation, typically representing neighbors
/// from the training sets constrained by the query type.
class GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem {
  /// The unique ID for each annotation.
  ///
  /// Used by FE to allocate the annotation in DB.
  core.String? annotationResourceName;

  /// The distance of this item to the annotation.
  core.double? distance;

  GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem({
    this.annotationResourceName,
    this.distance,
  });

  GoogleCloudAiplatformV1ErrorAnalysisAnnotationAttributedItem.fromJson(
      core.Map json_)
      : this(
          annotationResourceName: json_.containsKey('annotationResourceName')
              ? json_['annotationResourceName'] as core.String
              : null,
          distance: json_.containsKey('distance')
              ? (json_['distance'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationResourceName != null)
          'annotationResourceName': annotationResourceName!,
        if (distance != null) 'distance': distance!,
      };
}

/// True positive, false positive, or false negative.
///
/// EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
/// of `annotationSpec` dimension.
class GoogleCloudAiplatformV1EvaluatedAnnotation {
  /// The data item payload that the Model predicted this EvaluatedAnnotation
  /// on.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? dataItemPayload;

  /// Annotations of model error analysis results.
  core.List<GoogleCloudAiplatformV1ErrorAnalysisAnnotation>?
      errorAnalysisAnnotations;

  /// ID of the EvaluatedDataItemView under the same ancestor ModelEvaluation.
  ///
  /// The EvaluatedDataItemView consists of all ground truths and predictions on
  /// data_item_payload.
  ///
  /// Output only.
  core.String? evaluatedDataItemViewId;

  /// Explanations of predictions.
  ///
  /// Each element of the explanations indicates the explanation for one
  /// explanation Method. The attributions list in the
  /// EvaluatedAnnotationExplanation.explanation object corresponds to the
  /// predictions list. For example, the second element in the attributions list
  /// explains the second element in the predictions list.
  core.List<GoogleCloudAiplatformV1EvaluatedAnnotationExplanation>?
      explanations;

  /// The ground truth Annotations, i.e. the Annotations that exist in the test
  /// data the Model is evaluated on.
  ///
  /// For true positive, there is one and only one ground truth annotation,
  /// which matches the only prediction in predictions. For false positive,
  /// there are zero or more ground truth annotations that are similar to the
  /// only prediction in predictions, but not enough for a match. For false
  /// negative, there is one and only one ground truth annotation, which doesn't
  /// match any predictions created by the model. The schema of the ground truth
  /// is stored in ModelEvaluation.annotation_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? groundTruths;

  /// The model predicted annotations.
  ///
  /// For true positive, there is one and only one prediction, which matches the
  /// only one ground truth annotation in ground_truths. For false positive,
  /// there is one and only one prediction, which doesn't match any ground truth
  /// annotation of the corresponding data_item_view_id. For false negative,
  /// there are zero or more predictions which are similar to the only ground
  /// truth annotation in ground_truths but not enough for a match. The schema
  /// of the prediction is stored in ModelEvaluation.annotation_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  /// Type of the EvaluatedAnnotation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "EVALUATED_ANNOTATION_TYPE_UNSPECIFIED" : Invalid value.
  /// - "TRUE_POSITIVE" : The EvaluatedAnnotation is a true positive. It has a
  /// prediction created by the Model and a ground truth Annotation which the
  /// prediction matches.
  /// - "FALSE_POSITIVE" : The EvaluatedAnnotation is false positive. It has a
  /// prediction created by the Model which does not match any ground truth
  /// annotation.
  /// - "FALSE_NEGATIVE" : The EvaluatedAnnotation is false negative. It has a
  /// ground truth annotation which is not matched by any of the model created
  /// predictions.
  core.String? type;

  GoogleCloudAiplatformV1EvaluatedAnnotation({
    this.dataItemPayload,
    this.errorAnalysisAnnotations,
    this.evaluatedDataItemViewId,
    this.explanations,
    this.groundTruths,
    this.predictions,
    this.type,
  });

  GoogleCloudAiplatformV1EvaluatedAnnotation.fromJson(core.Map json_)
      : this(
          dataItemPayload: json_.containsKey('dataItemPayload')
              ? json_['dataItemPayload']
              : null,
          errorAnalysisAnnotations: json_
                  .containsKey('errorAnalysisAnnotations')
              ? (json_['errorAnalysisAnnotations'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ErrorAnalysisAnnotation.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          evaluatedDataItemViewId: json_.containsKey('evaluatedDataItemViewId')
              ? json_['evaluatedDataItemViewId'] as core.String
              : null,
          explanations: json_.containsKey('explanations')
              ? (json_['explanations'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1EvaluatedAnnotationExplanation
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          groundTruths: json_.containsKey('groundTruths')
              ? json_['groundTruths'] as core.List
              : null,
          predictions: json_.containsKey('predictions')
              ? json_['predictions'] as core.List
              : null,
          type: json_.containsKey('type') ? json_['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataItemPayload != null) 'dataItemPayload': dataItemPayload!,
        if (errorAnalysisAnnotations != null)
          'errorAnalysisAnnotations': errorAnalysisAnnotations!,
        if (evaluatedDataItemViewId != null)
          'evaluatedDataItemViewId': evaluatedDataItemViewId!,
        if (explanations != null) 'explanations': explanations!,
        if (groundTruths != null) 'groundTruths': groundTruths!,
        if (predictions != null) 'predictions': predictions!,
        if (type != null) 'type': type!,
      };
}

/// Explanation result of the prediction produced by the Model.
class GoogleCloudAiplatformV1EvaluatedAnnotationExplanation {
  /// Explanation attribution response details.
  GoogleCloudAiplatformV1Explanation? explanation;

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are: *
  /// `image-integrated-gradients` * `image-xrai`
  core.String? explanationType;

  GoogleCloudAiplatformV1EvaluatedAnnotationExplanation({
    this.explanation,
    this.explanationType,
  });

  GoogleCloudAiplatformV1EvaluatedAnnotationExplanation.fromJson(core.Map json_)
      : this(
          explanation: json_.containsKey('explanation')
              ? GoogleCloudAiplatformV1Explanation.fromJson(
                  json_['explanation'] as core.Map<core.String, core.dynamic>)
              : null,
          explanationType: json_.containsKey('explanationType')
              ? json_['explanationType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanation != null) 'explanation': explanation!,
        if (explanationType != null) 'explanationType': explanationType!,
      };
}

/// An edge describing the relationship between an Artifact and an Execution in
/// a lineage graph.
class GoogleCloudAiplatformV1Event {
  /// The relative resource name of the Artifact in the Event.
  ///
  /// Required.
  core.String? artifact;

  /// Time the Event occurred.
  ///
  /// Output only.
  core.String? eventTime;

  /// The relative resource name of the Execution in the Event.
  ///
  /// Output only.
  core.String? execution;

  /// The labels with user-defined metadata to annotate Events.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Event (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  core.Map<core.String, core.String>? labels;

  /// The type of the Event.
  ///
  /// Required.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Unspecified whether input or output of the
  /// Execution.
  /// - "INPUT" : An input of the Execution.
  /// - "OUTPUT" : An output of the Execution.
  core.String? type;

  GoogleCloudAiplatformV1Event({
    this.artifact,
    this.eventTime,
    this.execution,
    this.labels,
    this.type,
  });

  GoogleCloudAiplatformV1Event.fromJson(core.Map json_)
      : this(
          artifact: json_.containsKey('artifact')
              ? json_['artifact'] as core.String
              : null,
          eventTime: json_.containsKey('eventTime')
              ? json_['eventTime'] as core.String
              : null,
          execution: json_.containsKey('execution')
              ? json_['execution'] as core.String
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          type: json_.containsKey('type') ? json_['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifact != null) 'artifact': artifact!,
        if (eventTime != null) 'eventTime': eventTime!,
        if (execution != null) 'execution': execution!,
        if (labels != null) 'labels': labels!,
        if (type != null) 'type': type!,
      };
}

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
class GoogleCloudAiplatformV1Examples {
  /// The Cloud Storage input instances.
  GoogleCloudAiplatformV1ExamplesExampleGcsSource? exampleGcsSource;

  /// The full configuration for the generated index, the semantics are the same
  /// as metadata and should match
  /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? nearestNeighborSearchConfig;

  /// The number of neighbors to return when querying for examples.
  core.int? neighborCount;

  /// Simplified preset configuration, which automatically sets configuration
  /// values based on the desired query speed-precision trade-off and modality.
  GoogleCloudAiplatformV1Presets? presets;

  GoogleCloudAiplatformV1Examples({
    this.exampleGcsSource,
    this.nearestNeighborSearchConfig,
    this.neighborCount,
    this.presets,
  });

  GoogleCloudAiplatformV1Examples.fromJson(core.Map json_)
      : this(
          exampleGcsSource: json_.containsKey('exampleGcsSource')
              ? GoogleCloudAiplatformV1ExamplesExampleGcsSource.fromJson(
                  json_['exampleGcsSource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          nearestNeighborSearchConfig:
              json_.containsKey('nearestNeighborSearchConfig')
                  ? json_['nearestNeighborSearchConfig']
                  : null,
          neighborCount: json_.containsKey('neighborCount')
              ? json_['neighborCount'] as core.int
              : null,
          presets: json_.containsKey('presets')
              ? GoogleCloudAiplatformV1Presets.fromJson(
                  json_['presets'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exampleGcsSource != null) 'exampleGcsSource': exampleGcsSource!,
        if (nearestNeighborSearchConfig != null)
          'nearestNeighborSearchConfig': nearestNeighborSearchConfig!,
        if (neighborCount != null) 'neighborCount': neighborCount!,
        if (presets != null) 'presets': presets!,
      };
}

/// The Cloud Storage input instances.
class GoogleCloudAiplatformV1ExamplesExampleGcsSource {
  /// The format in which instances are given, if not specified, assume it's
  /// JSONL format.
  ///
  /// Currently only JSONL format is supported.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Format unspecified, used when unset.
  /// - "JSONL" : Examples are stored in JSONL files.
  core.String? dataFormat;

  /// The Cloud Storage location for the input instances.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  GoogleCloudAiplatformV1ExamplesExampleGcsSource({
    this.dataFormat,
    this.gcsSource,
  });

  GoogleCloudAiplatformV1ExamplesExampleGcsSource.fromJson(core.Map json_)
      : this(
          dataFormat: json_.containsKey('dataFormat')
              ? json_['dataFormat'] as core.String
              : null,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataFormat != null) 'dataFormat': dataFormat!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
      };
}

/// Overrides for example-based explanations.
class GoogleCloudAiplatformV1ExamplesOverride {
  /// The number of neighbors to return that have the same crowding tag.
  core.int? crowdingCount;

  /// The format of the data being provided with each call.
  /// Possible string values are:
  /// - "DATA_FORMAT_UNSPECIFIED" : Unspecified format. Must not be used.
  /// - "INSTANCES" : Provided data is a set of model inputs.
  /// - "EMBEDDINGS" : Provided data is a set of embeddings.
  core.String? dataFormat;

  /// The number of neighbors to return.
  core.int? neighborCount;

  /// Restrict the resulting nearest neighbors to respect these constraints.
  core.List<GoogleCloudAiplatformV1ExamplesRestrictionsNamespace>? restrictions;

  /// If true, return the embeddings instead of neighbors.
  core.bool? returnEmbeddings;

  GoogleCloudAiplatformV1ExamplesOverride({
    this.crowdingCount,
    this.dataFormat,
    this.neighborCount,
    this.restrictions,
    this.returnEmbeddings,
  });

  GoogleCloudAiplatformV1ExamplesOverride.fromJson(core.Map json_)
      : this(
          crowdingCount: json_.containsKey('crowdingCount')
              ? json_['crowdingCount'] as core.int
              : null,
          dataFormat: json_.containsKey('dataFormat')
              ? json_['dataFormat'] as core.String
              : null,
          neighborCount: json_.containsKey('neighborCount')
              ? json_['neighborCount'] as core.int
              : null,
          restrictions: json_.containsKey('restrictions')
              ? (json_['restrictions'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ExamplesRestrictionsNamespace
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          returnEmbeddings: json_.containsKey('returnEmbeddings')
              ? json_['returnEmbeddings'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (crowdingCount != null) 'crowdingCount': crowdingCount!,
        if (dataFormat != null) 'dataFormat': dataFormat!,
        if (neighborCount != null) 'neighborCount': neighborCount!,
        if (restrictions != null) 'restrictions': restrictions!,
        if (returnEmbeddings != null) 'returnEmbeddings': returnEmbeddings!,
      };
}

/// Restrictions namespace for example-based explanations overrides.
class GoogleCloudAiplatformV1ExamplesRestrictionsNamespace {
  /// The list of allowed tags.
  core.List<core.String>? allow;

  /// The list of deny tags.
  core.List<core.String>? deny;

  /// The namespace name.
  core.String? namespaceName;

  GoogleCloudAiplatformV1ExamplesRestrictionsNamespace({
    this.allow,
    this.deny,
    this.namespaceName,
  });

  GoogleCloudAiplatformV1ExamplesRestrictionsNamespace.fromJson(core.Map json_)
      : this(
          allow: json_.containsKey('allow')
              ? (json_['allow'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          deny: json_.containsKey('deny')
              ? (json_['deny'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          namespaceName: json_.containsKey('namespaceName')
              ? json_['namespaceName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allow != null) 'allow': allow!,
        if (deny != null) 'deny': deny!,
        if (namespaceName != null) 'namespaceName': namespaceName!,
      };
}

/// Instance of a general execution.
class GoogleCloudAiplatformV1Execution {
  /// Timestamp when this Execution was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Execution
  core.String? description;

  /// User provided display name of the Execution.
  ///
  /// May be up to 128 Unicode characters.
  core.String? displayName;

  /// An eTag used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Executions.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Execution (System labels are
  /// excluded).
  core.Map<core.String, core.String>? labels;

  /// Properties of the Execution.
  ///
  /// Top level metadata keys' heading and trailing spaces will be trimmed. The
  /// size of this field should not exceed 200KB.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The resource name of the Execution.
  ///
  /// Output only.
  core.String? name;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaTitle;

  /// The version of the schema in `schema_title` to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  core.String? schemaVersion;

  /// The state of this Execution.
  ///
  /// This is a property of the Execution, and does not imply or capture any
  /// ongoing process. This property is managed by clients (such as Vertex AI
  /// Pipelines) and the system does not prescribe or check the validity of
  /// state transitions.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified Execution state
  /// - "NEW" : The Execution is new
  /// - "RUNNING" : The Execution is running
  /// - "COMPLETE" : The Execution has finished running
  /// - "FAILED" : The Execution has failed
  /// - "CACHED" : The Execution completed through Cache hit.
  /// - "CANCELLED" : The Execution was cancelled.
  core.String? state;

  /// Timestamp when this Execution was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Execution({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.metadata,
    this.name,
    this.schemaTitle,
    this.schemaVersion,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Execution.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          schemaTitle: json_.containsKey('schemaTitle')
              ? json_['schemaTitle'] as core.String
              : null,
          schemaVersion: json_.containsKey('schemaVersion')
              ? json_['schemaVersion'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (schemaTitle != null) 'schemaTitle': schemaTitle!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Request message for PredictionService.Explain.
class GoogleCloudAiplatformV1ExplainRequest {
  /// If specified, this ExplainRequest will be served by the chosen
  /// DeployedModel, overriding Endpoint.traffic_split.
  core.String? deployedModelId;

  /// If specified, overrides the explanation_spec of the DeployedModel.
  ///
  /// Can be used for explaining prediction results with different
  /// configurations, such as: - Explaining top-5 predictions results as opposed
  /// to top-1; - Increasing path count or step count of the attribution methods
  /// to reduce approximate errors; - Using different baselines for explaining
  /// the prediction results.
  GoogleCloudAiplatformV1ExplanationSpecOverride? explanationSpecOverride;

  /// The instances that are the input to the explanation call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the explanation call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  GoogleCloudAiplatformV1ExplainRequest({
    this.deployedModelId,
    this.explanationSpecOverride,
    this.instances,
    this.parameters,
  });

  GoogleCloudAiplatformV1ExplainRequest.fromJson(core.Map json_)
      : this(
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          explanationSpecOverride: json_.containsKey('explanationSpecOverride')
              ? GoogleCloudAiplatformV1ExplanationSpecOverride.fromJson(
                  json_['explanationSpecOverride']
                      as core.Map<core.String, core.dynamic>)
              : null,
          instances: json_.containsKey('instances')
              ? json_['instances'] as core.List
              : null,
          parameters:
              json_.containsKey('parameters') ? json_['parameters'] : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (explanationSpecOverride != null)
          'explanationSpecOverride': explanationSpecOverride!,
        if (instances != null) 'instances': instances!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Response message for PredictionService.Explain.
class GoogleCloudAiplatformV1ExplainResponse {
  /// ID of the Endpoint's DeployedModel that served this explanation.
  core.String? deployedModelId;

  /// The explanations of the Model's PredictResponse.predictions.
  ///
  /// It has the same number of elements as instances to be explained.
  core.List<GoogleCloudAiplatformV1Explanation>? explanations;

  /// The predictions that are the output of the predictions call.
  ///
  /// Same as PredictResponse.predictions.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  GoogleCloudAiplatformV1ExplainResponse({
    this.deployedModelId,
    this.explanations,
    this.predictions,
  });

  GoogleCloudAiplatformV1ExplainResponse.fromJson(core.Map json_)
      : this(
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          explanations: json_.containsKey('explanations')
              ? (json_['explanations'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Explanation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          predictions: json_.containsKey('predictions')
              ? json_['predictions'] as core.List
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (explanations != null) 'explanations': explanations!,
        if (predictions != null) 'predictions': predictions!,
      };
}

/// Explanation of a prediction (provided in PredictResponse.predictions)
/// produced by the Model on a given instance.
class GoogleCloudAiplatformV1Explanation {
  /// Feature attributions grouped by predicted outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item. Attribution.output_index can be used to identify which
  /// output this attribution is explaining. If users set
  /// ExplanationParameters.top_k, the attributions are sorted by
  /// instance_output_value in descending order. If
  /// ExplanationParameters.output_indices is specified, the attributions are
  /// stored by Attribution.output_index in the same order as they appear in the
  /// output_indices.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Attribution>? attributions;

  /// List of the nearest neighbors for example-based explanations.
  ///
  /// For models deployed with the examples explanations feature enabled, the
  /// attributions field is empty and instead the neighbors field is populated.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Neighbor>? neighbors;

  GoogleCloudAiplatformV1Explanation({
    this.attributions,
    this.neighbors,
  });

  GoogleCloudAiplatformV1Explanation.fromJson(core.Map json_)
      : this(
          attributions: json_.containsKey('attributions')
              ? (json_['attributions'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Attribution.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          neighbors: json_.containsKey('neighbors')
              ? (json_['neighbors'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Neighbor.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributions != null) 'attributions': attributions!,
        if (neighbors != null) 'neighbors': neighbors!,
      };
}

/// Metadata describing the Model's input and output for explanation.
class GoogleCloudAiplatformV1ExplanationMetadata {
  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of the feature attributions.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML tabular Models always have this field populated by Vertex AI. Note:
  /// The URI given on output may be different, including the URI scheme, than
  /// the one given on input. The output URI will point to a location where the
  /// user only has a read access.
  core.String? featureAttributionsSchemaUri;

  /// Map from feature names to feature input metadata.
  ///
  /// Keys are the name of the features. Values are the specification of the
  /// feature. An empty InputMetadata is valid. It describes a text feature
  /// which has the name specified as the key in ExplanationMetadata.inputs. The
  /// baseline of the empty feature is chosen by Vertex AI. For Vertex
  /// AI-provided Tensorflow images, the key can be any friendly name of the
  /// feature. Once specified, featureAttributions are keyed by this key (if not
  /// grouped with another feature). For custom images, the key must match with
  /// the key in instance.
  ///
  /// Required.
  core.Map<core.String,
      GoogleCloudAiplatformV1ExplanationMetadataInputMetadata>? inputs;

  /// Name of the source to generate embeddings for example based explanations.
  core.String? latentSpaceSource;

  /// Map from output names to output metadata.
  ///
  /// For Vertex AI-provided Tensorflow images, keys can be any user defined
  /// string that consists of any UTF-8 characters. For custom images, keys are
  /// the name of the output field in the prediction to be explained. Currently
  /// only one key is allowed.
  ///
  /// Required.
  core.Map<core.String,
      GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata>? outputs;

  GoogleCloudAiplatformV1ExplanationMetadata({
    this.featureAttributionsSchemaUri,
    this.inputs,
    this.latentSpaceSource,
    this.outputs,
  });

  GoogleCloudAiplatformV1ExplanationMetadata.fromJson(core.Map json_)
      : this(
          featureAttributionsSchemaUri:
              json_.containsKey('featureAttributionsSchemaUri')
                  ? json_['featureAttributionsSchemaUri'] as core.String
                  : null,
          inputs: json_.containsKey('inputs')
              ? (json_['inputs'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1ExplanationMetadataInputMetadata
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          latentSpaceSource: json_.containsKey('latentSpaceSource')
              ? json_['latentSpaceSource'] as core.String
              : null,
          outputs: json_.containsKey('outputs')
              ? (json_['outputs'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureAttributionsSchemaUri != null)
          'featureAttributionsSchemaUri': featureAttributionsSchemaUri!,
        if (inputs != null) 'inputs': inputs!,
        if (latentSpaceSource != null) 'latentSpaceSource': latentSpaceSource!,
        if (outputs != null) 'outputs': outputs!,
      };
}

/// Metadata of the input of a feature.
///
/// Fields other than InputMetadata.input_baselines are applicable only for
/// Models that are using Vertex AI-provided images for Tensorflow.
class GoogleCloudAiplatformV1ExplanationMetadataInputMetadata {
  /// Specifies the shape of the values of the input if the input is a sparse
  /// representation.
  ///
  /// Refer to Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  core.String? denseShapeTensorName;

  /// A list of baselines for the encoded tensor.
  ///
  /// The shape of each baseline should match the shape of the encoded tensor.
  /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
  /// encoded tensor.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? encodedBaselines;

  /// Encoded tensor is a transformation of the input tensor.
  ///
  /// Must be provided if choosing Integrated Gradients attribution or XRAI
  /// attribution and the input tensor is not differentiable. An encoded tensor
  /// is generated if the input tensor is encoded by a lookup table.
  core.String? encodedTensorName;

  /// Defines how the feature is encoded into the input tensor.
  ///
  /// Defaults to IDENTITY.
  /// Possible string values are:
  /// - "ENCODING_UNSPECIFIED" : Default value. This is the same as IDENTITY.
  /// - "IDENTITY" : The tensor represents one feature.
  /// - "BAG_OF_FEATURES" : The tensor represents a bag of features where each
  /// index maps to a feature. InputMetadata.index_feature_mapping must be
  /// provided for this encoding. For example: ``` input = [27, 6.0, 150]
  /// index_feature_mapping = ["age", "height", "weight"] ```
  /// - "BAG_OF_FEATURES_SPARSE" : The tensor represents a bag of features where
  /// each index maps to a feature. Zero values in the tensor indicates feature
  /// being non-existent. InputMetadata.index_feature_mapping must be provided
  /// for this encoding. For example: ``` input = [2, 0, 5, 0, 1]
  /// index_feature_mapping = ["a", "b", "c", "d", "e"] ```
  /// - "INDICATOR" : The tensor is a list of binaries representing whether a
  /// feature exists or not (1 indicates existence).
  /// InputMetadata.index_feature_mapping must be provided for this encoding.
  /// For example: ``` input = [1, 0, 1, 0, 1] index_feature_mapping = ["a",
  /// "b", "c", "d", "e"] ```
  /// - "COMBINED_EMBEDDING" : The tensor is encoded into a 1-dimensional array
  /// represented by an encoded tensor. InputMetadata.encoded_tensor_name must
  /// be provided for this encoding. For example: ``` input = ["This", "is",
  /// "a", "test", "."] encoded = [0.1, 0.2, 0.3, 0.4, 0.5] ```
  /// - "CONCAT_EMBEDDING" : Select this encoding when the input tensor is
  /// encoded into a 2-dimensional array represented by an encoded tensor.
  /// InputMetadata.encoded_tensor_name must be provided for this encoding. The
  /// first dimension of the encoded tensor's shape is the same as the input
  /// tensor's shape. For example: ``` input = ["This", "is", "a", "test", "."]
  /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5], [0.2, 0.1, 0.4, 0.3, 0.5], [0.5,
  /// 0.1, 0.3, 0.5, 0.4], [0.5, 0.3, 0.1, 0.2, 0.4], [0.4, 0.3, 0.2, 0.5, 0.1]]
  /// ```
  core.String? encoding;

  /// The domain details of the input feature value.
  ///
  /// Like min/max, original mean or standard deviation if normalized.
  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain?
      featureValueDomain;

  /// Name of the group that the input belongs to.
  ///
  /// Features with the same group name will be treated as one feature when
  /// computing attributions. Features grouped together can have different
  /// shapes in value. If provided, there will be one single attribution
  /// generated in Attribution.feature_attributions, keyed by the group name.
  core.String? groupName;

  /// A list of feature names for each index in the input tensor.
  ///
  /// Required when the input InputMetadata.encoding is BAG_OF_FEATURES,
  /// BAG_OF_FEATURES_SPARSE, INDICATOR.
  core.List<core.String>? indexFeatureMapping;

  /// Specifies the index of the values of the input tensor.
  ///
  /// Required when the input tensor is a sparse representation. Refer to
  /// Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  core.String? indicesTensorName;

  /// Baseline inputs for this feature.
  ///
  /// If no baseline is specified, Vertex AI chooses the baseline for this
  /// feature. If multiple baselines are specified, Vertex AI returns the
  /// average attributions across them in Attribution.feature_attributions. For
  /// Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape of each
  /// baseline must match the shape of the input tensor. If a scalar is
  /// provided, we broadcast to the same shape as the input tensor. For custom
  /// images, the element of the baselines must be in the same format as the
  /// feature's input in the instance\[\]. The schema of any single instance may
  /// be specified via Endpoint's DeployedModels' Model's PredictSchemata's
  /// instance_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? inputBaselines;

  /// Name of the input tensor for this feature.
  ///
  /// Required and is only applicable to Vertex AI-provided images for
  /// Tensorflow.
  core.String? inputTensorName;

  /// Modality of the feature.
  ///
  /// Valid values are: numeric, image. Defaults to numeric.
  core.String? modality;

  /// Visualization configurations for image explanation.
  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization?
      visualization;

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadata({
    this.denseShapeTensorName,
    this.encodedBaselines,
    this.encodedTensorName,
    this.encoding,
    this.featureValueDomain,
    this.groupName,
    this.indexFeatureMapping,
    this.indicesTensorName,
    this.inputBaselines,
    this.inputTensorName,
    this.modality,
    this.visualization,
  });

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadata.fromJson(
      core.Map json_)
      : this(
          denseShapeTensorName: json_.containsKey('denseShapeTensorName')
              ? json_['denseShapeTensorName'] as core.String
              : null,
          encodedBaselines: json_.containsKey('encodedBaselines')
              ? json_['encodedBaselines'] as core.List
              : null,
          encodedTensorName: json_.containsKey('encodedTensorName')
              ? json_['encodedTensorName'] as core.String
              : null,
          encoding: json_.containsKey('encoding')
              ? json_['encoding'] as core.String
              : null,
          featureValueDomain: json_.containsKey('featureValueDomain')
              ? GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain
                  .fromJson(json_['featureValueDomain']
                      as core.Map<core.String, core.dynamic>)
              : null,
          groupName: json_.containsKey('groupName')
              ? json_['groupName'] as core.String
              : null,
          indexFeatureMapping: json_.containsKey('indexFeatureMapping')
              ? (json_['indexFeatureMapping'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          indicesTensorName: json_.containsKey('indicesTensorName')
              ? json_['indicesTensorName'] as core.String
              : null,
          inputBaselines: json_.containsKey('inputBaselines')
              ? json_['inputBaselines'] as core.List
              : null,
          inputTensorName: json_.containsKey('inputTensorName')
              ? json_['inputTensorName'] as core.String
              : null,
          modality: json_.containsKey('modality')
              ? json_['modality'] as core.String
              : null,
          visualization: json_.containsKey('visualization')
              ? GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization
                  .fromJson(json_['visualization']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (denseShapeTensorName != null)
          'denseShapeTensorName': denseShapeTensorName!,
        if (encodedBaselines != null) 'encodedBaselines': encodedBaselines!,
        if (encodedTensorName != null) 'encodedTensorName': encodedTensorName!,
        if (encoding != null) 'encoding': encoding!,
        if (featureValueDomain != null)
          'featureValueDomain': featureValueDomain!,
        if (groupName != null) 'groupName': groupName!,
        if (indexFeatureMapping != null)
          'indexFeatureMapping': indexFeatureMapping!,
        if (indicesTensorName != null) 'indicesTensorName': indicesTensorName!,
        if (inputBaselines != null) 'inputBaselines': inputBaselines!,
        if (inputTensorName != null) 'inputTensorName': inputTensorName!,
        if (modality != null) 'modality': modality!,
        if (visualization != null) 'visualization': visualization!,
      };
}

/// Domain details of the input feature value.
///
/// Provides numeric information about the feature, such as its range (min,
/// max). If the feature has been pre-processed, for example with z-scoring,
/// then it provides information about how to recover the original feature. For
/// example, if the input feature is an image and it has been pre-processed to
/// obtain 0-mean and stddev = 1 values, then original_mean, and original_stddev
/// refer to the mean and stddev of the original feature (e.g. image tensor)
/// from which input feature (with mean = 0 and stddev = 1) was obtained.
class GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain {
  /// The maximum permissible value for this feature.
  core.double? maxValue;

  /// The minimum permissible value for this feature.
  core.double? minValue;

  /// If this input feature has been normalized to a mean value of 0, the
  /// original_mean specifies the mean value of the domain prior to
  /// normalization.
  core.double? originalMean;

  /// If this input feature has been normalized to a standard deviation of 1.0,
  /// the original_stddev specifies the standard deviation of the domain prior
  /// to normalization.
  core.double? originalStddev;

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain({
    this.maxValue,
    this.minValue,
    this.originalMean,
    this.originalStddev,
  });

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataFeatureValueDomain.fromJson(
      core.Map json_)
      : this(
          maxValue: json_.containsKey('maxValue')
              ? (json_['maxValue'] as core.num).toDouble()
              : null,
          minValue: json_.containsKey('minValue')
              ? (json_['minValue'] as core.num).toDouble()
              : null,
          originalMean: json_.containsKey('originalMean')
              ? (json_['originalMean'] as core.num).toDouble()
              : null,
          originalStddev: json_.containsKey('originalStddev')
              ? (json_['originalStddev'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxValue != null) 'maxValue': maxValue!,
        if (minValue != null) 'minValue': minValue!,
        if (originalMean != null) 'originalMean': originalMean!,
        if (originalStddev != null) 'originalStddev': originalStddev!,
      };
}

/// Visualization configurations for image explanation.
class GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization {
  /// Excludes attributions below the specified percentile, from the highlighted
  /// areas.
  ///
  /// Defaults to 62.
  core.double? clipPercentLowerbound;

  /// Excludes attributions above the specified percentile from the highlighted
  /// areas.
  ///
  /// Using the clip_percent_upperbound and clip_percent_lowerbound together can
  /// be useful for filtering out noise and making it easier to see areas of
  /// strong attribution. Defaults to 99.9.
  core.double? clipPercentUpperbound;

  /// The color scheme used for the highlighted areas.
  ///
  /// Defaults to PINK_GREEN for Integrated Gradients attribution, which shows
  /// positive attributions in green and negative in pink. Defaults to VIRIDIS
  /// for XRAI attribution, which highlights the most influential regions in
  /// yellow and the least influential in blue.
  /// Possible string values are:
  /// - "COLOR_MAP_UNSPECIFIED" : Should not be used.
  /// - "PINK_GREEN" : Positive: green. Negative: pink.
  /// - "VIRIDIS" : Viridis color map: A perceptually uniform color mapping
  /// which is easier to see by those with colorblindness and progresses from
  /// yellow to green to blue. Positive: yellow. Negative: blue.
  /// - "RED" : Positive: red. Negative: red.
  /// - "GREEN" : Positive: green. Negative: green.
  /// - "RED_GREEN" : Positive: green. Negative: red.
  /// - "PINK_WHITE_GREEN" : PiYG palette.
  core.String? colorMap;

  /// How the original image is displayed in the visualization.
  ///
  /// Adjusting the overlay can help increase visual clarity if the original
  /// image makes it difficult to view the visualization. Defaults to NONE.
  /// Possible string values are:
  /// - "OVERLAY_TYPE_UNSPECIFIED" : Default value. This is the same as NONE.
  /// - "NONE" : No overlay.
  /// - "ORIGINAL" : The attributions are shown on top of the original image.
  /// - "GRAYSCALE" : The attributions are shown on top of grayscaled version of
  /// the original image.
  /// - "MASK_BLACK" : The attributions are used as a mask to reveal predictive
  /// parts of the image and hide the un-predictive parts.
  core.String? overlayType;

  /// Whether to only highlight pixels with positive contributions, negative or
  /// both.
  ///
  /// Defaults to POSITIVE.
  /// Possible string values are:
  /// - "POLARITY_UNSPECIFIED" : Default value. This is the same as POSITIVE.
  /// - "POSITIVE" : Highlights the pixels/outlines that were most influential
  /// to the model's prediction.
  /// - "NEGATIVE" : Setting polarity to negative highlights areas that does not
  /// lead to the models's current prediction.
  /// - "BOTH" : Shows both positive and negative attributions.
  core.String? polarity;

  /// Type of the image visualization.
  ///
  /// Only applicable to Integrated Gradients attribution. OUTLINES shows
  /// regions of attribution, while PIXELS shows per-pixel attribution. Defaults
  /// to OUTLINES.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Should not be used.
  /// - "PIXELS" : Shows which pixel contributed to the image prediction.
  /// - "OUTLINES" : Shows which region contributed to the image prediction by
  /// outlining the region.
  core.String? type;

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization({
    this.clipPercentLowerbound,
    this.clipPercentUpperbound,
    this.colorMap,
    this.overlayType,
    this.polarity,
    this.type,
  });

  GoogleCloudAiplatformV1ExplanationMetadataInputMetadataVisualization.fromJson(
      core.Map json_)
      : this(
          clipPercentLowerbound: json_.containsKey('clipPercentLowerbound')
              ? (json_['clipPercentLowerbound'] as core.num).toDouble()
              : null,
          clipPercentUpperbound: json_.containsKey('clipPercentUpperbound')
              ? (json_['clipPercentUpperbound'] as core.num).toDouble()
              : null,
          colorMap: json_.containsKey('colorMap')
              ? json_['colorMap'] as core.String
              : null,
          overlayType: json_.containsKey('overlayType')
              ? json_['overlayType'] as core.String
              : null,
          polarity: json_.containsKey('polarity')
              ? json_['polarity'] as core.String
              : null,
          type: json_.containsKey('type') ? json_['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clipPercentLowerbound != null)
          'clipPercentLowerbound': clipPercentLowerbound!,
        if (clipPercentUpperbound != null)
          'clipPercentUpperbound': clipPercentUpperbound!,
        if (colorMap != null) 'colorMap': colorMap!,
        if (overlayType != null) 'overlayType': overlayType!,
        if (polarity != null) 'polarity': polarity!,
        if (type != null) 'type': type!,
      };
}

/// Metadata of the prediction output to be explained.
class GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata {
  /// Specify a field name in the prediction to look for the display name.
  ///
  /// Use this if the prediction contains the display names for the outputs. The
  /// display names in the prediction must have the same shape of the outputs,
  /// so that it can be located by Attribution.output_index for a specific
  /// output.
  core.String? displayNameMappingKey;

  /// Static mapping between the index and display name.
  ///
  /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
  /// list of scores of all the classes in a pre-defined order for a
  /// multi-classification Model. It's not feasible if the outputs are
  /// non-deterministic, e.g. the Model produces top-k classes or sort the
  /// outputs by their values. The shape of the value must be an n-dimensional
  /// array of strings. The number of dimensions must match that of the outputs
  /// to be explained. The Attribution.output_display_name is populated by
  /// locating in the mapping with Attribution.output_index.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? indexDisplayNameMapping;

  /// Name of the output tensor.
  ///
  /// Required and is only applicable to Vertex AI provided images for
  /// Tensorflow.
  core.String? outputTensorName;

  GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata({
    this.displayNameMappingKey,
    this.indexDisplayNameMapping,
    this.outputTensorName,
  });

  GoogleCloudAiplatformV1ExplanationMetadataOutputMetadata.fromJson(
      core.Map json_)
      : this(
          displayNameMappingKey: json_.containsKey('displayNameMappingKey')
              ? json_['displayNameMappingKey'] as core.String
              : null,
          indexDisplayNameMapping: json_.containsKey('indexDisplayNameMapping')
              ? json_['indexDisplayNameMapping']
              : null,
          outputTensorName: json_.containsKey('outputTensorName')
              ? json_['outputTensorName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayNameMappingKey != null)
          'displayNameMappingKey': displayNameMappingKey!,
        if (indexDisplayNameMapping != null)
          'indexDisplayNameMapping': indexDisplayNameMapping!,
        if (outputTensorName != null) 'outputTensorName': outputTensorName!,
      };
}

/// The ExplanationMetadata entries that can be overridden at online explanation
/// time.
class GoogleCloudAiplatformV1ExplanationMetadataOverride {
  /// Overrides the input metadata of the features.
  ///
  /// The key is the name of the feature to be overridden. The keys specified
  /// here must exist in the input metadata to be overridden. If a feature is
  /// not specified here, the corresponding feature's input metadata is not
  /// overridden.
  ///
  /// Required.
  core.Map<core.String,
          GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride>?
      inputs;

  GoogleCloudAiplatformV1ExplanationMetadataOverride({
    this.inputs,
  });

  GoogleCloudAiplatformV1ExplanationMetadataOverride.fromJson(core.Map json_)
      : this(
          inputs: json_.containsKey('inputs')
              ? (json_['inputs'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputs != null) 'inputs': inputs!,
      };
}

/// The input metadata entries to be overridden.
class GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride {
  /// Baseline inputs for this feature.
  ///
  /// This overrides the `input_baseline` field of the
  /// ExplanationMetadata.InputMetadata object of the corresponding feature's
  /// input metadata. If it's not specified, the original baselines are not
  /// overridden.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? inputBaselines;

  GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride({
    this.inputBaselines,
  });

  GoogleCloudAiplatformV1ExplanationMetadataOverrideInputMetadataOverride.fromJson(
      core.Map json_)
      : this(
          inputBaselines: json_.containsKey('inputBaselines')
              ? json_['inputBaselines'] as core.List
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputBaselines != null) 'inputBaselines': inputBaselines!,
      };
}

/// Parameters to configure explaining for Model's predictions.
class GoogleCloudAiplatformV1ExplanationParameters {
  /// Example-based explanations that returns the nearest neighbors from the
  /// provided dataset.
  GoogleCloudAiplatformV1Examples? examples;

  /// An attribution method that computes Aumann-Shapley values taking advantage
  /// of the model's fully differentiable structure.
  ///
  /// Refer to this paper for more details: https://arxiv.org/abs/1703.01365
  GoogleCloudAiplatformV1IntegratedGradientsAttribution?
      integratedGradientsAttribution;

  /// If populated, only returns attributions that have output_index contained
  /// in output_indices.
  ///
  /// It must be an ndarray of integers, with the same shape of the output it's
  /// explaining. If not populated, returns attributions for top_k indices of
  /// outputs. If neither top_k nor output_indices is populated, returns the
  /// argmax index of the outputs. Only applicable to Models that predict
  /// multiple outputs (e,g, multi-class Models that predict multiple classes).
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? outputIndices;

  /// An attribution method that approximates Shapley values for features that
  /// contribute to the label being predicted.
  ///
  /// A sampling strategy is used to approximate the value rather than
  /// considering all subsets of features. Refer to this paper for model
  /// details: https://arxiv.org/abs/1306.4265.
  GoogleCloudAiplatformV1SampledShapleyAttribution? sampledShapleyAttribution;

  /// If populated, returns attributions for top K indices of outputs (defaults
  /// to 1).
  ///
  /// Only applies to Models that predicts more than one outputs (e,g,
  /// multi-class Models). When set to -1, returns explanations for all outputs.
  core.int? topK;

  /// An attribution method that redistributes Integrated Gradients attribution
  /// to segmented regions, taking advantage of the model's fully differentiable
  /// structure.
  ///
  /// Refer to this paper for more details: https://arxiv.org/abs/1906.02825
  /// XRAI currently performs better on natural images, like a picture of a
  /// house or an animal. If the images are taken in artificial environments,
  /// like a lab or manufacturing line, or from diagnostic equipment, like
  /// x-rays or quality-control cameras, use Integrated Gradients instead.
  GoogleCloudAiplatformV1XraiAttribution? xraiAttribution;

  GoogleCloudAiplatformV1ExplanationParameters({
    this.examples,
    this.integratedGradientsAttribution,
    this.outputIndices,
    this.sampledShapleyAttribution,
    this.topK,
    this.xraiAttribution,
  });

  GoogleCloudAiplatformV1ExplanationParameters.fromJson(core.Map json_)
      : this(
          examples: json_.containsKey('examples')
              ? GoogleCloudAiplatformV1Examples.fromJson(
                  json_['examples'] as core.Map<core.String, core.dynamic>)
              : null,
          integratedGradientsAttribution: json_
                  .containsKey('integratedGradientsAttribution')
              ? GoogleCloudAiplatformV1IntegratedGradientsAttribution.fromJson(
                  json_['integratedGradientsAttribution']
                      as core.Map<core.String, core.dynamic>)
              : null,
          outputIndices: json_.containsKey('outputIndices')
              ? json_['outputIndices'] as core.List
              : null,
          sampledShapleyAttribution:
              json_.containsKey('sampledShapleyAttribution')
                  ? GoogleCloudAiplatformV1SampledShapleyAttribution.fromJson(
                      json_['sampledShapleyAttribution']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          topK: json_.containsKey('topK') ? json_['topK'] as core.int : null,
          xraiAttribution: json_.containsKey('xraiAttribution')
              ? GoogleCloudAiplatformV1XraiAttribution.fromJson(
                  json_['xraiAttribution']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (examples != null) 'examples': examples!,
        if (integratedGradientsAttribution != null)
          'integratedGradientsAttribution': integratedGradientsAttribution!,
        if (outputIndices != null) 'outputIndices': outputIndices!,
        if (sampledShapleyAttribution != null)
          'sampledShapleyAttribution': sampledShapleyAttribution!,
        if (topK != null) 'topK': topK!,
        if (xraiAttribution != null) 'xraiAttribution': xraiAttribution!,
      };
}

/// Specification of Model explanation.
class GoogleCloudAiplatformV1ExplanationSpec {
  /// Metadata describing the Model's input and output for explanation.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ExplanationMetadata? metadata;

  /// Parameters that configure explaining of the Model's predictions.
  ///
  /// Required.
  GoogleCloudAiplatformV1ExplanationParameters? parameters;

  GoogleCloudAiplatformV1ExplanationSpec({
    this.metadata,
    this.parameters,
  });

  GoogleCloudAiplatformV1ExplanationSpec.fromJson(core.Map json_)
      : this(
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1ExplanationMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1ExplanationParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metadata != null) 'metadata': metadata!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// The ExplanationSpec entries that can be overridden at online explanation
/// time.
class GoogleCloudAiplatformV1ExplanationSpecOverride {
  /// The example-based explanations parameter overrides.
  GoogleCloudAiplatformV1ExamplesOverride? examplesOverride;

  /// The metadata to be overridden.
  ///
  /// If not specified, no metadata is overridden.
  GoogleCloudAiplatformV1ExplanationMetadataOverride? metadata;

  /// The parameters to be overridden.
  ///
  /// Note that the attribution method cannot be changed. If not specified, no
  /// parameter is overridden.
  GoogleCloudAiplatformV1ExplanationParameters? parameters;

  GoogleCloudAiplatformV1ExplanationSpecOverride({
    this.examplesOverride,
    this.metadata,
    this.parameters,
  });

  GoogleCloudAiplatformV1ExplanationSpecOverride.fromJson(core.Map json_)
      : this(
          examplesOverride: json_.containsKey('examplesOverride')
              ? GoogleCloudAiplatformV1ExamplesOverride.fromJson(
                  json_['examplesOverride']
                      as core.Map<core.String, core.dynamic>)
              : null,
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1ExplanationMetadataOverride.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1ExplanationParameters.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (examplesOverride != null) 'examplesOverride': examplesOverride!,
        if (metadata != null) 'metadata': metadata!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Describes what part of the Dataset is to be exported, the destination of the
/// export and how to export.
class GoogleCloudAiplatformV1ExportDataConfig {
  /// An expression for filtering what part of the Dataset is to be exported.
  ///
  /// Only Annotations that match this filter will be exported. The filter
  /// syntax is the same as in ListAnnotations.
  core.String? annotationsFilter;

  /// Split based on fractions defining the size of each set.
  GoogleCloudAiplatformV1ExportFractionSplit? fractionSplit;

  /// The Google Cloud Storage location where the output is to be written to.
  ///
  /// In the given directory a new directory will be created with name:
  /// `export-data--` where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601
  /// format. All export output will be written into that directory. Inside that
  /// directory, annotations with the same schema will be grouped into sub
  /// directories which are named with the corresponding annotations' schema
  /// title. Inside these sub directories, a schema.yaml will be created to
  /// describe the output format.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1ExportDataConfig({
    this.annotationsFilter,
    this.fractionSplit,
    this.gcsDestination,
  });

  GoogleCloudAiplatformV1ExportDataConfig.fromJson(core.Map json_)
      : this(
          annotationsFilter: json_.containsKey('annotationsFilter')
              ? json_['annotationsFilter'] as core.String
              : null,
          fractionSplit: json_.containsKey('fractionSplit')
              ? GoogleCloudAiplatformV1ExportFractionSplit.fromJson(
                  json_['fractionSplit'] as core.Map<core.String, core.dynamic>)
              : null,
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationsFilter != null) 'annotationsFilter': annotationsFilter!,
        if (fractionSplit != null) 'fractionSplit': fractionSplit!,
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
      };
}

/// Request message for DatasetService.ExportData.
class GoogleCloudAiplatformV1ExportDataRequest {
  /// The desired output location.
  ///
  /// Required.
  GoogleCloudAiplatformV1ExportDataConfig? exportConfig;

  GoogleCloudAiplatformV1ExportDataRequest({
    this.exportConfig,
  });

  GoogleCloudAiplatformV1ExportDataRequest.fromJson(core.Map json_)
      : this(
          exportConfig: json_.containsKey('exportConfig')
              ? GoogleCloudAiplatformV1ExportDataConfig.fromJson(
                  json_['exportConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exportConfig != null) 'exportConfig': exportConfig!,
      };
}

/// Request message for FeaturestoreService.ExportFeatureValues.
class GoogleCloudAiplatformV1ExportFeatureValuesRequest {
  /// Specifies destination location and format.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureValueDestination? destination;

  /// Selects Features to export values of.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  /// Exports all historical values of all entities of the EntityType within a
  /// time range
  GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport? fullExport;

  /// Per-Feature export settings.
  core.List<GoogleCloudAiplatformV1DestinationFeatureSetting>? settings;

  /// Exports the latest Feature values of all entities of the EntityType within
  /// a time range.
  GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport?
      snapshotExport;

  GoogleCloudAiplatformV1ExportFeatureValuesRequest({
    this.destination,
    this.featureSelector,
    this.fullExport,
    this.settings,
    this.snapshotExport,
  });

  GoogleCloudAiplatformV1ExportFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          destination: json_.containsKey('destination')
              ? GoogleCloudAiplatformV1FeatureValueDestination.fromJson(
                  json_['destination'] as core.Map<core.String, core.dynamic>)
              : null,
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
          fullExport: json_.containsKey('fullExport')
              ? GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport
                  .fromJson(json_['fullExport']
                      as core.Map<core.String, core.dynamic>)
              : null,
          settings: json_.containsKey('settings')
              ? (json_['settings'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1DestinationFeatureSetting.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          snapshotExport: json_.containsKey('snapshotExport')
              ? GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport
                  .fromJson(json_['snapshotExport']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (destination != null) 'destination': destination!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
        if (fullExport != null) 'fullExport': fullExport!,
        if (settings != null) 'settings': settings!,
        if (snapshotExport != null) 'snapshotExport': snapshotExport!,
      };
}

/// Describes exporting all historical Feature values of all entities of the
/// EntityType between \[start_time, end_time\].
class GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport {
  /// Exports Feature values as of this timestamp.
  ///
  /// If not set, retrieve values as of now. Timestamp, if present, must not
  /// have higher than millisecond precision.
  core.String? endTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  core.String? startTime;

  GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport({
    this.endTime,
    this.startTime,
  });

  GoogleCloudAiplatformV1ExportFeatureValuesRequestFullExport.fromJson(
      core.Map json_)
      : this(
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endTime != null) 'endTime': endTime!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Describes exporting the latest Feature values of all entities of the
/// EntityType between \[start_time, snapshot_time\].
class GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport {
  /// Exports Feature values as of this timestamp.
  ///
  /// If not set, retrieve values as of now. Timestamp, if present, must not
  /// have higher than millisecond precision.
  core.String? snapshotTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp.
  ///
  /// If not set, retrieve oldest values kept in Feature Store. Timestamp, if
  /// present, must not have higher than millisecond precision.
  core.String? startTime;

  GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport({
    this.snapshotTime,
    this.startTime,
  });

  GoogleCloudAiplatformV1ExportFeatureValuesRequestSnapshotExport.fromJson(
      core.Map json_)
      : this(
          snapshotTime: json_.containsKey('snapshotTime')
              ? json_['snapshotTime'] as core.String
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (snapshotTime != null) 'snapshotTime': snapshotTime!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions.
///
/// Any of `training_fraction`, `validation_fraction` and `test_fraction` may
/// optionally be provided, they must sum to up to 1. If the provided ones sum
/// to less than 1, the remainder is assigned to sets as decided by Vertex AI.
/// If none of the fractions are set, by default roughly 80% of data is used for
/// training, 10% for validation, and 10% for test.
typedef GoogleCloudAiplatformV1ExportFractionSplit = $FractionSplit;

/// Request message for ModelService.ExportModel.
class GoogleCloudAiplatformV1ExportModelRequest {
  /// The desired output location and configuration.
  ///
  /// Required.
  GoogleCloudAiplatformV1ExportModelRequestOutputConfig? outputConfig;

  GoogleCloudAiplatformV1ExportModelRequest({
    this.outputConfig,
  });

  GoogleCloudAiplatformV1ExportModelRequest.fromJson(core.Map json_)
      : this(
          outputConfig: json_.containsKey('outputConfig')
              ? GoogleCloudAiplatformV1ExportModelRequestOutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputConfig != null) 'outputConfig': outputConfig!,
      };
}

/// Output configuration for the Model export.
class GoogleCloudAiplatformV1ExportModelRequestOutputConfig {
  /// The Cloud Storage location where the Model artifact is to be written to.
  ///
  /// Under the directory given as the destination a new one with name
  /// "`model-export--`", where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ
  /// ISO-8601 format, will be created. Inside, the Model and any of its
  /// supporting files will be written. This field should only be set when the
  /// `exportableContent` field of the \[Model.supported_export_formats\] object
  /// contains `ARTIFACT`.
  GoogleCloudAiplatformV1GcsDestination? artifactDestination;

  /// The ID of the format in which the Model must be exported.
  ///
  /// Each Model lists the export formats it supports. If no value is provided
  /// here, then the first from the list of the Model's supported formats is
  /// used by default.
  core.String? exportFormatId;

  /// The Google Container Registry or Artifact Registry uri where the Model
  /// container image will be copied to.
  ///
  /// This field should only be set when the `exportableContent` field of the
  /// \[Model.supported_export_formats\] object contains `IMAGE`.
  GoogleCloudAiplatformV1ContainerRegistryDestination? imageDestination;

  GoogleCloudAiplatformV1ExportModelRequestOutputConfig({
    this.artifactDestination,
    this.exportFormatId,
    this.imageDestination,
  });

  GoogleCloudAiplatformV1ExportModelRequestOutputConfig.fromJson(core.Map json_)
      : this(
          artifactDestination: json_.containsKey('artifactDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['artifactDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          exportFormatId: json_.containsKey('exportFormatId')
              ? json_['exportFormatId'] as core.String
              : null,
          imageDestination: json_.containsKey('imageDestination')
              ? GoogleCloudAiplatformV1ContainerRegistryDestination.fromJson(
                  json_['imageDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactDestination != null)
          'artifactDestination': artifactDestination!,
        if (exportFormatId != null) 'exportFormatId': exportFormatId!,
        if (imageDestination != null) 'imageDestination': imageDestination!,
      };
}

/// Request message for TensorboardService.ExportTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest {
  /// Exports the TensorboardTimeSeries' data that match the filter expression.
  core.String? filter;

  /// Field to use to sort the TensorboardTimeSeries' data.
  ///
  /// By default, TensorboardTimeSeries' data is returned in a pseudo random
  /// order.
  core.String? orderBy;

  /// The maximum number of data points to return per page.
  ///
  /// The default page_size is 1000. Values must be between 1 and 10000. Values
  /// above 10000 are coerced to 10000.
  core.int? pageSize;

  /// A page token, received from a previous ExportTensorboardTimeSeriesData
  /// call.
  ///
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to ExportTensorboardTimeSeriesData must match the call
  /// that provided the page token.
  core.String? pageToken;

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest({
    this.filter,
    this.orderBy,
    this.pageSize,
    this.pageToken,
  });

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataRequest.fromJson(
      core.Map json_)
      : this(
          filter: json_.containsKey('filter')
              ? json_['filter'] as core.String
              : null,
          orderBy: json_.containsKey('orderBy')
              ? json_['orderBy'] as core.String
              : null,
          pageSize: json_.containsKey('pageSize')
              ? json_['pageSize'] as core.int
              : null,
          pageToken: json_.containsKey('pageToken')
              ? json_['pageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (orderBy != null) 'orderBy': orderBy!,
        if (pageSize != null) 'pageSize': pageSize!,
        if (pageToken != null) 'pageToken': pageToken!,
      };
}

/// Response message for TensorboardService.ExportTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse {
  /// A token, which can be sent as page_token to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The returned time series data points.
  core.List<GoogleCloudAiplatformV1TimeSeriesDataPoint>? timeSeriesDataPoints;

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse({
    this.nextPageToken,
    this.timeSeriesDataPoints,
  });

  GoogleCloudAiplatformV1ExportTensorboardTimeSeriesDataResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          timeSeriesDataPoints: json_.containsKey('timeSeriesDataPoints')
              ? (json_['timeSeriesDataPoints'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TimeSeriesDataPoint.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (timeSeriesDataPoints != null)
          'timeSeriesDataPoints': timeSeriesDataPoints!,
      };
}

/// Feature Metadata information.
///
/// For example, color is a feature that describes an apple.
class GoogleCloudAiplatformV1Feature {
  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Timestamp when this EntityType was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Feature.
  core.String? description;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// If not set, use the monitoring_config defined for the EntityType this
  /// Feature belongs to. Only Features with type (Feature.ValueType) BOOL,
  /// STRING, DOUBLE or INT64 can enable monitoring. If set to true, all types
  /// of data monitoring are disabled despite the config on EntityType.
  ///
  /// Optional.
  core.bool? disableMonitoring;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Features.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one Feature (System labels
  /// are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// The list of historical stats and anomalies with specified objectives.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly>?
      monitoringStatsAnomalies;

  /// Name of the Feature.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and
  /// a-z, underscore(_), and ASCII digits 0-9 starting with a letter. The value
  /// will be unique given an entity type.
  ///
  /// Immutable.
  core.String? name;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Timestamp when this EntityType was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  ///
  /// Type of Feature value.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "BOOL" : Used for Feature that is a boolean.
  /// - "BOOL_ARRAY" : Used for Feature that is a list of boolean.
  /// - "DOUBLE" : Used for Feature that is double.
  /// - "DOUBLE_ARRAY" : Used for Feature that is a list of double.
  /// - "INT64" : Used for Feature that is INT64.
  /// - "INT64_ARRAY" : Used for Feature that is a list of INT64.
  /// - "STRING" : Used for Feature that is string.
  /// - "STRING_ARRAY" : Used for Feature that is a list of String.
  /// - "BYTES" : Used for Feature that is bytes.
  core.String? valueType;

  GoogleCloudAiplatformV1Feature({
    this.createTime,
    this.description,
    this.disableMonitoring,
    this.etag,
    this.labels,
    this.monitoringStatsAnomalies,
    this.name,
    this.updateTime,
    this.valueType,
  });

  GoogleCloudAiplatformV1Feature.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          disableMonitoring: json_.containsKey('disableMonitoring')
              ? json_['disableMonitoring'] as core.bool
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          monitoringStatsAnomalies: json_
                  .containsKey('monitoringStatsAnomalies')
              ? (json_['monitoringStatsAnomalies'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
          valueType: json_.containsKey('valueType')
              ? json_['valueType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (disableMonitoring != null) 'disableMonitoring': disableMonitoring!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (monitoringStatsAnomalies != null)
          'monitoringStatsAnomalies': monitoringStatsAnomalies!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (valueType != null) 'valueType': valueType!,
      };
}

/// A list of historical SnapshotAnalysis or ImportFeaturesAnalysis stats
/// requested by user, sorted by FeatureStatsAnomaly.start_time descending.
class GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly {
  /// The stats and anomalies generated at specific timestamp.
  ///
  /// Output only.
  GoogleCloudAiplatformV1FeatureStatsAnomaly? featureStatsAnomaly;

  /// The objective for each stats.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "OBJECTIVE_UNSPECIFIED" : If it's OBJECTIVE_UNSPECIFIED,
  /// monitoring_stats will be empty.
  /// - "IMPORT_FEATURE_ANALYSIS" : Stats are generated by Import Feature
  /// Analysis.
  /// - "SNAPSHOT_ANALYSIS" : Stats are generated by Snapshot Analysis.
  core.String? objective;

  GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly({
    this.featureStatsAnomaly,
    this.objective,
  });

  GoogleCloudAiplatformV1FeatureMonitoringStatsAnomaly.fromJson(core.Map json_)
      : this(
          featureStatsAnomaly: json_.containsKey('featureStatsAnomaly')
              ? GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(
                  json_['featureStatsAnomaly']
                      as core.Map<core.String, core.dynamic>)
              : null,
          objective: json_.containsKey('objective')
              ? json_['objective'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureStatsAnomaly != null)
          'featureStatsAnomaly': featureStatsAnomaly!,
        if (objective != null) 'objective': objective!,
      };
}

/// Noise sigma by features.
///
/// Noise sigma represents the standard deviation of the gaussian kernel that
/// will be used to add noise to interpolated inputs prior to computing
/// gradients.
class GoogleCloudAiplatformV1FeatureNoiseSigma {
  /// Noise sigma per feature.
  ///
  /// No noise is added to features that are not set.
  core.List<GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature>?
      noiseSigma;

  GoogleCloudAiplatformV1FeatureNoiseSigma({
    this.noiseSigma,
  });

  GoogleCloudAiplatformV1FeatureNoiseSigma.fromJson(core.Map json_)
      : this(
          noiseSigma: json_.containsKey('noiseSigma')
              ? (json_['noiseSigma'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (noiseSigma != null) 'noiseSigma': noiseSigma!,
      };
}

/// Noise sigma for a single feature.
class GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature {
  /// The name of the input feature for which noise sigma is provided.
  ///
  /// The features are defined in explanation metadata inputs.
  core.String? name;

  /// This represents the standard deviation of the Gaussian kernel that will be
  /// used to add noise to the feature prior to computing gradients.
  ///
  /// Similar to noise_sigma but represents the noise added to the current
  /// feature. Defaults to 0.1.
  core.double? sigma;

  GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature({
    this.name,
    this.sigma,
  });

  GoogleCloudAiplatformV1FeatureNoiseSigmaNoiseSigmaForFeature.fromJson(
      core.Map json_)
      : this(
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          sigma: json_.containsKey('sigma')
              ? (json_['sigma'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (sigma != null) 'sigma': sigma!,
      };
}

/// Selector for Features of an EntityType.
class GoogleCloudAiplatformV1FeatureSelector {
  /// Matches Features based on ID.
  ///
  /// Required.
  GoogleCloudAiplatformV1IdMatcher? idMatcher;

  GoogleCloudAiplatformV1FeatureSelector({
    this.idMatcher,
  });

  GoogleCloudAiplatformV1FeatureSelector.fromJson(core.Map json_)
      : this(
          idMatcher: json_.containsKey('idMatcher')
              ? GoogleCloudAiplatformV1IdMatcher.fromJson(
                  json_['idMatcher'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (idMatcher != null) 'idMatcher': idMatcher!,
      };
}

/// Stats and Anomaly generated at specific timestamp for specific Feature.
///
/// The start_time and end_time are used to define the time range of the dataset
/// that current stats belongs to, e.g. prediction traffic is bucketed into
/// prediction datasets by time window. If the Dataset is not defined by time
/// window, start_time = end_time. Timestamp of the stats and anomalies always
/// refers to end_time. Raw stats and anomalies are stored in stats_uri or
/// anomaly_uri in the tensorflow defined protos. Field data_stats contains
/// almost identical information with the raw stats in Vertex AI defined proto,
/// for UI to display.
class GoogleCloudAiplatformV1FeatureStatsAnomaly {
  /// This is the threshold used when detecting anomalies.
  ///
  /// The threshold can be changed by user, so this one might be different from
  /// ThresholdConfig.value.
  core.double? anomalyDetectionThreshold;

  /// Path of the anomaly file for current feature values in Cloud Storage
  /// bucket.
  ///
  /// Format: gs:////anomalies. Example:
  /// gs://monitoring_bucket/feature_name/anomalies. Stats are stored as binary
  /// format with Protobuf message Anoamlies are stored as binary format with
  /// Protobuf message
  /// [tensorflow.metadata.v0.AnomalyInfo](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto).
  core.String? anomalyUri;

  /// Deviation from the current stats to baseline stats.
  ///
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by Jensen–Shannon divergence.
  core.double? distributionDeviation;

  /// The end timestamp of window where stats were generated.
  ///
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), end_time indicates the timestamp of the data used to
  /// generate stats (e.g. timestamp we take snapshots for feature values).
  core.String? endTime;

  /// Feature importance score, only populated when cross-feature monitoring is
  /// enabled.
  ///
  /// For now only used to represent feature attribution score within range \[0,
  /// 1\] for ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW
  /// and ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT.
  core.double? score;

  /// The start timestamp of window where stats were generated.
  ///
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), start_time is only used to indicate the monitoring
  /// intervals, so it always equals to (end_time - monitoring_interval).
  core.String? startTime;

  /// Path of the stats file for current feature values in Cloud Storage bucket.
  ///
  /// Format: gs:////stats. Example: gs://monitoring_bucket/feature_name/stats.
  /// Stats are stored as binary format with Protobuf message
  /// [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
  core.String? statsUri;

  GoogleCloudAiplatformV1FeatureStatsAnomaly({
    this.anomalyDetectionThreshold,
    this.anomalyUri,
    this.distributionDeviation,
    this.endTime,
    this.score,
    this.startTime,
    this.statsUri,
  });

  GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(core.Map json_)
      : this(
          anomalyDetectionThreshold:
              json_.containsKey('anomalyDetectionThreshold')
                  ? (json_['anomalyDetectionThreshold'] as core.num).toDouble()
                  : null,
          anomalyUri: json_.containsKey('anomalyUri')
              ? json_['anomalyUri'] as core.String
              : null,
          distributionDeviation: json_.containsKey('distributionDeviation')
              ? (json_['distributionDeviation'] as core.num).toDouble()
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          score: json_.containsKey('score')
              ? (json_['score'] as core.num).toDouble()
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          statsUri: json_.containsKey('statsUri')
              ? json_['statsUri'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (anomalyDetectionThreshold != null)
          'anomalyDetectionThreshold': anomalyDetectionThreshold!,
        if (anomalyUri != null) 'anomalyUri': anomalyUri!,
        if (distributionDeviation != null)
          'distributionDeviation': distributionDeviation!,
        if (endTime != null) 'endTime': endTime!,
        if (score != null) 'score': score!,
        if (startTime != null) 'startTime': startTime!,
        if (statsUri != null) 'statsUri': statsUri!,
      };
}

/// Value for a feature.
class GoogleCloudAiplatformV1FeatureValue {
  /// A list of bool type feature value.
  GoogleCloudAiplatformV1BoolArray? boolArrayValue;

  /// Bool type feature value.
  core.bool? boolValue;

  /// Bytes feature value.
  core.String? bytesValue;
  core.List<core.int> get bytesValueAsBytes =>
      convert.base64.decode(bytesValue!);

  set bytesValueAsBytes(core.List<core.int> bytes_) {
    bytesValue =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A list of double type feature value.
  GoogleCloudAiplatformV1DoubleArray? doubleArrayValue;

  /// Double type feature value.
  core.double? doubleValue;

  /// A list of int64 type feature value.
  GoogleCloudAiplatformV1Int64Array? int64ArrayValue;

  /// Int64 feature value.
  core.String? int64Value;

  /// Metadata of feature value.
  GoogleCloudAiplatformV1FeatureValueMetadata? metadata;

  /// A list of string type feature value.
  GoogleCloudAiplatformV1StringArray? stringArrayValue;

  /// String feature value.
  core.String? stringValue;

  GoogleCloudAiplatformV1FeatureValue({
    this.boolArrayValue,
    this.boolValue,
    this.bytesValue,
    this.doubleArrayValue,
    this.doubleValue,
    this.int64ArrayValue,
    this.int64Value,
    this.metadata,
    this.stringArrayValue,
    this.stringValue,
  });

  GoogleCloudAiplatformV1FeatureValue.fromJson(core.Map json_)
      : this(
          boolArrayValue: json_.containsKey('boolArrayValue')
              ? GoogleCloudAiplatformV1BoolArray.fromJson(
                  json_['boolArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          boolValue: json_.containsKey('boolValue')
              ? json_['boolValue'] as core.bool
              : null,
          bytesValue: json_.containsKey('bytesValue')
              ? json_['bytesValue'] as core.String
              : null,
          doubleArrayValue: json_.containsKey('doubleArrayValue')
              ? GoogleCloudAiplatformV1DoubleArray.fromJson(
                  json_['doubleArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          doubleValue: json_.containsKey('doubleValue')
              ? (json_['doubleValue'] as core.num).toDouble()
              : null,
          int64ArrayValue: json_.containsKey('int64ArrayValue')
              ? GoogleCloudAiplatformV1Int64Array.fromJson(
                  json_['int64ArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          int64Value: json_.containsKey('int64Value')
              ? json_['int64Value'] as core.String
              : null,
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1FeatureValueMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          stringArrayValue: json_.containsKey('stringArrayValue')
              ? GoogleCloudAiplatformV1StringArray.fromJson(
                  json_['stringArrayValue']
                      as core.Map<core.String, core.dynamic>)
              : null,
          stringValue: json_.containsKey('stringValue')
              ? json_['stringValue'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (boolArrayValue != null) 'boolArrayValue': boolArrayValue!,
        if (boolValue != null) 'boolValue': boolValue!,
        if (bytesValue != null) 'bytesValue': bytesValue!,
        if (doubleArrayValue != null) 'doubleArrayValue': doubleArrayValue!,
        if (doubleValue != null) 'doubleValue': doubleValue!,
        if (int64ArrayValue != null) 'int64ArrayValue': int64ArrayValue!,
        if (int64Value != null) 'int64Value': int64Value!,
        if (metadata != null) 'metadata': metadata!,
        if (stringArrayValue != null) 'stringArrayValue': stringArrayValue!,
        if (stringValue != null) 'stringValue': stringValue!,
      };
}

/// A destination location for Feature values and format.
class GoogleCloudAiplatformV1FeatureValueDestination {
  /// Output in BigQuery format.
  ///
  /// BigQueryDestination.output_uri in
  /// FeatureValueDestination.bigquery_destination must refer to a table.
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// Output in CSV format.
  ///
  /// Array Feature value types are not allowed in CSV format.
  GoogleCloudAiplatformV1CsvDestination? csvDestination;

  /// Output in TFRecord format.
  ///
  /// Below are the mapping from Feature value type in Featurestore to Feature
  /// value type in TFRecord: Value type in Featurestore | Value type in
  /// TFRecord DOUBLE, DOUBLE_ARRAY | FLOAT_LIST INT64, INT64_ARRAY | INT64_LIST
  /// STRING, STRING_ARRAY, BYTES | BYTES_LIST true -\> byte_string("true"),
  /// false -\> byte_string("false") BOOL, BOOL_ARRAY (true, false) | BYTES_LIST
  GoogleCloudAiplatformV1TFRecordDestination? tfrecordDestination;

  GoogleCloudAiplatformV1FeatureValueDestination({
    this.bigqueryDestination,
    this.csvDestination,
    this.tfrecordDestination,
  });

  GoogleCloudAiplatformV1FeatureValueDestination.fromJson(core.Map json_)
      : this(
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          csvDestination: json_.containsKey('csvDestination')
              ? GoogleCloudAiplatformV1CsvDestination.fromJson(
                  json_['csvDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          tfrecordDestination: json_.containsKey('tfrecordDestination')
              ? GoogleCloudAiplatformV1TFRecordDestination.fromJson(
                  json_['tfrecordDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (csvDestination != null) 'csvDestination': csvDestination!,
        if (tfrecordDestination != null)
          'tfrecordDestination': tfrecordDestination!,
      };
}

/// Container for list of values.
class GoogleCloudAiplatformV1FeatureValueList {
  /// A list of feature values.
  ///
  /// All of them should be the same data type.
  core.List<GoogleCloudAiplatformV1FeatureValue>? values;

  GoogleCloudAiplatformV1FeatureValueList({
    this.values,
  });

  GoogleCloudAiplatformV1FeatureValueList.fromJson(core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1FeatureValue.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Metadata of feature value.
class GoogleCloudAiplatformV1FeatureValueMetadata {
  /// Feature generation timestamp.
  ///
  /// Typically, it is provided by user at feature ingestion time. If not,
  /// feature store will use the system timestamp when the data is ingested into
  /// feature store. For streaming ingestion, the time, aligned by days, must be
  /// no older than five years (1825 days) and no later than one year (366 days)
  /// in the future.
  core.String? generateTime;

  GoogleCloudAiplatformV1FeatureValueMetadata({
    this.generateTime,
  });

  GoogleCloudAiplatformV1FeatureValueMetadata.fromJson(core.Map json_)
      : this(
          generateTime: json_.containsKey('generateTime')
              ? json_['generateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (generateTime != null) 'generateTime': generateTime!,
      };
}

/// Vertex AI Feature Store provides a centralized repository for organizing,
/// storing, and serving ML features.
///
/// The Featurestore is a top-level container for your features and their
/// values.
class GoogleCloudAiplatformV1Featurestore {
  /// Timestamp when this Featurestore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Customer-managed encryption key spec for data storage.
  ///
  /// If set, both of the online and offline data storage will be secured by
  /// this key.
  ///
  /// Optional.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  ///
  /// Optional.
  core.String? etag;

  /// The labels with user-defined metadata to organize your Featurestore.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information on and examples of labels. No
  /// more than 64 user labels can be associated with one Featurestore(System
  /// labels are excluded)." System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  ///
  /// Optional.
  core.Map<core.String, core.String>? labels;

  /// Name of the Featurestore.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  ///
  /// Output only.
  core.String? name;

  /// Config for online storage resources.
  ///
  /// The field should not co-exist with the field of
  /// `OnlineStoreReplicationConfig`. If both of it and
  /// OnlineStoreReplicationConfig are unset, the feature store will not have an
  /// online store and cannot be used for online serving.
  ///
  /// Optional.
  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig? onlineServingConfig;

  /// TTL in days for feature values that will be stored in online serving
  /// storage.
  ///
  /// The Feature Store online storage periodically removes obsolete feature
  /// values older than `online_storage_ttl_days` since the feature generation
  /// time. Note that `online_storage_ttl_days` should be less than or equal to
  /// `offline_storage_ttl_days` for each EntityType under a featurestore. If
  /// not set, default to 4000 days
  ///
  /// Optional.
  core.int? onlineStorageTtlDays;

  /// State of the featurestore.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value. This value is unused.
  /// - "STABLE" : State when the featurestore configuration is not being
  /// updated and the fields reflect the current configuration of the
  /// featurestore. The featurestore is usable in this state.
  /// - "UPDATING" : The state of the featurestore configuration when it is
  /// being updated. During an update, the fields reflect either the original
  /// configuration or the updated configuration of the featurestore. For
  /// example, `online_serving_config.fixed_node_count` can take minutes to
  /// update. While the update is in progress, the featurestore is in the
  /// UPDATING state, and the value of `fixed_node_count` can be the original
  /// value or the updated value, depending on the progress of the operation.
  /// Until the update completes, the actual number of nodes can still be the
  /// original value of `fixed_node_count`. The featurestore is still usable in
  /// this state.
  core.String? state;

  /// Timestamp when this Featurestore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Featurestore({
    this.createTime,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.onlineServingConfig,
    this.onlineStorageTtlDays,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Featurestore.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          onlineServingConfig: json_.containsKey('onlineServingConfig')
              ? GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig.fromJson(
                  json_['onlineServingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          onlineStorageTtlDays: json_.containsKey('onlineStorageTtlDays')
              ? json_['onlineStorageTtlDays'] as core.int
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (onlineServingConfig != null)
          'onlineServingConfig': onlineServingConfig!,
        if (onlineStorageTtlDays != null)
          'onlineStorageTtlDays': onlineStorageTtlDays!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Configuration of how features in Featurestore are monitored.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfig {
  /// Threshold for categorical features of anomaly detection.
  ///
  /// This is shared by all types of Featurestore Monitoring for categorical
  /// features (i.e. Features with type (Feature.ValueType) BOOL or STRING).
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig?
      categoricalThresholdConfig;

  /// The config for ImportFeatures Analysis Based Feature Monitoring.
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis?
      importFeaturesAnalysis;

  /// Threshold for numerical features of anomaly detection.
  ///
  /// This is shared by all objectives of Featurestore Monitoring for numerical
  /// features (i.e. Features with type (Feature.ValueType) DOUBLE or INT64).
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig?
      numericalThresholdConfig;

  /// The config for Snapshot Analysis Based Feature Monitoring.
  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis?
      snapshotAnalysis;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfig({
    this.categoricalThresholdConfig,
    this.importFeaturesAnalysis,
    this.numericalThresholdConfig,
    this.snapshotAnalysis,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfig.fromJson(core.Map json_)
      : this(
          categoricalThresholdConfig: json_
                  .containsKey('categoricalThresholdConfig')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig
                  .fromJson(json_['categoricalThresholdConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          importFeaturesAnalysis: json_.containsKey('importFeaturesAnalysis')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis
                  .fromJson(json_['importFeaturesAnalysis']
                      as core.Map<core.String, core.dynamic>)
              : null,
          numericalThresholdConfig: json_
                  .containsKey('numericalThresholdConfig')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig
                  .fromJson(json_['numericalThresholdConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          snapshotAnalysis: json_.containsKey('snapshotAnalysis')
              ? GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis
                  .fromJson(json_['snapshotAnalysis']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (categoricalThresholdConfig != null)
          'categoricalThresholdConfig': categoricalThresholdConfig!,
        if (importFeaturesAnalysis != null)
          'importFeaturesAnalysis': importFeaturesAnalysis!,
        if (numericalThresholdConfig != null)
          'numericalThresholdConfig': numericalThresholdConfig!,
        if (snapshotAnalysis != null) 'snapshotAnalysis': snapshotAnalysis!,
      };
}

/// Configuration of the Featurestore's ImportFeature Analysis Based Monitoring.
///
/// This type of analysis generates statistics for values of each Feature
/// imported by every ImportFeatureValues operation.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis {
  /// The baseline used to do anomaly detection for the statistics generated by
  /// import features analysis.
  /// Possible string values are:
  /// - "BASELINE_UNSPECIFIED" : Should not be used.
  /// - "LATEST_STATS" : Choose the later one statistics generated by either
  /// most recent snapshot analysis or previous import features analysis. If non
  /// of them exists, skip anomaly detection and only generate a statistics.
  /// - "MOST_RECENT_SNAPSHOT_STATS" : Use the statistics generated by the most
  /// recent snapshot analysis if exists.
  /// - "PREVIOUS_IMPORT_FEATURES_STATS" : Use the statistics generated by the
  /// previous import features analysis if exists.
  core.String? anomalyDetectionBaseline;

  /// Whether to enable / disable / inherite default hebavior for import
  /// features analysis.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Should not be used.
  /// - "DEFAULT" : The default behavior of whether to enable the monitoring.
  /// EntityType-level config: disabled. Feature-level config: inherited from
  /// the configuration of EntityType this Feature belongs to.
  /// - "ENABLED" : Explicitly enables import features analysis.
  /// EntityType-level config: by default enables import features analysis for
  /// all Features under it. Feature-level config: enables import features
  /// analysis regardless of the EntityType-level config.
  /// - "DISABLED" : Explicitly disables import features analysis.
  /// EntityType-level config: by default disables import features analysis for
  /// all Features under it. Feature-level config: disables import features
  /// analysis regardless of the EntityType-level config.
  core.String? state;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis({
    this.anomalyDetectionBaseline,
    this.state,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigImportFeaturesAnalysis.fromJson(
      core.Map json_)
      : this(
          anomalyDetectionBaseline:
              json_.containsKey('anomalyDetectionBaseline')
                  ? json_['anomalyDetectionBaseline'] as core.String
                  : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (anomalyDetectionBaseline != null)
          'anomalyDetectionBaseline': anomalyDetectionBaseline!,
        if (state != null) 'state': state!,
      };
}

/// Configuration of the Featurestore's Snapshot Analysis Based Monitoring.
///
/// This type of analysis generates statistics for each Feature based on a
/// snapshot of the latest feature value of each entities every
/// monitoring_interval.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis {
  /// The monitoring schedule for snapshot analysis.
  ///
  /// For EntityType-level config: unset / disabled = true indicates disabled by
  /// default for Features under it; otherwise by default enable snapshot
  /// analysis monitoring with monitoring_interval for Features under it.
  /// Feature-level config: disabled = true indicates disabled regardless of the
  /// EntityType-level config; unset monitoring_interval indicates going with
  /// EntityType-level config; otherwise run snapshot analysis monitoring with
  /// monitoring_interval regardless of the EntityType-level config. Explicitly
  /// Disable the snapshot analysis based monitoring.
  core.bool? disabled;

  /// Configuration of the snapshot analysis based monitoring pipeline running
  /// interval.
  ///
  /// The value indicates number of days.
  core.int? monitoringIntervalDays;

  /// Customized export features time window for snapshot analysis.
  ///
  /// Unit is one day. Default value is 3 weeks. Minimum value is 1 day. Maximum
  /// value is 4000 days.
  core.int? stalenessDays;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis({
    this.disabled,
    this.monitoringIntervalDays,
    this.stalenessDays,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigSnapshotAnalysis.fromJson(
      core.Map json_)
      : this(
          disabled: json_.containsKey('disabled')
              ? json_['disabled'] as core.bool
              : null,
          monitoringIntervalDays: json_.containsKey('monitoringIntervalDays')
              ? json_['monitoringIntervalDays'] as core.int
              : null,
          stalenessDays: json_.containsKey('stalenessDays')
              ? json_['stalenessDays'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disabled != null) 'disabled': disabled!,
        if (monitoringIntervalDays != null)
          'monitoringIntervalDays': monitoringIntervalDays!,
        if (stalenessDays != null) 'stalenessDays': stalenessDays!,
      };
}

/// The config for Featurestore Monitoring threshold.
class GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig {
  /// Specify a threshold value that can trigger the alert.
  ///
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by Jensen–Shannon divergence. Each feature must have a non-zero
  /// threshold if they need to be monitored. Otherwise no alert will be
  /// triggered for that feature.
  core.double? value;

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig({
    this.value,
  });

  GoogleCloudAiplatformV1FeaturestoreMonitoringConfigThresholdConfig.fromJson(
      core.Map json_)
      : this(
          value: json_.containsKey('value')
              ? (json_['value'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
      };
}

/// OnlineServingConfig specifies the details for provisioning online serving
/// resources.
class GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig {
  /// The number of nodes for the online store.
  ///
  /// The number of nodes doesn't scale automatically, but you can manually
  /// update the number of nodes. If set to 0, the featurestore will not have an
  /// online store and cannot be used for online serving.
  core.int? fixedNodeCount;

  /// Online serving scaling configuration.
  ///
  /// Only one of `fixed_node_count` and `scaling` can be set. Setting one will
  /// reset the other.
  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling? scaling;

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig({
    this.fixedNodeCount,
    this.scaling,
  });

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfig.fromJson(
      core.Map json_)
      : this(
          fixedNodeCount: json_.containsKey('fixedNodeCount')
              ? json_['fixedNodeCount'] as core.int
              : null,
          scaling: json_.containsKey('scaling')
              ? GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling
                  .fromJson(
                      json_['scaling'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (fixedNodeCount != null) 'fixedNodeCount': fixedNodeCount!,
        if (scaling != null) 'scaling': scaling!,
      };
}

/// Online serving scaling configuration.
///
/// If min_node_count and max_node_count are set to the same value, the cluster
/// will be configured with the fixed number of node (no auto-scaling).
class GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling {
  /// The cpu utilization that the Autoscaler should be trying to achieve.
  ///
  /// This number is on a scale from 0 (no utilization) to 100 (total
  /// utilization), and is limited between 10 and 80. When a cluster's CPU
  /// utilization exceeds the target that you have set, Bigtable immediately
  /// adds nodes to the cluster. When CPU utilization is substantially lower
  /// than the target, Bigtable removes nodes. If not set or set to 0, default
  /// to 50.
  ///
  /// Optional.
  core.int? cpuUtilizationTarget;

  /// The maximum number of nodes to scale up to.
  ///
  /// Must be greater than min_node_count, and less than or equal to 10 times of
  /// 'min_node_count'.
  core.int? maxNodeCount;

  /// The minimum number of nodes to scale down to.
  ///
  /// Must be greater than or equal to 1.
  ///
  /// Required.
  core.int? minNodeCount;

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling({
    this.cpuUtilizationTarget,
    this.maxNodeCount,
    this.minNodeCount,
  });

  GoogleCloudAiplatformV1FeaturestoreOnlineServingConfigScaling.fromJson(
      core.Map json_)
      : this(
          cpuUtilizationTarget: json_.containsKey('cpuUtilizationTarget')
              ? json_['cpuUtilizationTarget'] as core.int
              : null,
          maxNodeCount: json_.containsKey('maxNodeCount')
              ? json_['maxNodeCount'] as core.int
              : null,
          minNodeCount: json_.containsKey('minNodeCount')
              ? json_['minNodeCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (cpuUtilizationTarget != null)
          'cpuUtilizationTarget': cpuUtilizationTarget!,
        if (maxNodeCount != null) 'maxNodeCount': maxNodeCount!,
        if (minNodeCount != null) 'minNodeCount': minNodeCount!,
      };
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored.
///
/// Currently only supported for Datasets containing DataItems. If any of the
/// filters in this message are to match nothing, then they can be set as '-'
/// (the minus sign). Supported only for unstructured Datasets.
class GoogleCloudAiplatformV1FilterSplit {
  /// A filter on DataItems of the Dataset.
  ///
  /// DataItems that match this filter are used to test the Model. A filter with
  /// same syntax as the one used in DatasetService.ListDataItems may be used.
  /// If a single DataItem is matched by more than one of the FilterSplit
  /// filters, then it is assigned to the first set that applies to it in the
  /// training, validation, test order.
  ///
  /// Required.
  core.String? testFilter;

  /// A filter on DataItems of the Dataset.
  ///
  /// DataItems that match this filter are used to train the Model. A filter
  /// with same syntax as the one used in DatasetService.ListDataItems may be
  /// used. If a single DataItem is matched by more than one of the FilterSplit
  /// filters, then it is assigned to the first set that applies to it in the
  /// training, validation, test order.
  ///
  /// Required.
  core.String? trainingFilter;

  /// A filter on DataItems of the Dataset.
  ///
  /// DataItems that match this filter are used to validate the Model. A filter
  /// with same syntax as the one used in DatasetService.ListDataItems may be
  /// used. If a single DataItem is matched by more than one of the FilterSplit
  /// filters, then it is assigned to the first set that applies to it in the
  /// training, validation, test order.
  ///
  /// Required.
  core.String? validationFilter;

  GoogleCloudAiplatformV1FilterSplit({
    this.testFilter,
    this.trainingFilter,
    this.validationFilter,
  });

  GoogleCloudAiplatformV1FilterSplit.fromJson(core.Map json_)
      : this(
          testFilter: json_.containsKey('testFilter')
              ? json_['testFilter'] as core.String
              : null,
          trainingFilter: json_.containsKey('trainingFilter')
              ? json_['trainingFilter'] as core.String
              : null,
          validationFilter: json_.containsKey('validationFilter')
              ? json_['validationFilter'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (testFilter != null) 'testFilter': testFilter!,
        if (trainingFilter != null) 'trainingFilter': trainingFilter!,
        if (validationFilter != null) 'validationFilter': validationFilter!,
      };
}

/// The request message for MatchService.FindNeighbors.
class GoogleCloudAiplatformV1FindNeighborsRequest {
  /// The ID of the DeployedIndex that will serve the request.
  ///
  /// This request is sent to a specific IndexEndpoint, as per the
  /// IndexEndpoint.network. That IndexEndpoint also has
  /// IndexEndpoint.deployed_indexes, and each such index has a DeployedIndex.id
  /// field. The value of the field below must equal one of the DeployedIndex.id
  /// fields of the IndexEndpoint that is being called for this request.
  core.String? deployedIndexId;

  /// The list of queries.
  core.List<GoogleCloudAiplatformV1FindNeighborsRequestQuery>? queries;

  /// If set to true, the full datapoints (including all vector values and
  /// restricts) of the nearest neighbors are returned.
  ///
  /// Note that returning full datapoint will significantly increase the latency
  /// and cost of the query.
  core.bool? returnFullDatapoint;

  GoogleCloudAiplatformV1FindNeighborsRequest({
    this.deployedIndexId,
    this.queries,
    this.returnFullDatapoint,
  });

  GoogleCloudAiplatformV1FindNeighborsRequest.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_.containsKey('deployedIndexId')
              ? json_['deployedIndexId'] as core.String
              : null,
          queries: json_.containsKey('queries')
              ? (json_['queries'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1FindNeighborsRequestQuery.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          returnFullDatapoint: json_.containsKey('returnFullDatapoint')
              ? json_['returnFullDatapoint'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
        if (queries != null) 'queries': queries!,
        if (returnFullDatapoint != null)
          'returnFullDatapoint': returnFullDatapoint!,
      };
}

/// A query to find a number of the nearest neighbors (most similar vectors) of
/// a vector.
class GoogleCloudAiplatformV1FindNeighborsRequestQuery {
  /// The number of neighbors to find via approximate search before exact
  /// reordering is performed.
  ///
  /// If not set, the default value from scam config is used; if set, this value
  /// must be \> 0.
  core.int? approximateNeighborCount;

  /// The datapoint/vector whose nearest neighbors should be searched for.
  ///
  /// Required.
  GoogleCloudAiplatformV1IndexDatapoint? datapoint;

  /// The fraction of the number of leaves to search, set at query time allows
  /// user to tune search performance.
  ///
  /// This value increase result in both search accuracy and latency increase.
  /// The value should be between 0.0 and 1.0. If not set or set to 0.0, query
  /// uses the default value specified in
  /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
  core.double? fractionLeafNodesToSearchOverride;

  /// The number of nearest neighbors to be retrieved from database for each
  /// query.
  ///
  /// If not set, will use the default from the service configuration
  /// (https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config).
  core.int? neighborCount;

  /// Crowding is a constraint on a neighbor list produced by nearest neighbor
  /// search requiring that no more than some value k' of the k neighbors
  /// returned have the same value of crowding_attribute.
  ///
  /// It's used for improving result diversity. This field is the maximum number
  /// of matches with the same crowding tag.
  core.int? perCrowdingAttributeNeighborCount;

  GoogleCloudAiplatformV1FindNeighborsRequestQuery({
    this.approximateNeighborCount,
    this.datapoint,
    this.fractionLeafNodesToSearchOverride,
    this.neighborCount,
    this.perCrowdingAttributeNeighborCount,
  });

  GoogleCloudAiplatformV1FindNeighborsRequestQuery.fromJson(core.Map json_)
      : this(
          approximateNeighborCount:
              json_.containsKey('approximateNeighborCount')
                  ? json_['approximateNeighborCount'] as core.int
                  : null,
          datapoint: json_.containsKey('datapoint')
              ? GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                  json_['datapoint'] as core.Map<core.String, core.dynamic>)
              : null,
          fractionLeafNodesToSearchOverride:
              json_.containsKey('fractionLeafNodesToSearchOverride')
                  ? (json_['fractionLeafNodesToSearchOverride'] as core.num)
                      .toDouble()
                  : null,
          neighborCount: json_.containsKey('neighborCount')
              ? json_['neighborCount'] as core.int
              : null,
          perCrowdingAttributeNeighborCount:
              json_.containsKey('perCrowdingAttributeNeighborCount')
                  ? json_['perCrowdingAttributeNeighborCount'] as core.int
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (approximateNeighborCount != null)
          'approximateNeighborCount': approximateNeighborCount!,
        if (datapoint != null) 'datapoint': datapoint!,
        if (fractionLeafNodesToSearchOverride != null)
          'fractionLeafNodesToSearchOverride':
              fractionLeafNodesToSearchOverride!,
        if (neighborCount != null) 'neighborCount': neighborCount!,
        if (perCrowdingAttributeNeighborCount != null)
          'perCrowdingAttributeNeighborCount':
              perCrowdingAttributeNeighborCount!,
      };
}

/// The response message for MatchService.FindNeighbors.
class GoogleCloudAiplatformV1FindNeighborsResponse {
  /// The nearest neighbors of the query datapoints.
  core.List<GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors>?
      nearestNeighbors;

  GoogleCloudAiplatformV1FindNeighborsResponse({
    this.nearestNeighbors,
  });

  GoogleCloudAiplatformV1FindNeighborsResponse.fromJson(core.Map json_)
      : this(
          nearestNeighbors: json_.containsKey('nearestNeighbors')
              ? (json_['nearestNeighbors'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nearestNeighbors != null) 'nearestNeighbors': nearestNeighbors!,
      };
}

/// Nearest neighbors for one query.
class GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors {
  /// The ID of the query datapoint.
  core.String? id;

  /// All its neighbors.
  core.List<GoogleCloudAiplatformV1FindNeighborsResponseNeighbor>? neighbors;

  GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors({
    this.id,
    this.neighbors,
  });

  GoogleCloudAiplatformV1FindNeighborsResponseNearestNeighbors.fromJson(
      core.Map json_)
      : this(
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
          neighbors: json_.containsKey('neighbors')
              ? (json_['neighbors'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1FindNeighborsResponseNeighbor
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (neighbors != null) 'neighbors': neighbors!,
      };
}

/// A neighbor of the query vector.
class GoogleCloudAiplatformV1FindNeighborsResponseNeighbor {
  /// The datapoint of the neighbor.
  ///
  /// Note that full datapoints are returned only when "return_full_datapoint"
  /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
  /// fields are populated.
  GoogleCloudAiplatformV1IndexDatapoint? datapoint;

  /// The distance between the neighbor and the query vector.
  core.double? distance;

  GoogleCloudAiplatformV1FindNeighborsResponseNeighbor({
    this.datapoint,
    this.distance,
  });

  GoogleCloudAiplatformV1FindNeighborsResponseNeighbor.fromJson(core.Map json_)
      : this(
          datapoint: json_.containsKey('datapoint')
              ? GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                  json_['datapoint'] as core.Map<core.String, core.dynamic>)
              : null,
          distance: json_.containsKey('distance')
              ? (json_['distance'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapoint != null) 'datapoint': datapoint!,
        if (distance != null) 'distance': distance!,
      };
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions.
///
/// Any of `training_fraction`, `validation_fraction` and `test_fraction` may
/// optionally be provided, they must sum to up to 1. If the provided ones sum
/// to less than 1, the remainder is assigned to sets as decided by Vertex AI.
/// If none of the fractions are set, by default roughly 80% of data is used for
/// training, 10% for validation, and 10% for test.
typedef GoogleCloudAiplatformV1FractionSplit = $FractionSplit;

/// The Google Cloud Storage location where the output is to be written to.
class GoogleCloudAiplatformV1GcsDestination {
  /// Google Cloud Storage URI to output directory.
  ///
  /// If the uri doesn't end with '/', a '/' will be automatically appended. The
  /// directory is created if it doesn't exist.
  ///
  /// Required.
  core.String? outputUriPrefix;

  GoogleCloudAiplatformV1GcsDestination({
    this.outputUriPrefix,
  });

  GoogleCloudAiplatformV1GcsDestination.fromJson(core.Map json_)
      : this(
          outputUriPrefix: json_.containsKey('outputUriPrefix')
              ? json_['outputUriPrefix'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputUriPrefix != null) 'outputUriPrefix': outputUriPrefix!,
      };
}

/// The Google Cloud Storage location for the input content.
class GoogleCloudAiplatformV1GcsSource {
  /// Google Cloud Storage URI(-s) to the input file(s).
  ///
  /// May contain wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames.
  ///
  /// Required.
  core.List<core.String>? uris;

  GoogleCloudAiplatformV1GcsSource({
    this.uris,
  });

  GoogleCloudAiplatformV1GcsSource.fromJson(core.Map json_)
      : this(
          uris: json_.containsKey('uris')
              ? (json_['uris'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (uris != null) 'uris': uris!,
      };
}

/// Represents a HyperparameterTuningJob.
///
/// A HyperparameterTuningJob has a Study specification and multiple CustomJobs
/// with identical CustomJob specification.
class GoogleCloudAiplatformV1HyperparameterTuningJob {
  /// Time when the HyperparameterTuningJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the HyperparameterTuningJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key options for a HyperparameterTuningJob.
  ///
  /// If this is set, then all resources created by the HyperparameterTuningJob
  /// will be encrypted with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the HyperparameterTuningJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize
  /// HyperparameterTuningJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The number of failed Trials that need to be seen before failing the
  /// HyperparameterTuningJob.
  ///
  /// If set to 0, Vertex AI decides how many Trials must fail before the whole
  /// job fails.
  core.int? maxFailedTrialCount;

  /// The desired total number of Trials.
  ///
  /// Required.
  core.int? maxTrialCount;

  /// Resource name of the HyperparameterTuningJob.
  ///
  /// Output only.
  core.String? name;

  /// The desired number of Trials to run in parallel.
  ///
  /// Required.
  core.int? parallelTrialCount;

  /// Time when the HyperparameterTuningJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Study configuration of the HyperparameterTuningJob.
  ///
  /// Required.
  GoogleCloudAiplatformV1StudySpec? studySpec;

  /// The spec of a trial job.
  ///
  /// The same spec applies to the CustomJobs created in all the trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? trialJobSpec;

  /// Trials of the HyperparameterTuningJob.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Trial>? trials;

  /// Time when the HyperparameterTuningJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1HyperparameterTuningJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.labels,
    this.maxFailedTrialCount,
    this.maxTrialCount,
    this.name,
    this.parallelTrialCount,
    this.startTime,
    this.state,
    this.studySpec,
    this.trialJobSpec,
    this.trials,
    this.updateTime,
  });

  GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          maxFailedTrialCount: json_.containsKey('maxFailedTrialCount')
              ? json_['maxFailedTrialCount'] as core.int
              : null,
          maxTrialCount: json_.containsKey('maxTrialCount')
              ? json_['maxTrialCount'] as core.int
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          parallelTrialCount: json_.containsKey('parallelTrialCount')
              ? json_['parallelTrialCount'] as core.int
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          studySpec: json_.containsKey('studySpec')
              ? GoogleCloudAiplatformV1StudySpec.fromJson(
                  json_['studySpec'] as core.Map<core.String, core.dynamic>)
              : null,
          trialJobSpec: json_.containsKey('trialJobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['trialJobSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          trials: json_.containsKey('trials')
              ? (json_['trials'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Trial.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (labels != null) 'labels': labels!,
        if (maxFailedTrialCount != null)
          'maxFailedTrialCount': maxFailedTrialCount!,
        if (maxTrialCount != null) 'maxTrialCount': maxTrialCount!,
        if (name != null) 'name': name!,
        if (parallelTrialCount != null)
          'parallelTrialCount': parallelTrialCount!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (studySpec != null) 'studySpec': studySpec!,
        if (trialJobSpec != null) 'trialJobSpec': trialJobSpec!,
        if (trials != null) 'trials': trials!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Matcher for Features of an EntityType by Feature ID.
class GoogleCloudAiplatformV1IdMatcher {
  /// The following are accepted as `ids`: * A single-element list containing
  /// only `*`, which selects all Features in the target EntityType, or * A list
  /// containing only Feature IDs, which selects only Features with those IDs in
  /// the target EntityType.
  ///
  /// Required.
  core.List<core.String>? ids;

  GoogleCloudAiplatformV1IdMatcher({
    this.ids,
  });

  GoogleCloudAiplatformV1IdMatcher.fromJson(core.Map json_)
      : this(
          ids: json_.containsKey('ids')
              ? (json_['ids'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (ids != null) 'ids': ids!,
      };
}

/// Describes the location from where we import data into a Dataset, together
/// with the labels that will be applied to the DataItems and the Annotations.
class GoogleCloudAiplatformV1ImportDataConfig {
  /// Labels that will be applied to newly imported Annotations.
  ///
  /// If two Annotations are identical, one of them will be deduped. Two
  /// Annotations are considered identical if their payload, payload_schema_uri
  /// and all of their labels are the same. These labels will be overridden by
  /// Annotation labels specified inside index file referenced by
  /// import_schema_uri, e.g. jsonl file.
  core.Map<core.String, core.String>? annotationLabels;

  /// Labels that will be applied to newly imported DataItems.
  ///
  /// If an identical DataItem as one being imported already exists in the
  /// Dataset, then these labels will be appended to these of the already
  /// existing one, and if labels with identical key is imported before, the old
  /// label value will be overwritten. If two DataItems are identical in the
  /// same import data operation, the labels will be combined and if key
  /// collision happens in this case, one of the values will be picked randomly.
  /// Two DataItems are considered identical if their content bytes are
  /// identical (e.g. image bytes or pdf bytes). These labels will be overridden
  /// by Annotation labels specified inside index file referenced by
  /// import_schema_uri, e.g. jsonl file.
  core.Map<core.String, core.String>? dataItemLabels;

  /// The Google Cloud Storage location for the input content.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// Points to a YAML file stored on Google Cloud Storage describing the import
  /// format.
  ///
  /// Validation will be done against the schema. The schema is defined as an
  /// [OpenAPI 3.0.2 Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  ///
  /// Required.
  core.String? importSchemaUri;

  GoogleCloudAiplatformV1ImportDataConfig({
    this.annotationLabels,
    this.dataItemLabels,
    this.gcsSource,
    this.importSchemaUri,
  });

  GoogleCloudAiplatformV1ImportDataConfig.fromJson(core.Map json_)
      : this(
          annotationLabels: json_.containsKey('annotationLabels')
              ? (json_['annotationLabels']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          dataItemLabels: json_.containsKey('dataItemLabels')
              ? (json_['dataItemLabels'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          importSchemaUri: json_.containsKey('importSchemaUri')
              ? json_['importSchemaUri'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationLabels != null) 'annotationLabels': annotationLabels!,
        if (dataItemLabels != null) 'dataItemLabels': dataItemLabels!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (importSchemaUri != null) 'importSchemaUri': importSchemaUri!,
      };
}

/// Request message for DatasetService.ImportData.
class GoogleCloudAiplatformV1ImportDataRequest {
  /// The desired input locations.
  ///
  /// The contents of all input locations will be imported in one batch.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ImportDataConfig>? importConfigs;

  GoogleCloudAiplatformV1ImportDataRequest({
    this.importConfigs,
  });

  GoogleCloudAiplatformV1ImportDataRequest.fromJson(core.Map json_)
      : this(
          importConfigs: json_.containsKey('importConfigs')
              ? (json_['importConfigs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ImportDataConfig.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (importConfigs != null) 'importConfigs': importConfigs!,
      };
}

/// Request message for FeaturestoreService.ImportFeatureValues.
class GoogleCloudAiplatformV1ImportFeatureValuesRequest {
  GoogleCloudAiplatformV1AvroSource? avroSource;
  GoogleCloudAiplatformV1BigQuerySource? bigquerySource;
  GoogleCloudAiplatformV1CsvSource? csvSource;

  /// If true, API doesn't start ingestion analysis pipeline.
  core.bool? disableIngestionAnalysis;

  /// If set, data will not be imported for online serving.
  ///
  /// This is typically used for backfilling, where Feature generation
  /// timestamps are not in the timestamp range needed for online serving.
  core.bool? disableOnlineServing;

  /// Source column that holds entity IDs.
  ///
  /// If not provided, entity IDs are extracted from the column named entity_id.
  core.String? entityIdField;

  /// Specifications defining which Feature values to import from the entity.
  ///
  /// The request fails if no feature_specs are provided, and having multiple
  /// feature_specs for one Feature is not allowed.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec>?
      featureSpecs;

  /// Single Feature timestamp for all entities being imported.
  ///
  /// The timestamp must not have higher than millisecond precision.
  core.String? featureTime;

  /// Source column that holds the Feature timestamp for all Feature values in
  /// each entity.
  core.String? featureTimeField;

  /// Specifies the number of workers that are used to write data to the
  /// Featurestore.
  ///
  /// Consider the online serving capacity that you require to achieve the
  /// desired import throughput without interfering with online serving. The
  /// value must be positive, and less than or equal to 100. If not set,
  /// defaults to using 1 worker. The low count ensures minimal impact on online
  /// serving performance.
  core.int? workerCount;

  GoogleCloudAiplatformV1ImportFeatureValuesRequest({
    this.avroSource,
    this.bigquerySource,
    this.csvSource,
    this.disableIngestionAnalysis,
    this.disableOnlineServing,
    this.entityIdField,
    this.featureSpecs,
    this.featureTime,
    this.featureTimeField,
    this.workerCount,
  });

  GoogleCloudAiplatformV1ImportFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          avroSource: json_.containsKey('avroSource')
              ? GoogleCloudAiplatformV1AvroSource.fromJson(
                  json_['avroSource'] as core.Map<core.String, core.dynamic>)
              : null,
          bigquerySource: json_.containsKey('bigquerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          csvSource: json_.containsKey('csvSource')
              ? GoogleCloudAiplatformV1CsvSource.fromJson(
                  json_['csvSource'] as core.Map<core.String, core.dynamic>)
              : null,
          disableIngestionAnalysis:
              json_.containsKey('disableIngestionAnalysis')
                  ? json_['disableIngestionAnalysis'] as core.bool
                  : null,
          disableOnlineServing: json_.containsKey('disableOnlineServing')
              ? json_['disableOnlineServing'] as core.bool
              : null,
          entityIdField: json_.containsKey('entityIdField')
              ? json_['entityIdField'] as core.String
              : null,
          featureSpecs: json_.containsKey('featureSpecs')
              ? (json_['featureSpecs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          featureTime: json_.containsKey('featureTime')
              ? json_['featureTime'] as core.String
              : null,
          featureTimeField: json_.containsKey('featureTimeField')
              ? json_['featureTimeField'] as core.String
              : null,
          workerCount: json_.containsKey('workerCount')
              ? json_['workerCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (avroSource != null) 'avroSource': avroSource!,
        if (bigquerySource != null) 'bigquerySource': bigquerySource!,
        if (csvSource != null) 'csvSource': csvSource!,
        if (disableIngestionAnalysis != null)
          'disableIngestionAnalysis': disableIngestionAnalysis!,
        if (disableOnlineServing != null)
          'disableOnlineServing': disableOnlineServing!,
        if (entityIdField != null) 'entityIdField': entityIdField!,
        if (featureSpecs != null) 'featureSpecs': featureSpecs!,
        if (featureTime != null) 'featureTime': featureTime!,
        if (featureTimeField != null) 'featureTimeField': featureTimeField!,
        if (workerCount != null) 'workerCount': workerCount!,
      };
}

/// Defines the Feature value(s) to import.
class GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec {
  /// ID of the Feature to import values of.
  ///
  /// This Feature must exist in the target EntityType, or the request will
  /// fail.
  ///
  /// Required.
  core.String? id;

  /// Source column to get the Feature values from.
  ///
  /// If not set, uses the column with the same name as the Feature ID.
  core.String? sourceField;

  GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec({
    this.id,
    this.sourceField,
  });

  GoogleCloudAiplatformV1ImportFeatureValuesRequestFeatureSpec.fromJson(
      core.Map json_)
      : this(
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
          sourceField: json_.containsKey('sourceField')
              ? json_['sourceField'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
        if (sourceField != null) 'sourceField': sourceField!,
      };
}

/// Request message for ModelService.ImportModelEvaluation
class GoogleCloudAiplatformV1ImportModelEvaluationRequest {
  /// Model evaluation resource to be imported.
  ///
  /// Required.
  GoogleCloudAiplatformV1ModelEvaluation? modelEvaluation;

  GoogleCloudAiplatformV1ImportModelEvaluationRequest({
    this.modelEvaluation,
  });

  GoogleCloudAiplatformV1ImportModelEvaluationRequest.fromJson(core.Map json_)
      : this(
          modelEvaluation: json_.containsKey('modelEvaluation')
              ? GoogleCloudAiplatformV1ModelEvaluation.fromJson(
                  json_['modelEvaluation']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelEvaluation != null) 'modelEvaluation': modelEvaluation!,
      };
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
class GoogleCloudAiplatformV1Index {
  /// Timestamp when this Index was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The pointers to DeployedIndexes created from this Index.
  ///
  /// An Index can be only deleted if all its DeployedIndexes had been
  /// undeployed first.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedIndexRef>? deployedIndexes;

  /// The description of the Index.
  core.String? description;

  /// The display name of the Index.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for an Index.
  ///
  /// If set, this Index and all sub-resources of this Index will be secured by
  /// this key.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Stats of the index resource.
  ///
  /// Output only.
  GoogleCloudAiplatformV1IndexStats? indexStats;

  /// The update method to use with this Index.
  ///
  /// If not set, BATCH_UPDATE will be used by default.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "INDEX_UPDATE_METHOD_UNSPECIFIED" : Should not be used.
  /// - "BATCH_UPDATE" : BatchUpdate: user can call UpdateIndex with files on
  /// Cloud Storage of Datapoints to update.
  /// - "STREAM_UPDATE" : StreamUpdate: user can call
  /// UpsertDatapoints/DeleteDatapoints to update the Index and the updates will
  /// be applied in corresponding DeployedIndexes in nearly real-time.
  core.String? indexUpdateMethod;

  /// The labels with user-defined metadata to organize your Indexes.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// An additional information about the Index; the schema of the metadata can
  /// be found in metadata_schema.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Index, that is specific to it.
  ///
  /// Unset if the Index does not have any additional information. The schema is
  /// defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  ///
  /// Immutable.
  core.String? metadataSchemaUri;

  /// The resource name of the Index.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this Index was most recently updated.
  ///
  /// This also includes any update to the contents of the Index. Note that
  /// Operations working on this Index may have their
  /// Operations.metadata.generic_metadata.update_time a little after the value
  /// of this timestamp, yet that does not mean their results are not already
  /// reflected in the Index. Result of any successfully completed Operation on
  /// the Index is reflected in it.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Index({
    this.createTime,
    this.deployedIndexes,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.indexStats,
    this.indexUpdateMethod,
    this.labels,
    this.metadata,
    this.metadataSchemaUri,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Index.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          deployedIndexes: json_.containsKey('deployedIndexes')
              ? (json_['deployedIndexes'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1DeployedIndexRef.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          indexStats: json_.containsKey('indexStats')
              ? GoogleCloudAiplatformV1IndexStats.fromJson(
                  json_['indexStats'] as core.Map<core.String, core.dynamic>)
              : null,
          indexUpdateMethod: json_.containsKey('indexUpdateMethod')
              ? json_['indexUpdateMethod'] as core.String
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          metadata: json_.containsKey('metadata') ? json_['metadata'] : null,
          metadataSchemaUri: json_.containsKey('metadataSchemaUri')
              ? json_['metadataSchemaUri'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (deployedIndexes != null) 'deployedIndexes': deployedIndexes!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (indexStats != null) 'indexStats': indexStats!,
        if (indexUpdateMethod != null) 'indexUpdateMethod': indexUpdateMethod!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A datapoint of Index.
class GoogleCloudAiplatformV1IndexDatapoint {
  /// CrowdingTag of the datapoint, the number of neighbors to return in each
  /// crowding can be configured during query.
  ///
  /// Optional.
  GoogleCloudAiplatformV1IndexDatapointCrowdingTag? crowdingTag;

  /// Unique identifier of the datapoint.
  ///
  /// Required.
  core.String? datapointId;

  /// Feature embedding vector.
  ///
  /// An array of numbers with the length of
  /// \[NearestNeighborSearchConfig.dimensions\].
  ///
  /// Required.
  core.List<core.double>? featureVector;

  /// List of Restrict of the datapoint, used to perform "restricted searches"
  /// where boolean rule are used to filter the subset of the database eligible
  /// for matching.
  ///
  /// This uses categorical tokens. See:
  /// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1IndexDatapointRestriction>? restricts;

  GoogleCloudAiplatformV1IndexDatapoint({
    this.crowdingTag,
    this.datapointId,
    this.featureVector,
    this.restricts,
  });

  GoogleCloudAiplatformV1IndexDatapoint.fromJson(core.Map json_)
      : this(
          crowdingTag: json_.containsKey('crowdingTag')
              ? GoogleCloudAiplatformV1IndexDatapointCrowdingTag.fromJson(
                  json_['crowdingTag'] as core.Map<core.String, core.dynamic>)
              : null,
          datapointId: json_.containsKey('datapointId')
              ? json_['datapointId'] as core.String
              : null,
          featureVector: json_.containsKey('featureVector')
              ? (json_['featureVector'] as core.List)
                  .map((value) => (value as core.num).toDouble())
                  .toList()
              : null,
          restricts: json_.containsKey('restricts')
              ? (json_['restricts'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1IndexDatapointRestriction.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (crowdingTag != null) 'crowdingTag': crowdingTag!,
        if (datapointId != null) 'datapointId': datapointId!,
        if (featureVector != null) 'featureVector': featureVector!,
        if (restricts != null) 'restricts': restricts!,
      };
}

/// Crowding tag is a constraint on a neighbor list produced by nearest neighbor
/// search requiring that no more than some value k' of the k neighbors returned
/// have the same value of crowding_attribute.
class GoogleCloudAiplatformV1IndexDatapointCrowdingTag {
  /// The attribute value used for crowding.
  ///
  /// The maximum number of neighbors to return per crowding attribute value
  /// (per_crowding_attribute_num_neighbors) is configured per-query. This field
  /// is ignored if per_crowding_attribute_num_neighbors is larger than the
  /// total number of neighbors to return for a given query.
  core.String? crowdingAttribute;

  GoogleCloudAiplatformV1IndexDatapointCrowdingTag({
    this.crowdingAttribute,
  });

  GoogleCloudAiplatformV1IndexDatapointCrowdingTag.fromJson(core.Map json_)
      : this(
          crowdingAttribute: json_.containsKey('crowdingAttribute')
              ? json_['crowdingAttribute'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (crowdingAttribute != null) 'crowdingAttribute': crowdingAttribute!,
      };
}

/// Restriction of a datapoint which describe its attributes(tokens) from each
/// of several attribute categories(namespaces).
class GoogleCloudAiplatformV1IndexDatapointRestriction {
  /// The attributes to allow in this namespace.
  ///
  /// e.g.: 'red'
  core.List<core.String>? allowList;

  /// The attributes to deny in this namespace.
  ///
  /// e.g.: 'blue'
  core.List<core.String>? denyList;

  /// The namespace of this restriction.
  ///
  /// e.g.: color.
  core.String? namespace;

  GoogleCloudAiplatformV1IndexDatapointRestriction({
    this.allowList,
    this.denyList,
    this.namespace,
  });

  GoogleCloudAiplatformV1IndexDatapointRestriction.fromJson(core.Map json_)
      : this(
          allowList: json_.containsKey('allowList')
              ? (json_['allowList'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          denyList: json_.containsKey('denyList')
              ? (json_['denyList'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          namespace: json_.containsKey('namespace')
              ? json_['namespace'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowList != null) 'allowList': allowList!,
        if (denyList != null) 'denyList': denyList!,
        if (namespace != null) 'namespace': namespace!,
      };
}

/// Indexes are deployed into it.
///
/// An IndexEndpoint can have multiple DeployedIndexes.
class GoogleCloudAiplatformV1IndexEndpoint {
  /// Timestamp when this IndexEndpoint was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The indexes deployed in this endpoint.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedIndex>? deployedIndexes;

  /// The description of the IndexEndpoint.
  core.String? description;

  /// The display name of the IndexEndpoint.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Deprecated: If true, expose the IndexEndpoint via private service connect.
  ///
  /// Only one of the fields, network or enable_private_service_connect, can be
  /// set.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enablePrivateServiceConnect;

  /// Customer-managed encryption key spec for an IndexEndpoint.
  ///
  /// If set, this IndexEndpoint and all sub-resources of this IndexEndpoint
  /// will be secured by this key.
  ///
  /// Immutable.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your IndexEndpoints.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the IndexEndpoint.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
  /// to which the IndexEndpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If
  /// left unspecified, the Endpoint is not peered with any network. network and
  /// private_service_connect_config are mutually exclusive.
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in '12345', and {network} is network name.
  ///
  /// Optional.
  core.String? network;

  /// Configuration for private service connect.
  ///
  /// network and private_service_connect_config are mutually exclusive.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PrivateServiceConnectConfig?
      privateServiceConnectConfig;

  /// If public_endpoint_enabled is true, this field will be populated with the
  /// domain name to use for this index endpoint.
  ///
  /// Output only.
  core.String? publicEndpointDomainName;

  /// If true, the deployed index will be accessible through public endpoint.
  ///
  /// Optional.
  core.bool? publicEndpointEnabled;

  /// Timestamp when this IndexEndpoint was last updated.
  ///
  /// This timestamp is not updated when the endpoint's DeployedIndexes are
  /// updated, e.g. due to updates of the original Indexes they are the
  /// deployments of.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1IndexEndpoint({
    this.createTime,
    this.deployedIndexes,
    this.description,
    this.displayName,
    this.enablePrivateServiceConnect,
    this.encryptionSpec,
    this.etag,
    this.labels,
    this.name,
    this.network,
    this.privateServiceConnectConfig,
    this.publicEndpointDomainName,
    this.publicEndpointEnabled,
    this.updateTime,
  });

  GoogleCloudAiplatformV1IndexEndpoint.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          deployedIndexes: json_.containsKey('deployedIndexes')
              ? (json_['deployedIndexes'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1DeployedIndex.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          enablePrivateServiceConnect:
              json_.containsKey('enablePrivateServiceConnect')
                  ? json_['enablePrivateServiceConnect'] as core.bool
                  : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          network: json_.containsKey('network')
              ? json_['network'] as core.String
              : null,
          privateServiceConnectConfig:
              json_.containsKey('privateServiceConnectConfig')
                  ? GoogleCloudAiplatformV1PrivateServiceConnectConfig.fromJson(
                      json_['privateServiceConnectConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          publicEndpointDomainName:
              json_.containsKey('publicEndpointDomainName')
                  ? json_['publicEndpointDomainName'] as core.String
                  : null,
          publicEndpointEnabled: json_.containsKey('publicEndpointEnabled')
              ? json_['publicEndpointEnabled'] as core.bool
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (deployedIndexes != null) 'deployedIndexes': deployedIndexes!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (enablePrivateServiceConnect != null)
          'enablePrivateServiceConnect': enablePrivateServiceConnect!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (privateServiceConnectConfig != null)
          'privateServiceConnectConfig': privateServiceConnectConfig!,
        if (publicEndpointDomainName != null)
          'publicEndpointDomainName': publicEndpointDomainName!,
        if (publicEndpointEnabled != null)
          'publicEndpointEnabled': publicEndpointEnabled!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// IndexPrivateEndpoints proto is used to provide paths for users to send
/// requests via private endpoints (e.g. private service access, private service
/// connect).
///
/// To send request via private service access, use match_grpc_address. To send
/// request via private service connect, use service_attachment.
class GoogleCloudAiplatformV1IndexPrivateEndpoints {
  /// The ip address used to send match gRPC requests.
  ///
  /// Output only.
  core.String? matchGrpcAddress;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1IndexPrivateEndpoints({
    this.matchGrpcAddress,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1IndexPrivateEndpoints.fromJson(core.Map json_)
      : this(
          matchGrpcAddress: json_.containsKey('matchGrpcAddress')
              ? json_['matchGrpcAddress'] as core.String
              : null,
          serviceAttachment: json_.containsKey('serviceAttachment')
              ? json_['serviceAttachment'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (matchGrpcAddress != null) 'matchGrpcAddress': matchGrpcAddress!,
        if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
      };
}

/// Stats of the Index.
class GoogleCloudAiplatformV1IndexStats {
  /// The number of shards in the Index.
  ///
  /// Output only.
  core.int? shardsCount;

  /// The number of vectors in the Index.
  ///
  /// Output only.
  core.String? vectorsCount;

  GoogleCloudAiplatformV1IndexStats({
    this.shardsCount,
    this.vectorsCount,
  });

  GoogleCloudAiplatformV1IndexStats.fromJson(core.Map json_)
      : this(
          shardsCount: json_.containsKey('shardsCount')
              ? json_['shardsCount'] as core.int
              : null,
          vectorsCount: json_.containsKey('vectorsCount')
              ? json_['vectorsCount'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (shardsCount != null) 'shardsCount': shardsCount!,
        if (vectorsCount != null) 'vectorsCount': vectorsCount!,
      };
}

/// Specifies Vertex AI owned input data to be used for training, and possibly
/// evaluating, the Model.
class GoogleCloudAiplatformV1InputDataConfig {
  /// Applicable only to custom training with Datasets that have DataItems and
  /// Annotations.
  ///
  /// Cloud Storage URI that points to a YAML file describing the annotation
  /// schema. The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/ , note that the
  /// chosen schema must be consistent with metadata of the Dataset specified by
  /// dataset_id. Only Annotations that both match this schema and belong to
  /// DataItems not ignored by the split method are used in respectively
  /// training, validation or test role, depending on the role of the DataItem
  /// they are on. When used in conjunction with annotations_filter, the
  /// Annotations used for training are filtered by both annotations_filter and
  /// annotation_schema_uri.
  core.String? annotationSchemaUri;

  /// Applicable only to Datasets that have DataItems and Annotations.
  ///
  /// A filter on Annotations of the Dataset. Only Annotations that both match
  /// this filter and belong to DataItems not ignored by the split method are
  /// used in respectively training, validation or test role, depending on the
  /// role of the DataItem they are on (for the auto-assigned that role is
  /// decided by Vertex AI). A filter with same syntax as the one used in
  /// ListAnnotations may be used, but note here it filters across all
  /// Annotations of the Dataset, and not just within a single DataItem.
  core.String? annotationsFilter;

  /// Only applicable to custom training with tabular Dataset with BigQuery
  /// source.
  ///
  /// The BigQuery project location where the training data is to be written to.
  /// In the given project a new dataset is created with name `dataset___` where
  /// timestamp is in YYYY_MM_DDThh_mm_ss_sssZ format. All training input data
  /// is written into that dataset. In the dataset three tables are created,
  /// `training`, `validation` and `test`. * AIP_DATA_FORMAT = "bigquery". *
  /// AIP_TRAINING_DATA_URI = "bigquery_destination.dataset___.training" *
  /// AIP_VALIDATION_DATA_URI = "bigquery_destination.dataset___.validation" *
  /// AIP_TEST_DATA_URI = "bigquery_destination.dataset___.test"
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// The ID of the Dataset in the same Project and Location which data will be
  /// used to train the Model.
  ///
  /// The Dataset must use schema compatible with Model being trained, and what
  /// is compatible should be described in the used TrainingPipeline's
  /// training_task_definition. For tabular Datasets, all their data is exported
  /// to training, to pick and choose from.
  ///
  /// Required.
  core.String? datasetId;

  /// Split based on the provided filters for each set.
  GoogleCloudAiplatformV1FilterSplit? filterSplit;

  /// Split based on fractions defining the size of each set.
  GoogleCloudAiplatformV1FractionSplit? fractionSplit;

  /// The Cloud Storage location where the training data is to be written to.
  ///
  /// In the given directory a new directory is created with name: `dataset---`
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All
  /// training input data is written into that directory. The Vertex AI
  /// environment variables representing Cloud Storage data URIs are represented
  /// in the Cloud Storage wildcard format to support sharded data. e.g.:
  /// "gs://.../training-*.jsonl" * AIP_DATA_FORMAT = "jsonl" for non-tabular
  /// data, "csv" for tabular data * AIP_TRAINING_DATA_URI =
  /// "gcs_destination/dataset---/training-*.${AIP_DATA_FORMAT}" *
  /// AIP_VALIDATION_DATA_URI =
  /// "gcs_destination/dataset---/validation-*.${AIP_DATA_FORMAT}" *
  /// AIP_TEST_DATA_URI = "gcs_destination/dataset---/test-*.${AIP_DATA_FORMAT}"
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  /// Whether to persist the ML use assignment to data item system labels.
  core.bool? persistMlUseAssignment;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on a predefined key.
  GoogleCloudAiplatformV1PredefinedSplit? predefinedSplit;

  /// Only applicable to Datasets that have SavedQueries.
  ///
  /// The ID of a SavedQuery (annotation set) under the Dataset specified by
  /// dataset_id used for filtering Annotations for training. Only Annotations
  /// that are associated with this SavedQuery are used in respectively
  /// training. When used in conjunction with annotations_filter, the
  /// Annotations used for training are filtered by both saved_query_id and
  /// annotations_filter. Only one of saved_query_id and annotation_schema_uri
  /// should be specified as both of them represent the same thing: problem
  /// type.
  core.String? savedQueryId;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the distribution of the specified column.
  GoogleCloudAiplatformV1StratifiedSplit? stratifiedSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the timestamp of the input data pieces.
  GoogleCloudAiplatformV1TimestampSplit? timestampSplit;

  GoogleCloudAiplatformV1InputDataConfig({
    this.annotationSchemaUri,
    this.annotationsFilter,
    this.bigqueryDestination,
    this.datasetId,
    this.filterSplit,
    this.fractionSplit,
    this.gcsDestination,
    this.persistMlUseAssignment,
    this.predefinedSplit,
    this.savedQueryId,
    this.stratifiedSplit,
    this.timestampSplit,
  });

  GoogleCloudAiplatformV1InputDataConfig.fromJson(core.Map json_)
      : this(
          annotationSchemaUri: json_.containsKey('annotationSchemaUri')
              ? json_['annotationSchemaUri'] as core.String
              : null,
          annotationsFilter: json_.containsKey('annotationsFilter')
              ? json_['annotationsFilter'] as core.String
              : null,
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          datasetId: json_.containsKey('datasetId')
              ? json_['datasetId'] as core.String
              : null,
          filterSplit: json_.containsKey('filterSplit')
              ? GoogleCloudAiplatformV1FilterSplit.fromJson(
                  json_['filterSplit'] as core.Map<core.String, core.dynamic>)
              : null,
          fractionSplit: json_.containsKey('fractionSplit')
              ? GoogleCloudAiplatformV1FractionSplit.fromJson(
                  json_['fractionSplit'] as core.Map<core.String, core.dynamic>)
              : null,
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          persistMlUseAssignment: json_.containsKey('persistMlUseAssignment')
              ? json_['persistMlUseAssignment'] as core.bool
              : null,
          predefinedSplit: json_.containsKey('predefinedSplit')
              ? GoogleCloudAiplatformV1PredefinedSplit.fromJson(
                  json_['predefinedSplit']
                      as core.Map<core.String, core.dynamic>)
              : null,
          savedQueryId: json_.containsKey('savedQueryId')
              ? json_['savedQueryId'] as core.String
              : null,
          stratifiedSplit: json_.containsKey('stratifiedSplit')
              ? GoogleCloudAiplatformV1StratifiedSplit.fromJson(
                  json_['stratifiedSplit']
                      as core.Map<core.String, core.dynamic>)
              : null,
          timestampSplit: json_.containsKey('timestampSplit')
              ? GoogleCloudAiplatformV1TimestampSplit.fromJson(
                  json_['timestampSplit']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationSchemaUri != null)
          'annotationSchemaUri': annotationSchemaUri!,
        if (annotationsFilter != null) 'annotationsFilter': annotationsFilter!,
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (datasetId != null) 'datasetId': datasetId!,
        if (filterSplit != null) 'filterSplit': filterSplit!,
        if (fractionSplit != null) 'fractionSplit': fractionSplit!,
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
        if (persistMlUseAssignment != null)
          'persistMlUseAssignment': persistMlUseAssignment!,
        if (predefinedSplit != null) 'predefinedSplit': predefinedSplit!,
        if (savedQueryId != null) 'savedQueryId': savedQueryId!,
        if (stratifiedSplit != null) 'stratifiedSplit': stratifiedSplit!,
        if (timestampSplit != null) 'timestampSplit': timestampSplit!,
      };
}

/// A list of int64 values.
class GoogleCloudAiplatformV1Int64Array {
  /// A list of int64 values.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1Int64Array({
    this.values,
  });

  GoogleCloudAiplatformV1Int64Array.fromJson(core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// An attribution method that computes the Aumann-Shapley value taking
/// advantage of the model's fully differentiable structure.
///
/// Refer to this paper for more details: https://arxiv.org/abs/1703.01365
class GoogleCloudAiplatformV1IntegratedGradientsAttribution {
  /// Config for IG with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image)
  /// is motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  GoogleCloudAiplatformV1BlurBaselineConfig? blurBaselineConfig;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding noise can help
  /// improve the computed gradients. Refer to this paper for more details:
  /// https://arxiv.org/pdf/1706.03825.pdf
  GoogleCloudAiplatformV1SmoothGradConfig? smoothGradConfig;

  /// The number of steps for approximating the path integral.
  ///
  /// A good value to start is 50 and gradually increase until the sum to diff
  /// property is within the desired error range. Valid range of its value is
  /// \[1, 100\], inclusively.
  ///
  /// Required.
  core.int? stepCount;

  GoogleCloudAiplatformV1IntegratedGradientsAttribution({
    this.blurBaselineConfig,
    this.smoothGradConfig,
    this.stepCount,
  });

  GoogleCloudAiplatformV1IntegratedGradientsAttribution.fromJson(core.Map json_)
      : this(
          blurBaselineConfig: json_.containsKey('blurBaselineConfig')
              ? GoogleCloudAiplatformV1BlurBaselineConfig.fromJson(
                  json_['blurBaselineConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          smoothGradConfig: json_.containsKey('smoothGradConfig')
              ? GoogleCloudAiplatformV1SmoothGradConfig.fromJson(
                  json_['smoothGradConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          stepCount: json_.containsKey('stepCount')
              ? json_['stepCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blurBaselineConfig != null)
          'blurBaselineConfig': blurBaselineConfig!,
        if (smoothGradConfig != null) 'smoothGradConfig': smoothGradConfig!,
        if (stepCount != null) 'stepCount': stepCount!,
      };
}

/// Contains information about the Large Model.
class GoogleCloudAiplatformV1LargeModelReference {
  /// The unique name of the large Foundation or pre-built model.
  ///
  /// Like "chat-bison", "text-bison". Or model name with version ID, like
  /// "chat-bison@001", "text-bison@005", etc.
  ///
  /// Required.
  core.String? name;

  GoogleCloudAiplatformV1LargeModelReference({
    this.name,
  });

  GoogleCloudAiplatformV1LargeModelReference.fromJson(core.Map json_)
      : this(
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
      };
}

/// A subgraph of the overall lineage graph.
///
/// Event edges connect Artifact and Execution nodes.
class GoogleCloudAiplatformV1LineageSubgraph {
  /// The Artifact nodes in the subgraph.
  core.List<GoogleCloudAiplatformV1Artifact>? artifacts;

  /// The Event edges between Artifacts and Executions in the subgraph.
  core.List<GoogleCloudAiplatformV1Event>? events;

  /// The Execution nodes in the subgraph.
  core.List<GoogleCloudAiplatformV1Execution>? executions;

  GoogleCloudAiplatformV1LineageSubgraph({
    this.artifacts,
    this.events,
    this.executions,
  });

  GoogleCloudAiplatformV1LineageSubgraph.fromJson(core.Map json_)
      : this(
          artifacts: json_.containsKey('artifacts')
              ? (json_['artifacts'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Artifact.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          events: json_.containsKey('events')
              ? (json_['events'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Event.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          executions: json_.containsKey('executions')
              ? (json_['executions'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Execution.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
        if (events != null) 'events': events!,
        if (executions != null) 'executions': executions!,
      };
}

/// Response message for DatasetService.ListAnnotations.
class GoogleCloudAiplatformV1ListAnnotationsResponse {
  /// A list of Annotations that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1Annotation>? annotations;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListAnnotationsResponse({
    this.annotations,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListAnnotationsResponse.fromJson(core.Map json_)
      : this(
          annotations: json_.containsKey('annotations')
              ? (json_['annotations'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Annotation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotations != null) 'annotations': annotations!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListArtifacts.
class GoogleCloudAiplatformV1ListArtifactsResponse {
  /// The Artifacts retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1Artifact>? artifacts;

  /// A token, which can be sent as ListArtifactsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListArtifactsResponse({
    this.artifacts,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListArtifactsResponse.fromJson(core.Map json_)
      : this(
          artifacts: json_.containsKey('artifacts')
              ? (json_['artifacts'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Artifact.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListBatchPredictionJobs
class GoogleCloudAiplatformV1ListBatchPredictionJobsResponse {
  /// List of BatchPredictionJobs in the requested page.
  core.List<GoogleCloudAiplatformV1BatchPredictionJob>? batchPredictionJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListBatchPredictionJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListBatchPredictionJobsResponse({
    this.batchPredictionJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListBatchPredictionJobsResponse.fromJson(
      core.Map json_)
      : this(
          batchPredictionJobs: json_.containsKey('batchPredictionJobs')
              ? (json_['batchPredictionJobs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1BatchPredictionJob.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (batchPredictionJobs != null)
          'batchPredictionJobs': batchPredictionJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListContexts.
class GoogleCloudAiplatformV1ListContextsResponse {
  /// The Contexts retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1Context>? contexts;

  /// A token, which can be sent as ListContextsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListContextsResponse({
    this.contexts,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListContextsResponse.fromJson(core.Map json_)
      : this(
          contexts: json_.containsKey('contexts')
              ? (json_['contexts'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Context.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (contexts != null) 'contexts': contexts!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListCustomJobs
class GoogleCloudAiplatformV1ListCustomJobsResponse {
  /// List of CustomJobs in the requested page.
  core.List<GoogleCloudAiplatformV1CustomJob>? customJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListCustomJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListCustomJobsResponse({
    this.customJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListCustomJobsResponse.fromJson(core.Map json_)
      : this(
          customJobs: json_.containsKey('customJobs')
              ? (json_['customJobs'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1CustomJob.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (customJobs != null) 'customJobs': customJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for DatasetService.ListDataItems.
class GoogleCloudAiplatformV1ListDataItemsResponse {
  /// A list of DataItems that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1DataItem>? dataItems;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDataItemsResponse({
    this.dataItems,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDataItemsResponse.fromJson(core.Map json_)
      : this(
          dataItems: json_.containsKey('dataItems')
              ? (json_['dataItems'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1DataItem.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataItems != null) 'dataItems': dataItems!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListDataLabelingJobs.
class GoogleCloudAiplatformV1ListDataLabelingJobsResponse {
  /// A list of DataLabelingJobs that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1DataLabelingJob>? dataLabelingJobs;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDataLabelingJobsResponse({
    this.dataLabelingJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDataLabelingJobsResponse.fromJson(core.Map json_)
      : this(
          dataLabelingJobs: json_.containsKey('dataLabelingJobs')
              ? (json_['dataLabelingJobs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1DataLabelingJob.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataLabelingJobs != null) 'dataLabelingJobs': dataLabelingJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for DatasetService.ListDatasetVersions.
class GoogleCloudAiplatformV1ListDatasetVersionsResponse {
  /// A list of DatasetVersions that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1DatasetVersion>? datasetVersions;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDatasetVersionsResponse({
    this.datasetVersions,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDatasetVersionsResponse.fromJson(core.Map json_)
      : this(
          datasetVersions: json_.containsKey('datasetVersions')
              ? (json_['datasetVersions'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1DatasetVersion.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datasetVersions != null) 'datasetVersions': datasetVersions!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for DatasetService.ListDatasets.
class GoogleCloudAiplatformV1ListDatasetsResponse {
  /// A list of Datasets that matches the specified filter in the request.
  core.List<GoogleCloudAiplatformV1Dataset>? datasets;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListDatasetsResponse({
    this.datasets,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListDatasetsResponse.fromJson(core.Map json_)
      : this(
          datasets: json_.containsKey('datasets')
              ? (json_['datasets'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Dataset.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datasets != null) 'datasets': datasets!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for EndpointService.ListEndpoints.
class GoogleCloudAiplatformV1ListEndpointsResponse {
  /// List of Endpoints in the requested page.
  core.List<GoogleCloudAiplatformV1Endpoint>? endpoints;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListEndpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListEndpointsResponse({
    this.endpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListEndpointsResponse.fromJson(core.Map json_)
      : this(
          endpoints: json_.containsKey('endpoints')
              ? (json_['endpoints'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Endpoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoints != null) 'endpoints': endpoints!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeaturestoreService.ListEntityTypes.
class GoogleCloudAiplatformV1ListEntityTypesResponse {
  /// The EntityTypes matching the request.
  core.List<GoogleCloudAiplatformV1EntityType>? entityTypes;

  /// A token, which can be sent as ListEntityTypesRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListEntityTypesResponse({
    this.entityTypes,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListEntityTypesResponse.fromJson(core.Map json_)
      : this(
          entityTypes: json_.containsKey('entityTypes')
              ? (json_['entityTypes'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1EntityType.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityTypes != null) 'entityTypes': entityTypes!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListExecutions.
class GoogleCloudAiplatformV1ListExecutionsResponse {
  /// The Executions retrieved from the MetadataStore.
  core.List<GoogleCloudAiplatformV1Execution>? executions;

  /// A token, which can be sent as ListExecutionsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListExecutionsResponse({
    this.executions,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListExecutionsResponse.fromJson(core.Map json_)
      : this(
          executions: json_.containsKey('executions')
              ? (json_['executions'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Execution.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (executions != null) 'executions': executions!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeaturestoreService.ListFeatures.
///
/// Response message for FeatureRegistryService.ListFeatures.
class GoogleCloudAiplatformV1ListFeaturesResponse {
  /// The Features matching the request.
  core.List<GoogleCloudAiplatformV1Feature>? features;

  /// A token, which can be sent as ListFeaturesRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeaturesResponse({
    this.features,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeaturesResponse.fromJson(core.Map json_)
      : this(
          features: json_.containsKey('features')
              ? (json_['features'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Feature.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (features != null) 'features': features!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeaturestoreService.ListFeaturestores.
class GoogleCloudAiplatformV1ListFeaturestoresResponse {
  /// The Featurestores matching the request.
  core.List<GoogleCloudAiplatformV1Featurestore>? featurestores;

  /// A token, which can be sent as ListFeaturestoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListFeaturestoresResponse({
    this.featurestores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListFeaturestoresResponse.fromJson(core.Map json_)
      : this(
          featurestores: json_.containsKey('featurestores')
              ? (json_['featurestores'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Featurestore.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featurestores != null) 'featurestores': featurestores!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListHyperparameterTuningJobs
class GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse {
  /// List of HyperparameterTuningJobs in the requested page.
  ///
  /// HyperparameterTuningJob.trials of the jobs will be not be returned.
  core.List<GoogleCloudAiplatformV1HyperparameterTuningJob>?
      hyperparameterTuningJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListHyperparameterTuningJobsRequest.page_token to obtain that
  /// page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse({
    this.hyperparameterTuningJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListHyperparameterTuningJobsResponse.fromJson(
      core.Map json_)
      : this(
          hyperparameterTuningJobs: json_
                  .containsKey('hyperparameterTuningJobs')
              ? (json_['hyperparameterTuningJobs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1HyperparameterTuningJob.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (hyperparameterTuningJobs != null)
          'hyperparameterTuningJobs': hyperparameterTuningJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for IndexEndpointService.ListIndexEndpoints.
class GoogleCloudAiplatformV1ListIndexEndpointsResponse {
  /// List of IndexEndpoints in the requested page.
  core.List<GoogleCloudAiplatformV1IndexEndpoint>? indexEndpoints;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListIndexEndpointsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListIndexEndpointsResponse({
    this.indexEndpoints,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListIndexEndpointsResponse.fromJson(core.Map json_)
      : this(
          indexEndpoints: json_.containsKey('indexEndpoints')
              ? (json_['indexEndpoints'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1IndexEndpoint.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (indexEndpoints != null) 'indexEndpoints': indexEndpoints!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for IndexService.ListIndexes.
class GoogleCloudAiplatformV1ListIndexesResponse {
  /// List of indexes in the requested page.
  core.List<GoogleCloudAiplatformV1Index>? indexes;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListIndexesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListIndexesResponse({
    this.indexes,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListIndexesResponse.fromJson(core.Map json_)
      : this(
          indexes: json_.containsKey('indexes')
              ? (json_['indexes'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Index.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (indexes != null) 'indexes': indexes!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListMetadataSchemas.
class GoogleCloudAiplatformV1ListMetadataSchemasResponse {
  /// The MetadataSchemas found for the MetadataStore.
  core.List<GoogleCloudAiplatformV1MetadataSchema>? metadataSchemas;

  /// A token, which can be sent as ListMetadataSchemasRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListMetadataSchemasResponse({
    this.metadataSchemas,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListMetadataSchemasResponse.fromJson(core.Map json_)
      : this(
          metadataSchemas: json_.containsKey('metadataSchemas')
              ? (json_['metadataSchemas'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1MetadataSchema.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metadataSchemas != null) 'metadataSchemas': metadataSchemas!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for MetadataService.ListMetadataStores.
class GoogleCloudAiplatformV1ListMetadataStoresResponse {
  /// The MetadataStores found for the Location.
  core.List<GoogleCloudAiplatformV1MetadataStore>? metadataStores;

  /// A token, which can be sent as ListMetadataStoresRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is not populated, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListMetadataStoresResponse({
    this.metadataStores,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListMetadataStoresResponse.fromJson(core.Map json_)
      : this(
          metadataStores: json_.containsKey('metadataStores')
              ? (json_['metadataStores'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1MetadataStore.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metadataStores != null) 'metadataStores': metadataStores!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListModelDeploymentMonitoringJobs.
class GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse {
  /// A list of ModelDeploymentMonitoringJobs that matches the specified filter
  /// in the request.
  core.List<GoogleCloudAiplatformV1ModelDeploymentMonitoringJob>?
      modelDeploymentMonitoringJobs;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse({
    this.modelDeploymentMonitoringJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelDeploymentMonitoringJobsResponse.fromJson(
      core.Map json_)
      : this(
          modelDeploymentMonitoringJobs:
              json_.containsKey('modelDeploymentMonitoringJobs')
                  ? (json_['modelDeploymentMonitoringJobs'] as core.List)
                      .map((value) =>
                          GoogleCloudAiplatformV1ModelDeploymentMonitoringJob
                              .fromJson(
                                  value as core.Map<core.String, core.dynamic>))
                      .toList()
                  : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelDeploymentMonitoringJobs != null)
          'modelDeploymentMonitoringJobs': modelDeploymentMonitoringJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModelEvaluationSlices.
class GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse {
  /// List of ModelEvaluations in the requested page.
  core.List<GoogleCloudAiplatformV1ModelEvaluationSlice>? modelEvaluationSlices;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelEvaluationSlicesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse({
    this.modelEvaluationSlices,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelEvaluationSlicesResponse.fromJson(
      core.Map json_)
      : this(
          modelEvaluationSlices: json_.containsKey('modelEvaluationSlices')
              ? (json_['modelEvaluationSlices'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelEvaluationSlice.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelEvaluationSlices != null)
          'modelEvaluationSlices': modelEvaluationSlices!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModelEvaluations.
class GoogleCloudAiplatformV1ListModelEvaluationsResponse {
  /// List of ModelEvaluations in the requested page.
  core.List<GoogleCloudAiplatformV1ModelEvaluation>? modelEvaluations;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelEvaluationsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelEvaluationsResponse({
    this.modelEvaluations,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelEvaluationsResponse.fromJson(core.Map json_)
      : this(
          modelEvaluations: json_.containsKey('modelEvaluations')
              ? (json_['modelEvaluations'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelEvaluation.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modelEvaluations != null) 'modelEvaluations': modelEvaluations!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModelVersions
class GoogleCloudAiplatformV1ListModelVersionsResponse {
  /// List of Model versions in the requested page.
  ///
  /// In the returned Model name field, version ID instead of regvision tag will
  /// be included.
  core.List<GoogleCloudAiplatformV1Model>? models;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListModelVersionsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelVersionsResponse({
    this.models,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelVersionsResponse.fromJson(core.Map json_)
      : this(
          models: json_.containsKey('models')
              ? (json_['models'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Model.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (models != null) 'models': models!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for ModelService.ListModels
class GoogleCloudAiplatformV1ListModelsResponse {
  /// List of Models in the requested page.
  core.List<GoogleCloudAiplatformV1Model>? models;

  /// A token to retrieve next page of results.
  ///
  /// Pass to ListModelsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListModelsResponse({
    this.models,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListModelsResponse.fromJson(core.Map json_)
      : this(
          models: json_.containsKey('models')
              ? (json_['models'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Model.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (models != null) 'models': models!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListNasJobs
class GoogleCloudAiplatformV1ListNasJobsResponse {
  /// List of NasJobs in the requested page.
  ///
  /// NasJob.nas_job_output of the jobs will not be returned.
  core.List<GoogleCloudAiplatformV1NasJob>? nasJobs;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListNasJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListNasJobsResponse({
    this.nasJobs,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListNasJobsResponse.fromJson(core.Map json_)
      : this(
          nasJobs: json_.containsKey('nasJobs')
              ? (json_['nasJobs'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1NasJob.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nasJobs != null) 'nasJobs': nasJobs!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for JobService.ListNasTrialDetails
class GoogleCloudAiplatformV1ListNasTrialDetailsResponse {
  /// List of top NasTrials in the requested page.
  core.List<GoogleCloudAiplatformV1NasTrialDetail>? nasTrialDetails;

  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListNasTrialDetailsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1ListNasTrialDetailsResponse({
    this.nasTrialDetails,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1ListNasTrialDetailsResponse.fromJson(core.Map json_)
      : this(
          nasTrialDetails: json_.containsKey('nasTrialDetails')
              ? (json_['nasTrialDetails'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1NasTrialDetail.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nasTrialDetails != null) 'nasTrialDetails': nasTrialDetails!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for NotebookService.ListNotebookRuntimeTemplates.
class GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookRuntimeTemplatesRequest.page_token to obtain that
  /// page.
  core.String? nextPageToken;

  /// List of NotebookRuntimeTemplates in the requested page.
  core.List<GoogleCloudAiplatformV1NotebookRuntimeTemplate>?
      notebookRuntimeTemplates;

  GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse({
    this.nextPageToken,
    this.notebookRuntimeTemplates,
  });

  GoogleCloudAiplatformV1ListNotebookRuntimeTemplatesResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          notebookRuntimeTemplates: json_
                  .containsKey('notebookRuntimeTemplates')
              ? (json_['notebookRuntimeTemplates'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (notebookRuntimeTemplates != null)
          'notebookRuntimeTemplates': notebookRuntimeTemplates!,
      };
}

/// Response message for NotebookService.ListNotebookRuntimes.
class GoogleCloudAiplatformV1ListNotebookRuntimesResponse {
  /// A token to retrieve next page of results.
  ///
  /// Pass to ListNotebookRuntimesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of NotebookRuntimes in the requested page.
  core.List<GoogleCloudAiplatformV1NotebookRuntime>? notebookRuntimes;

  GoogleCloudAiplatformV1ListNotebookRuntimesResponse({
    this.nextPageToken,
    this.notebookRuntimes,
  });

  GoogleCloudAiplatformV1ListNotebookRuntimesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          notebookRuntimes: json_.containsKey('notebookRuntimes')
              ? (json_['notebookRuntimes'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1NotebookRuntime.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (notebookRuntimes != null) 'notebookRuntimes': notebookRuntimes!,
      };
}

/// Request message for VizierService.ListOptimalTrials.
typedef GoogleCloudAiplatformV1ListOptimalTrialsRequest = $Empty;

/// Response message for VizierService.ListOptimalTrials.
class GoogleCloudAiplatformV1ListOptimalTrialsResponse {
  /// The pareto-optimal Trials for multiple objective Study or the optimal
  /// trial for single objective Study.
  ///
  /// The definition of pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  core.List<GoogleCloudAiplatformV1Trial>? optimalTrials;

  GoogleCloudAiplatformV1ListOptimalTrialsResponse({
    this.optimalTrials,
  });

  GoogleCloudAiplatformV1ListOptimalTrialsResponse.fromJson(core.Map json_)
      : this(
          optimalTrials: json_.containsKey('optimalTrials')
              ? (json_['optimalTrials'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Trial.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (optimalTrials != null) 'optimalTrials': optimalTrials!,
      };
}

/// Response message for PipelineService.ListPipelineJobs
class GoogleCloudAiplatformV1ListPipelineJobsResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListPipelineJobsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of PipelineJobs in the requested page.
  core.List<GoogleCloudAiplatformV1PipelineJob>? pipelineJobs;

  GoogleCloudAiplatformV1ListPipelineJobsResponse({
    this.nextPageToken,
    this.pipelineJobs,
  });

  GoogleCloudAiplatformV1ListPipelineJobsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          pipelineJobs: json_.containsKey('pipelineJobs')
              ? (json_['pipelineJobs'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1PipelineJob.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (pipelineJobs != null) 'pipelineJobs': pipelineJobs!,
      };
}

/// Response message for DatasetService.ListSavedQueries.
class GoogleCloudAiplatformV1ListSavedQueriesResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of SavedQueries that match the specified filter in the request.
  core.List<GoogleCloudAiplatformV1SavedQuery>? savedQueries;

  GoogleCloudAiplatformV1ListSavedQueriesResponse({
    this.nextPageToken,
    this.savedQueries,
  });

  GoogleCloudAiplatformV1ListSavedQueriesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          savedQueries: json_.containsKey('savedQueries')
              ? (json_['savedQueries'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1SavedQuery.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (savedQueries != null) 'savedQueries': savedQueries!,
      };
}

/// Response message for ScheduleService.ListSchedules
class GoogleCloudAiplatformV1ListSchedulesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListSchedulesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of Schedules in the requested page.
  core.List<GoogleCloudAiplatformV1Schedule>? schedules;

  GoogleCloudAiplatformV1ListSchedulesResponse({
    this.nextPageToken,
    this.schedules,
  });

  GoogleCloudAiplatformV1ListSchedulesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          schedules: json_.containsKey('schedules')
              ? (json_['schedules'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Schedule.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (schedules != null) 'schedules': schedules!,
      };
}

/// Response message for SpecialistPoolService.ListSpecialistPools.
class GoogleCloudAiplatformV1ListSpecialistPoolsResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of SpecialistPools that matches the specified filter in the
  /// request.
  core.List<GoogleCloudAiplatformV1SpecialistPool>? specialistPools;

  GoogleCloudAiplatformV1ListSpecialistPoolsResponse({
    this.nextPageToken,
    this.specialistPools,
  });

  GoogleCloudAiplatformV1ListSpecialistPoolsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          specialistPools: json_.containsKey('specialistPools')
              ? (json_['specialistPools'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1SpecialistPool.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (specialistPools != null) 'specialistPools': specialistPools!,
      };
}

/// Response message for VizierService.ListStudies.
class GoogleCloudAiplatformV1ListStudiesResponse {
  /// Passes this token as the `page_token` field of the request for a
  /// subsequent call.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The studies associated with the project.
  core.List<GoogleCloudAiplatformV1Study>? studies;

  GoogleCloudAiplatformV1ListStudiesResponse({
    this.nextPageToken,
    this.studies,
  });

  GoogleCloudAiplatformV1ListStudiesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          studies: json_.containsKey('studies')
              ? (json_['studies'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Study.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (studies != null) 'studies': studies!,
      };
}

/// Response message for TensorboardService.ListTensorboardExperiments.
class GoogleCloudAiplatformV1ListTensorboardExperimentsResponse {
  /// A token, which can be sent as ListTensorboardExperimentsRequest.page_token
  /// to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardExperiments mathching the request.
  core.List<GoogleCloudAiplatformV1TensorboardExperiment>?
      tensorboardExperiments;

  GoogleCloudAiplatformV1ListTensorboardExperimentsResponse({
    this.nextPageToken,
    this.tensorboardExperiments,
  });

  GoogleCloudAiplatformV1ListTensorboardExperimentsResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          tensorboardExperiments: json_.containsKey('tensorboardExperiments')
              ? (json_['tensorboardExperiments'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TensorboardExperiment.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboardExperiments != null)
          'tensorboardExperiments': tensorboardExperiments!,
      };
}

/// Response message for TensorboardService.ListTensorboardRuns.
class GoogleCloudAiplatformV1ListTensorboardRunsResponse {
  /// A token, which can be sent as ListTensorboardRunsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardRuns mathching the request.
  core.List<GoogleCloudAiplatformV1TensorboardRun>? tensorboardRuns;

  GoogleCloudAiplatformV1ListTensorboardRunsResponse({
    this.nextPageToken,
    this.tensorboardRuns,
  });

  GoogleCloudAiplatformV1ListTensorboardRunsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          tensorboardRuns: json_.containsKey('tensorboardRuns')
              ? (json_['tensorboardRuns'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TensorboardRun.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboardRuns != null) 'tensorboardRuns': tensorboardRuns!,
      };
}

/// Response message for TensorboardService.ListTensorboardTimeSeries.
class GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse {
  /// A token, which can be sent as ListTensorboardTimeSeriesRequest.page_token
  /// to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The TensorboardTimeSeries mathching the request.
  core.List<GoogleCloudAiplatformV1TensorboardTimeSeries>?
      tensorboardTimeSeries;

  GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse({
    this.nextPageToken,
    this.tensorboardTimeSeries,
  });

  GoogleCloudAiplatformV1ListTensorboardTimeSeriesResponse.fromJson(
      core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          tensorboardTimeSeries: json_.containsKey('tensorboardTimeSeries')
              ? (json_['tensorboardTimeSeries'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboardTimeSeries != null)
          'tensorboardTimeSeries': tensorboardTimeSeries!,
      };
}

/// Response message for TensorboardService.ListTensorboards.
class GoogleCloudAiplatformV1ListTensorboardsResponse {
  /// A token, which can be sent as ListTensorboardsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The Tensorboards mathching the request.
  core.List<GoogleCloudAiplatformV1Tensorboard>? tensorboards;

  GoogleCloudAiplatformV1ListTensorboardsResponse({
    this.nextPageToken,
    this.tensorboards,
  });

  GoogleCloudAiplatformV1ListTensorboardsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          tensorboards: json_.containsKey('tensorboards')
              ? (json_['tensorboards'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Tensorboard.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (tensorboards != null) 'tensorboards': tensorboards!,
      };
}

/// Response message for PipelineService.ListTrainingPipelines
class GoogleCloudAiplatformV1ListTrainingPipelinesResponse {
  /// A token to retrieve the next page of results.
  ///
  /// Pass to ListTrainingPipelinesRequest.page_token to obtain that page.
  core.String? nextPageToken;

  /// List of TrainingPipelines in the requested page.
  core.List<GoogleCloudAiplatformV1TrainingPipeline>? trainingPipelines;

  GoogleCloudAiplatformV1ListTrainingPipelinesResponse({
    this.nextPageToken,
    this.trainingPipelines,
  });

  GoogleCloudAiplatformV1ListTrainingPipelinesResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          trainingPipelines: json_.containsKey('trainingPipelines')
              ? (json_['trainingPipelines'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TrainingPipeline.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (trainingPipelines != null) 'trainingPipelines': trainingPipelines!,
      };
}

/// Response message for VizierService.ListTrials.
class GoogleCloudAiplatformV1ListTrialsResponse {
  /// Pass this token as the `page_token` field of the request for a subsequent
  /// call.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The Trials associated with the Study.
  core.List<GoogleCloudAiplatformV1Trial>? trials;

  GoogleCloudAiplatformV1ListTrialsResponse({
    this.nextPageToken,
    this.trials,
  });

  GoogleCloudAiplatformV1ListTrialsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          trials: json_.containsKey('trials')
              ? (json_['trials'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Trial.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (trials != null) 'trials': trials!,
      };
}

/// Request message for VizierService.LookupStudy.
class GoogleCloudAiplatformV1LookupStudyRequest {
  /// The user-defined display name of the Study
  ///
  /// Required.
  core.String? displayName;

  GoogleCloudAiplatformV1LookupStudyRequest({
    this.displayName,
  });

  GoogleCloudAiplatformV1LookupStudyRequest.fromJson(core.Map json_)
      : this(
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
      };
}

/// Specification of a single machine.
class GoogleCloudAiplatformV1MachineSpec {
  /// The number of accelerators to attach to the machine.
  core.int? acceleratorCount;

  /// The type of accelerator(s) that may be attached to the machine as per
  /// accelerator_count.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "ACCELERATOR_TYPE_UNSPECIFIED" : Unspecified accelerator type, which
  /// means no accelerator.
  /// - "NVIDIA_TESLA_K80" : Nvidia Tesla K80 GPU.
  /// - "NVIDIA_TESLA_P100" : Nvidia Tesla P100 GPU.
  /// - "NVIDIA_TESLA_V100" : Nvidia Tesla V100 GPU.
  /// - "NVIDIA_TESLA_P4" : Nvidia Tesla P4 GPU.
  /// - "NVIDIA_TESLA_T4" : Nvidia Tesla T4 GPU.
  /// - "NVIDIA_TESLA_A100" : Nvidia Tesla A100 GPU.
  /// - "NVIDIA_A100_80GB" : Nvidia A100 80GB GPU.
  /// - "NVIDIA_L4" : Nvidia L4 GPU.
  /// - "TPU_V2" : TPU v2.
  /// - "TPU_V3" : TPU v3.
  /// - "TPU_V4_POD" : TPU v4.
  core.String? acceleratorType;

  /// The type of the machine.
  ///
  /// See the
  /// [list of machine types supported for prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
  /// See the
  /// [list of machine types supported for custom training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
  /// For DeployedModel this field is optional, and the default value is
  /// `n1-standard-2`. For BatchPredictionJob or as part of WorkerPoolSpec this
  /// field is required.
  ///
  /// Immutable.
  core.String? machineType;

  /// The topology of the TPUs.
  ///
  /// Corresponds to the TPU topologies available from GKE. (Example:
  /// tpu_topology: "2x2x1").
  ///
  /// Immutable.
  core.String? tpuTopology;

  GoogleCloudAiplatformV1MachineSpec({
    this.acceleratorCount,
    this.acceleratorType,
    this.machineType,
    this.tpuTopology,
  });

  GoogleCloudAiplatformV1MachineSpec.fromJson(core.Map json_)
      : this(
          acceleratorCount: json_.containsKey('acceleratorCount')
              ? json_['acceleratorCount'] as core.int
              : null,
          acceleratorType: json_.containsKey('acceleratorType')
              ? json_['acceleratorType'] as core.String
              : null,
          machineType: json_.containsKey('machineType')
              ? json_['machineType'] as core.String
              : null,
          tpuTopology: json_.containsKey('tpuTopology')
              ? json_['tpuTopology'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (acceleratorCount != null) 'acceleratorCount': acceleratorCount!,
        if (acceleratorType != null) 'acceleratorType': acceleratorType!,
        if (machineType != null) 'machineType': machineType!,
        if (tpuTopology != null) 'tpuTopology': tpuTopology!,
      };
}

/// Manual batch tuning parameters.
class GoogleCloudAiplatformV1ManualBatchTuningParameters {
  /// The number of the records (e.g. instances) of the operation given in each
  /// batch to a machine replica.
  ///
  /// Machine type, and size of a single record should be considered when
  /// setting this parameter, higher value speeds up the batch operation's
  /// execution, but too high value will result in a whole batch not fitting in
  /// a machine's memory, and the whole operation will fail. The default value
  /// is 64.
  ///
  /// Immutable.
  core.int? batchSize;

  GoogleCloudAiplatformV1ManualBatchTuningParameters({
    this.batchSize,
  });

  GoogleCloudAiplatformV1ManualBatchTuningParameters.fromJson(core.Map json_)
      : this(
          batchSize: json_.containsKey('batchSize')
              ? json_['batchSize'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (batchSize != null) 'batchSize': batchSize!,
      };
}

/// A message representing a Measurement of a Trial.
///
/// A Measurement contains the Metrics got by executing a Trial using suggested
/// hyperparameter values.
class GoogleCloudAiplatformV1Measurement {
  /// Time that the Trial has been running at the point of this Measurement.
  ///
  /// Output only.
  core.String? elapsedDuration;

  /// A list of metrics got by evaluating the objective functions using
  /// suggested Parameter values.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1MeasurementMetric>? metrics;

  /// The number of steps the machine learning model has been trained for.
  ///
  /// Must be non-negative.
  ///
  /// Output only.
  core.String? stepCount;

  GoogleCloudAiplatformV1Measurement({
    this.elapsedDuration,
    this.metrics,
    this.stepCount,
  });

  GoogleCloudAiplatformV1Measurement.fromJson(core.Map json_)
      : this(
          elapsedDuration: json_.containsKey('elapsedDuration')
              ? json_['elapsedDuration'] as core.String
              : null,
          metrics: json_.containsKey('metrics')
              ? (json_['metrics'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1MeasurementMetric.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          stepCount: json_.containsKey('stepCount')
              ? json_['stepCount'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (elapsedDuration != null) 'elapsedDuration': elapsedDuration!,
        if (metrics != null) 'metrics': metrics!,
        if (stepCount != null) 'stepCount': stepCount!,
      };
}

/// A message representing a metric in the measurement.
class GoogleCloudAiplatformV1MeasurementMetric {
  /// The ID of the Metric.
  ///
  /// The Metric should be defined in StudySpec's Metrics.
  ///
  /// Output only.
  core.String? metricId;

  /// The value for this metric.
  ///
  /// Output only.
  core.double? value;

  GoogleCloudAiplatformV1MeasurementMetric({
    this.metricId,
    this.value,
  });

  GoogleCloudAiplatformV1MeasurementMetric.fromJson(core.Map json_)
      : this(
          metricId: json_.containsKey('metricId')
              ? json_['metricId'] as core.String
              : null,
          value: json_.containsKey('value')
              ? (json_['value'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metricId != null) 'metricId': metricId!,
        if (value != null) 'value': value!,
      };
}

/// Request message for ModelService.MergeVersionAliases.
class GoogleCloudAiplatformV1MergeVersionAliasesRequest {
  /// The set of version aliases to merge.
  ///
  /// The alias should be at most 128 characters, and match
  /// `a-z{0,126}[a-z-0-9]`. Add the `-` prefix to an alias means removing that
  /// alias from the version. `-` is NOT counted in the 128 characters. Example:
  /// `-golden` means removing the `golden` alias from the version. There is NO
  /// ordering in aliases, which means 1) The aliases returned from GetModel API
  /// might not have the exactly same order from this MergeVersionAliases API.
  /// 2) Adding and deleting the same alias in the request is not recommended,
  /// and the 2 operations will be cancelled out.
  ///
  /// Required.
  core.List<core.String>? versionAliases;

  GoogleCloudAiplatformV1MergeVersionAliasesRequest({
    this.versionAliases,
  });

  GoogleCloudAiplatformV1MergeVersionAliasesRequest.fromJson(core.Map json_)
      : this(
          versionAliases: json_.containsKey('versionAliases')
              ? (json_['versionAliases'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (versionAliases != null) 'versionAliases': versionAliases!,
      };
}

/// Instance of a general MetadataSchema.
class GoogleCloudAiplatformV1MetadataSchema {
  /// Timestamp when this MetadataSchema was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the Metadata Schema
  core.String? description;

  /// The resource name of the MetadataSchema.
  ///
  /// Output only.
  core.String? name;

  /// The raw YAML string representation of the MetadataSchema.
  ///
  /// The combination of \[MetadataSchema.version\] and the schema name given by
  /// `title` in \[MetadataSchema.schema\] must be unique within a
  /// MetadataStore. The schema is defined as an OpenAPI 3.0.2
  /// [MetadataSchema Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#schemaObject)
  ///
  /// Required.
  core.String? schema;

  /// The type of the MetadataSchema.
  ///
  /// This is a property that identifies which metadata types will use the
  /// MetadataSchema.
  /// Possible string values are:
  /// - "METADATA_SCHEMA_TYPE_UNSPECIFIED" : Unspecified type for the
  /// MetadataSchema.
  /// - "ARTIFACT_TYPE" : A type indicating that the MetadataSchema will be used
  /// by Artifacts.
  /// - "EXECUTION_TYPE" : A typee indicating that the MetadataSchema will be
  /// used by Executions.
  /// - "CONTEXT_TYPE" : A state indicating that the MetadataSchema will be used
  /// by Contexts.
  core.String? schemaType;

  /// The version of the MetadataSchema.
  ///
  /// The version's format must match the following regular expression:
  /// `^[0-9]+.+.+$`, which would allow to order/compare different versions.
  /// Example: 1.0.0, 1.0.1, etc.
  core.String? schemaVersion;

  GoogleCloudAiplatformV1MetadataSchema({
    this.createTime,
    this.description,
    this.name,
    this.schema,
    this.schemaType,
    this.schemaVersion,
  });

  GoogleCloudAiplatformV1MetadataSchema.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          schema: json_.containsKey('schema')
              ? json_['schema'] as core.String
              : null,
          schemaType: json_.containsKey('schemaType')
              ? json_['schemaType'] as core.String
              : null,
          schemaVersion: json_.containsKey('schemaVersion')
              ? json_['schemaVersion'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (name != null) 'name': name!,
        if (schema != null) 'schema': schema!,
        if (schemaType != null) 'schemaType': schemaType!,
        if (schemaVersion != null) 'schemaVersion': schemaVersion!,
      };
}

/// Instance of a metadata store.
///
/// Contains a set of metadata that can be queried.
class GoogleCloudAiplatformV1MetadataStore {
  /// Timestamp when this MetadataStore was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of the MetadataStore.
  core.String? description;

  /// Customer-managed encryption key spec for a Metadata Store.
  ///
  /// If set, this Metadata Store and all sub-resources of this Metadata Store
  /// are secured using this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// The resource name of the MetadataStore instance.
  ///
  /// Output only.
  core.String? name;

  /// State information of the MetadataStore.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MetadataStoreMetadataStoreState? state;

  /// Timestamp when this MetadataStore was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1MetadataStore({
    this.createTime,
    this.description,
    this.encryptionSpec,
    this.name,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1MetadataStore.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          state: json_.containsKey('state')
              ? GoogleCloudAiplatformV1MetadataStoreMetadataStoreState.fromJson(
                  json_['state'] as core.Map<core.String, core.dynamic>)
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (name != null) 'name': name!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Represents state information for a MetadataStore.
class GoogleCloudAiplatformV1MetadataStoreMetadataStoreState {
  /// The disk utilization of the MetadataStore in bytes.
  core.String? diskUtilizationBytes;

  GoogleCloudAiplatformV1MetadataStoreMetadataStoreState({
    this.diskUtilizationBytes,
  });

  GoogleCloudAiplatformV1MetadataStoreMetadataStoreState.fromJson(
      core.Map json_)
      : this(
          diskUtilizationBytes: json_.containsKey('diskUtilizationBytes')
              ? json_['diskUtilizationBytes'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskUtilizationBytes != null)
          'diskUtilizationBytes': diskUtilizationBytes!,
      };
}

/// Represents one resource that exists in automl.googleapis.com,
/// datalabeling.googleapis.com or ml.googleapis.com.
class GoogleCloudAiplatformV1MigratableResource {
  /// Represents one Dataset in automl.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceAutomlDataset? automlDataset;

  /// Represents one Model in automl.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceAutomlModel? automlModel;

  /// Represents one Dataset in datalabeling.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset?
      dataLabelingDataset;

  /// Timestamp when the last migration attempt on this MigratableResource
  /// started.
  ///
  /// Will not be set if there's no migration attempt on this
  /// MigratableResource.
  ///
  /// Output only.
  core.String? lastMigrateTime;

  /// Timestamp when this MigratableResource was last updated.
  ///
  /// Output only.
  core.String? lastUpdateTime;

  /// Represents one Version in ml.googleapis.com.
  ///
  /// Output only.
  GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion?
      mlEngineModelVersion;

  GoogleCloudAiplatformV1MigratableResource({
    this.automlDataset,
    this.automlModel,
    this.dataLabelingDataset,
    this.lastMigrateTime,
    this.lastUpdateTime,
    this.mlEngineModelVersion,
  });

  GoogleCloudAiplatformV1MigratableResource.fromJson(core.Map json_)
      : this(
          automlDataset: json_.containsKey('automlDataset')
              ? GoogleCloudAiplatformV1MigratableResourceAutomlDataset.fromJson(
                  json_['automlDataset'] as core.Map<core.String, core.dynamic>)
              : null,
          automlModel: json_.containsKey('automlModel')
              ? GoogleCloudAiplatformV1MigratableResourceAutomlModel.fromJson(
                  json_['automlModel'] as core.Map<core.String, core.dynamic>)
              : null,
          dataLabelingDataset: json_.containsKey('dataLabelingDataset')
              ? GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset
                  .fromJson(json_['dataLabelingDataset']
                      as core.Map<core.String, core.dynamic>)
              : null,
          lastMigrateTime: json_.containsKey('lastMigrateTime')
              ? json_['lastMigrateTime'] as core.String
              : null,
          lastUpdateTime: json_.containsKey('lastUpdateTime')
              ? json_['lastUpdateTime'] as core.String
              : null,
          mlEngineModelVersion: json_.containsKey('mlEngineModelVersion')
              ? GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion
                  .fromJson(json_['mlEngineModelVersion']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (automlDataset != null) 'automlDataset': automlDataset!,
        if (automlModel != null) 'automlModel': automlModel!,
        if (dataLabelingDataset != null)
          'dataLabelingDataset': dataLabelingDataset!,
        if (lastMigrateTime != null) 'lastMigrateTime': lastMigrateTime!,
        if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!,
        if (mlEngineModelVersion != null)
          'mlEngineModelVersion': mlEngineModelVersion!,
      };
}

/// Represents one Dataset in automl.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceAutomlDataset {
  /// Full resource name of automl Dataset.
  ///
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`.
  core.String? dataset;

  /// The Dataset's display name in automl.googleapis.com.
  core.String? datasetDisplayName;

  GoogleCloudAiplatformV1MigratableResourceAutomlDataset({
    this.dataset,
    this.datasetDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceAutomlDataset.fromJson(
      core.Map json_)
      : this(
          dataset: json_.containsKey('dataset')
              ? json_['dataset'] as core.String
              : null,
          datasetDisplayName: json_.containsKey('datasetDisplayName')
              ? json_['datasetDisplayName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
      };
}

/// Represents one Model in automl.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceAutomlModel {
  /// Full resource name of automl Model.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  core.String? model;

  /// The Model's display name in automl.googleapis.com.
  core.String? modelDisplayName;

  GoogleCloudAiplatformV1MigratableResourceAutomlModel({
    this.model,
    this.modelDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceAutomlModel.fromJson(core.Map json_)
      : this(
          model:
              json_.containsKey('model') ? json_['model'] as core.String : null,
          modelDisplayName: json_.containsKey('modelDisplayName')
              ? json_['modelDisplayName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
      };
}

/// Represents one Dataset in datalabeling.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset {
  /// The migratable AnnotatedDataset in datalabeling.googleapis.com belongs to
  /// the data labeling Dataset.
  core.List<
          GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset>?
      dataLabelingAnnotatedDatasets;

  /// Full resource name of data labeling Dataset.
  ///
  /// Format: `projects/{project}/datasets/{dataset}`.
  core.String? dataset;

  /// The Dataset's display name in datalabeling.googleapis.com.
  core.String? datasetDisplayName;

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset({
    this.dataLabelingAnnotatedDatasets,
    this.dataset,
    this.datasetDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDataset.fromJson(
      core.Map json_)
      : this(
          dataLabelingAnnotatedDatasets: json_
                  .containsKey('dataLabelingAnnotatedDatasets')
              ? (json_['dataLabelingAnnotatedDatasets'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          dataset: json_.containsKey('dataset')
              ? json_['dataset'] as core.String
              : null,
          datasetDisplayName: json_.containsKey('datasetDisplayName')
              ? json_['datasetDisplayName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataLabelingAnnotatedDatasets != null)
          'dataLabelingAnnotatedDatasets': dataLabelingAnnotatedDatasets!,
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
      };
}

/// Represents one AnnotatedDataset in datalabeling.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset {
  /// Full resource name of data labeling AnnotatedDataset.
  ///
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  core.String? annotatedDataset;

  /// The AnnotatedDataset's display name in datalabeling.googleapis.com.
  core.String? annotatedDatasetDisplayName;

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset({
    this.annotatedDataset,
    this.annotatedDatasetDisplayName,
  });

  GoogleCloudAiplatformV1MigratableResourceDataLabelingDatasetDataLabelingAnnotatedDataset.fromJson(
      core.Map json_)
      : this(
          annotatedDataset: json_.containsKey('annotatedDataset')
              ? json_['annotatedDataset'] as core.String
              : null,
          annotatedDatasetDisplayName:
              json_.containsKey('annotatedDatasetDisplayName')
                  ? json_['annotatedDatasetDisplayName'] as core.String
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotatedDataset != null) 'annotatedDataset': annotatedDataset!,
        if (annotatedDatasetDisplayName != null)
          'annotatedDatasetDisplayName': annotatedDatasetDisplayName!,
      };
}

/// Represents one model Version in ml.googleapis.com.
class GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion {
  /// The ml.googleapis.com endpoint that this model Version currently lives in.
  ///
  /// Example values: * ml.googleapis.com * us-centrall-ml.googleapis.com *
  /// europe-west4-ml.googleapis.com * asia-east1-ml.googleapis.com
  core.String? endpoint;

  /// Full resource name of ml engine model Version.
  ///
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  core.String? version;

  GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion({
    this.endpoint,
    this.version,
  });

  GoogleCloudAiplatformV1MigratableResourceMlEngineModelVersion.fromJson(
      core.Map json_)
      : this(
          endpoint: json_.containsKey('endpoint')
              ? json_['endpoint'] as core.String
              : null,
          version: json_.containsKey('version')
              ? json_['version'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
        if (version != null) 'version': version!,
      };
}

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
class GoogleCloudAiplatformV1MigrateResourceRequest {
  /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
  /// Dataset.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig?
      migrateAutomlDatasetConfig;

  /// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig?
      migrateAutomlModelConfig;

  /// Config for migrating Dataset in datalabeling.googleapis.com to Vertex AI's
  /// Dataset.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig?
      migrateDataLabelingDatasetConfig;

  /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
  GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig?
      migrateMlEngineModelVersionConfig;

  GoogleCloudAiplatformV1MigrateResourceRequest({
    this.migrateAutomlDatasetConfig,
    this.migrateAutomlModelConfig,
    this.migrateDataLabelingDatasetConfig,
    this.migrateMlEngineModelVersionConfig,
  });

  GoogleCloudAiplatformV1MigrateResourceRequest.fromJson(core.Map json_)
      : this(
          migrateAutomlDatasetConfig: json_
                  .containsKey('migrateAutomlDatasetConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig
                  .fromJson(json_['migrateAutomlDatasetConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          migrateAutomlModelConfig: json_
                  .containsKey('migrateAutomlModelConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig
                  .fromJson(json_['migrateAutomlModelConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          migrateDataLabelingDatasetConfig: json_
                  .containsKey('migrateDataLabelingDatasetConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig
                  .fromJson(json_['migrateDataLabelingDatasetConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          migrateMlEngineModelVersionConfig: json_
                  .containsKey('migrateMlEngineModelVersionConfig')
              ? GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig
                  .fromJson(json_['migrateMlEngineModelVersionConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (migrateAutomlDatasetConfig != null)
          'migrateAutomlDatasetConfig': migrateAutomlDatasetConfig!,
        if (migrateAutomlModelConfig != null)
          'migrateAutomlModelConfig': migrateAutomlModelConfig!,
        if (migrateDataLabelingDatasetConfig != null)
          'migrateDataLabelingDatasetConfig': migrateDataLabelingDatasetConfig!,
        if (migrateMlEngineModelVersionConfig != null)
          'migrateMlEngineModelVersionConfig':
              migrateMlEngineModelVersionConfig!,
      };
}

/// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
/// Dataset.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig {
  /// Full resource name of automl Dataset.
  ///
  /// Format: `projects/{project}/locations/{location}/datasets/{dataset}`.
  ///
  /// Required.
  core.String? dataset;

  /// Display name of the Dataset in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Required.
  core.String? datasetDisplayName;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlDatasetConfig.fromJson(
      core.Map json_)
      : this(
          dataset: json_.containsKey('dataset')
              ? json_['dataset'] as core.String
              : null,
          datasetDisplayName: json_.containsKey('datasetDisplayName')
              ? json_['datasetDisplayName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
      };
}

/// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig {
  /// Full resource name of automl Model.
  ///
  /// Format: `projects/{project}/locations/{location}/models/{model}`.
  ///
  /// Required.
  core.String? model;

  /// Display name of the model in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Optional.
  core.String? modelDisplayName;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig({
    this.model,
    this.modelDisplayName,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateAutomlModelConfig.fromJson(
      core.Map json_)
      : this(
          model:
              json_.containsKey('model') ? json_['model'] as core.String : null,
          modelDisplayName: json_.containsKey('modelDisplayName')
              ? json_['modelDisplayName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
      };
}

/// Config for migrating Dataset in datalabeling.googleapis.com to Vertex AI's
/// Dataset.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig {
  /// Full resource name of data labeling Dataset.
  ///
  /// Format: `projects/{project}/datasets/{dataset}`.
  ///
  /// Required.
  core.String? dataset;

  /// Display name of the Dataset in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Optional.
  core.String? datasetDisplayName;

  /// Configs for migrating AnnotatedDataset in datalabeling.googleapis.com to
  /// Vertex AI's SavedQuery.
  ///
  /// The specified AnnotatedDatasets have to belong to the datalabeling
  /// Dataset.
  ///
  /// Optional.
  core.List<
          GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig>?
      migrateDataLabelingAnnotatedDatasetConfigs;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
    this.migrateDataLabelingAnnotatedDatasetConfigs,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfig.fromJson(
      core.Map json_)
      : this(
          dataset: json_.containsKey('dataset')
              ? json_['dataset'] as core.String
              : null,
          datasetDisplayName: json_.containsKey('datasetDisplayName')
              ? json_['datasetDisplayName'] as core.String
              : null,
          migrateDataLabelingAnnotatedDatasetConfigs: json_
                  .containsKey('migrateDataLabelingAnnotatedDatasetConfigs')
              ? (json_['migrateDataLabelingAnnotatedDatasetConfigs']
                      as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataset != null) 'dataset': dataset!,
        if (datasetDisplayName != null)
          'datasetDisplayName': datasetDisplayName!,
        if (migrateDataLabelingAnnotatedDatasetConfigs != null)
          'migrateDataLabelingAnnotatedDatasetConfigs':
              migrateDataLabelingAnnotatedDatasetConfigs!,
      };
}

/// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
/// Vertex AI's SavedQuery.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig {
  /// Full resource name of data labeling AnnotatedDataset.
  ///
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  ///
  /// Required.
  core.String? annotatedDataset;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig({
    this.annotatedDataset,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateDataLabelingDatasetConfigMigrateDataLabelingAnnotatedDatasetConfig.fromJson(
      core.Map json_)
      : this(
          annotatedDataset: json_.containsKey('annotatedDataset')
              ? json_['annotatedDataset'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotatedDataset != null) 'annotatedDataset': annotatedDataset!,
      };
}

/// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
class GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig {
  /// The ml.googleapis.com endpoint that this model version should be migrated
  /// from.
  ///
  /// Example values: * ml.googleapis.com * us-centrall-ml.googleapis.com *
  /// europe-west4-ml.googleapis.com * asia-east1-ml.googleapis.com
  ///
  /// Required.
  core.String? endpoint;

  /// Display name of the model in Vertex AI.
  ///
  /// System will pick a display name if unspecified.
  ///
  /// Required.
  core.String? modelDisplayName;

  /// Full resource name of ml engine model version.
  ///
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  ///
  /// Required.
  core.String? modelVersion;

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig({
    this.endpoint,
    this.modelDisplayName,
    this.modelVersion,
  });

  GoogleCloudAiplatformV1MigrateResourceRequestMigrateMlEngineModelVersionConfig.fromJson(
      core.Map json_)
      : this(
          endpoint: json_.containsKey('endpoint')
              ? json_['endpoint'] as core.String
              : null,
          modelDisplayName: json_.containsKey('modelDisplayName')
              ? json_['modelDisplayName'] as core.String
              : null,
          modelVersion: json_.containsKey('modelVersion')
              ? json_['modelVersion'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endpoint != null) 'endpoint': endpoint!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
        if (modelVersion != null) 'modelVersion': modelVersion!,
      };
}

/// A trained machine learning Model.
class GoogleCloudAiplatformV1Model {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  ///
  /// Not present for AutoML Models or Large Models.
  ///
  /// Immutable.
  core.String? artifactUri;

  /// Input only.
  ///
  /// The specification of the container that is to be used when deploying this
  /// Model. The specification is ingested upon ModelService.UploadModel, and
  /// all binaries it contains are copied and stored internally by Vertex AI.
  /// Not present for AutoML Models or Large Models.
  GoogleCloudAiplatformV1ModelContainerSpec? containerSpec;

  /// Timestamp when this Model was uploaded into Vertex AI.
  ///
  /// Output only.
  core.String? createTime;

  /// The pointers to DeployedModels created from this Model.
  ///
  /// Note that Model could have been deployed to Endpoints in different
  /// Locations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1DeployedModelRef>? deployedModels;

  /// The description of the Model.
  core.String? description;

  /// The display name of the Model.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Model.
  ///
  /// If set, this Model and all sub-resources of this Model will be secured by
  /// this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The default explanation specification for this Model.
  ///
  /// The Model can be used for requesting explanation after being deployed if
  /// it is populated. The Model can be used for batch explanation if it is
  /// populated. All fields of the explanation_spec can be overridden by
  /// explanation_spec of DeployModelRequest.deployed_model, or explanation_spec
  /// of BatchPredictionJob. If the default explanation specification is not set
  /// for this Model, this Model can still be used for requesting explanation by
  /// setting explanation_spec of DeployModelRequest.deployed_model and for
  /// batch explanation by setting explanation_spec of BatchPredictionJob.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// The labels with user-defined metadata to organize your Models.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// An additional information about the Model; the schema of the metadata can
  /// be found in metadata_schema.
  ///
  /// Unset if the Model does not have any additional information.
  ///
  /// Immutable.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Artifact that was created in MetadataStore when
  /// creating the Model.
  ///
  /// The Artifact resource name pattern is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  ///
  /// Output only.
  core.String? metadataArtifact;

  /// Points to a YAML file stored on Google Cloud Storage describing additional
  /// information about the Model, that is specific to it.
  ///
  /// Unset if the Model does not have any additional information. The schema is
  /// defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// additional metadata is needed, this field is set to an empty string. Note:
  /// The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  ///
  /// Immutable.
  core.String? metadataSchemaUri;

  /// Source of a model.
  ///
  /// It can either be automl training pipeline, custom training pipeline,
  /// BigQuery ML, or existing Vertex AI Model.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelSourceInfo? modelSourceInfo;

  /// The resource name of the Model.
  core.String? name;

  /// If this Model is a copy of another Model, this contains info about the
  /// original.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelOriginalModelInfo? originalModelInfo;

  /// This field is populated if the model is produced by a pipeline job.
  ///
  /// Optional.
  core.String? pipelineJob;

  /// The schemata that describe formats of the Model's predictions and
  /// explanations as given and returned via PredictionService.Predict and
  /// PredictionService.Explain.
  GoogleCloudAiplatformV1PredictSchemata? predictSchemata;

  /// When this Model is deployed, its prediction resources are described by the
  /// `prediction_resources` field of the Endpoint.deployed_models object.
  ///
  /// Because not all Models support all resource configuration types, the
  /// configuration types this Model supports are listed here. If no
  /// configuration types are listed, the Model cannot be deployed to an
  /// Endpoint and does not support online predictions
  /// (PredictionService.Predict or PredictionService.Explain). Such a Model can
  /// serve predictions by using a BatchPredictionJob, if it has at least one
  /// entry each in supported_input_storage_formats and
  /// supported_output_storage_formats.
  ///
  /// Output only.
  core.List<core.String>? supportedDeploymentResourcesTypes;

  /// The formats in which this Model may be exported.
  ///
  /// If empty, this Model is not available for export.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModelExportFormat>? supportedExportFormats;

  /// The formats this Model supports in BatchPredictionJob.input_config.
  ///
  /// If PredictSchemata.instance_schema_uri exists, the instances should be
  /// given as per that schema. The possible formats are: * `jsonl` The JSON
  /// Lines format, where each instance is a single line. Uses GcsSource. *
  /// `csv` The CSV format, where each instance is a single comma-separated
  /// line. The first line in the file is the header, containing comma-separated
  /// field names. Uses GcsSource. * `tf-record` The TFRecord format, where each
  /// instance is a single record in tfrecord syntax. Uses GcsSource. *
  /// `tf-record-gzip` Similar to `tf-record`, but the file is gzipped. Uses
  /// GcsSource. * `bigquery` Each instance is a single row in BigQuery. Uses
  /// BigQuerySource. * `file-list` Each line of the file is the location of an
  /// instance to process, uses `gcs_source` field of the InputConfig object. If
  /// this Model doesn't support any of these formats it means it cannot be used
  /// with a BatchPredictionJob. However, if it has
  /// supported_deployment_resources_types, it could serve online predictions by
  /// using PredictionService.Predict or PredictionService.Explain.
  ///
  /// Output only.
  core.List<core.String>? supportedInputStorageFormats;

  /// The formats this Model supports in BatchPredictionJob.output_config.
  ///
  /// If both PredictSchemata.instance_schema_uri and
  /// PredictSchemata.prediction_schema_uri exist, the predictions are returned
  /// together with their instances. In other words, the prediction has the
  /// original instance data first, followed by the actual prediction content
  /// (as per the schema). The possible formats are: * `jsonl` The JSON Lines
  /// format, where each prediction is a single line. Uses GcsDestination. *
  /// `csv` The CSV format, where each prediction is a single comma-separated
  /// line. The first line in the file is the header, containing comma-separated
  /// field names. Uses GcsDestination. * `bigquery` Each prediction is a single
  /// row in a BigQuery table, uses BigQueryDestination . If this Model doesn't
  /// support any of these formats it means it cannot be used with a
  /// BatchPredictionJob. However, if it has
  /// supported_deployment_resources_types, it could serve online predictions by
  /// using PredictionService.Predict or PredictionService.Explain.
  ///
  /// Output only.
  core.List<core.String>? supportedOutputStorageFormats;

  /// The resource name of the TrainingPipeline that uploaded this Model, if
  /// any.
  ///
  /// Output only.
  core.String? trainingPipeline;

  /// Timestamp when this Model was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// User provided version aliases so that a model version can be referenced
  /// via alias (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
  /// instead of auto-generated version id (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
  ///
  /// The format is a-z{0,126}\[a-z0-9\] to distinguish from version_id. A
  /// default version alias will be created for the first version of the model,
  /// and there must be exactly one default version alias for a model.
  core.List<core.String>? versionAliases;

  /// Timestamp when this version was created.
  ///
  /// Output only.
  core.String? versionCreateTime;

  /// The description of this version.
  core.String? versionDescription;

  /// The version ID of the model.
  ///
  /// A new version is committed when a new model version is uploaded or trained
  /// under an existing model id. It is an auto-incrementing decimal number in
  /// string representation.
  ///
  /// Output only. Immutable.
  core.String? versionId;

  /// Timestamp when this version was most recently updated.
  ///
  /// Output only.
  core.String? versionUpdateTime;

  GoogleCloudAiplatformV1Model({
    this.artifactUri,
    this.containerSpec,
    this.createTime,
    this.deployedModels,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.explanationSpec,
    this.labels,
    this.metadata,
    this.metadataArtifact,
    this.metadataSchemaUri,
    this.modelSourceInfo,
    this.name,
    this.originalModelInfo,
    this.pipelineJob,
    this.predictSchemata,
    this.supportedDeploymentResourcesTypes,
    this.supportedExportFormats,
    this.supportedInputStorageFormats,
    this.supportedOutputStorageFormats,
    this.trainingPipeline,
    this.updateTime,
    this.versionAliases,
    this.versionCreateTime,
    this.versionDescription,
    this.versionId,
    this.versionUpdateTime,
  });

  GoogleCloudAiplatformV1Model.fromJson(core.Map json_)
      : this(
          artifactUri: json_.containsKey('artifactUri')
              ? json_['artifactUri'] as core.String
              : null,
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          deployedModels: json_.containsKey('deployedModels')
              ? (json_['deployedModels'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1DeployedModelRef.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          metadata: json_.containsKey('metadata') ? json_['metadata'] : null,
          metadataArtifact: json_.containsKey('metadataArtifact')
              ? json_['metadataArtifact'] as core.String
              : null,
          metadataSchemaUri: json_.containsKey('metadataSchemaUri')
              ? json_['metadataSchemaUri'] as core.String
              : null,
          modelSourceInfo: json_.containsKey('modelSourceInfo')
              ? GoogleCloudAiplatformV1ModelSourceInfo.fromJson(
                  json_['modelSourceInfo']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          originalModelInfo: json_.containsKey('originalModelInfo')
              ? GoogleCloudAiplatformV1ModelOriginalModelInfo.fromJson(
                  json_['originalModelInfo']
                      as core.Map<core.String, core.dynamic>)
              : null,
          pipelineJob: json_.containsKey('pipelineJob')
              ? json_['pipelineJob'] as core.String
              : null,
          predictSchemata: json_.containsKey('predictSchemata')
              ? GoogleCloudAiplatformV1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          supportedDeploymentResourcesTypes:
              json_.containsKey('supportedDeploymentResourcesTypes')
                  ? (json_['supportedDeploymentResourcesTypes'] as core.List)
                      .map((value) => value as core.String)
                      .toList()
                  : null,
          supportedExportFormats: json_.containsKey('supportedExportFormats')
              ? (json_['supportedExportFormats'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelExportFormat.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          supportedInputStorageFormats:
              json_.containsKey('supportedInputStorageFormats')
                  ? (json_['supportedInputStorageFormats'] as core.List)
                      .map((value) => value as core.String)
                      .toList()
                  : null,
          supportedOutputStorageFormats:
              json_.containsKey('supportedOutputStorageFormats')
                  ? (json_['supportedOutputStorageFormats'] as core.List)
                      .map((value) => value as core.String)
                      .toList()
                  : null,
          trainingPipeline: json_.containsKey('trainingPipeline')
              ? json_['trainingPipeline'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
          versionAliases: json_.containsKey('versionAliases')
              ? (json_['versionAliases'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          versionCreateTime: json_.containsKey('versionCreateTime')
              ? json_['versionCreateTime'] as core.String
              : null,
          versionDescription: json_.containsKey('versionDescription')
              ? json_['versionDescription'] as core.String
              : null,
          versionId: json_.containsKey('versionId')
              ? json_['versionId'] as core.String
              : null,
          versionUpdateTime: json_.containsKey('versionUpdateTime')
              ? json_['versionUpdateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactUri != null) 'artifactUri': artifactUri!,
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (createTime != null) 'createTime': createTime!,
        if (deployedModels != null) 'deployedModels': deployedModels!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (labels != null) 'labels': labels!,
        if (metadata != null) 'metadata': metadata!,
        if (metadataArtifact != null) 'metadataArtifact': metadataArtifact!,
        if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri!,
        if (modelSourceInfo != null) 'modelSourceInfo': modelSourceInfo!,
        if (name != null) 'name': name!,
        if (originalModelInfo != null) 'originalModelInfo': originalModelInfo!,
        if (pipelineJob != null) 'pipelineJob': pipelineJob!,
        if (predictSchemata != null) 'predictSchemata': predictSchemata!,
        if (supportedDeploymentResourcesTypes != null)
          'supportedDeploymentResourcesTypes':
              supportedDeploymentResourcesTypes!,
        if (supportedExportFormats != null)
          'supportedExportFormats': supportedExportFormats!,
        if (supportedInputStorageFormats != null)
          'supportedInputStorageFormats': supportedInputStorageFormats!,
        if (supportedOutputStorageFormats != null)
          'supportedOutputStorageFormats': supportedOutputStorageFormats!,
        if (trainingPipeline != null) 'trainingPipeline': trainingPipeline!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (versionAliases != null) 'versionAliases': versionAliases!,
        if (versionCreateTime != null) 'versionCreateTime': versionCreateTime!,
        if (versionDescription != null)
          'versionDescription': versionDescription!,
        if (versionId != null) 'versionId': versionId!,
        if (versionUpdateTime != null) 'versionUpdateTime': versionUpdateTime!,
      };
}

/// Specification of a container for serving predictions.
///
/// Some fields in this message correspond to fields in the
/// [Kubernetes Container v1 core specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
class GoogleCloudAiplatformV1ModelContainerSpec {
  /// Specifies arguments for the command that runs when the container starts.
  ///
  /// This overrides the container's
  /// \[`CMD`\](https://docs.docker.com/engine/reference/builder/#cmd). Specify
  /// this field as an array of executable and arguments, similar to a Docker
  /// `CMD`'s "default parameters" form. If you don't specify this field but do
  /// specify the command field, then the command from the `command` field runs
  /// without any additional arguments. See the \[Kubernetes documentation about
  /// how the `command` and `args` fields interact with a container's
  /// `ENTRYPOINT` and
  /// `CMD`\](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  /// If you don't specify this field and don't specify the `command` field,
  /// then the container's
  /// \[`ENTRYPOINT`\](https://docs.docker.com/engine/reference/builder/#cmd)
  /// and `CMD` determine what runs based on their default behavior. See the
  /// Docker documentation about \[how `CMD` and `ENTRYPOINT`
  /// interact\](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  /// In this field, you can reference
  /// [environment variables set by Vertex AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the env field. You cannot reference
  /// environment variables set in the Docker image. In order for environment
  /// variables to be expanded, reference them by using the following syntax: $(
  /// VARIABLE_NAME) Note that this differs from Bash variable expansion, which
  /// does not use parentheses. If a variable cannot be resolved, the reference
  /// in the input string is used unchanged. To avoid variable expansion, you
  /// can escape this syntax with `$$`; for example: $$(VARIABLE_NAME) This
  /// field corresponds to the `args` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<core.String>? args;

  /// Specifies the command that runs when the container starts.
  ///
  /// This overrides the container's
  /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
  /// Specify this field as an array of executable and arguments, similar to a
  /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form. If you do not
  /// specify this field, then the container's `ENTRYPOINT` runs, in conjunction
  /// with the args field or the container's
  /// \[`CMD`\](https://docs.docker.com/engine/reference/builder/#cmd), if
  /// either exists. If this field is not specified and the container does not
  /// have an `ENTRYPOINT`, then refer to the Docker documentation about \[how
  /// `CMD` and `ENTRYPOINT`
  /// interact\](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  /// If you specify this field, then you can also specify the `args` field to
  /// provide additional arguments for this command. However, if you specify
  /// this field, then the container's `CMD` is ignored. See the \[Kubernetes
  /// documentation about how the `command` and `args` fields interact with a
  /// container's `ENTRYPOINT` and
  /// `CMD`\](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  /// In this field, you can reference
  /// [environment variables set by Vertex AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the env field. You cannot reference
  /// environment variables set in the Docker image. In order for environment
  /// variables to be expanded, reference them by using the following syntax: $(
  /// VARIABLE_NAME) Note that this differs from Bash variable expansion, which
  /// does not use parentheses. If a variable cannot be resolved, the reference
  /// in the input string is used unchanged. To avoid variable expansion, you
  /// can escape this syntax with `$$`; for example: $$(VARIABLE_NAME) This
  /// field corresponds to the `command` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<core.String>? command;

  /// List of environment variables to set in the container.
  ///
  /// After the container starts running, code running in the container can read
  /// these environment variables. Additionally, the command and args fields can
  /// reference these variables. Later entries in this list can also reference
  /// earlier entries. For example, the following example sets the variable
  /// `VAR_2` to have the value `foo bar`: ```json [ { "name": "VAR_1", "value":
  /// "foo" }, { "name": "VAR_2", "value": "$(VAR_1) bar" } ] ``` If you switch
  /// the order of the variables in the example, then the expansion does not
  /// occur. This field corresponds to the `env` field of the Kubernetes
  /// Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// HTTP path on the container to send health checks to.
  ///
  /// Vertex AI intermittently sends GET requests to this path on the
  /// container's IP address and port to check that the container is healthy.
  /// Read more about
  /// [health checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
  /// For example, if you set this field to `/bar`, then Vertex AI
  /// intermittently sends a GET request to the `/bar` path on the port of your
  /// container specified by the first value of this `ModelContainerSpec`'s
  /// ports field. If you don't specify this field, it defaults to the following
  /// value when you deploy this Model to an Endpoint:
  /// /v1/endpoints/ENDPOINT/deployedModels/ DEPLOYED_MODEL:predict The
  /// placeholders in this value are replaced as follows: * ENDPOINT: The last
  /// segment (following `endpoints/`)of the Endpoint.name\]\[\] field of the
  /// Endpoint where this Model has been deployed. (Vertex AI makes this value
  /// available to your container code as the \[`AIP_ENDPOINT_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  /// * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`. (Vertex AI
  /// makes this value available to your container code as the
  /// \[`AIP_DEPLOYED_MODEL_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// Immutable.
  core.String? healthRoute;

  /// URI of the Docker image to be used as the custom container for serving
  /// predictions.
  ///
  /// This URI must identify an image in Artifact Registry or Container
  /// Registry. Learn more about the
  /// [container publishing requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
  /// including permissions requirements for the Vertex AI Service Agent. The
  /// container image is ingested upon ModelService.UploadModel, stored
  /// internally, and this original path is afterwards not used. To learn about
  /// the requirements for the Docker image itself, see
  /// [Custom container requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
  /// You can use the URI to one of Vertex AI's \[pre-built container images for
  /// prediction\](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
  /// in this field.
  ///
  /// Required. Immutable.
  core.String? imageUri;

  /// List of ports to expose from the container.
  ///
  /// Vertex AI sends any prediction requests that it receives to the first port
  /// on this list. Vertex AI also sends
  /// [liveness and health checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
  /// to this port. If you do not specify this field, it defaults to following
  /// value: ```json [ { "containerPort": 8080 } ] ``` Vertex AI does not use
  /// ports other than the first one listed. This field corresponds to the
  /// `ports` field of the Kubernetes Containers
  /// [v1 core API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  ///
  /// Immutable.
  core.List<GoogleCloudAiplatformV1Port>? ports;

  /// HTTP path on the container to send prediction requests to.
  ///
  /// Vertex AI forwards requests sent using
  /// projects.locations.endpoints.predict to this path on the container's IP
  /// address and port. Vertex AI then returns the container's response in the
  /// API response. For example, if you set this field to `/foo`, then when
  /// Vertex AI receives a prediction request, it forwards the request body in a
  /// POST request to the `/foo` path on the port of your container specified by
  /// the first value of this `ModelContainerSpec`'s ports field. If you don't
  /// specify this field, it defaults to the following value when you deploy
  /// this Model to an Endpoint:
  /// /v1/endpoints/ENDPOINT/deployedModels/DEPLOYED_MODEL:predict The
  /// placeholders in this value are replaced as follows: * ENDPOINT: The last
  /// segment (following `endpoints/`)of the Endpoint.name\]\[\] field of the
  /// Endpoint where this Model has been deployed. (Vertex AI makes this value
  /// available to your container code as the \[`AIP_ENDPOINT_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  /// * DEPLOYED_MODEL: DeployedModel.id of the `DeployedModel`. (Vertex AI
  /// makes this value available to your container code as the
  /// \[`AIP_DEPLOYED_MODEL_ID` environment
  /// variable\](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// Immutable.
  core.String? predictRoute;

  GoogleCloudAiplatformV1ModelContainerSpec({
    this.args,
    this.command,
    this.env,
    this.healthRoute,
    this.imageUri,
    this.ports,
    this.predictRoute,
  });

  GoogleCloudAiplatformV1ModelContainerSpec.fromJson(core.Map json_)
      : this(
          args: json_.containsKey('args')
              ? (json_['args'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          command: json_.containsKey('command')
              ? (json_['command'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          env: json_.containsKey('env')
              ? (json_['env'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          healthRoute: json_.containsKey('healthRoute')
              ? json_['healthRoute'] as core.String
              : null,
          imageUri: json_.containsKey('imageUri')
              ? json_['imageUri'] as core.String
              : null,
          ports: json_.containsKey('ports')
              ? (json_['ports'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Port.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          predictRoute: json_.containsKey('predictRoute')
              ? json_['predictRoute'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (args != null) 'args': args!,
        if (command != null) 'command': command!,
        if (env != null) 'env': env!,
        if (healthRoute != null) 'healthRoute': healthRoute!,
        if (imageUri != null) 'imageUri': imageUri!,
        if (ports != null) 'ports': ports!,
        if (predictRoute != null) 'predictRoute': predictRoute!,
      };
}

/// ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name as
/// well as some information of the logs stored in this table.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable {
  /// The created BigQuery table to store logs.
  ///
  /// Customer could do their own query & analysis. Format:
  /// `bq://.model_deployment_monitoring_._`
  core.String? bigqueryTablePath;

  /// The source of log.
  /// Possible string values are:
  /// - "LOG_SOURCE_UNSPECIFIED" : Unspecified source.
  /// - "TRAINING" : Logs coming from Training dataset.
  /// - "SERVING" : Logs coming from Serving traffic.
  core.String? logSource;

  /// The type of log.
  /// Possible string values are:
  /// - "LOG_TYPE_UNSPECIFIED" : Unspecified type.
  /// - "PREDICT" : Predict logs.
  /// - "EXPLAIN" : Explain logs.
  core.String? logType;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable({
    this.bigqueryTablePath,
    this.logSource,
    this.logType,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable.fromJson(
      core.Map json_)
      : this(
          bigqueryTablePath: json_.containsKey('bigqueryTablePath')
              ? json_['bigqueryTablePath'] as core.String
              : null,
          logSource: json_.containsKey('logSource')
              ? json_['logSource'] as core.String
              : null,
          logType: json_.containsKey('logType')
              ? json_['logType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryTablePath != null) 'bigqueryTablePath': bigqueryTablePath!,
        if (logSource != null) 'logSource': logSource!,
        if (logType != null) 'logType': logType!,
      };
}

/// Represents a job that runs periodically to monitor the deployed models in an
/// endpoint.
///
/// It will analyze the logged training & prediction data to detect any abnormal
/// behaviors.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringJob {
  /// YAML schema file uri describing the format of a single instance that you
  /// want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If this field is empty, all the feature data types are inferred from
  /// predict_instance_schema_uri, meaning that TFDV will use the data in the
  /// exact format(data type) as prediction request/response. If there are any
  /// data type differences between predict instance and TFDV instance, this
  /// field can be used to override the schema. For models trained with Vertex
  /// AI, this field must be set as all the fields in predict instance formatted
  /// as string.
  core.String? analysisInstanceSchemaUri;

  /// The created bigquery tables for the job under customer project.
  ///
  /// Customer could do their own query & analysis. There could be 4 log tables
  /// in maximum: 1. Training data logging predict request/response 2. Serving
  /// data logging predict request/response
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable>?
      bigqueryTables;

  /// Timestamp when this ModelDeploymentMonitoringJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the ModelDeploymentMonitoringJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. Display name of a ModelDeploymentMonitoringJob.
  ///
  /// Required.
  core.String? displayName;

  /// If true, the scheduled monitoring pipeline logs are sent to Google Cloud
  /// Logging, including pipeline status and anomalies detected.
  ///
  /// Please note the logs incur cost, which are subject to
  /// [Cloud Logging pricing](https://cloud.google.com/logging#pricing).
  core.bool? enableMonitoringPipelineLogs;

  /// Customer-managed encryption key spec for a ModelDeploymentMonitoringJob.
  ///
  /// If set, this ModelDeploymentMonitoringJob and all sub-resources of this
  /// ModelDeploymentMonitoringJob will be secured by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Endpoint resource name.
  ///
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  ///
  /// Required.
  core.String? endpoint;

  /// Only populated when the job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize your
  /// ModelDeploymentMonitoringJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Latest triggered monitoring pipeline metadata.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata?
      latestMonitoringPipelineMetadata;

  /// The TTL of BigQuery tables in user projects which stores logs.
  ///
  /// A day is the basic unit of the TTL and we take the ceil of TTL/86400(a
  /// day). e.g. { second: 3600} indicates ttl = 1 day.
  core.String? logTtl;

  /// Sample Strategy for logging.
  ///
  /// Required.
  GoogleCloudAiplatformV1SamplingStrategy? loggingSamplingStrategy;

  /// The config for monitoring objectives.
  ///
  /// This is a per DeployedModel config. Each DeployedModel needs to be
  /// configured separately.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig>?
      modelDeploymentMonitoringObjectiveConfigs;

  /// Schedule config for running the monitoring job.
  ///
  /// Required.
  GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig?
      modelDeploymentMonitoringScheduleConfig;

  /// Alert config for model monitoring.
  GoogleCloudAiplatformV1ModelMonitoringAlertConfig? modelMonitoringAlertConfig;

  /// Resource name of a ModelDeploymentMonitoringJob.
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this monitoring pipeline will be scheduled to run for the
  /// next round.
  ///
  /// Output only.
  core.String? nextScheduleTime;

  /// YAML schema file uri describing the format of a single instance, which are
  /// given to format this Endpoint's prediction (and explanation).
  ///
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  core.String? predictInstanceSchemaUri;

  /// Sample Predict instance, same format as PredictRequest.instances, this can
  /// be set as a replacement of
  /// ModelDeploymentMonitoringJob.predict_instance_schema_uri.
  ///
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? samplePredictInstance;

  /// Schedule state when the monitoring job is in Running state.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "MONITORING_SCHEDULE_STATE_UNSPECIFIED" : Unspecified state.
  /// - "PENDING" : The pipeline is picked up and wait to run.
  /// - "OFFLINE" : The pipeline is offline and will be scheduled for next run.
  /// - "RUNNING" : The pipeline is running.
  core.String? scheduleState;

  /// The detailed state of the monitoring job.
  ///
  /// When the job is still creating, the state will be 'PENDING'. Once the job
  /// is successfully created, the state will be 'RUNNING'. Pause the job, the
  /// state will be 'PAUSED'. Resume the job, the state will return to
  /// 'RUNNING'.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Stats anomalies base folder path.
  GoogleCloudAiplatformV1GcsDestination? statsAnomaliesBaseDirectory;

  /// Timestamp when this ModelDeploymentMonitoringJob was updated most
  /// recently.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJob({
    this.analysisInstanceSchemaUri,
    this.bigqueryTables,
    this.createTime,
    this.displayName,
    this.enableMonitoringPipelineLogs,
    this.encryptionSpec,
    this.endpoint,
    this.error,
    this.labels,
    this.latestMonitoringPipelineMetadata,
    this.logTtl,
    this.loggingSamplingStrategy,
    this.modelDeploymentMonitoringObjectiveConfigs,
    this.modelDeploymentMonitoringScheduleConfig,
    this.modelMonitoringAlertConfig,
    this.name,
    this.nextScheduleTime,
    this.predictInstanceSchemaUri,
    this.samplePredictInstance,
    this.scheduleState,
    this.state,
    this.statsAnomaliesBaseDirectory,
    this.updateTime,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJob.fromJson(core.Map json_)
      : this(
          analysisInstanceSchemaUri:
              json_.containsKey('analysisInstanceSchemaUri')
                  ? json_['analysisInstanceSchemaUri'] as core.String
                  : null,
          bigqueryTables: json_.containsKey('bigqueryTables')
              ? (json_['bigqueryTables'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelDeploymentMonitoringBigQueryTable
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          enableMonitoringPipelineLogs:
              json_.containsKey('enableMonitoringPipelineLogs')
                  ? json_['enableMonitoringPipelineLogs'] as core.bool
                  : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endpoint: json_.containsKey('endpoint')
              ? json_['endpoint'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          latestMonitoringPipelineMetadata: json_
                  .containsKey('latestMonitoringPipelineMetadata')
              ? GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata
                  .fromJson(json_['latestMonitoringPipelineMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          logTtl: json_.containsKey('logTtl')
              ? json_['logTtl'] as core.String
              : null,
          loggingSamplingStrategy: json_.containsKey('loggingSamplingStrategy')
              ? GoogleCloudAiplatformV1SamplingStrategy.fromJson(
                  json_['loggingSamplingStrategy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelDeploymentMonitoringObjectiveConfigs: json_
                  .containsKey('modelDeploymentMonitoringObjectiveConfigs')
              ? (json_['modelDeploymentMonitoringObjectiveConfigs']
                      as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          modelDeploymentMonitoringScheduleConfig: json_
                  .containsKey('modelDeploymentMonitoringScheduleConfig')
              ? GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig
                  .fromJson(json_['modelDeploymentMonitoringScheduleConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelMonitoringAlertConfig:
              json_.containsKey('modelMonitoringAlertConfig')
                  ? GoogleCloudAiplatformV1ModelMonitoringAlertConfig.fromJson(
                      json_['modelMonitoringAlertConfig']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          nextScheduleTime: json_.containsKey('nextScheduleTime')
              ? json_['nextScheduleTime'] as core.String
              : null,
          predictInstanceSchemaUri:
              json_.containsKey('predictInstanceSchemaUri')
                  ? json_['predictInstanceSchemaUri'] as core.String
                  : null,
          samplePredictInstance: json_.containsKey('samplePredictInstance')
              ? json_['samplePredictInstance']
              : null,
          scheduleState: json_.containsKey('scheduleState')
              ? json_['scheduleState'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          statsAnomaliesBaseDirectory:
              json_.containsKey('statsAnomaliesBaseDirectory')
                  ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                      json_['statsAnomaliesBaseDirectory']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (analysisInstanceSchemaUri != null)
          'analysisInstanceSchemaUri': analysisInstanceSchemaUri!,
        if (bigqueryTables != null) 'bigqueryTables': bigqueryTables!,
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (enableMonitoringPipelineLogs != null)
          'enableMonitoringPipelineLogs': enableMonitoringPipelineLogs!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endpoint != null) 'endpoint': endpoint!,
        if (error != null) 'error': error!,
        if (labels != null) 'labels': labels!,
        if (latestMonitoringPipelineMetadata != null)
          'latestMonitoringPipelineMetadata': latestMonitoringPipelineMetadata!,
        if (logTtl != null) 'logTtl': logTtl!,
        if (loggingSamplingStrategy != null)
          'loggingSamplingStrategy': loggingSamplingStrategy!,
        if (modelDeploymentMonitoringObjectiveConfigs != null)
          'modelDeploymentMonitoringObjectiveConfigs':
              modelDeploymentMonitoringObjectiveConfigs!,
        if (modelDeploymentMonitoringScheduleConfig != null)
          'modelDeploymentMonitoringScheduleConfig':
              modelDeploymentMonitoringScheduleConfig!,
        if (modelMonitoringAlertConfig != null)
          'modelMonitoringAlertConfig': modelMonitoringAlertConfig!,
        if (name != null) 'name': name!,
        if (nextScheduleTime != null) 'nextScheduleTime': nextScheduleTime!,
        if (predictInstanceSchemaUri != null)
          'predictInstanceSchemaUri': predictInstanceSchemaUri!,
        if (samplePredictInstance != null)
          'samplePredictInstance': samplePredictInstance!,
        if (scheduleState != null) 'scheduleState': scheduleState!,
        if (state != null) 'state': state!,
        if (statsAnomaliesBaseDirectory != null)
          'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// All metadata of most recent monitoring pipelines.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata {
  /// The time that most recent monitoring pipelines that is related to this
  /// run.
  core.String? runTime;

  /// The status of the most recent monitoring pipeline.
  GoogleRpcStatus? status;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata({
    this.runTime,
    this.status,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringJobLatestMonitoringPipelineMetadata.fromJson(
      core.Map json_)
      : this(
          runTime: json_.containsKey('runTime')
              ? json_['runTime'] as core.String
              : null,
          status: json_.containsKey('status')
              ? GoogleRpcStatus.fromJson(
                  json_['status'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (runTime != null) 'runTime': runTime!,
        if (status != null) 'status': status!,
      };
}

/// ModelDeploymentMonitoringObjectiveConfig contains the pair of
/// deployed_model_id to ModelMonitoringObjectiveConfig.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig {
  /// The DeployedModel ID of the objective config.
  core.String? deployedModelId;

  /// The objective config of for the modelmonitoring job of this deployed
  /// model.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig? objectiveConfig;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig({
    this.deployedModelId,
    this.objectiveConfig,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringObjectiveConfig.fromJson(
      core.Map json_)
      : this(
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          objectiveConfig: json_.containsKey('objectiveConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig.fromJson(
                  json_['objectiveConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (objectiveConfig != null) 'objectiveConfig': objectiveConfig!,
      };
}

/// The config for scheduling monitoring job.
class GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig {
  /// The model monitoring job scheduling interval.
  ///
  /// It will be rounded up to next full hour. This defines how often the
  /// monitoring jobs are triggered.
  ///
  /// Required.
  core.String? monitorInterval;

  /// The time window of the prediction data being included in each prediction
  /// dataset.
  ///
  /// This window specifies how long the data should be collected from
  /// historical model results for each run. If not set,
  /// ModelDeploymentMonitoringScheduleConfig.monitor_interval will be used.
  /// e.g. If currently the cutoff time is 2022-01-08 14:30:00 and the
  /// monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to
  /// 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the
  /// monitoring statistics.
  core.String? monitorWindow;

  GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig({
    this.monitorInterval,
    this.monitorWindow,
  });

  GoogleCloudAiplatformV1ModelDeploymentMonitoringScheduleConfig.fromJson(
      core.Map json_)
      : this(
          monitorInterval: json_.containsKey('monitorInterval')
              ? json_['monitorInterval'] as core.String
              : null,
          monitorWindow: json_.containsKey('monitorWindow')
              ? json_['monitorWindow'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (monitorInterval != null) 'monitorInterval': monitorInterval!,
        if (monitorWindow != null) 'monitorWindow': monitorWindow!,
      };
}

/// A collection of metrics calculated by comparing Model's predictions on all
/// of the test data against annotations from the test data.
class GoogleCloudAiplatformV1ModelEvaluation {
  /// Points to a YAML file stored on Google Cloud Storage describing
  /// EvaluatedDataItemView.predictions, EvaluatedDataItemView.ground_truths,
  /// EvaluatedAnnotation.predictions, and EvaluatedAnnotation.ground_truths.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// This field is not populated if there are neither EvaluatedDataItemViews
  /// nor EvaluatedAnnotations under this ModelEvaluation.
  core.String? annotationSchemaUri;

  /// Timestamp when this ModelEvaluation was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Points to a YAML file stored on Google Cloud Storage describing
  /// EvaluatedDataItemView.data_item_payload and
  /// EvaluatedAnnotation.data_item_payload.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// This field is not populated if there are neither EvaluatedDataItemViews
  /// nor EvaluatedAnnotations under this ModelEvaluation.
  core.String? dataItemSchemaUri;

  /// The display name of the ModelEvaluation.
  core.String? displayName;

  /// Describes the values of ExplanationSpec that are used for explaining the
  /// predicted values on the evaluated data.
  core.List<
          GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec>?
      explanationSpecs;

  /// The metadata of the ModelEvaluation.
  ///
  /// For the ModelEvaluation uploaded from Managed Pipeline, metadata contains
  /// a structured value with keys of "pipeline_job_id",
  /// "evaluation_dataset_type", "evaluation_dataset_path".
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Evaluation metrics of the Model.
  ///
  /// The schema of the metrics is stored in metrics_schema_uri
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metrics;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// metrics of this ModelEvaluation.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  core.String? metricsSchemaUri;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses.
  ///
  /// This field is populated only if the Model is evaluated with explanations,
  /// and only for AutoML tabular Models.
  GoogleCloudAiplatformV1ModelExplanation? modelExplanation;

  /// The resource name of the ModelEvaluation.
  ///
  /// Output only.
  core.String? name;

  /// All possible dimensions of ModelEvaluationSlices.
  ///
  /// The dimensions can be used as the filter of the
  /// ModelService.ListModelEvaluationSlices request, in the form of
  /// `slice.dimension = `.
  core.List<core.String>? sliceDimensions;

  GoogleCloudAiplatformV1ModelEvaluation({
    this.annotationSchemaUri,
    this.createTime,
    this.dataItemSchemaUri,
    this.displayName,
    this.explanationSpecs,
    this.metadata,
    this.metrics,
    this.metricsSchemaUri,
    this.modelExplanation,
    this.name,
    this.sliceDimensions,
  });

  GoogleCloudAiplatformV1ModelEvaluation.fromJson(core.Map json_)
      : this(
          annotationSchemaUri: json_.containsKey('annotationSchemaUri')
              ? json_['annotationSchemaUri'] as core.String
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          dataItemSchemaUri: json_.containsKey('dataItemSchemaUri')
              ? json_['dataItemSchemaUri'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          explanationSpecs: json_.containsKey('explanationSpecs')
              ? (json_['explanationSpecs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          metadata: json_.containsKey('metadata') ? json_['metadata'] : null,
          metrics: json_.containsKey('metrics') ? json_['metrics'] : null,
          metricsSchemaUri: json_.containsKey('metricsSchemaUri')
              ? json_['metricsSchemaUri'] as core.String
              : null,
          modelExplanation: json_.containsKey('modelExplanation')
              ? GoogleCloudAiplatformV1ModelExplanation.fromJson(
                  json_['modelExplanation']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          sliceDimensions: json_.containsKey('sliceDimensions')
              ? (json_['sliceDimensions'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationSchemaUri != null)
          'annotationSchemaUri': annotationSchemaUri!,
        if (createTime != null) 'createTime': createTime!,
        if (dataItemSchemaUri != null) 'dataItemSchemaUri': dataItemSchemaUri!,
        if (displayName != null) 'displayName': displayName!,
        if (explanationSpecs != null) 'explanationSpecs': explanationSpecs!,
        if (metadata != null) 'metadata': metadata!,
        if (metrics != null) 'metrics': metrics!,
        if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri!,
        if (modelExplanation != null) 'modelExplanation': modelExplanation!,
        if (name != null) 'name': name!,
        if (sliceDimensions != null) 'sliceDimensions': sliceDimensions!,
      };
}

class GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec {
  /// Explanation spec details.
  GoogleCloudAiplatformV1ExplanationSpec? explanationSpec;

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are: *
  /// `image-integrated-gradients` * `image-xrai`
  core.String? explanationType;

  GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec({
    this.explanationSpec,
    this.explanationType,
  });

  GoogleCloudAiplatformV1ModelEvaluationModelEvaluationExplanationSpec.fromJson(
      core.Map json_)
      : this(
          explanationSpec: json_.containsKey('explanationSpec')
              ? GoogleCloudAiplatformV1ExplanationSpec.fromJson(
                  json_['explanationSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          explanationType: json_.containsKey('explanationType')
              ? json_['explanationType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanationSpec != null) 'explanationSpec': explanationSpec!,
        if (explanationType != null) 'explanationType': explanationType!,
      };
}

/// A collection of metrics calculated by comparing Model's predictions on a
/// slice of the test data against ground truth annotations.
class GoogleCloudAiplatformV1ModelEvaluationSlice {
  /// Timestamp when this ModelEvaluationSlice was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Sliced evaluation metrics of the Model.
  ///
  /// The schema of the metrics is stored in metrics_schema_uri
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metrics;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// metrics of this ModelEvaluationSlice.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  ///
  /// Output only.
  core.String? metricsSchemaUri;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses.
  ///
  /// This field is populated only if the Model is evaluated with explanations,
  /// and only for tabular Models.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelExplanation? modelExplanation;

  /// The resource name of the ModelEvaluationSlice.
  ///
  /// Output only.
  core.String? name;

  /// The slice of the test data that is used to evaluate the Model.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelEvaluationSliceSlice? slice;

  GoogleCloudAiplatformV1ModelEvaluationSlice({
    this.createTime,
    this.metrics,
    this.metricsSchemaUri,
    this.modelExplanation,
    this.name,
    this.slice,
  });

  GoogleCloudAiplatformV1ModelEvaluationSlice.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          metrics: json_.containsKey('metrics') ? json_['metrics'] : null,
          metricsSchemaUri: json_.containsKey('metricsSchemaUri')
              ? json_['metricsSchemaUri'] as core.String
              : null,
          modelExplanation: json_.containsKey('modelExplanation')
              ? GoogleCloudAiplatformV1ModelExplanation.fromJson(
                  json_['modelExplanation']
                      as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          slice: json_.containsKey('slice')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSlice.fromJson(
                  json_['slice'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (metrics != null) 'metrics': metrics!,
        if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri!,
        if (modelExplanation != null) 'modelExplanation': modelExplanation!,
        if (name != null) 'name': name!,
        if (slice != null) 'slice': slice!,
      };
}

/// Definition of a slice.
class GoogleCloudAiplatformV1ModelEvaluationSliceSlice {
  /// The dimension of the slice.
  ///
  /// Well-known dimensions are: * `annotationSpec`: This slice is on the test
  /// data that has either ground truth or prediction with
  /// AnnotationSpec.display_name equals to value. * `slice`: This slice is a
  /// user customized slice defined by its SliceSpec.
  ///
  /// Output only.
  core.String? dimension;

  /// Specification for how the data was sliced.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec? sliceSpec;

  /// The value of the dimension in this slice.
  ///
  /// Output only.
  core.String? value;

  GoogleCloudAiplatformV1ModelEvaluationSliceSlice({
    this.dimension,
    this.sliceSpec,
    this.value,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSlice.fromJson(core.Map json_)
      : this(
          dimension: json_.containsKey('dimension')
              ? json_['dimension'] as core.String
              : null,
          sliceSpec: json_.containsKey('sliceSpec')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec
                  .fromJson(
                      json_['sliceSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          value:
              json_.containsKey('value') ? json_['value'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dimension != null) 'dimension': dimension!,
        if (sliceSpec != null) 'sliceSpec': sliceSpec!,
        if (value != null) 'value': value!,
      };
}

/// Specification for how the data should be sliced.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec {
  /// Mapping configuration for this SliceSpec.
  ///
  /// The key is the name of the feature. By default, the key will be prefixed
  /// by "instance" as a dictionary prefix for Vertex Batch Predictions output
  /// format.
  core.Map<core.String,
          GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig>?
      configs;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec({
    this.configs,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpec.fromJson(
      core.Map json_)
      : this(
          configs: json_.containsKey('configs')
              ? (json_['configs'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (configs != null) 'configs': configs!,
      };
}

/// A range of values for slice(s).
///
/// `low` is inclusive, `high` is exclusive.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange {
  /// Exclusive high value for the range.
  core.double? high;

  /// Inclusive low value for the range.
  core.double? low;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange({
    this.high,
    this.low,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange.fromJson(
      core.Map json_)
      : this(
          high: json_.containsKey('high')
              ? (json_['high'] as core.num).toDouble()
              : null,
          low: json_.containsKey('low')
              ? (json_['low'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (high != null) 'high': high!,
        if (low != null) 'low': low!,
      };
}

/// Specification message containing the config for this SliceSpec.
///
/// When `kind` is selected as `value` and/or `range`, only a single slice will
/// be computed. When `all_values` is present, a separate slice will be computed
/// for each possible label/value for the corresponding key in `config`.
/// Examples, with feature zip_code with values 12345, 23334, 88888 and feature
/// country with values "US", "Canada", "Mexico" in the dataset: Example 1: {
/// "zip_code": { "value": { "float_value": 12345.0 } } } A single slice for any
/// data with zip_code 12345 in the dataset. Example 2: { "zip_code": { "range":
/// { "low": 12345, "high": 20000 } } } A single slice containing data where the
/// zip_codes between 12345 and 20000 For this example, data with the zip_code
/// of 12345 will be in this slice. Example 3: { "zip_code": { "range": { "low":
/// 10000, "high": 20000 } }, "country": { "value": { "string_value": "US" } } }
/// A single slice containing data where the zip_codes between 10000 and 20000
/// has the country "US". For this example, data with the zip_code of 12345 and
/// country "US" will be in this slice. Example 4: { "country": {"all_values": {
/// "value": true } } } Three slices are computed, one for each unique country
/// in the dataset. Example 5: { "country": { "all_values": { "value": true } },
/// "zip_code": { "value": { "float_value": 12345.0 } } } Three slices are
/// computed, one for each unique country in the dataset where the zip_code is
/// also 12345. For this example, data with zip_code 12345 and country "US" will
/// be in one slice, zip_code 12345 and country "Canada" in another slice, and
/// zip_code 12345 and country "Mexico" in another slice, totaling 3 slices.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig {
  /// If all_values is set to true, then all possible labels of the keyed
  /// feature will have another slice computed.
  ///
  /// Example: `{"all_values":{"value":true}}`
  core.bool? allValues;

  /// A range of values for a numerical feature.
  ///
  /// Example: `{"range":{"low":10000.0,"high":50000.0}}` will capture 12345 and
  /// 23334 in the slice.
  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange? range;

  /// A unique specific value for a given feature.
  ///
  /// Example: `{ "value": { "string_value": "12345" } }`
  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue? value;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig({
    this.allValues,
    this.range,
    this.value,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecSliceConfig.fromJson(
      core.Map json_)
      : this(
          allValues: json_.containsKey('allValues')
              ? json_['allValues'] as core.bool
              : null,
          range: json_.containsKey('range')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecRange
                  .fromJson(
                      json_['range'] as core.Map<core.String, core.dynamic>)
              : null,
          value: json_.containsKey('value')
              ? GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue
                  .fromJson(
                      json_['value'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allValues != null) 'allValues': allValues!,
        if (range != null) 'range': range!,
        if (value != null) 'value': value!,
      };
}

/// Single value that supports strings and floats.
class GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue {
  /// Float type.
  core.double? floatValue;

  /// String type.
  core.String? stringValue;

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue({
    this.floatValue,
    this.stringValue,
  });

  GoogleCloudAiplatformV1ModelEvaluationSliceSliceSliceSpecValue.fromJson(
      core.Map json_)
      : this(
          floatValue: json_.containsKey('floatValue')
              ? (json_['floatValue'] as core.num).toDouble()
              : null,
          stringValue: json_.containsKey('stringValue')
              ? json_['stringValue'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (floatValue != null) 'floatValue': floatValue!,
        if (stringValue != null) 'stringValue': stringValue!,
      };
}

/// Aggregated explanation metrics for a Model over a set of instances.
class GoogleCloudAiplatformV1ModelExplanation {
  /// Aggregated attributions explaining the Model's prediction outputs over the
  /// set of instances.
  ///
  /// The attributions are grouped by outputs. For Models that predict only one
  /// output, such as regression Models that predict only one score, there is
  /// only one attibution that explains the predicted output. For Models that
  /// predict multiple outputs, such as multiclass Models that predict multiple
  /// classes, each element explains one specific item. Attribution.output_index
  /// can be used to identify which output this attribution is explaining. The
  /// baselineOutputValue, instanceOutputValue and featureAttributions fields
  /// are averaged over the test data. NOTE: Currently AutoML tabular
  /// classification Models produce only one attribution, which averages
  /// attributions over all the classes it predicts.
  /// Attribution.approximation_error is not populated.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Attribution>? meanAttributions;

  GoogleCloudAiplatformV1ModelExplanation({
    this.meanAttributions,
  });

  GoogleCloudAiplatformV1ModelExplanation.fromJson(core.Map json_)
      : this(
          meanAttributions: json_.containsKey('meanAttributions')
              ? (json_['meanAttributions'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Attribution.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (meanAttributions != null) 'meanAttributions': meanAttributions!,
      };
}

/// Represents export format supported by the Model.
///
/// All formats export to Google Cloud Storage.
class GoogleCloudAiplatformV1ModelExportFormat {
  /// The content of this Model that may be exported.
  ///
  /// Output only.
  core.List<core.String>? exportableContents;

  /// The ID of the export format.
  ///
  /// The possible format IDs are: * `tflite` Used for Android mobile devices. *
  /// `edgetpu-tflite` Used for [Edge TPU](https://cloud.google.com/edge-tpu/)
  /// devices. * `tf-saved-model` A tensorflow model in SavedModel format. *
  /// `tf-js` A [TensorFlow.js](https://www.tensorflow.org/js) model that can be
  /// used in the browser and in Node.js using JavaScript. * `core-ml` Used for
  /// iOS mobile devices. * `custom-trained` A Model that was uploaded or
  /// trained by custom code.
  ///
  /// Output only.
  core.String? id;

  GoogleCloudAiplatformV1ModelExportFormat({
    this.exportableContents,
    this.id,
  });

  GoogleCloudAiplatformV1ModelExportFormat.fromJson(core.Map json_)
      : this(
          exportableContents: json_.containsKey('exportableContents')
              ? (json_['exportableContents'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (exportableContents != null)
          'exportableContents': exportableContents!,
        if (id != null) 'id': id!,
      };
}

class GoogleCloudAiplatformV1ModelMonitoringAlertConfig {
  /// Email alert config.
  GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig?
      emailAlertConfig;

  /// Dump the anomalies to Cloud Logging.
  ///
  /// The anomalies will be put to json payload encoded from proto
  /// google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry. This can
  /// be further sinked to Pub/Sub or any other services supported by Cloud
  /// Logging.
  core.bool? enableLogging;

  /// Resource names of the NotificationChannels to send alert.
  ///
  /// Must be of the format `projects//notificationChannels/`
  core.List<core.String>? notificationChannels;

  GoogleCloudAiplatformV1ModelMonitoringAlertConfig({
    this.emailAlertConfig,
    this.enableLogging,
    this.notificationChannels,
  });

  GoogleCloudAiplatformV1ModelMonitoringAlertConfig.fromJson(core.Map json_)
      : this(
          emailAlertConfig: json_.containsKey('emailAlertConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig
                  .fromJson(json_['emailAlertConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          enableLogging: json_.containsKey('enableLogging')
              ? json_['enableLogging'] as core.bool
              : null,
          notificationChannels: json_.containsKey('notificationChannels')
              ? (json_['notificationChannels'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (emailAlertConfig != null) 'emailAlertConfig': emailAlertConfig!,
        if (enableLogging != null) 'enableLogging': enableLogging!,
        if (notificationChannels != null)
          'notificationChannels': notificationChannels!,
      };
}

/// The config for email alert.
class GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig {
  /// The email addresses to send the alert.
  core.List<core.String>? userEmails;

  GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig({
    this.userEmails,
  });

  GoogleCloudAiplatformV1ModelMonitoringAlertConfigEmailAlertConfig.fromJson(
      core.Map json_)
      : this(
          userEmails: json_.containsKey('userEmails')
              ? (json_['userEmails'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (userEmails != null) 'userEmails': userEmails!,
      };
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig {
  /// The config for integrating with Vertex Explainable AI.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig?
      explanationConfig;

  /// The config for drift of prediction data.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig?
      predictionDriftDetectionConfig;

  /// Training dataset for models.
  ///
  /// This field has to be set only if TrainingPredictionSkewDetectionConfig is
  /// specified.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset?
      trainingDataset;

  /// The config for skew between training data and prediction data.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig?
      trainingPredictionSkewDetectionConfig;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig({
    this.explanationConfig,
    this.predictionDriftDetectionConfig,
    this.trainingDataset,
    this.trainingPredictionSkewDetectionConfig,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfig.fromJson(core.Map json_)
      : this(
          explanationConfig: json_.containsKey('explanationConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig
                  .fromJson(json_['explanationConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          predictionDriftDetectionConfig: json_
                  .containsKey('predictionDriftDetectionConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig
                  .fromJson(json_['predictionDriftDetectionConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trainingDataset: json_.containsKey('trainingDataset')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset
                  .fromJson(json_['trainingDataset']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trainingPredictionSkewDetectionConfig: json_
                  .containsKey('trainingPredictionSkewDetectionConfig')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig
                  .fromJson(json_['trainingPredictionSkewDetectionConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explanationConfig != null) 'explanationConfig': explanationConfig!,
        if (predictionDriftDetectionConfig != null)
          'predictionDriftDetectionConfig': predictionDriftDetectionConfig!,
        if (trainingDataset != null) 'trainingDataset': trainingDataset!,
        if (trainingPredictionSkewDetectionConfig != null)
          'trainingPredictionSkewDetectionConfig':
              trainingPredictionSkewDetectionConfig!,
      };
}

/// The config for integrating with Vertex Explainable AI.
///
/// Only applicable if the Model has explanation_spec populated.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig {
  /// If want to analyze the Vertex Explainable AI feature attribute scores or
  /// not.
  ///
  /// If set to true, Vertex AI will log the feature attributions from explain
  /// response and do the skew/drift detection for them.
  core.bool? enableFeatureAttributes;

  /// Predictions generated by the BatchPredictionJob using baseline dataset.
  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline?
      explanationBaseline;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig({
    this.enableFeatureAttributes,
    this.explanationBaseline,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfig.fromJson(
      core.Map json_)
      : this(
          enableFeatureAttributes: json_.containsKey('enableFeatureAttributes')
              ? json_['enableFeatureAttributes'] as core.bool
              : null,
          explanationBaseline: json_.containsKey('explanationBaseline')
              ? GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline
                  .fromJson(json_['explanationBaseline']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableFeatureAttributes != null)
          'enableFeatureAttributes': enableFeatureAttributes!,
        if (explanationBaseline != null)
          'explanationBaseline': explanationBaseline!,
      };
}

/// Output from BatchPredictionJob for Model Monitoring baseline dataset, which
/// can be used to generate baseline attribution scores.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline {
  /// BigQuery location for BatchExplain output.
  GoogleCloudAiplatformV1BigQueryDestination? bigquery;

  /// Cloud Storage location for BatchExplain output.
  GoogleCloudAiplatformV1GcsDestination? gcs;

  /// The storage format of the predictions generated BatchPrediction job.
  /// Possible string values are:
  /// - "PREDICTION_FORMAT_UNSPECIFIED" : Should not be set.
  /// - "JSONL" : Predictions are in JSONL files.
  /// - "BIGQUERY" : Predictions are in BigQuery.
  core.String? predictionFormat;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline({
    this.bigquery,
    this.gcs,
    this.predictionFormat,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigExplanationConfigExplanationBaseline.fromJson(
      core.Map json_)
      : this(
          bigquery: json_.containsKey('bigquery')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigquery'] as core.Map<core.String, core.dynamic>)
              : null,
          gcs: json_.containsKey('gcs')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcs'] as core.Map<core.String, core.dynamic>)
              : null,
          predictionFormat: json_.containsKey('predictionFormat')
              ? json_['predictionFormat'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigquery != null) 'bigquery': bigquery!,
        if (gcs != null) 'gcs': gcs!,
        if (predictionFormat != null) 'predictionFormat': predictionFormat!,
      };
}

/// The config for Prediction data drift detection.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig {
  /// Key is the feature name and value is the threshold.
  ///
  /// The threshold here is against attribution score distance between different
  /// time windows.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>?
      attributionScoreDriftThresholds;

  /// Drift anomaly detection threshold used by all features.
  ///
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  GoogleCloudAiplatformV1ThresholdConfig? defaultDriftThreshold;

  /// Key is the feature name and value is the threshold.
  ///
  /// If a feature needs to be monitored for drift, a value threshold must be
  /// configured for that feature. The threshold here is against feature
  /// distribution distance between different time windws.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>?
      driftThresholds;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig({
    this.attributionScoreDriftThresholds,
    this.defaultDriftThreshold,
    this.driftThresholds,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigPredictionDriftDetectionConfig.fromJson(
      core.Map json_)
      : this(
          attributionScoreDriftThresholds:
              json_.containsKey('attributionScoreDriftThresholds')
                  ? (json_['attributionScoreDriftThresholds']
                          as core.Map<core.String, core.dynamic>)
                      .map(
                      (key, value) => core.MapEntry(
                        key,
                        GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                            value as core.Map<core.String, core.dynamic>),
                      ),
                    )
                  : null,
          defaultDriftThreshold: json_.containsKey('defaultDriftThreshold')
              ? GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  json_['defaultDriftThreshold']
                      as core.Map<core.String, core.dynamic>)
              : null,
          driftThresholds: json_.containsKey('driftThresholds')
              ? (json_['driftThresholds']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributionScoreDriftThresholds != null)
          'attributionScoreDriftThresholds': attributionScoreDriftThresholds!,
        if (defaultDriftThreshold != null)
          'defaultDriftThreshold': defaultDriftThreshold!,
        if (driftThresholds != null) 'driftThresholds': driftThresholds!,
      };
}

/// Training Dataset information.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset {
  /// The BigQuery table of the unmanaged Dataset used to train this Model.
  GoogleCloudAiplatformV1BigQuerySource? bigquerySource;

  /// Data format of the dataset, only applicable if the input is from Google
  /// Cloud Storage.
  ///
  /// The possible formats are: "tf-record" The source file is a TFRecord file.
  /// "csv" The source file is a CSV file. "jsonl" The source file is a JSONL
  /// file.
  core.String? dataFormat;

  /// The resource name of the Dataset used to train this Model.
  core.String? dataset;

  /// The Google Cloud Storage uri of the unmanaged Dataset used to train this
  /// Model.
  GoogleCloudAiplatformV1GcsSource? gcsSource;

  /// Strategy to sample data from Training Dataset.
  ///
  /// If not set, we process the whole dataset.
  GoogleCloudAiplatformV1SamplingStrategy? loggingSamplingStrategy;

  /// The target field name the model is to predict.
  ///
  /// This field will be excluded when doing Predict and (or) Explain for the
  /// training data.
  core.String? targetField;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset({
    this.bigquerySource,
    this.dataFormat,
    this.dataset,
    this.gcsSource,
    this.loggingSamplingStrategy,
    this.targetField,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingDataset.fromJson(
      core.Map json_)
      : this(
          bigquerySource: json_.containsKey('bigquerySource')
              ? GoogleCloudAiplatformV1BigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>)
              : null,
          dataFormat: json_.containsKey('dataFormat')
              ? json_['dataFormat'] as core.String
              : null,
          dataset: json_.containsKey('dataset')
              ? json_['dataset'] as core.String
              : null,
          gcsSource: json_.containsKey('gcsSource')
              ? GoogleCloudAiplatformV1GcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>)
              : null,
          loggingSamplingStrategy: json_.containsKey('loggingSamplingStrategy')
              ? GoogleCloudAiplatformV1SamplingStrategy.fromJson(
                  json_['loggingSamplingStrategy']
                      as core.Map<core.String, core.dynamic>)
              : null,
          targetField: json_.containsKey('targetField')
              ? json_['targetField'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigquerySource != null) 'bigquerySource': bigquerySource!,
        if (dataFormat != null) 'dataFormat': dataFormat!,
        if (dataset != null) 'dataset': dataset!,
        if (gcsSource != null) 'gcsSource': gcsSource!,
        if (loggingSamplingStrategy != null)
          'loggingSamplingStrategy': loggingSamplingStrategy!,
        if (targetField != null) 'targetField': targetField!,
      };
}

/// The config for Training & Prediction data skew detection.
///
/// It specifies the training dataset sources and the skew detection parameters.
class GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig {
  /// Key is the feature name and value is the threshold.
  ///
  /// The threshold here is against attribution score distance between the
  /// training and prediction feature.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>?
      attributionScoreSkewThresholds;

  /// Skew anomaly detection threshold used by all features.
  ///
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  GoogleCloudAiplatformV1ThresholdConfig? defaultSkewThreshold;

  /// Key is the feature name and value is the threshold.
  ///
  /// If a feature needs to be monitored for skew, a value threshold must be
  /// configured for that feature. The threshold here is against feature
  /// distribution distance between the training and prediction feature.
  core.Map<core.String, GoogleCloudAiplatformV1ThresholdConfig>? skewThresholds;

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig({
    this.attributionScoreSkewThresholds,
    this.defaultSkewThreshold,
    this.skewThresholds,
  });

  GoogleCloudAiplatformV1ModelMonitoringObjectiveConfigTrainingPredictionSkewDetectionConfig.fromJson(
      core.Map json_)
      : this(
          attributionScoreSkewThresholds:
              json_.containsKey('attributionScoreSkewThresholds')
                  ? (json_['attributionScoreSkewThresholds']
                          as core.Map<core.String, core.dynamic>)
                      .map(
                      (key, value) => core.MapEntry(
                        key,
                        GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                            value as core.Map<core.String, core.dynamic>),
                      ),
                    )
                  : null,
          defaultSkewThreshold: json_.containsKey('defaultSkewThreshold')
              ? GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  json_['defaultSkewThreshold']
                      as core.Map<core.String, core.dynamic>)
              : null,
          skewThresholds: json_.containsKey('skewThresholds')
              ? (json_['skewThresholds'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (attributionScoreSkewThresholds != null)
          'attributionScoreSkewThresholds': attributionScoreSkewThresholds!,
        if (defaultSkewThreshold != null)
          'defaultSkewThreshold': defaultSkewThreshold!,
        if (skewThresholds != null) 'skewThresholds': skewThresholds!,
      };
}

/// Statistics and anomalies generated by Model Monitoring.
class GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies {
  /// Number of anomalies within all stats.
  core.int? anomalyCount;

  /// Deployed Model ID.
  core.String? deployedModelId;

  /// A list of historical Stats and Anomalies generated for all Features.
  core.List<
          GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies>?
      featureStats;

  /// Model Monitoring Objective those stats and anomalies belonging to.
  /// Possible string values are:
  /// - "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" : Default
  /// value, should not be set.
  /// - "RAW_FEATURE_SKEW" : Raw feature values' stats to detect skew between
  /// Training-Prediction datasets.
  /// - "RAW_FEATURE_DRIFT" : Raw feature values' stats to detect drift between
  /// Serving-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_SKEW" : Feature attribution scores to detect skew
  /// between Training-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_DRIFT" : Feature attribution scores to detect skew
  /// between Prediction datasets collected within different time windows.
  core.String? objective;

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies({
    this.anomalyCount,
    this.deployedModelId,
    this.featureStats,
    this.objective,
  });

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies.fromJson(core.Map json_)
      : this(
          anomalyCount: json_.containsKey('anomalyCount')
              ? json_['anomalyCount'] as core.int
              : null,
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          featureStats: json_.containsKey('featureStats')
              ? (json_['featureStats'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          objective: json_.containsKey('objective')
              ? json_['objective'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (anomalyCount != null) 'anomalyCount': anomalyCount!,
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (featureStats != null) 'featureStats': featureStats!,
        if (objective != null) 'objective': objective!,
      };
}

/// Historical Stats (and Anomalies) for a specific Feature.
class GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies {
  /// Display Name of the Feature.
  core.String? featureDisplayName;

  /// A list of historical stats generated by different time window's Prediction
  /// Dataset.
  core.List<GoogleCloudAiplatformV1FeatureStatsAnomaly>? predictionStats;

  /// Threshold for anomaly detection.
  GoogleCloudAiplatformV1ThresholdConfig? threshold;

  /// Stats calculated for the Training Dataset.
  GoogleCloudAiplatformV1FeatureStatsAnomaly? trainingStats;

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies({
    this.featureDisplayName,
    this.predictionStats,
    this.threshold,
    this.trainingStats,
  });

  GoogleCloudAiplatformV1ModelMonitoringStatsAnomaliesFeatureHistoricStatsAnomalies.fromJson(
      core.Map json_)
      : this(
          featureDisplayName: json_.containsKey('featureDisplayName')
              ? json_['featureDisplayName'] as core.String
              : null,
          predictionStats: json_.containsKey('predictionStats')
              ? (json_['predictionStats'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          threshold: json_.containsKey('threshold')
              ? GoogleCloudAiplatformV1ThresholdConfig.fromJson(
                  json_['threshold'] as core.Map<core.String, core.dynamic>)
              : null,
          trainingStats: json_.containsKey('trainingStats')
              ? GoogleCloudAiplatformV1FeatureStatsAnomaly.fromJson(
                  json_['trainingStats'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureDisplayName != null)
          'featureDisplayName': featureDisplayName!,
        if (predictionStats != null) 'predictionStats': predictionStats!,
        if (threshold != null) 'threshold': threshold!,
        if (trainingStats != null) 'trainingStats': trainingStats!,
      };
}

/// Contains information about the original Model if this Model is a copy.
class GoogleCloudAiplatformV1ModelOriginalModelInfo {
  /// The resource name of the Model this Model is a copy of, including the
  /// revision.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
  ///
  /// Output only.
  core.String? model;

  GoogleCloudAiplatformV1ModelOriginalModelInfo({
    this.model,
  });

  GoogleCloudAiplatformV1ModelOriginalModelInfo.fromJson(core.Map json_)
      : this(
          model:
              json_.containsKey('model') ? json_['model'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
      };
}

/// Detail description of the source information of the model.
class GoogleCloudAiplatformV1ModelSourceInfo {
  /// If this Model is copy of another Model.
  ///
  /// If true then source_type pertains to the original.
  core.bool? copy;

  /// Type of the model source.
  /// Possible string values are:
  /// - "MODEL_SOURCE_TYPE_UNSPECIFIED" : Should not be used.
  /// - "AUTOML" : The Model is uploaded by automl training pipeline.
  /// - "CUSTOM" : The Model is uploaded by user or custom training pipeline.
  /// - "BQML" : The Model is registered and sync'ed from BigQuery ML.
  /// - "MODEL_GARDEN" : The Model is saved or tuned from Model Garden.
  /// - "GENIE" : The Model is saved or tuned from Genie.
  core.String? sourceType;

  GoogleCloudAiplatformV1ModelSourceInfo({
    this.copy,
    this.sourceType,
  });

  GoogleCloudAiplatformV1ModelSourceInfo.fromJson(core.Map json_)
      : this(
          copy: json_.containsKey('copy') ? json_['copy'] as core.bool : null,
          sourceType: json_.containsKey('sourceType')
              ? json_['sourceType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (copy != null) 'copy': copy!,
        if (sourceType != null) 'sourceType': sourceType!,
      };
}

/// Request message for EndpointService.MutateDeployedModel.
class GoogleCloudAiplatformV1MutateDeployedModelRequest {
  /// The DeployedModel to be mutated within the Endpoint.
  ///
  /// Only the following fields can be mutated: * `min_replica_count` in either
  /// DedicatedResources or AutomaticResources * `max_replica_count` in either
  /// DedicatedResources or AutomaticResources * autoscaling_metric_specs *
  /// `disable_container_logging` (v1 only) * `enable_container_logging`
  /// (v1beta1 only)
  ///
  /// Required.
  GoogleCloudAiplatformV1DeployedModel? deployedModel;

  /// The update mask applies to the resource.
  ///
  /// See google.protobuf.FieldMask.
  ///
  /// Required.
  core.String? updateMask;

  GoogleCloudAiplatformV1MutateDeployedModelRequest({
    this.deployedModel,
    this.updateMask,
  });

  GoogleCloudAiplatformV1MutateDeployedModelRequest.fromJson(core.Map json_)
      : this(
          deployedModel: json_.containsKey('deployedModel')
              ? GoogleCloudAiplatformV1DeployedModel.fromJson(
                  json_['deployedModel'] as core.Map<core.String, core.dynamic>)
              : null,
          updateMask: json_.containsKey('updateMask')
              ? json_['updateMask'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModel != null) 'deployedModel': deployedModel!,
        if (updateMask != null) 'updateMask': updateMask!,
      };
}

/// Represents a Neural Architecture Search (NAS) job.
class GoogleCloudAiplatformV1NasJob {
  /// Time when the NasJob was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the NasJob.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Enable a separation of Custom model training and restricted image training
  /// for tenant project.
  ///
  /// Optional.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableRestrictedImageTraining;

  /// Customer-managed encryption key options for a NasJob.
  ///
  /// If this is set, then all resources created by the NasJob will be encrypted
  /// with the provided encryption key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the NasJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The labels with user-defined metadata to organize NasJobs.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// Resource name of the NasJob.
  ///
  /// Output only.
  core.String? name;

  /// Output of the NasJob.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NasJobOutput? nasJobOutput;

  /// The specification of a NasJob.
  ///
  /// Required.
  GoogleCloudAiplatformV1NasJobSpec? nasJobSpec;

  /// Time when the NasJob for the first time entered the `JOB_STATE_RUNNING`
  /// state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "JOB_STATE_UNSPECIFIED" : The job state is unspecified.
  /// - "JOB_STATE_QUEUED" : The job has been just created or resumed and
  /// processing has not yet begun.
  /// - "JOB_STATE_PENDING" : The service is preparing to run the job.
  /// - "JOB_STATE_RUNNING" : The job is in progress.
  /// - "JOB_STATE_SUCCEEDED" : The job completed successfully.
  /// - "JOB_STATE_FAILED" : The job failed.
  /// - "JOB_STATE_CANCELLING" : The job is being cancelled. From this state the
  /// job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  /// - "JOB_STATE_CANCELLED" : The job has been cancelled.
  /// - "JOB_STATE_PAUSED" : The job has been stopped, and can be resumed.
  /// - "JOB_STATE_EXPIRED" : The job has expired.
  /// - "JOB_STATE_UPDATING" : The job is being updated. Only jobs in the
  /// `RUNNING` state can be updated. After updating, the job goes back to the
  /// `RUNNING` state.
  /// - "JOB_STATE_PARTIALLY_SUCCEEDED" : The job is partially succeeded, some
  /// results may be missing due to errors.
  core.String? state;

  /// Time when the NasJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1NasJob({
    this.createTime,
    this.displayName,
    this.enableRestrictedImageTraining,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.labels,
    this.name,
    this.nasJobOutput,
    this.nasJobSpec,
    this.startTime,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1NasJob.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          enableRestrictedImageTraining:
              json_.containsKey('enableRestrictedImageTraining')
                  ? json_['enableRestrictedImageTraining'] as core.bool
                  : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          nasJobOutput: json_.containsKey('nasJobOutput')
              ? GoogleCloudAiplatformV1NasJobOutput.fromJson(
                  json_['nasJobOutput'] as core.Map<core.String, core.dynamic>)
              : null,
          nasJobSpec: json_.containsKey('nasJobSpec')
              ? GoogleCloudAiplatformV1NasJobSpec.fromJson(
                  json_['nasJobSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (enableRestrictedImageTraining != null)
          'enableRestrictedImageTraining': enableRestrictedImageTraining!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (nasJobOutput != null) 'nasJobOutput': nasJobOutput!,
        if (nasJobSpec != null) 'nasJobSpec': nasJobSpec!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Represents a uCAIP NasJob output.
class GoogleCloudAiplatformV1NasJobOutput {
  /// The output of this multi-trial Neural Architecture Search (NAS) job.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput? multiTrialJobOutput;

  GoogleCloudAiplatformV1NasJobOutput({
    this.multiTrialJobOutput,
  });

  GoogleCloudAiplatformV1NasJobOutput.fromJson(core.Map json_)
      : this(
          multiTrialJobOutput: json_.containsKey('multiTrialJobOutput')
              ? GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput.fromJson(
                  json_['multiTrialJobOutput']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (multiTrialJobOutput != null)
          'multiTrialJobOutput': multiTrialJobOutput!,
      };
}

/// The output of a multi-trial Neural Architecture Search (NAS) jobs.
class GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput {
  /// List of NasTrials that were started as part of search stage.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1NasTrial>? searchTrials;

  /// List of NasTrials that were started as part of train stage.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1NasTrial>? trainTrials;

  GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput({
    this.searchTrials,
    this.trainTrials,
  });

  GoogleCloudAiplatformV1NasJobOutputMultiTrialJobOutput.fromJson(
      core.Map json_)
      : this(
          searchTrials: json_.containsKey('searchTrials')
              ? (json_['searchTrials'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1NasTrial.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          trainTrials: json_.containsKey('trainTrials')
              ? (json_['trainTrials'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1NasTrial.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (searchTrials != null) 'searchTrials': searchTrials!,
        if (trainTrials != null) 'trainTrials': trainTrials!,
      };
}

/// Represents the spec of a NasJob.
class GoogleCloudAiplatformV1NasJobSpec {
  /// The spec of multi-trial algorithms.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec?
      multiTrialAlgorithmSpec;

  /// The ID of the existing NasJob in the same Project and Location which will
  /// be used to resume search.
  ///
  /// search_space_spec and nas_algorithm_spec are obtained from previous NasJob
  /// hence should not provide them again for this NasJob.
  core.String? resumeNasJobId;

  /// It defines the search space for Neural Architecture Search (NAS).
  core.String? searchSpaceSpec;

  GoogleCloudAiplatformV1NasJobSpec({
    this.multiTrialAlgorithmSpec,
    this.resumeNasJobId,
    this.searchSpaceSpec,
  });

  GoogleCloudAiplatformV1NasJobSpec.fromJson(core.Map json_)
      : this(
          multiTrialAlgorithmSpec: json_.containsKey('multiTrialAlgorithmSpec')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec
                  .fromJson(json_['multiTrialAlgorithmSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          resumeNasJobId: json_.containsKey('resumeNasJobId')
              ? json_['resumeNasJobId'] as core.String
              : null,
          searchSpaceSpec: json_.containsKey('searchSpaceSpec')
              ? json_['searchSpaceSpec'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (multiTrialAlgorithmSpec != null)
          'multiTrialAlgorithmSpec': multiTrialAlgorithmSpec!,
        if (resumeNasJobId != null) 'resumeNasJobId': resumeNasJobId!,
        if (searchSpaceSpec != null) 'searchSpaceSpec': searchSpaceSpec!,
      };
}

/// The spec of multi-trial Neural Architecture Search (NAS).
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec {
  /// Metric specs for the NAS job.
  ///
  /// Validation for this field is done at `multi_trial_algorithm_spec` field.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec? metric;

  /// The multi-trial Neural Architecture Search (NAS) algorithm type.
  ///
  /// Defaults to `REINFORCEMENT_LEARNING`.
  /// Possible string values are:
  /// - "MULTI_TRIAL_ALGORITHM_UNSPECIFIED" : Defaults to
  /// `REINFORCEMENT_LEARNING`.
  /// - "REINFORCEMENT_LEARNING" : The Reinforcement Learning Algorithm for
  /// Multi-trial Neural Architecture Search (NAS).
  /// - "GRID_SEARCH" : The Grid Search Algorithm for Multi-trial Neural
  /// Architecture Search (NAS).
  core.String? multiTrialAlgorithm;

  /// Spec for search trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec?
      searchTrialSpec;

  /// Spec for train trials.
  ///
  /// Top N \[TrainTrialSpec.max_parallel_trial_count\] search trials will be
  /// trained for every M \[TrainTrialSpec.frequency\] trials searched.
  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec?
      trainTrialSpec;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec({
    this.metric,
    this.multiTrialAlgorithm,
    this.searchTrialSpec,
    this.trainTrialSpec,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpec.fromJson(
      core.Map json_)
      : this(
          metric: json_.containsKey('metric')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec
                  .fromJson(
                      json_['metric'] as core.Map<core.String, core.dynamic>)
              : null,
          multiTrialAlgorithm: json_.containsKey('multiTrialAlgorithm')
              ? json_['multiTrialAlgorithm'] as core.String
              : null,
          searchTrialSpec: json_.containsKey('searchTrialSpec')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec
                  .fromJson(json_['searchTrialSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          trainTrialSpec: json_.containsKey('trainTrialSpec')
              ? GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec
                  .fromJson(json_['trainTrialSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (metric != null) 'metric': metric!,
        if (multiTrialAlgorithm != null)
          'multiTrialAlgorithm': multiTrialAlgorithm!,
        if (searchTrialSpec != null) 'searchTrialSpec': searchTrialSpec!,
        if (trainTrialSpec != null) 'trainTrialSpec': trainTrialSpec!,
      };
}

/// Represents a metric to optimize.
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec {
  /// The optimization goal of the metric.
  ///
  /// Required.
  /// Possible string values are:
  /// - "GOAL_TYPE_UNSPECIFIED" : Goal Type will default to maximize.
  /// - "MAXIMIZE" : Maximize the goal metric.
  /// - "MINIMIZE" : Minimize the goal metric.
  core.String? goal;

  /// The ID of the metric.
  ///
  /// Must not contain whitespaces.
  ///
  /// Required.
  core.String? metricId;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec({
    this.goal,
    this.metricId,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecMetricSpec.fromJson(
      core.Map json_)
      : this(
          goal: json_.containsKey('goal') ? json_['goal'] as core.String : null,
          metricId: json_.containsKey('metricId')
              ? json_['metricId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (goal != null) 'goal': goal!,
        if (metricId != null) 'metricId': metricId!,
      };
}

/// Represent spec for search trials.
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec {
  /// The number of failed trials that need to be seen before failing the
  /// NasJob.
  ///
  /// If set to 0, Vertex AI decides how many trials must fail before the whole
  /// job fails.
  core.int? maxFailedTrialCount;

  /// The maximum number of trials to run in parallel.
  ///
  /// Required.
  core.int? maxParallelTrialCount;

  /// The maximum number of Neural Architecture Search (NAS) trials to run.
  ///
  /// Required.
  core.int? maxTrialCount;

  /// The spec of a search trial job.
  ///
  /// The same spec applies to all search trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? searchTrialJobSpec;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec({
    this.maxFailedTrialCount,
    this.maxParallelTrialCount,
    this.maxTrialCount,
    this.searchTrialJobSpec,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecSearchTrialSpec.fromJson(
      core.Map json_)
      : this(
          maxFailedTrialCount: json_.containsKey('maxFailedTrialCount')
              ? json_['maxFailedTrialCount'] as core.int
              : null,
          maxParallelTrialCount: json_.containsKey('maxParallelTrialCount')
              ? json_['maxParallelTrialCount'] as core.int
              : null,
          maxTrialCount: json_.containsKey('maxTrialCount')
              ? json_['maxTrialCount'] as core.int
              : null,
          searchTrialJobSpec: json_.containsKey('searchTrialJobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['searchTrialJobSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxFailedTrialCount != null)
          'maxFailedTrialCount': maxFailedTrialCount!,
        if (maxParallelTrialCount != null)
          'maxParallelTrialCount': maxParallelTrialCount!,
        if (maxTrialCount != null) 'maxTrialCount': maxTrialCount!,
        if (searchTrialJobSpec != null)
          'searchTrialJobSpec': searchTrialJobSpec!,
      };
}

/// Represent spec for train trials.
class GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec {
  /// Frequency of search trials to start train stage.
  ///
  /// Top N \[TrainTrialSpec.max_parallel_trial_count\] search trials will be
  /// trained for every M \[TrainTrialSpec.frequency\] trials searched.
  ///
  /// Required.
  core.int? frequency;

  /// The maximum number of trials to run in parallel.
  ///
  /// Required.
  core.int? maxParallelTrialCount;

  /// The spec of a train trial job.
  ///
  /// The same spec applies to all train trials.
  ///
  /// Required.
  GoogleCloudAiplatformV1CustomJobSpec? trainTrialJobSpec;

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec({
    this.frequency,
    this.maxParallelTrialCount,
    this.trainTrialJobSpec,
  });

  GoogleCloudAiplatformV1NasJobSpecMultiTrialAlgorithmSpecTrainTrialSpec.fromJson(
      core.Map json_)
      : this(
          frequency: json_.containsKey('frequency')
              ? json_['frequency'] as core.int
              : null,
          maxParallelTrialCount: json_.containsKey('maxParallelTrialCount')
              ? json_['maxParallelTrialCount'] as core.int
              : null,
          trainTrialJobSpec: json_.containsKey('trainTrialJobSpec')
              ? GoogleCloudAiplatformV1CustomJobSpec.fromJson(
                  json_['trainTrialJobSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (frequency != null) 'frequency': frequency!,
        if (maxParallelTrialCount != null)
          'maxParallelTrialCount': maxParallelTrialCount!,
        if (trainTrialJobSpec != null) 'trainTrialJobSpec': trainTrialJobSpec!,
      };
}

/// Represents a uCAIP NasJob trial.
class GoogleCloudAiplatformV1NasTrial {
  /// Time when the NasTrial's status changed to `SUCCEEDED` or `INFEASIBLE`.
  ///
  /// Output only.
  core.String? endTime;

  /// The final measurement containing the objective value.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Measurement? finalMeasurement;

  /// The identifier of the NasTrial assigned by the service.
  ///
  /// Output only.
  core.String? id;

  /// Time when the NasTrial was started.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the NasTrial.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The NasTrial state is unspecified.
  /// - "REQUESTED" : Indicates that a specific NasTrial has been requested, but
  /// it has not yet been suggested by the service.
  /// - "ACTIVE" : Indicates that the NasTrial has been suggested.
  /// - "STOPPING" : Indicates that the NasTrial should stop according to the
  /// service.
  /// - "SUCCEEDED" : Indicates that the NasTrial is completed successfully.
  /// - "INFEASIBLE" : Indicates that the NasTrial should not be attempted
  /// again. The service will set a NasTrial to INFEASIBLE when it's done but
  /// missing the final_measurement.
  core.String? state;

  GoogleCloudAiplatformV1NasTrial({
    this.endTime,
    this.finalMeasurement,
    this.id,
    this.startTime,
    this.state,
  });

  GoogleCloudAiplatformV1NasTrial.fromJson(core.Map json_)
      : this(
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          finalMeasurement: json_.containsKey('finalMeasurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>)
              : null,
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endTime != null) 'endTime': endTime!,
        if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
        if (id != null) 'id': id!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
      };
}

/// Represents a NasTrial details along with its parameters.
///
/// If there is a corresponding train NasTrial, the train NasTrial is also
/// returned.
class GoogleCloudAiplatformV1NasTrialDetail {
  /// Resource name of the NasTrialDetail.
  ///
  /// Output only.
  core.String? name;

  /// The parameters for the NasJob NasTrial.
  core.String? parameters;

  /// The requested search NasTrial.
  GoogleCloudAiplatformV1NasTrial? searchTrial;

  /// The train NasTrial corresponding to search_trial.
  ///
  /// Only populated if search_trial is used for training.
  GoogleCloudAiplatformV1NasTrial? trainTrial;

  GoogleCloudAiplatformV1NasTrialDetail({
    this.name,
    this.parameters,
    this.searchTrial,
    this.trainTrial,
  });

  GoogleCloudAiplatformV1NasTrialDetail.fromJson(core.Map json_)
      : this(
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          parameters: json_.containsKey('parameters')
              ? json_['parameters'] as core.String
              : null,
          searchTrial: json_.containsKey('searchTrial')
              ? GoogleCloudAiplatformV1NasTrial.fromJson(
                  json_['searchTrial'] as core.Map<core.String, core.dynamic>)
              : null,
          trainTrial: json_.containsKey('trainTrial')
              ? GoogleCloudAiplatformV1NasTrial.fromJson(
                  json_['trainTrial'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (name != null) 'name': name!,
        if (parameters != null) 'parameters': parameters!,
        if (searchTrial != null) 'searchTrial': searchTrial!,
        if (trainTrial != null) 'trainTrial': trainTrial!,
      };
}

/// Neighbors for example-based explanations.
class GoogleCloudAiplatformV1Neighbor {
  /// The neighbor distance.
  ///
  /// Output only.
  core.double? neighborDistance;

  /// The neighbor id.
  ///
  /// Output only.
  core.String? neighborId;

  GoogleCloudAiplatformV1Neighbor({
    this.neighborDistance,
    this.neighborId,
  });

  GoogleCloudAiplatformV1Neighbor.fromJson(core.Map json_)
      : this(
          neighborDistance: json_.containsKey('neighborDistance')
              ? (json_['neighborDistance'] as core.num).toDouble()
              : null,
          neighborId: json_.containsKey('neighborId')
              ? json_['neighborId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (neighborDistance != null) 'neighborDistance': neighborDistance!,
        if (neighborId != null) 'neighborId': neighborId!,
      };
}

/// Network spec.
class GoogleCloudAiplatformV1NetworkSpec {
  /// Whether to enable public internet access.
  ///
  /// Default false.
  core.bool? enableInternetAccess;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  core.String? network;

  /// The name of the subnet that this instance is in.
  ///
  /// Format:
  /// `projects/{project_id_or_number}/regions/{region}/subnetworks/{subnetwork_id}`
  core.String? subnetwork;

  GoogleCloudAiplatformV1NetworkSpec({
    this.enableInternetAccess,
    this.network,
    this.subnetwork,
  });

  GoogleCloudAiplatformV1NetworkSpec.fromJson(core.Map json_)
      : this(
          enableInternetAccess: json_.containsKey('enableInternetAccess')
              ? json_['enableInternetAccess'] as core.bool
              : null,
          network: json_.containsKey('network')
              ? json_['network'] as core.String
              : null,
          subnetwork: json_.containsKey('subnetwork')
              ? json_['subnetwork'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enableInternetAccess != null)
          'enableInternetAccess': enableInternetAccess!,
        if (network != null) 'network': network!,
        if (subnetwork != null) 'subnetwork': subnetwork!,
      };
}

/// Represents a mount configuration for Network File System (NFS) to mount.
class GoogleCloudAiplatformV1NfsMount {
  /// Destination mount path.
  ///
  /// The NFS will be mounted for the user under /mnt/nfs/
  ///
  /// Required.
  core.String? mountPoint;

  /// Source path exported from NFS server.
  ///
  /// Has to start with '/', and combined with the ip address, it indicates the
  /// source mount path in the form of `server:path`
  ///
  /// Required.
  core.String? path;

  /// IP address of the NFS server.
  ///
  /// Required.
  core.String? server;

  GoogleCloudAiplatformV1NfsMount({
    this.mountPoint,
    this.path,
    this.server,
  });

  GoogleCloudAiplatformV1NfsMount.fromJson(core.Map json_)
      : this(
          mountPoint: json_.containsKey('mountPoint')
              ? json_['mountPoint'] as core.String
              : null,
          path: json_.containsKey('path') ? json_['path'] as core.String : null,
          server: json_.containsKey('server')
              ? json_['server'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (mountPoint != null) 'mountPoint': mountPoint!,
        if (path != null) 'path': path!,
        if (server != null) 'server': server!,
      };
}

/// The euc configuration of NotebookRuntimeTemplate.
class GoogleCloudAiplatformV1NotebookEucConfig {
  /// Whether ActAs check is bypassed for service account attached to the VM.
  ///
  /// If false, we need ActAs check for the default Compute Engine Service
  /// account. When a Runtime is created, a VM is allocated using Default
  /// Compute Engine Service Account. Any user requesting to use this Runtime
  /// requires Service Account User (ActAs) permission over this SA. If true,
  /// Runtime owner is using EUC and does not require the above permission as VM
  /// no longer use default Compute Engine SA, but a P4SA.
  ///
  /// Output only.
  core.bool? bypassActasCheck;

  /// Input only.
  ///
  /// Whether EUC is disabled in this NotebookRuntimeTemplate. In proto3, the
  /// default value of a boolean is false. In this way, by default EUC will be
  /// enabled for NotebookRuntimeTemplate.
  core.bool? eucDisabled;

  GoogleCloudAiplatformV1NotebookEucConfig({
    this.bypassActasCheck,
    this.eucDisabled,
  });

  GoogleCloudAiplatformV1NotebookEucConfig.fromJson(core.Map json_)
      : this(
          bypassActasCheck: json_.containsKey('bypassActasCheck')
              ? json_['bypassActasCheck'] as core.bool
              : null,
          eucDisabled: json_.containsKey('eucDisabled')
              ? json_['eucDisabled'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bypassActasCheck != null) 'bypassActasCheck': bypassActasCheck!,
        if (eucDisabled != null) 'eucDisabled': eucDisabled!,
      };
}

/// The idle shutdown configuration of NotebookRuntimeTemplate, which contains
/// the idle_timeout as required field.
class GoogleCloudAiplatformV1NotebookIdleShutdownConfig {
  /// Whether Idle Shutdown is disabled in this NotebookRuntimeTemplate.
  core.bool? idleShutdownDisabled;

  /// Duration is accurate to the second.
  ///
  /// In Notebook, Idle Timeout is accurate to minute so the range of
  /// idle_timeout (second) is: 10 * 60 ~ 1440 * 60.
  ///
  /// Required.
  core.String? idleTimeout;

  GoogleCloudAiplatformV1NotebookIdleShutdownConfig({
    this.idleShutdownDisabled,
    this.idleTimeout,
  });

  GoogleCloudAiplatformV1NotebookIdleShutdownConfig.fromJson(core.Map json_)
      : this(
          idleShutdownDisabled: json_.containsKey('idleShutdownDisabled')
              ? json_['idleShutdownDisabled'] as core.bool
              : null,
          idleTimeout: json_.containsKey('idleTimeout')
              ? json_['idleTimeout'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (idleShutdownDisabled != null)
          'idleShutdownDisabled': idleShutdownDisabled!,
        if (idleTimeout != null) 'idleTimeout': idleTimeout!,
      };
}

/// A runtime is a virtual machine allocated to a particular user for a
/// particular Notebook file on temporary basis with lifetime limited to 24
/// hours.
class GoogleCloudAiplatformV1NotebookRuntime {
  /// Timestamp when this NotebookRuntime was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The description of the NotebookRuntime.
  core.String? description;

  /// The display name of the NotebookRuntime.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Timestamp when this NotebookRuntime will be expired: 1.
  ///
  /// System Predefined NotebookRuntime: 24 hours after creation. After
  /// expiration, system predifined runtime will be deleted. 2. User created
  /// NotebookRuntime: 6 months after last upgrade. After expiration, user
  /// created runtime will be stopped and allowed for upgrade.
  ///
  /// Output only.
  core.String? expirationTime;

  /// The health state of the NotebookRuntime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "HEALTH_STATE_UNSPECIFIED" : Unspecified health state.
  /// - "HEALTHY" : NotebookRuntime is in healthy state. Applies to ACTIVE
  /// state.
  /// - "UNHEALTHY" : NotebookRuntime is in unhealthy state. Applies to ACTIVE
  /// state.
  core.String? healthState;

  /// The labels with user-defined metadata to organize your NotebookRuntime.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one NotebookRuntime (System labels
  /// are excluded). See https://goo.gl/xmQnxf for more information and examples
  /// of labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable. Following system labels
  /// exist for NotebookRuntime: *
  /// "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output only,
  /// its value is the Compute Engine instance id. *
  /// "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
  /// either "bigquery" or "vertex"; if absent, it should be "vertex". This is
  /// to describe the entry service, either BigQuery or Vertex.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the NotebookRuntime.
  ///
  /// Output only.
  core.String? name;

  /// The pointer to NotebookRuntimeTemplate this NotebookRuntime is created
  /// from.
  ///
  /// Output only.
  GoogleCloudAiplatformV1NotebookRuntimeTemplateRef? notebookRuntimeTemplateRef;

  /// The type of the notebook runtime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" : Unspecified notebook runtime type,
  /// NotebookRuntimeType will default to USER_DEFINED.
  /// - "USER_DEFINED" : runtime or template with coustomized configurations
  /// from user.
  /// - "ONE_CLICK" : runtime or template with system defined configurations.
  core.String? notebookRuntimeType;

  /// The proxy endpoint used to access the NotebookRuntime.
  ///
  /// Output only.
  core.String? proxyUri;

  /// The runtime (instance) state of the NotebookRuntime.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "RUNTIME_STATE_UNSPECIFIED" : Unspecified runtime state.
  /// - "RUNNING" : NotebookRuntime is in running state.
  /// - "BEING_STARTED" : NotebookRuntime is in starting state.
  /// - "BEING_STOPPED" : NotebookRuntime is in stopping state.
  /// - "STOPPED" : NotebookRuntime is in stopped state.
  /// - "BEING_UPGRADED" : NotebookRuntime is in upgrading state. It is in the
  /// middle of upgrading process.
  core.String? runtimeState;

  /// The user email of the NotebookRuntime.
  ///
  /// Required.
  core.String? runtimeUser;

  /// The service account that the NotebookRuntime workload runs as.
  ///
  /// Output only.
  core.String? serviceAccount;

  /// Timestamp when this NotebookRuntime was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// The VM os image version of NotebookRuntime.
  ///
  /// Output only.
  core.String? version;

  GoogleCloudAiplatformV1NotebookRuntime({
    this.createTime,
    this.description,
    this.displayName,
    this.expirationTime,
    this.healthState,
    this.labels,
    this.name,
    this.notebookRuntimeTemplateRef,
    this.notebookRuntimeType,
    this.proxyUri,
    this.runtimeState,
    this.runtimeUser,
    this.serviceAccount,
    this.updateTime,
    this.version,
  });

  GoogleCloudAiplatformV1NotebookRuntime.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          expirationTime: json_.containsKey('expirationTime')
              ? json_['expirationTime'] as core.String
              : null,
          healthState: json_.containsKey('healthState')
              ? json_['healthState'] as core.String
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          notebookRuntimeTemplateRef:
              json_.containsKey('notebookRuntimeTemplateRef')
                  ? GoogleCloudAiplatformV1NotebookRuntimeTemplateRef.fromJson(
                      json_['notebookRuntimeTemplateRef']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          notebookRuntimeType: json_.containsKey('notebookRuntimeType')
              ? json_['notebookRuntimeType'] as core.String
              : null,
          proxyUri: json_.containsKey('proxyUri')
              ? json_['proxyUri'] as core.String
              : null,
          runtimeState: json_.containsKey('runtimeState')
              ? json_['runtimeState'] as core.String
              : null,
          runtimeUser: json_.containsKey('runtimeUser')
              ? json_['runtimeUser'] as core.String
              : null,
          serviceAccount: json_.containsKey('serviceAccount')
              ? json_['serviceAccount'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
          version: json_.containsKey('version')
              ? json_['version'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (expirationTime != null) 'expirationTime': expirationTime!,
        if (healthState != null) 'healthState': healthState!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (notebookRuntimeTemplateRef != null)
          'notebookRuntimeTemplateRef': notebookRuntimeTemplateRef!,
        if (notebookRuntimeType != null)
          'notebookRuntimeType': notebookRuntimeType!,
        if (proxyUri != null) 'proxyUri': proxyUri!,
        if (runtimeState != null) 'runtimeState': runtimeState!,
        if (runtimeUser != null) 'runtimeUser': runtimeUser!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (version != null) 'version': version!,
      };
}

/// A template that specifies runtime configurations such as machine type,
/// runtime version, network configurations, etc.
///
/// Multiple runtimes can be created from a runtime template.
class GoogleCloudAiplatformV1NotebookRuntimeTemplate {
  /// Timestamp when this NotebookRuntimeTemplate was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The specification of persistent disk attached to the runtime as data disk
  /// storage.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PersistentDiskSpec? dataPersistentDiskSpec;

  /// The description of the NotebookRuntimeTemplate.
  core.String? description;

  /// The display name of the NotebookRuntimeTemplate.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// EUC configuration of the NotebookRuntimeTemplate.
  GoogleCloudAiplatformV1NotebookEucConfig? eucConfig;

  /// The idle shutdown configuration of NotebookRuntimeTemplate.
  ///
  /// This config will only be set when idle shutdown is enabled.
  GoogleCloudAiplatformV1NotebookIdleShutdownConfig? idleShutdownConfig;

  /// The default template to use if not specified.
  ///
  /// Output only.
  core.bool? isDefault;

  /// The labels with user-defined metadata to organize the
  /// NotebookRuntimeTemplates.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The specification of a single machine for the template.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// The resource name of the NotebookRuntimeTemplate.
  ///
  /// Output only.
  core.String? name;

  /// Network spec.
  ///
  /// Optional.
  GoogleCloudAiplatformV1NetworkSpec? networkSpec;

  /// The type of the notebook runtime template.
  ///
  /// Optional. Immutable.
  /// Possible string values are:
  /// - "NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED" : Unspecified notebook runtime type,
  /// NotebookRuntimeType will default to USER_DEFINED.
  /// - "USER_DEFINED" : runtime or template with coustomized configurations
  /// from user.
  /// - "ONE_CLICK" : runtime or template with system defined configurations.
  core.String? notebookRuntimeType;

  /// The service account that the runtime workload runs as.
  ///
  /// You can use any service account within the same project, but you must have
  /// the service account user permission to use the instance. If not specified,
  /// the
  /// [Compute Engine default service account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
  /// is used.
  core.String? serviceAccount;

  /// Timestamp when this NotebookRuntimeTemplate was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1NotebookRuntimeTemplate({
    this.createTime,
    this.dataPersistentDiskSpec,
    this.description,
    this.displayName,
    this.etag,
    this.eucConfig,
    this.idleShutdownConfig,
    this.isDefault,
    this.labels,
    this.machineSpec,
    this.name,
    this.networkSpec,
    this.notebookRuntimeType,
    this.serviceAccount,
    this.updateTime,
  });

  GoogleCloudAiplatformV1NotebookRuntimeTemplate.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          dataPersistentDiskSpec: json_.containsKey('dataPersistentDiskSpec')
              ? GoogleCloudAiplatformV1PersistentDiskSpec.fromJson(
                  json_['dataPersistentDiskSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          eucConfig: json_.containsKey('eucConfig')
              ? GoogleCloudAiplatformV1NotebookEucConfig.fromJson(
                  json_['eucConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          idleShutdownConfig: json_.containsKey('idleShutdownConfig')
              ? GoogleCloudAiplatformV1NotebookIdleShutdownConfig.fromJson(
                  json_['idleShutdownConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          isDefault: json_.containsKey('isDefault')
              ? json_['isDefault'] as core.bool
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          networkSpec: json_.containsKey('networkSpec')
              ? GoogleCloudAiplatformV1NetworkSpec.fromJson(
                  json_['networkSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          notebookRuntimeType: json_.containsKey('notebookRuntimeType')
              ? json_['notebookRuntimeType'] as core.String
              : null,
          serviceAccount: json_.containsKey('serviceAccount')
              ? json_['serviceAccount'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (dataPersistentDiskSpec != null)
          'dataPersistentDiskSpec': dataPersistentDiskSpec!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (eucConfig != null) 'eucConfig': eucConfig!,
        if (idleShutdownConfig != null)
          'idleShutdownConfig': idleShutdownConfig!,
        if (isDefault != null) 'isDefault': isDefault!,
        if (labels != null) 'labels': labels!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (name != null) 'name': name!,
        if (networkSpec != null) 'networkSpec': networkSpec!,
        if (notebookRuntimeType != null)
          'notebookRuntimeType': notebookRuntimeType!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Points to a NotebookRuntimeTemplateRef.
class GoogleCloudAiplatformV1NotebookRuntimeTemplateRef {
  /// A resource name of the NotebookRuntimeTemplate.
  ///
  /// Immutable.
  core.String? notebookRuntimeTemplate;

  GoogleCloudAiplatformV1NotebookRuntimeTemplateRef({
    this.notebookRuntimeTemplate,
  });

  GoogleCloudAiplatformV1NotebookRuntimeTemplateRef.fromJson(core.Map json_)
      : this(
          notebookRuntimeTemplate: json_.containsKey('notebookRuntimeTemplate')
              ? json_['notebookRuntimeTemplate'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (notebookRuntimeTemplate != null)
          'notebookRuntimeTemplate': notebookRuntimeTemplate!,
      };
}

/// Request message for JobService.PauseModelDeploymentMonitoringJob.
typedef GoogleCloudAiplatformV1PauseModelDeploymentMonitoringJobRequest
    = $Empty;

/// Request message for ScheduleService.PauseSchedule.
typedef GoogleCloudAiplatformV1PauseScheduleRequest = $Empty;

/// Represents the spec of persistent disk options.
class GoogleCloudAiplatformV1PersistentDiskSpec {
  /// Size in GB of the disk (default is 100GB).
  core.String? diskSizeGb;

  /// Type of the disk (default is "pd-standard").
  ///
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive) "pd-standard"
  /// (Persistent Disk Hard Disk Drive) "pd-balanced" (Balanced Persistent Disk)
  /// "pd-extreme" (Extreme Persistent Disk)
  core.String? diskType;

  GoogleCloudAiplatformV1PersistentDiskSpec({
    this.diskSizeGb,
    this.diskType,
  });

  GoogleCloudAiplatformV1PersistentDiskSpec.fromJson(core.Map json_)
      : this(
          diskSizeGb: json_.containsKey('diskSizeGb')
              ? json_['diskSizeGb'] as core.String
              : null,
          diskType: json_.containsKey('diskType')
              ? json_['diskType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (diskSizeGb != null) 'diskSizeGb': diskSizeGb!,
        if (diskType != null) 'diskType': diskType!,
      };
}

/// An instance of a machine learning PipelineJob.
class GoogleCloudAiplatformV1PipelineJob {
  /// Pipeline creation time.
  ///
  /// Output only.
  core.String? createTime;

  /// The display name of the Pipeline.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  core.String? displayName;

  /// Customer-managed encryption key spec for a pipelineJob.
  ///
  /// If set, this PipelineJob and all of its sub-resources will be secured by
  /// this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Pipeline end time.
  ///
  /// Output only.
  core.String? endTime;

  /// The error that occurred during pipeline execution.
  ///
  /// Only populated when the pipeline's state is FAILED or CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The details of pipeline run.
  ///
  /// Not available in the list view.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineJobDetail? jobDetail;

  /// The labels with user-defined metadata to organize PipelineJob.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels. Note
  /// there is some reserved label key for Vertex AI Pipelines. -
  /// `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
  core.Map<core.String, core.String>? labels;

  /// The resource name of the PipelineJob.
  ///
  /// Output only.
  core.String? name;

  /// The full name of the Compute Engine
  /// \[network\](/compute/docs/networks-and-firewalls#networks) to which the
  /// Pipeline Job's workload should be peered.
  ///
  /// For example, `projects/12345/global/networks/myVPC`.
  /// \[Format\](/compute/docs/reference/rest/v1/networks/insert) is of the form
  /// `projects/{project}/global/networks/{network}`. Where {project} is a
  /// project number, as in `12345`, and {network} is a network name. Private
  /// services access must already be configured for the network. Pipeline job
  /// will apply the network configuration to the Google Cloud resources being
  /// launched, if applied, such as Vertex AI Training or Dataflow job. If left
  /// unspecified, the workload is not peered with any network.
  core.String? network;

  /// The spec of the pipeline.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? pipelineSpec;

  /// A list of names for the reserved ip ranges under the VPC network that can
  /// be used for this Pipeline Job's workload.
  ///
  /// If set, we will deploy the Pipeline Job's workload within the provided ip
  /// ranges. Otherwise, the job will be deployed to any ip ranges under the
  /// provided VPC network. Example: \['vertex-ai-ip-range'\].
  core.List<core.String>? reservedIpRanges;

  /// Runtime config of the pipeline.
  GoogleCloudAiplatformV1PipelineJobRuntimeConfig? runtimeConfig;

  /// The schedule resource name.
  ///
  /// Only returned if the Pipeline is created by Schedule API.
  ///
  /// Output only.
  core.String? scheduleName;

  /// The service account that the pipeline workload runs as.
  ///
  /// If not specified, the Compute Engine default service account in the
  /// project will be used. See
  /// https://cloud.google.com/compute/docs/access/service-accounts#default_service_account
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  core.String? serviceAccount;

  /// Pipeline start time.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the job.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PIPELINE_STATE_UNSPECIFIED" : The pipeline state is unspecified.
  /// - "PIPELINE_STATE_QUEUED" : The pipeline has been created or resumed, and
  /// processing has not yet begun.
  /// - "PIPELINE_STATE_PENDING" : The service is preparing to run the pipeline.
  /// - "PIPELINE_STATE_RUNNING" : The pipeline is in progress.
  /// - "PIPELINE_STATE_SUCCEEDED" : The pipeline completed successfully.
  /// - "PIPELINE_STATE_FAILED" : The pipeline failed.
  /// - "PIPELINE_STATE_CANCELLING" : The pipeline is being cancelled. From this
  /// state, the pipeline may only go to either PIPELINE_STATE_SUCCEEDED,
  /// PIPELINE_STATE_FAILED or PIPELINE_STATE_CANCELLED.
  /// - "PIPELINE_STATE_CANCELLED" : The pipeline has been cancelled.
  /// - "PIPELINE_STATE_PAUSED" : The pipeline has been stopped, and can be
  /// resumed.
  core.String? state;

  /// Pipeline template metadata.
  ///
  /// Will fill up fields if PipelineJob.template_uri is from supported template
  /// registry.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTemplateMetadata? templateMetadata;

  /// A template uri from where the PipelineJob.pipeline_spec, if empty, will be
  /// downloaded.
  ///
  /// Currently, only uri from Vertex Template Registry & Gallery is supported.
  /// Reference to
  /// https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
  core.String? templateUri;

  /// Timestamp when this PipelineJob was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1PipelineJob({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.jobDetail,
    this.labels,
    this.name,
    this.network,
    this.pipelineSpec,
    this.reservedIpRanges,
    this.runtimeConfig,
    this.scheduleName,
    this.serviceAccount,
    this.startTime,
    this.state,
    this.templateMetadata,
    this.templateUri,
    this.updateTime,
  });

  GoogleCloudAiplatformV1PipelineJob.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          jobDetail: json_.containsKey('jobDetail')
              ? GoogleCloudAiplatformV1PipelineJobDetail.fromJson(
                  json_['jobDetail'] as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          network: json_.containsKey('network')
              ? json_['network'] as core.String
              : null,
          pipelineSpec: json_.containsKey('pipelineSpec')
              ? json_['pipelineSpec'] as core.Map<core.String, core.dynamic>
              : null,
          reservedIpRanges: json_.containsKey('reservedIpRanges')
              ? (json_['reservedIpRanges'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          runtimeConfig: json_.containsKey('runtimeConfig')
              ? GoogleCloudAiplatformV1PipelineJobRuntimeConfig.fromJson(
                  json_['runtimeConfig'] as core.Map<core.String, core.dynamic>)
              : null,
          scheduleName: json_.containsKey('scheduleName')
              ? json_['scheduleName'] as core.String
              : null,
          serviceAccount: json_.containsKey('serviceAccount')
              ? json_['serviceAccount'] as core.String
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          templateMetadata: json_.containsKey('templateMetadata')
              ? GoogleCloudAiplatformV1PipelineTemplateMetadata.fromJson(
                  json_['templateMetadata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          templateUri: json_.containsKey('templateUri')
              ? json_['templateUri'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (jobDetail != null) 'jobDetail': jobDetail!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (network != null) 'network': network!,
        if (pipelineSpec != null) 'pipelineSpec': pipelineSpec!,
        if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges!,
        if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!,
        if (scheduleName != null) 'scheduleName': scheduleName!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (templateMetadata != null) 'templateMetadata': templateMetadata!,
        if (templateUri != null) 'templateUri': templateUri!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// The runtime detail of PipelineJob.
class GoogleCloudAiplatformV1PipelineJobDetail {
  /// The context of the pipeline.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Context? pipelineContext;

  /// The context of the current pipeline run.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Context? pipelineRunContext;

  /// The runtime details of the tasks under the pipeline.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1PipelineTaskDetail>? taskDetails;

  GoogleCloudAiplatformV1PipelineJobDetail({
    this.pipelineContext,
    this.pipelineRunContext,
    this.taskDetails,
  });

  GoogleCloudAiplatformV1PipelineJobDetail.fromJson(core.Map json_)
      : this(
          pipelineContext: json_.containsKey('pipelineContext')
              ? GoogleCloudAiplatformV1Context.fromJson(json_['pipelineContext']
                  as core.Map<core.String, core.dynamic>)
              : null,
          pipelineRunContext: json_.containsKey('pipelineRunContext')
              ? GoogleCloudAiplatformV1Context.fromJson(
                  json_['pipelineRunContext']
                      as core.Map<core.String, core.dynamic>)
              : null,
          taskDetails: json_.containsKey('taskDetails')
              ? (json_['taskDetails'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1PipelineTaskDetail.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (pipelineContext != null) 'pipelineContext': pipelineContext!,
        if (pipelineRunContext != null)
          'pipelineRunContext': pipelineRunContext!,
        if (taskDetails != null) 'taskDetails': taskDetails!,
      };
}

/// The runtime config of a PipelineJob.
class GoogleCloudAiplatformV1PipelineJobRuntimeConfig {
  /// Represents the failure policy of a pipeline.
  ///
  /// Currently, the default of a pipeline is that the pipeline will continue to
  /// run until no more tasks can be executed, also known as
  /// PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a pipeline is set to
  /// PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling any new tasks
  /// when a task has failed. Any scheduled tasks will continue to completion.
  /// Possible string values are:
  /// - "PIPELINE_FAILURE_POLICY_UNSPECIFIED" : Default value, and follows fail
  /// slow behavior.
  /// - "PIPELINE_FAILURE_POLICY_FAIL_SLOW" : Indicates that the pipeline should
  /// continue to run until all possible tasks have been scheduled and
  /// completed.
  /// - "PIPELINE_FAILURE_POLICY_FAIL_FAST" : Indicates that the pipeline should
  /// stop scheduling new tasks after a task has failed.
  core.String? failurePolicy;

  /// A path in a Cloud Storage bucket, which will be treated as the root output
  /// directory of the pipeline.
  ///
  /// It is used by the system to generate the paths of output artifacts. The
  /// artifact paths are generated with a sub-path pattern
  /// `{job_id}/{task_id}/{output_key}` under the specified output directory.
  /// The service account specified in this pipeline must have the
  /// `storage.objects.get` and `storage.objects.create` permissions for this
  /// bucket.
  ///
  /// Required.
  core.String? gcsOutputDirectory;

  /// The runtime artifacts of the PipelineJob.
  ///
  /// The key will be the input artifact name and the value would be one of the
  /// InputArtifact.
  core.Map<core.String,
          GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact>?
      inputArtifacts;

  /// The runtime parameters of the PipelineJob.
  ///
  /// The parameters will be passed into PipelineJob.pipeline_spec to replace
  /// the placeholders at runtime. This field is used by pipelines built using
  /// `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as pipelines built
  /// using Kubeflow Pipelines SDK 1.9 or higher and the v2 DSL.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? parameterValues;

  /// Use RuntimeConfig.parameter_values instead.
  ///
  /// The runtime parameters of the PipelineJob. The parameters will be passed
  /// into PipelineJob.pipeline_spec to replace the placeholders at runtime.
  /// This field is used by pipelines built using
  /// `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower, such as
  /// pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
  ///
  /// Deprecated.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.Map<core.String, GoogleCloudAiplatformV1Value>? parameters;

  GoogleCloudAiplatformV1PipelineJobRuntimeConfig({
    this.failurePolicy,
    this.gcsOutputDirectory,
    this.inputArtifacts,
    this.parameterValues,
    this.parameters,
  });

  GoogleCloudAiplatformV1PipelineJobRuntimeConfig.fromJson(core.Map json_)
      : this(
          failurePolicy: json_.containsKey('failurePolicy')
              ? json_['failurePolicy'] as core.String
              : null,
          gcsOutputDirectory: json_.containsKey('gcsOutputDirectory')
              ? json_['gcsOutputDirectory'] as core.String
              : null,
          inputArtifacts: json_.containsKey('inputArtifacts')
              ? (json_['inputArtifacts'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          parameterValues: json_.containsKey('parameterValues')
              ? json_['parameterValues'] as core.Map<core.String, core.dynamic>
              : null,
          parameters: json_.containsKey('parameters')
              ? (json_['parameters'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1Value.fromJson(
                        value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failurePolicy != null) 'failurePolicy': failurePolicy!,
        if (gcsOutputDirectory != null)
          'gcsOutputDirectory': gcsOutputDirectory!,
        if (inputArtifacts != null) 'inputArtifacts': inputArtifacts!,
        if (parameterValues != null) 'parameterValues': parameterValues!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// The type of an input artifact.
class GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact {
  /// Artifact resource id from MLMD.
  ///
  /// Which is the last portion of an artifact resource name:
  /// `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`.
  /// The artifact must stay within the same project, location and default
  /// metadatastore as the pipeline.
  core.String? artifactId;

  GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact({
    this.artifactId,
  });

  GoogleCloudAiplatformV1PipelineJobRuntimeConfigInputArtifact.fromJson(
      core.Map json_)
      : this(
          artifactId: json_.containsKey('artifactId')
              ? json_['artifactId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactId != null) 'artifactId': artifactId!,
      };
}

/// The runtime detail of a task execution.
class GoogleCloudAiplatformV1PipelineTaskDetail {
  /// Task create time.
  ///
  /// Output only.
  core.String? createTime;

  /// Task end time.
  ///
  /// Output only.
  core.String? endTime;

  /// The error that occurred during task execution.
  ///
  /// Only populated when the task's state is FAILED or CANCELLED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The execution metadata of the task.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Execution? execution;

  /// The detailed execution info.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTaskExecutorDetail? executorDetail;

  /// The runtime input artifacts of the task.
  ///
  /// Output only.
  core.Map<core.String, GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>?
      inputs;

  /// The runtime output artifacts of the task.
  ///
  /// Output only.
  core.Map<core.String, GoogleCloudAiplatformV1PipelineTaskDetailArtifactList>?
      outputs;

  /// The id of the parent task if the task is within a component scope.
  ///
  /// Empty if the task is at the root level.
  ///
  /// Output only.
  core.String? parentTaskId;

  /// A list of task status.
  ///
  /// This field keeps a record of task status evolving over time.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus>?
      pipelineTaskStatus;

  /// Task start time.
  ///
  /// Output only.
  core.String? startTime;

  /// State of the task.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "PENDING" : Specifies pending state for the task.
  /// - "RUNNING" : Specifies task is being executed.
  /// - "SUCCEEDED" : Specifies task completed successfully.
  /// - "CANCEL_PENDING" : Specifies Task cancel is in pending state.
  /// - "CANCELLING" : Specifies task is being cancelled.
  /// - "CANCELLED" : Specifies task was cancelled.
  /// - "FAILED" : Specifies task failed.
  /// - "SKIPPED" : Specifies task was skipped due to cache hit.
  /// - "NOT_TRIGGERED" : Specifies that the task was not triggered because the
  /// task's trigger policy is not satisfied. The trigger policy is specified in
  /// the `condition` field of PipelineJob.pipeline_spec.
  core.String? state;

  /// The system generated ID of the task.
  ///
  /// Output only.
  core.String? taskId;

  /// The user specified name of the task that is defined in pipeline_spec.
  ///
  /// Output only.
  core.String? taskName;

  GoogleCloudAiplatformV1PipelineTaskDetail({
    this.createTime,
    this.endTime,
    this.error,
    this.execution,
    this.executorDetail,
    this.inputs,
    this.outputs,
    this.parentTaskId,
    this.pipelineTaskStatus,
    this.startTime,
    this.state,
    this.taskId,
    this.taskName,
  });

  GoogleCloudAiplatformV1PipelineTaskDetail.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          execution: json_.containsKey('execution')
              ? GoogleCloudAiplatformV1Execution.fromJson(
                  json_['execution'] as core.Map<core.String, core.dynamic>)
              : null,
          executorDetail: json_.containsKey('executorDetail')
              ? GoogleCloudAiplatformV1PipelineTaskExecutorDetail.fromJson(
                  json_['executorDetail']
                      as core.Map<core.String, core.dynamic>)
              : null,
          inputs: json_.containsKey('inputs')
              ? (json_['inputs'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1PipelineTaskDetailArtifactList
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          outputs: json_.containsKey('outputs')
              ? (json_['outputs'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1PipelineTaskDetailArtifactList
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          parentTaskId: json_.containsKey('parentTaskId')
              ? json_['parentTaskId'] as core.String
              : null,
          pipelineTaskStatus: json_.containsKey('pipelineTaskStatus')
              ? (json_['pipelineTaskStatus'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          taskId: json_.containsKey('taskId')
              ? json_['taskId'] as core.String
              : null,
          taskName: json_.containsKey('taskName')
              ? json_['taskName'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (execution != null) 'execution': execution!,
        if (executorDetail != null) 'executorDetail': executorDetail!,
        if (inputs != null) 'inputs': inputs!,
        if (outputs != null) 'outputs': outputs!,
        if (parentTaskId != null) 'parentTaskId': parentTaskId!,
        if (pipelineTaskStatus != null)
          'pipelineTaskStatus': pipelineTaskStatus!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (taskId != null) 'taskId': taskId!,
        if (taskName != null) 'taskName': taskName!,
      };
}

/// A list of artifact metadata.
class GoogleCloudAiplatformV1PipelineTaskDetailArtifactList {
  /// A list of artifact metadata.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Artifact>? artifacts;

  GoogleCloudAiplatformV1PipelineTaskDetailArtifactList({
    this.artifacts,
  });

  GoogleCloudAiplatformV1PipelineTaskDetailArtifactList.fromJson(core.Map json_)
      : this(
          artifacts: json_.containsKey('artifacts')
              ? (json_['artifacts'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Artifact.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifacts != null) 'artifacts': artifacts!,
      };
}

/// A single record of the task status.
class GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus {
  /// The error that occurred during the state.
  ///
  /// May be set when the state is any of the non-final state
  /// (PENDING/RUNNING/CANCELLING) or FAILED state. If the state is FAILED, the
  /// error here is final and not going to be retried. If the state is a
  /// non-final state, the error indicates a system-error being retried.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// The state of the task.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "PENDING" : Specifies pending state for the task.
  /// - "RUNNING" : Specifies task is being executed.
  /// - "SUCCEEDED" : Specifies task completed successfully.
  /// - "CANCEL_PENDING" : Specifies Task cancel is in pending state.
  /// - "CANCELLING" : Specifies task is being cancelled.
  /// - "CANCELLED" : Specifies task was cancelled.
  /// - "FAILED" : Specifies task failed.
  /// - "SKIPPED" : Specifies task was skipped due to cache hit.
  /// - "NOT_TRIGGERED" : Specifies that the task was not triggered because the
  /// task's trigger policy is not satisfied. The trigger policy is specified in
  /// the `condition` field of PipelineJob.pipeline_spec.
  core.String? state;

  /// Update time of this status.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus({
    this.error,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1PipelineTaskDetailPipelineTaskStatus.fromJson(
      core.Map json_)
      : this(
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (error != null) 'error': error!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// The runtime detail of a pipeline executor.
class GoogleCloudAiplatformV1PipelineTaskExecutorDetail {
  /// The detailed info for a container executor.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail?
      containerDetail;

  /// The detailed info for a custom job executor.
  ///
  /// Output only.
  GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail?
      customJobDetail;

  GoogleCloudAiplatformV1PipelineTaskExecutorDetail({
    this.containerDetail,
    this.customJobDetail,
  });

  GoogleCloudAiplatformV1PipelineTaskExecutorDetail.fromJson(core.Map json_)
      : this(
          containerDetail: json_.containsKey('containerDetail')
              ? GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail
                  .fromJson(json_['containerDetail']
                      as core.Map<core.String, core.dynamic>)
              : null,
          customJobDetail: json_.containsKey('customJobDetail')
              ? GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail
                  .fromJson(json_['customJobDetail']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerDetail != null) 'containerDetail': containerDetail!,
        if (customJobDetail != null) 'customJobDetail': customJobDetail!,
      };
}

/// The detail of a container execution.
///
/// It contains the job names of the lifecycle of a container execution.
class GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail {
  /// The names of the previously failed CustomJob for the main container
  /// executions.
  ///
  /// The list includes the all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedMainJobs;

  /// The names of the previously failed CustomJob for the pre-caching-check
  /// container executions.
  ///
  /// This job will be available if the PipelineJob.pipeline_spec specifies the
  /// `pre_caching_check` hook in the lifecycle events. The list includes the
  /// all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedPreCachingCheckJobs;

  /// The name of the CustomJob for the main container execution.
  ///
  /// Output only.
  core.String? mainJob;

  /// The name of the CustomJob for the pre-caching-check container execution.
  ///
  /// This job will be available if the PipelineJob.pipeline_spec specifies the
  /// `pre_caching_check` hook in the lifecycle events.
  ///
  /// Output only.
  core.String? preCachingCheckJob;

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail({
    this.failedMainJobs,
    this.failedPreCachingCheckJobs,
    this.mainJob,
    this.preCachingCheckJob,
  });

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailContainerDetail.fromJson(
      core.Map json_)
      : this(
          failedMainJobs: json_.containsKey('failedMainJobs')
              ? (json_['failedMainJobs'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          failedPreCachingCheckJobs:
              json_.containsKey('failedPreCachingCheckJobs')
                  ? (json_['failedPreCachingCheckJobs'] as core.List)
                      .map((value) => value as core.String)
                      .toList()
                  : null,
          mainJob: json_.containsKey('mainJob')
              ? json_['mainJob'] as core.String
              : null,
          preCachingCheckJob: json_.containsKey('preCachingCheckJob')
              ? json_['preCachingCheckJob'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failedMainJobs != null) 'failedMainJobs': failedMainJobs!,
        if (failedPreCachingCheckJobs != null)
          'failedPreCachingCheckJobs': failedPreCachingCheckJobs!,
        if (mainJob != null) 'mainJob': mainJob!,
        if (preCachingCheckJob != null)
          'preCachingCheckJob': preCachingCheckJob!,
      };
}

/// The detailed info for a custom job executor.
class GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail {
  /// The names of the previously failed CustomJob.
  ///
  /// The list includes the all attempts in chronological order.
  ///
  /// Output only.
  core.List<core.String>? failedJobs;

  /// The name of the CustomJob.
  ///
  /// Output only.
  core.String? job;

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail({
    this.failedJobs,
    this.job,
  });

  GoogleCloudAiplatformV1PipelineTaskExecutorDetailCustomJobDetail.fromJson(
      core.Map json_)
      : this(
          failedJobs: json_.containsKey('failedJobs')
              ? (json_['failedJobs'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          job: json_.containsKey('job') ? json_['job'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (failedJobs != null) 'failedJobs': failedJobs!,
        if (job != null) 'job': job!,
      };
}

/// Pipeline template metadata if PipelineJob.template_uri is from supported
/// template registry.
///
/// Currently, the only supported registry is Artifact Registry.
class GoogleCloudAiplatformV1PipelineTemplateMetadata {
  /// The version_name in artifact registry.
  ///
  /// Will always be presented in output if the PipelineJob.template_uri is from
  /// supported template registry. Format is "sha256:abcdef123456...".
  core.String? version;

  GoogleCloudAiplatformV1PipelineTemplateMetadata({
    this.version,
  });

  GoogleCloudAiplatformV1PipelineTemplateMetadata.fromJson(core.Map json_)
      : this(
          version: json_.containsKey('version')
              ? json_['version'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (version != null) 'version': version!,
      };
}

/// Represents a network port in a container.
class GoogleCloudAiplatformV1Port {
  /// The number of the port to expose on the pod's IP address.
  ///
  /// Must be a valid port number, between 1 and 65535 inclusive.
  core.int? containerPort;

  GoogleCloudAiplatformV1Port({
    this.containerPort,
  });

  GoogleCloudAiplatformV1Port.fromJson(core.Map json_)
      : this(
          containerPort: json_.containsKey('containerPort')
              ? json_['containerPort'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerPort != null) 'containerPort': containerPort!,
      };
}

/// Assigns input data to training, validation, and test sets based on the value
/// of a provided key.
///
/// Supported only for tabular Datasets.
class GoogleCloudAiplatformV1PredefinedSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The value of the key (either the label's value or value in the column)
  /// must be one of {`training`, `validation`, `test`}, and it defines to which
  /// set the given piece of data is assigned. If for a piece of data the key is
  /// not present or has an invalid value, that piece is ignored by the
  /// pipeline.
  ///
  /// Required.
  core.String? key;

  GoogleCloudAiplatformV1PredefinedSplit({
    this.key,
  });

  GoogleCloudAiplatformV1PredefinedSplit.fromJson(core.Map json_)
      : this(
          key: json_.containsKey('key') ? json_['key'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
      };
}

/// Request message for PredictionService.Predict.
class GoogleCloudAiplatformV1PredictRequest {
  /// The instances that are the input to the prediction call.
  ///
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the prediction call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model. The schema of any single
  /// instance may be specified via Endpoint's DeployedModels' Model's
  /// PredictSchemata's instance_schema_uri.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? instances;

  /// The parameters that govern the prediction.
  ///
  /// The schema of the parameters may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's parameters_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? parameters;

  GoogleCloudAiplatformV1PredictRequest({
    this.instances,
    this.parameters,
  });

  GoogleCloudAiplatformV1PredictRequest.fromJson(core.Map json_)
      : this(
          instances: json_.containsKey('instances')
              ? json_['instances'] as core.List
              : null,
          parameters:
              json_.containsKey('parameters') ? json_['parameters'] : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instances != null) 'instances': instances!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Configuration for logging request-response to a BigQuery table.
class GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig {
  /// BigQuery table for logging.
  ///
  /// If only given a project, a new dataset will be created with name
  /// `logging__` where will be made BigQuery-dataset-name compatible (e.g. most
  /// special characters will become underscores). If no table name is given, a
  /// new table will be created with name `request_response_logging`
  GoogleCloudAiplatformV1BigQueryDestination? bigqueryDestination;

  /// If logging is enabled or not.
  core.bool? enabled;

  /// Percentage of requests to be logged, expressed as a fraction in
  /// range(0,1\].
  core.double? samplingRate;

  GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig({
    this.bigqueryDestination,
    this.enabled,
    this.samplingRate,
  });

  GoogleCloudAiplatformV1PredictRequestResponseLoggingConfig.fromJson(
      core.Map json_)
      : this(
          bigqueryDestination: json_.containsKey('bigqueryDestination')
              ? GoogleCloudAiplatformV1BigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
          enabled: json_.containsKey('enabled')
              ? json_['enabled'] as core.bool
              : null,
          samplingRate: json_.containsKey('samplingRate')
              ? (json_['samplingRate'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bigqueryDestination != null)
          'bigqueryDestination': bigqueryDestination!,
        if (enabled != null) 'enabled': enabled!,
        if (samplingRate != null) 'samplingRate': samplingRate!,
      };
}

/// Response message for PredictionService.Predict.
class GoogleCloudAiplatformV1PredictResponse {
  /// ID of the Endpoint's DeployedModel that served this prediction.
  core.String? deployedModelId;

  /// Request-level metadata returned by the model.
  ///
  /// The metadata type will be dependent upon the model implementation.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// The resource name of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? model;

  /// The display name of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? modelDisplayName;

  /// The version ID of the Model which is deployed as the DeployedModel that
  /// this prediction hits.
  ///
  /// Output only.
  core.String? modelVersionId;

  /// The predictions that are the output of the predictions call.
  ///
  /// The schema of any single prediction may be specified via Endpoint's
  /// DeployedModels' Model's PredictSchemata's prediction_schema_uri.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.List<core.Object?>? predictions;

  GoogleCloudAiplatformV1PredictResponse({
    this.deployedModelId,
    this.metadata,
    this.model,
    this.modelDisplayName,
    this.modelVersionId,
    this.predictions,
  });

  GoogleCloudAiplatformV1PredictResponse.fromJson(core.Map json_)
      : this(
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          metadata: json_.containsKey('metadata') ? json_['metadata'] : null,
          model:
              json_.containsKey('model') ? json_['model'] as core.String : null,
          modelDisplayName: json_.containsKey('modelDisplayName')
              ? json_['modelDisplayName'] as core.String
              : null,
          modelVersionId: json_.containsKey('modelVersionId')
              ? json_['modelVersionId'] as core.String
              : null,
          predictions: json_.containsKey('predictions')
              ? json_['predictions'] as core.List
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (metadata != null) 'metadata': metadata!,
        if (model != null) 'model': model!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
        if (modelVersionId != null) 'modelVersionId': modelVersionId!,
        if (predictions != null) 'predictions': predictions!,
      };
}

/// Contains the schemata used in Model's predictions and explanations via
/// PredictionService.Predict, PredictionService.Explain and BatchPredictionJob.
class GoogleCloudAiplatformV1PredictSchemata {
  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of a single instance, which are used in PredictRequest.instances,
  /// ExplainRequest.instances and BatchPredictionJob.input_config.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? instanceSchemaUri;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// parameters of prediction and explanation via PredictRequest.parameters,
  /// ExplainRequest.parameters and BatchPredictionJob.model_parameters.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// parameters are supported, then it is set to an empty string. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? parametersSchemaUri;

  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of a single prediction produced by this Model, which are returned via
  /// PredictResponse.predictions, ExplainResponse.explanations, and
  /// BatchPredictionJob.output_config.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [Schema Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Immutable.
  core.String? predictionSchemaUri;

  GoogleCloudAiplatformV1PredictSchemata({
    this.instanceSchemaUri,
    this.parametersSchemaUri,
    this.predictionSchemaUri,
  });

  GoogleCloudAiplatformV1PredictSchemata.fromJson(core.Map json_)
      : this(
          instanceSchemaUri: json_.containsKey('instanceSchemaUri')
              ? json_['instanceSchemaUri'] as core.String
              : null,
          parametersSchemaUri: json_.containsKey('parametersSchemaUri')
              ? json_['parametersSchemaUri'] as core.String
              : null,
          predictionSchemaUri: json_.containsKey('predictionSchemaUri')
              ? json_['predictionSchemaUri'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (instanceSchemaUri != null) 'instanceSchemaUri': instanceSchemaUri!,
        if (parametersSchemaUri != null)
          'parametersSchemaUri': parametersSchemaUri!,
        if (predictionSchemaUri != null)
          'predictionSchemaUri': predictionSchemaUri!,
      };
}

/// Preset configuration for example-based explanations
class GoogleCloudAiplatformV1Presets {
  /// The modality of the uploaded model, which automatically configures the
  /// distance measurement and feature normalization for the underlying example
  /// index and queries.
  ///
  /// If your model does not precisely fit one of these types, it is okay to
  /// choose the closest type.
  /// Possible string values are:
  /// - "MODALITY_UNSPECIFIED" : Should not be set. Added as a recommended best
  /// practice for enums
  /// - "IMAGE" : IMAGE modality
  /// - "TEXT" : TEXT modality
  /// - "TABULAR" : TABULAR modality
  core.String? modality;

  /// Preset option controlling parameters for speed-precision trade-off when
  /// querying for examples.
  ///
  /// If omitted, defaults to `PRECISE`.
  /// Possible string values are:
  /// - "PRECISE" : More precise neighbors as a trade-off against slower
  /// response.
  /// - "FAST" : Faster response as a trade-off against less precise neighbors.
  core.String? query;

  GoogleCloudAiplatformV1Presets({
    this.modality,
    this.query,
  });

  GoogleCloudAiplatformV1Presets.fromJson(core.Map json_)
      : this(
          modality: json_.containsKey('modality')
              ? json_['modality'] as core.String
              : null,
          query:
              json_.containsKey('query') ? json_['query'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (modality != null) 'modality': modality!,
        if (query != null) 'query': query!,
      };
}

/// PrivateEndpoints proto is used to provide paths for users to send requests
/// privately.
///
/// To send request via private service access, use predict_http_uri,
/// explain_http_uri or health_http_uri. To send request via private service
/// connect, use service_attachment.
class GoogleCloudAiplatformV1PrivateEndpoints {
  /// Http(s) path to send explain requests.
  ///
  /// Output only.
  core.String? explainHttpUri;

  /// Http(s) path to send health check requests.
  ///
  /// Output only.
  core.String? healthHttpUri;

  /// Http(s) path to send prediction requests.
  ///
  /// Output only.
  core.String? predictHttpUri;

  /// The name of the service attachment resource.
  ///
  /// Populated if private service connect is enabled.
  ///
  /// Output only.
  core.String? serviceAttachment;

  GoogleCloudAiplatformV1PrivateEndpoints({
    this.explainHttpUri,
    this.healthHttpUri,
    this.predictHttpUri,
    this.serviceAttachment,
  });

  GoogleCloudAiplatformV1PrivateEndpoints.fromJson(core.Map json_)
      : this(
          explainHttpUri: json_.containsKey('explainHttpUri')
              ? json_['explainHttpUri'] as core.String
              : null,
          healthHttpUri: json_.containsKey('healthHttpUri')
              ? json_['healthHttpUri'] as core.String
              : null,
          predictHttpUri: json_.containsKey('predictHttpUri')
              ? json_['predictHttpUri'] as core.String
              : null,
          serviceAttachment: json_.containsKey('serviceAttachment')
              ? json_['serviceAttachment'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (explainHttpUri != null) 'explainHttpUri': explainHttpUri!,
        if (healthHttpUri != null) 'healthHttpUri': healthHttpUri!,
        if (predictHttpUri != null) 'predictHttpUri': predictHttpUri!,
        if (serviceAttachment != null) 'serviceAttachment': serviceAttachment!,
      };
}

/// Represents configuration for private service connect.
class GoogleCloudAiplatformV1PrivateServiceConnectConfig {
  /// If true, expose the IndexEndpoint via private service connect.
  ///
  /// Required.
  core.bool? enablePrivateServiceConnect;

  /// A list of Projects from which the forwarding rule will target the service
  /// attachment.
  core.List<core.String>? projectAllowlist;

  GoogleCloudAiplatformV1PrivateServiceConnectConfig({
    this.enablePrivateServiceConnect,
    this.projectAllowlist,
  });

  GoogleCloudAiplatformV1PrivateServiceConnectConfig.fromJson(core.Map json_)
      : this(
          enablePrivateServiceConnect:
              json_.containsKey('enablePrivateServiceConnect')
                  ? json_['enablePrivateServiceConnect'] as core.bool
                  : null,
          projectAllowlist: json_.containsKey('projectAllowlist')
              ? (json_['projectAllowlist'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (enablePrivateServiceConnect != null)
          'enablePrivateServiceConnect': enablePrivateServiceConnect!,
        if (projectAllowlist != null) 'projectAllowlist': projectAllowlist!,
      };
}

/// A Model Garden Publisher Model.
class GoogleCloudAiplatformV1PublisherModel {
  /// Additional information about the model's Frameworks.
  ///
  /// Optional.
  core.List<core.String>? frameworks;

  /// Indicates the launch stage of the model.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "LAUNCH_STAGE_UNSPECIFIED" : The model launch stage is unspecified.
  /// - "EXPERIMENTAL" : Used to indicate the PublisherModel is at Experimental
  /// launch stage.
  /// - "PRIVATE_PREVIEW" : Used to indicate the PublisherModel is at Private
  /// Preview launch stage.
  /// - "PUBLIC_PREVIEW" : Used to indicate the PublisherModel is at Public
  /// Preview launch stage.
  /// - "GA" : Used to indicate the PublisherModel is at GA launch stage.
  core.String? launchStage;

  /// The resource name of the PublisherModel.
  ///
  /// Output only.
  core.String? name;

  /// Indicates the open source category of the publisher model.
  ///
  /// Required.
  /// Possible string values are:
  /// - "OPEN_SOURCE_CATEGORY_UNSPECIFIED" : The open source category is
  /// unspecified, which should not be used.
  /// - "PROPRIETARY" : Used to indicate the PublisherModel is not open sourced.
  /// - "GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" : Used to indicate the
  /// PublisherModel is a Google-owned open source model w/ Google checkpoint.
  /// - "THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT" : Used to indicate the
  /// PublisherModel is a 3p-owned open source model w/ Google checkpoint.
  /// - "GOOGLE_OWNED_OSS" : Used to indicate the PublisherModel is a
  /// Google-owned pure open source model.
  /// - "THIRD_PARTY_OWNED_OSS" : Used to indicate the PublisherModel is a
  /// 3p-owned pure open source model.
  core.String? openSourceCategory;

  /// The schemata that describes formats of the PublisherModel's predictions
  /// and explanations as given and returned via PredictionService.Predict.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PredictSchemata? predictSchemata;

  /// Used to indicate this model has a publisher model and provide the template
  /// of the publisher model resource name.
  ///
  /// Optional. Output only. Immutable.
  core.String? publisherModelTemplate;

  /// Supported call-to-action options.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToAction? supportedActions;

  /// The version ID of the PublisherModel.
  ///
  /// A new version is committed when a new model version is uploaded under an
  /// existing model id. It is an auto-incrementing decimal number in string
  /// representation.
  ///
  /// Output only. Immutable.
  core.String? versionId;

  GoogleCloudAiplatformV1PublisherModel({
    this.frameworks,
    this.launchStage,
    this.name,
    this.openSourceCategory,
    this.predictSchemata,
    this.publisherModelTemplate,
    this.supportedActions,
    this.versionId,
  });

  GoogleCloudAiplatformV1PublisherModel.fromJson(core.Map json_)
      : this(
          frameworks: json_.containsKey('frameworks')
              ? (json_['frameworks'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          launchStage: json_.containsKey('launchStage')
              ? json_['launchStage'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          openSourceCategory: json_.containsKey('openSourceCategory')
              ? json_['openSourceCategory'] as core.String
              : null,
          predictSchemata: json_.containsKey('predictSchemata')
              ? GoogleCloudAiplatformV1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>)
              : null,
          publisherModelTemplate: json_.containsKey('publisherModelTemplate')
              ? json_['publisherModelTemplate'] as core.String
              : null,
          supportedActions: json_.containsKey('supportedActions')
              ? GoogleCloudAiplatformV1PublisherModelCallToAction.fromJson(
                  json_['supportedActions']
                      as core.Map<core.String, core.dynamic>)
              : null,
          versionId: json_.containsKey('versionId')
              ? json_['versionId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (frameworks != null) 'frameworks': frameworks!,
        if (launchStage != null) 'launchStage': launchStage!,
        if (name != null) 'name': name!,
        if (openSourceCategory != null)
          'openSourceCategory': openSourceCategory!,
        if (predictSchemata != null) 'predictSchemata': predictSchemata!,
        if (publisherModelTemplate != null)
          'publisherModelTemplate': publisherModelTemplate!,
        if (supportedActions != null) 'supportedActions': supportedActions!,
        if (versionId != null) 'versionId': versionId!,
      };
}

/// Actions could take on this Publisher Model.
class GoogleCloudAiplatformV1PublisherModelCallToAction {
  /// Create application using the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      createApplication;

  /// Deploy the PublisherModel to Vertex Endpoint.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionDeploy? deploy;

  /// Open evaluation pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openEvaluationPipeline;

  /// Open fine-tuning pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openFineTuningPipeline;

  /// Open in Generation AI Studio.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openGenerationAiStudio;

  /// Open Genie / Playground.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openGenie;

  /// Open notebook of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openNotebook;

  /// Open prompt-tuning pipeline of the PublisherModel.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      openPromptTuningPipeline;

  /// Request for access.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences?
      requestAccess;

  /// To view Rest API docs.
  ///
  /// Optional.
  GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi? viewRestApi;

  GoogleCloudAiplatformV1PublisherModelCallToAction({
    this.createApplication,
    this.deploy,
    this.openEvaluationPipeline,
    this.openFineTuningPipeline,
    this.openGenerationAiStudio,
    this.openGenie,
    this.openNotebook,
    this.openPromptTuningPipeline,
    this.requestAccess,
    this.viewRestApi,
  });

  GoogleCloudAiplatformV1PublisherModelCallToAction.fromJson(core.Map json_)
      : this(
          createApplication: json_.containsKey('createApplication')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['createApplication']
                      as core.Map<core.String, core.dynamic>)
              : null,
          deploy: json_.containsKey('deploy')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionDeploy
                  .fromJson(
                      json_['deploy'] as core.Map<core.String, core.dynamic>)
              : null,
          openEvaluationPipeline: json_.containsKey('openEvaluationPipeline')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openEvaluationPipeline']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openFineTuningPipeline: json_.containsKey('openFineTuningPipeline')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openFineTuningPipeline']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openGenerationAiStudio: json_.containsKey('openGenerationAiStudio')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openGenerationAiStudio']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openGenie: json_.containsKey('openGenie')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(
                      json_['openGenie'] as core.Map<core.String, core.dynamic>)
              : null,
          openNotebook: json_.containsKey('openNotebook')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openNotebook']
                      as core.Map<core.String, core.dynamic>)
              : null,
          openPromptTuningPipeline: json_
                  .containsKey('openPromptTuningPipeline')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['openPromptTuningPipeline']
                      as core.Map<core.String, core.dynamic>)
              : null,
          requestAccess: json_.containsKey('requestAccess')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences
                  .fromJson(json_['requestAccess']
                      as core.Map<core.String, core.dynamic>)
              : null,
          viewRestApi: json_.containsKey('viewRestApi')
              ? GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi
                  .fromJson(json_['viewRestApi']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createApplication != null) 'createApplication': createApplication!,
        if (deploy != null) 'deploy': deploy!,
        if (openEvaluationPipeline != null)
          'openEvaluationPipeline': openEvaluationPipeline!,
        if (openFineTuningPipeline != null)
          'openFineTuningPipeline': openFineTuningPipeline!,
        if (openGenerationAiStudio != null)
          'openGenerationAiStudio': openGenerationAiStudio!,
        if (openGenie != null) 'openGenie': openGenie!,
        if (openNotebook != null) 'openNotebook': openNotebook!,
        if (openPromptTuningPipeline != null)
          'openPromptTuningPipeline': openPromptTuningPipeline!,
        if (requestAccess != null) 'requestAccess': requestAccess!,
        if (viewRestApi != null) 'viewRestApi': viewRestApi!,
      };
}

/// Model metadata that is needed for UploadModel or DeployModel/CreateEndpoint
/// requests.
class GoogleCloudAiplatformV1PublisherModelCallToActionDeploy {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  ///
  /// Optional.
  core.String? artifactUri;

  /// A description of resources that to large degree are decided by Vertex AI,
  /// and require only a modest additional configuration.
  GoogleCloudAiplatformV1AutomaticResources? automaticResources;

  /// The specification of the container that is to be used when deploying this
  /// Model in Vertex AI.
  ///
  /// Not present for Large Models.
  ///
  /// Optional.
  GoogleCloudAiplatformV1ModelContainerSpec? containerSpec;

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  GoogleCloudAiplatformV1DedicatedResources? dedicatedResources;

  /// Large model reference.
  ///
  /// When this is set, model_artifact_spec is not needed.
  ///
  /// Optional.
  GoogleCloudAiplatformV1LargeModelReference? largeModelReference;

  /// Default model display name.
  ///
  /// Optional.
  core.String? modelDisplayName;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  core.String? sharedResources;

  /// The title of the regional resource reference.
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelCallToActionDeploy({
    this.artifactUri,
    this.automaticResources,
    this.containerSpec,
    this.dedicatedResources,
    this.largeModelReference,
    this.modelDisplayName,
    this.sharedResources,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionDeploy.fromJson(
      core.Map json_)
      : this(
          artifactUri: json_.containsKey('artifactUri')
              ? json_['artifactUri'] as core.String
              : null,
          automaticResources: json_.containsKey('automaticResources')
              ? GoogleCloudAiplatformV1AutomaticResources.fromJson(
                  json_['automaticResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          dedicatedResources: json_.containsKey('dedicatedResources')
              ? GoogleCloudAiplatformV1DedicatedResources.fromJson(
                  json_['dedicatedResources']
                      as core.Map<core.String, core.dynamic>)
              : null,
          largeModelReference: json_.containsKey('largeModelReference')
              ? GoogleCloudAiplatformV1LargeModelReference.fromJson(
                  json_['largeModelReference']
                      as core.Map<core.String, core.dynamic>)
              : null,
          modelDisplayName: json_.containsKey('modelDisplayName')
              ? json_['modelDisplayName'] as core.String
              : null,
          sharedResources: json_.containsKey('sharedResources')
              ? json_['sharedResources'] as core.String
              : null,
          title:
              json_.containsKey('title') ? json_['title'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactUri != null) 'artifactUri': artifactUri!,
        if (automaticResources != null)
          'automaticResources': automaticResources!,
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (dedicatedResources != null)
          'dedicatedResources': dedicatedResources!,
        if (largeModelReference != null)
          'largeModelReference': largeModelReference!,
        if (modelDisplayName != null) 'modelDisplayName': modelDisplayName!,
        if (sharedResources != null) 'sharedResources': sharedResources!,
        if (title != null) 'title': title!,
      };
}

/// The regional resource name or the URI.
///
/// Key is region, e.g., us-central1, europe-west2, global, etc..
class GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences {
  /// Required.
  core.Map<core.String, GoogleCloudAiplatformV1PublisherModelResourceReference>?
      references;

  /// The title of the regional resource reference.
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences({
    this.references,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionRegionalResourceReferences.fromJson(
      core.Map json_)
      : this(
          references: json_.containsKey('references')
              ? (json_['references'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1PublisherModelResourceReference
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          title:
              json_.containsKey('title') ? json_['title'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (references != null) 'references': references!,
        if (title != null) 'title': title!,
      };
}

/// Rest API docs.
class GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi {
  /// Required.
  core.List<GoogleCloudAiplatformV1PublisherModelDocumentation>? documentations;

  /// The title of the view rest API.
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi({
    this.documentations,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelCallToActionViewRestApi.fromJson(
      core.Map json_)
      : this(
          documentations: json_.containsKey('documentations')
              ? (json_['documentations'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1PublisherModelDocumentation
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          title:
              json_.containsKey('title') ? json_['title'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (documentations != null) 'documentations': documentations!,
        if (title != null) 'title': title!,
      };
}

/// A named piece of documentation.
class GoogleCloudAiplatformV1PublisherModelDocumentation {
  /// Content of this piece of document (in Markdown format).
  ///
  /// Required.
  core.String? content;

  /// E.g., OVERVIEW, USE CASES, DOCUMENTATION, SDK & SAMPLES, JAVA, NODE.JS,
  /// etc..
  ///
  /// Required.
  core.String? title;

  GoogleCloudAiplatformV1PublisherModelDocumentation({
    this.content,
    this.title,
  });

  GoogleCloudAiplatformV1PublisherModelDocumentation.fromJson(core.Map json_)
      : this(
          content: json_.containsKey('content')
              ? json_['content'] as core.String
              : null,
          title:
              json_.containsKey('title') ? json_['title'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (content != null) 'content': content!,
        if (title != null) 'title': title!,
      };
}

/// Reference to a resource.
class GoogleCloudAiplatformV1PublisherModelResourceReference {
  /// The resource name of the Google Cloud resource.
  core.String? resourceName;

  /// The URI of the resource.
  core.String? uri;

  GoogleCloudAiplatformV1PublisherModelResourceReference({
    this.resourceName,
    this.uri,
  });

  GoogleCloudAiplatformV1PublisherModelResourceReference.fromJson(
      core.Map json_)
      : this(
          resourceName: json_.containsKey('resourceName')
              ? json_['resourceName'] as core.String
              : null,
          uri: json_.containsKey('uri') ? json_['uri'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (resourceName != null) 'resourceName': resourceName!,
        if (uri != null) 'uri': uri!,
      };
}

/// Request message for MetadataService.PurgeArtifacts.
class GoogleCloudAiplatformV1PurgeArtifactsRequest {
  /// A required filter matching the Artifacts to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Artifact
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  GoogleCloudAiplatformV1PurgeArtifactsRequest({
    this.filter,
    this.force,
  });

  GoogleCloudAiplatformV1PurgeArtifactsRequest.fromJson(core.Map json_)
      : this(
          filter: json_.containsKey('filter')
              ? json_['filter'] as core.String
              : null,
          force:
              json_.containsKey('force') ? json_['force'] as core.bool : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (force != null) 'force': force!,
      };
}

/// Request message for MetadataService.PurgeContexts.
class GoogleCloudAiplatformV1PurgeContextsRequest {
  /// A required filter matching the Contexts to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Context
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  GoogleCloudAiplatformV1PurgeContextsRequest({
    this.filter,
    this.force,
  });

  GoogleCloudAiplatformV1PurgeContextsRequest.fromJson(core.Map json_)
      : this(
          filter: json_.containsKey('filter')
              ? json_['filter'] as core.String
              : null,
          force:
              json_.containsKey('force') ? json_['force'] as core.bool : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (force != null) 'force': force!,
      };
}

/// Request message for MetadataService.PurgeExecutions.
class GoogleCloudAiplatformV1PurgeExecutionsRequest {
  /// A required filter matching the Executions to be purged.
  ///
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  ///
  /// Required.
  core.String? filter;

  /// Flag to indicate to actually perform the purge.
  ///
  /// If `force` is set to false, the method will return a sample of Execution
  /// names that would be deleted.
  ///
  /// Optional.
  core.bool? force;

  GoogleCloudAiplatformV1PurgeExecutionsRequest({
    this.filter,
    this.force,
  });

  GoogleCloudAiplatformV1PurgeExecutionsRequest.fromJson(core.Map json_)
      : this(
          filter: json_.containsKey('filter')
              ? json_['filter'] as core.String
              : null,
          force:
              json_.containsKey('force') ? json_['force'] as core.bool : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (force != null) 'force': force!,
      };
}

/// The spec of a Python packaged code.
class GoogleCloudAiplatformV1PythonPackageSpec {
  /// Command line arguments to be passed to the Python task.
  core.List<core.String>? args;

  /// Environment variables to be passed to the python module.
  ///
  /// Maximum limit is 100.
  core.List<GoogleCloudAiplatformV1EnvVar>? env;

  /// The URI of a container image in Artifact Registry that will run the
  /// provided Python package.
  ///
  /// Vertex AI provides a wide range of executor images with pre-installed
  /// packages to meet users' various use cases. See the list of \[pre-built
  /// containers for
  /// training\](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// You must use an image from this list.
  ///
  /// Required.
  core.String? executorImageUri;

  /// The Google Cloud Storage location of the Python package files which are
  /// the training program and its dependent packages.
  ///
  /// The maximum number of package URIs is 100.
  ///
  /// Required.
  core.List<core.String>? packageUris;

  /// The Python module name to run after installing the packages.
  ///
  /// Required.
  core.String? pythonModule;

  GoogleCloudAiplatformV1PythonPackageSpec({
    this.args,
    this.env,
    this.executorImageUri,
    this.packageUris,
    this.pythonModule,
  });

  GoogleCloudAiplatformV1PythonPackageSpec.fromJson(core.Map json_)
      : this(
          args: json_.containsKey('args')
              ? (json_['args'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          env: json_.containsKey('env')
              ? (json_['env'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1EnvVar.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          executorImageUri: json_.containsKey('executorImageUri')
              ? json_['executorImageUri'] as core.String
              : null,
          packageUris: json_.containsKey('packageUris')
              ? (json_['packageUris'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          pythonModule: json_.containsKey('pythonModule')
              ? json_['pythonModule'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (args != null) 'args': args!,
        if (env != null) 'env': env!,
        if (executorImageUri != null) 'executorImageUri': executorImageUri!,
        if (packageUris != null) 'packageUris': packageUris!,
        if (pythonModule != null) 'pythonModule': pythonModule!,
      };
}

/// Request message for PredictionService.RawPredict.
class GoogleCloudAiplatformV1RawPredictRequest {
  /// The prediction input.
  ///
  /// Supports HTTP headers and arbitrary data payload. A DeployedModel may have
  /// an upper limit on the number of instances it supports per request. When
  /// this limit it is exceeded for an AutoML model, the RawPredict method
  /// returns an error. When this limit is exceeded for a custom-trained model,
  /// the behavior varies depending on the model. You can specify the schema for
  /// each instance in the predict_schemata.instance_schema_uri field when you
  /// create a Model. This schema applies when you deploy the `Model` as a
  /// `DeployedModel` to an Endpoint and use the `RawPredict` method.
  GoogleApiHttpBody? httpBody;

  GoogleCloudAiplatformV1RawPredictRequest({
    this.httpBody,
  });

  GoogleCloudAiplatformV1RawPredictRequest.fromJson(core.Map json_)
      : this(
          httpBody: json_.containsKey('httpBody')
              ? GoogleApiHttpBody.fromJson(
                  json_['httpBody'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (httpBody != null) 'httpBody': httpBody!,
      };
}

/// Request message for FeaturestoreOnlineServingService.ReadFeatureValues.
class GoogleCloudAiplatformV1ReadFeatureValuesRequest {
  /// ID for a specific entity.
  ///
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an entity ID could be `user_123`.
  ///
  /// Required.
  core.String? entityId;

  /// Selector choosing Features of the target EntityType.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  GoogleCloudAiplatformV1ReadFeatureValuesRequest({
    this.entityId,
    this.featureSelector,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          entityId: json_.containsKey('entityId')
              ? json_['entityId'] as core.String
              : null,
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityId != null) 'entityId': entityId!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
      };
}

/// Response message for FeaturestoreOnlineServingService.ReadFeatureValues.
class GoogleCloudAiplatformV1ReadFeatureValuesResponse {
  /// Entity view with Feature values.
  ///
  /// This may be the entity in the Featurestore if values for all Features were
  /// requested, or a projection of the entity in the Featurestore if values for
  /// only some Features were requested.
  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView? entityView;

  /// Response header.
  GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader? header;

  GoogleCloudAiplatformV1ReadFeatureValuesResponse({
    this.entityView,
    this.header,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponse.fromJson(core.Map json_)
      : this(
          entityView: json_.containsKey('entityView')
              ? GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView
                  .fromJson(json_['entityView']
                      as core.Map<core.String, core.dynamic>)
              : null,
          header: json_.containsKey('header')
              ? GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader.fromJson(
                  json_['header'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityView != null) 'entityView': entityView!,
        if (header != null) 'header': header!,
      };
}

/// Entity view with Feature values.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView {
  /// Each piece of data holds the k requested values for one requested Feature.
  ///
  /// If no values for the requested Feature exist, the corresponding cell will
  /// be empty. This has the same size and is in the same order as the features
  /// from the header ReadFeatureValuesResponse.header.
  core.List<GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData>?
      data;

  /// ID of the requested entity.
  core.String? entityId;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView({
    this.data,
    this.entityId,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityView.fromJson(
      core.Map json_)
      : this(
          data: json_.containsKey('data')
              ? (json_['data'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          entityId: json_.containsKey('entityId')
              ? json_['entityId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (data != null) 'data': data!,
        if (entityId != null) 'entityId': entityId!,
      };
}

/// Container to hold value(s), successive in time, for one Feature from the
/// request.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData {
  /// Feature value if a single value is requested.
  GoogleCloudAiplatformV1FeatureValue? value;

  /// Feature values list if values, successive in time, are requested.
  ///
  /// If the requested number of values is greater than the number of existing
  /// Feature values, nonexistent values are omitted instead of being returned
  /// as empty.
  GoogleCloudAiplatformV1FeatureValueList? values;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData({
    this.value,
    this.values,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseEntityViewData.fromJson(
      core.Map json_)
      : this(
          value: json_.containsKey('value')
              ? GoogleCloudAiplatformV1FeatureValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>)
              : null,
          values: json_.containsKey('values')
              ? GoogleCloudAiplatformV1FeatureValueList.fromJson(
                  json_['values'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
        if (values != null) 'values': values!,
      };
}

/// Metadata for requested Features.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor {
  /// Feature ID.
  core.String? id;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor({
    this.id,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor.fromJson(
      core.Map json_)
      : this(
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (id != null) 'id': id!,
      };
}

/// Response header with metadata for the requested
/// ReadFeatureValuesRequest.entity_type and Features.
class GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader {
  /// The resource name of the EntityType from the ReadFeatureValuesRequest.
  ///
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  core.String? entityType;

  /// List of Feature metadata corresponding to each piece of
  /// ReadFeatureValuesResponse.EntityView.data.
  core.List<GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor>?
      featureDescriptors;

  GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader({
    this.entityType,
    this.featureDescriptors,
  });

  GoogleCloudAiplatformV1ReadFeatureValuesResponseHeader.fromJson(
      core.Map json_)
      : this(
          entityType: json_.containsKey('entityType')
              ? json_['entityType'] as core.String
              : null,
          featureDescriptors: json_.containsKey('featureDescriptors')
              ? (json_['featureDescriptors'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ReadFeatureValuesResponseFeatureDescriptor
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityType != null) 'entityType': entityType!,
        if (featureDescriptors != null)
          'featureDescriptors': featureDescriptors!,
      };
}

/// The request message for MatchService.ReadIndexDatapoints.
class GoogleCloudAiplatformV1ReadIndexDatapointsRequest {
  /// The ID of the DeployedIndex that will serve the request.
  core.String? deployedIndexId;

  /// IDs of the datapoints to be searched for.
  core.List<core.String>? ids;

  GoogleCloudAiplatformV1ReadIndexDatapointsRequest({
    this.deployedIndexId,
    this.ids,
  });

  GoogleCloudAiplatformV1ReadIndexDatapointsRequest.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_.containsKey('deployedIndexId')
              ? json_['deployedIndexId'] as core.String
              : null,
          ids: json_.containsKey('ids')
              ? (json_['ids'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
        if (ids != null) 'ids': ids!,
      };
}

/// The response message for MatchService.ReadIndexDatapoints.
class GoogleCloudAiplatformV1ReadIndexDatapointsResponse {
  /// The result list of datapoints.
  core.List<GoogleCloudAiplatformV1IndexDatapoint>? datapoints;

  GoogleCloudAiplatformV1ReadIndexDatapointsResponse({
    this.datapoints,
  });

  GoogleCloudAiplatformV1ReadIndexDatapointsResponse.fromJson(core.Map json_)
      : this(
          datapoints: json_.containsKey('datapoints')
              ? (json_['datapoints'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapoints != null) 'datapoints': datapoints!,
      };
}

/// Response message for TensorboardService.ReadTensorboardBlobData.
class GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse {
  /// Blob messages containing blob bytes.
  core.List<GoogleCloudAiplatformV1TensorboardBlob>? blobs;

  GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse({
    this.blobs,
  });

  GoogleCloudAiplatformV1ReadTensorboardBlobDataResponse.fromJson(
      core.Map json_)
      : this(
          blobs: json_.containsKey('blobs')
              ? (json_['blobs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TensorboardBlob.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blobs != null) 'blobs': blobs!,
      };
}

/// Response message for TensorboardService.ReadTensorboardSize.
class GoogleCloudAiplatformV1ReadTensorboardSizeResponse {
  /// Payload storage size for the TensorBoard
  core.String? storageSizeByte;

  GoogleCloudAiplatformV1ReadTensorboardSizeResponse({
    this.storageSizeByte,
  });

  GoogleCloudAiplatformV1ReadTensorboardSizeResponse.fromJson(core.Map json_)
      : this(
          storageSizeByte: json_.containsKey('storageSizeByte')
              ? json_['storageSizeByte'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (storageSizeByte != null) 'storageSizeByte': storageSizeByte!,
      };
}

/// Response message for TensorboardService.ReadTensorboardTimeSeriesData.
class GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse {
  /// The returned time series data.
  GoogleCloudAiplatformV1TimeSeriesData? timeSeriesData;

  GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse({
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1ReadTensorboardTimeSeriesDataResponse.fromJson(
      core.Map json_)
      : this(
          timeSeriesData: json_.containsKey('timeSeriesData')
              ? GoogleCloudAiplatformV1TimeSeriesData.fromJson(
                  json_['timeSeriesData']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
      };
}

/// Response message for TensorboardService.ReadTensorboardUsage.
class GoogleCloudAiplatformV1ReadTensorboardUsageResponse {
  /// Maps year-month (YYYYMM) string to per month usage data.
  core.Map<core.String,
          GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData>?
      monthlyUsageData;

  GoogleCloudAiplatformV1ReadTensorboardUsageResponse({
    this.monthlyUsageData,
  });

  GoogleCloudAiplatformV1ReadTensorboardUsageResponse.fromJson(core.Map json_)
      : this(
          monthlyUsageData: json_.containsKey('monthlyUsageData')
              ? (json_['monthlyUsageData']
                      as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData
                        .fromJson(value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (monthlyUsageData != null) 'monthlyUsageData': monthlyUsageData!,
      };
}

/// Per month usage data
class GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData {
  /// Usage data for each user in the given month.
  core.List<
          GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData>?
      userUsageData;

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData({
    this.userUsageData,
  });

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerMonthUsageData.fromJson(
      core.Map json_)
      : this(
          userUsageData: json_.containsKey('userUsageData')
              ? (json_['userUsageData'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (userUsageData != null) 'userUsageData': userUsageData!,
      };
}

/// Per user usage data.
class GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData {
  /// User's username
  core.String? username;

  /// Number of times the user has read data within the Tensorboard.
  core.String? viewCount;

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData({
    this.username,
    this.viewCount,
  });

  GoogleCloudAiplatformV1ReadTensorboardUsageResponsePerUserUsageData.fromJson(
      core.Map json_)
      : this(
          username: json_.containsKey('username')
              ? json_['username'] as core.String
              : null,
          viewCount: json_.containsKey('viewCount')
              ? json_['viewCount'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (username != null) 'username': username!,
        if (viewCount != null) 'viewCount': viewCount!,
      };
}

/// Request message for MetadataService.DeleteContextChildrenRequest.
typedef GoogleCloudAiplatformV1RemoveContextChildrenRequest
    = $ContextChildrenRequest;

/// Response message for MetadataService.RemoveContextChildren.
typedef GoogleCloudAiplatformV1RemoveContextChildrenResponse = $Empty;

/// Request message for IndexService.RemoveDatapoints
class GoogleCloudAiplatformV1RemoveDatapointsRequest {
  /// A list of datapoint ids to be deleted.
  core.List<core.String>? datapointIds;

  GoogleCloudAiplatformV1RemoveDatapointsRequest({
    this.datapointIds,
  });

  GoogleCloudAiplatformV1RemoveDatapointsRequest.fromJson(core.Map json_)
      : this(
          datapointIds: json_.containsKey('datapointIds')
              ? (json_['datapointIds'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapointIds != null) 'datapointIds': datapointIds!,
      };
}

/// Response message for IndexService.RemoveDatapoints
typedef GoogleCloudAiplatformV1RemoveDatapointsResponse = $Empty;

/// Statistics information about resource consumption.
class GoogleCloudAiplatformV1ResourcesConsumed {
  /// The number of replica hours used.
  ///
  /// Note that many replicas may run in parallel, and additionally any given
  /// work may be queued for some time. Therefore this value is not strictly
  /// related to wall time.
  ///
  /// Output only.
  core.double? replicaHours;

  GoogleCloudAiplatformV1ResourcesConsumed({
    this.replicaHours,
  });

  GoogleCloudAiplatformV1ResourcesConsumed.fromJson(core.Map json_)
      : this(
          replicaHours: json_.containsKey('replicaHours')
              ? (json_['replicaHours'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (replicaHours != null) 'replicaHours': replicaHours!,
      };
}

/// Request message for JobService.ResumeModelDeploymentMonitoringJob.
typedef GoogleCloudAiplatformV1ResumeModelDeploymentMonitoringJobRequest
    = $Empty;

/// Request message for ScheduleService.ResumeSchedule.
class GoogleCloudAiplatformV1ResumeScheduleRequest {
  /// Whether to backfill missed runs when the schedule is resumed from PAUSED
  /// state.
  ///
  /// If set to true, all missed runs will be scheduled. New runs will be
  /// scheduled after the backfill is complete. This will also update
  /// Schedule.catch_up field. Default to false.
  ///
  /// Optional.
  core.bool? catchUp;

  GoogleCloudAiplatformV1ResumeScheduleRequest({
    this.catchUp,
  });

  GoogleCloudAiplatformV1ResumeScheduleRequest.fromJson(core.Map json_)
      : this(
          catchUp: json_.containsKey('catchUp')
              ? json_['catchUp'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (catchUp != null) 'catchUp': catchUp!,
      };
}

/// Active learning data sampling config.
///
/// For every active learning labeling iteration, it will select a batch of data
/// based on the sampling strategy.
class GoogleCloudAiplatformV1SampleConfig {
  /// The percentage of data needed to be labeled in each following batch
  /// (except the first batch).
  core.int? followingBatchSamplePercentage;

  /// The percentage of data needed to be labeled in the first batch.
  core.int? initialBatchSamplePercentage;

  /// Field to choose sampling strategy.
  ///
  /// Sampling strategy will decide which data should be selected for human
  /// labeling in every batch.
  /// Possible string values are:
  /// - "SAMPLE_STRATEGY_UNSPECIFIED" : Default will be treated as UNCERTAINTY.
  /// - "UNCERTAINTY" : Sample the most uncertain data to label.
  core.String? sampleStrategy;

  GoogleCloudAiplatformV1SampleConfig({
    this.followingBatchSamplePercentage,
    this.initialBatchSamplePercentage,
    this.sampleStrategy,
  });

  GoogleCloudAiplatformV1SampleConfig.fromJson(core.Map json_)
      : this(
          followingBatchSamplePercentage:
              json_.containsKey('followingBatchSamplePercentage')
                  ? json_['followingBatchSamplePercentage'] as core.int
                  : null,
          initialBatchSamplePercentage:
              json_.containsKey('initialBatchSamplePercentage')
                  ? json_['initialBatchSamplePercentage'] as core.int
                  : null,
          sampleStrategy: json_.containsKey('sampleStrategy')
              ? json_['sampleStrategy'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (followingBatchSamplePercentage != null)
          'followingBatchSamplePercentage': followingBatchSamplePercentage!,
        if (initialBatchSamplePercentage != null)
          'initialBatchSamplePercentage': initialBatchSamplePercentage!,
        if (sampleStrategy != null) 'sampleStrategy': sampleStrategy!,
      };
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted.
///
/// A sampling strategy is used to approximate the value rather than considering
/// all subsets of features.
class GoogleCloudAiplatformV1SampledShapleyAttribution {
  /// The number of feature permutations to consider when approximating the
  /// Shapley values.
  ///
  /// Valid range of its value is \[1, 50\], inclusively.
  ///
  /// Required.
  core.int? pathCount;

  GoogleCloudAiplatformV1SampledShapleyAttribution({
    this.pathCount,
  });

  GoogleCloudAiplatformV1SampledShapleyAttribution.fromJson(core.Map json_)
      : this(
          pathCount: json_.containsKey('pathCount')
              ? json_['pathCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (pathCount != null) 'pathCount': pathCount!,
      };
}

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
class GoogleCloudAiplatformV1SamplingStrategy {
  /// Random sample config.
  ///
  /// Will support more sampling strategies later.
  GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig? randomSampleConfig;

  GoogleCloudAiplatformV1SamplingStrategy({
    this.randomSampleConfig,
  });

  GoogleCloudAiplatformV1SamplingStrategy.fromJson(core.Map json_)
      : this(
          randomSampleConfig: json_.containsKey('randomSampleConfig')
              ? GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig
                  .fromJson(json_['randomSampleConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (randomSampleConfig != null)
          'randomSampleConfig': randomSampleConfig!,
      };
}

/// Requests are randomly selected.
class GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig {
  /// Sample rate (0, 1\]
  core.double? sampleRate;

  GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig({
    this.sampleRate,
  });

  GoogleCloudAiplatformV1SamplingStrategyRandomSampleConfig.fromJson(
      core.Map json_)
      : this(
          sampleRate: json_.containsKey('sampleRate')
              ? (json_['sampleRate'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (sampleRate != null) 'sampleRate': sampleRate!,
      };
}

/// A SavedQuery is a view of the dataset.
///
/// It references a subset of annotations by problem type and filters.
class GoogleCloudAiplatformV1SavedQuery {
  /// Filters on the Annotations in the dataset.
  ///
  /// Output only.
  core.String? annotationFilter;

  /// Number of AnnotationSpecs in the context of the SavedQuery.
  ///
  /// Output only.
  core.int? annotationSpecCount;

  /// Timestamp when this SavedQuery was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of the SavedQuery.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write update.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Some additional information about the SavedQuery.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? metadata;

  /// Resource name of the SavedQuery.
  ///
  /// Output only.
  core.String? name;

  /// Problem type of the SavedQuery.
  ///
  /// Allowed values: * IMAGE_CLASSIFICATION_SINGLE_LABEL *
  /// IMAGE_CLASSIFICATION_MULTI_LABEL * IMAGE_BOUNDING_POLY *
  /// IMAGE_BOUNDING_BOX * TEXT_CLASSIFICATION_SINGLE_LABEL *
  /// TEXT_CLASSIFICATION_MULTI_LABEL * TEXT_EXTRACTION * TEXT_SENTIMENT *
  /// VIDEO_CLASSIFICATION * VIDEO_OBJECT_TRACKING
  ///
  /// Required.
  core.String? problemType;

  /// If the Annotations belonging to the SavedQuery can be used for AutoML
  /// training.
  ///
  /// Output only.
  core.bool? supportAutomlTraining;

  /// Timestamp when SavedQuery was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1SavedQuery({
    this.annotationFilter,
    this.annotationSpecCount,
    this.createTime,
    this.displayName,
    this.etag,
    this.metadata,
    this.name,
    this.problemType,
    this.supportAutomlTraining,
    this.updateTime,
  });

  GoogleCloudAiplatformV1SavedQuery.fromJson(core.Map json_)
      : this(
          annotationFilter: json_.containsKey('annotationFilter')
              ? json_['annotationFilter'] as core.String
              : null,
          annotationSpecCount: json_.containsKey('annotationSpecCount')
              ? json_['annotationSpecCount'] as core.int
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          metadata: json_.containsKey('metadata') ? json_['metadata'] : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          problemType: json_.containsKey('problemType')
              ? json_['problemType'] as core.String
              : null,
          supportAutomlTraining: json_.containsKey('supportAutomlTraining')
              ? json_['supportAutomlTraining'] as core.bool
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (annotationFilter != null) 'annotationFilter': annotationFilter!,
        if (annotationSpecCount != null)
          'annotationSpecCount': annotationSpecCount!,
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (problemType != null) 'problemType': problemType!,
        if (supportAutomlTraining != null)
          'supportAutomlTraining': supportAutomlTraining!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// One point viewable on a scalar metric plot.
class GoogleCloudAiplatformV1Scalar {
  /// Value of the point at this step / timestamp.
  core.double? value;

  GoogleCloudAiplatformV1Scalar({
    this.value,
  });

  GoogleCloudAiplatformV1Scalar.fromJson(core.Map json_)
      : this(
          value: json_.containsKey('value')
              ? (json_['value'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
      };
}

/// An instance of a Schedule periodically schedules runs to make API calls
/// based on user specified time specification and API request type.
class GoogleCloudAiplatformV1Schedule {
  /// Whether new scheduled runs can be queued when max_concurrent_runs limit is
  /// reached.
  ///
  /// If set to true, new runs will be queued instead of skipped. Default to
  /// false.
  ///
  /// Optional.
  core.bool? allowQueueing;

  /// Whether to backfill missed runs when the schedule is resumed from PAUSED
  /// state.
  ///
  /// If set to true, all missed runs will be scheduled. New runs will be
  /// scheduled after the backfill is complete. Default to false.
  ///
  /// Output only.
  core.bool? catchUp;

  /// Request for PipelineService.CreatePipelineJob.
  ///
  /// CreatePipelineJobRequest.parent field is required (format:
  /// projects/{project}/locations/{location}).
  GoogleCloudAiplatformV1CreatePipelineJobRequest? createPipelineJobRequest;

  /// Timestamp when this Schedule was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs.
  ///
  /// To explicitly set a timezone to the cron tab, apply a prefix in the cron
  /// tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}". The
  /// ${IANA_TIME_ZONE} may only be a valid string from IANA time zone database.
  /// For example, "CRON_TZ=America/New_York 1 * * * *", or "TZ=America/New_York
  /// 1 * * * *".
  core.String? cron;

  /// User provided name of the Schedule.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Timestamp after which no new runs can be scheduled.
  ///
  /// If specified, The schedule will be completed when either end_time is
  /// reached or when scheduled_run_count \>= max_run_count. If not specified,
  /// new runs will keep getting scheduled until this Schedule is paused or
  /// deleted. Already scheduled runs will be allowed to complete. Unset if not
  /// specified.
  ///
  /// Optional.
  core.String? endTime;

  /// Timestamp when this Schedule was last paused.
  ///
  /// Unset if never paused.
  ///
  /// Output only.
  core.String? lastPauseTime;

  /// Timestamp when this Schedule was last resumed.
  ///
  /// Unset if never resumed from pause.
  ///
  /// Output only.
  core.String? lastResumeTime;

  /// Response of the last scheduled run.
  ///
  /// This is the response for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  /// Unset if no run has been scheduled yet.
  ///
  /// Output only.
  GoogleCloudAiplatformV1ScheduleRunResponse? lastScheduledRunResponse;

  /// Maximum number of runs that can be started concurrently for this Schedule.
  ///
  /// This is the limit for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  ///
  /// Required.
  core.String? maxConcurrentRunCount;

  /// Maximum run count of the schedule.
  ///
  /// If specified, The schedule will be completed when either started_run_count
  /// \>= max_run_count or when end_time is reached. If not specified, new runs
  /// will keep getting scheduled until this Schedule is paused or deleted.
  /// Already scheduled runs will be allowed to complete. Unset if not
  /// specified.
  ///
  /// Optional.
  core.String? maxRunCount;

  /// The resource name of the Schedule.
  ///
  /// Immutable.
  core.String? name;

  /// Timestamp when this Schedule should schedule the next run.
  ///
  /// Having a next_run_time in the past means the runs are being started behind
  /// schedule.
  ///
  /// Output only.
  core.String? nextRunTime;

  /// Timestamp after which the first run can be scheduled.
  ///
  /// Default to Schedule create time if not specified.
  ///
  /// Optional.
  core.String? startTime;

  /// The number of runs started by this schedule.
  ///
  /// Output only.
  core.String? startedRunCount;

  /// The state of this Schedule.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unspecified.
  /// - "ACTIVE" : The Schedule is active. Runs are being scheduled on the
  /// user-specified timespec.
  /// - "PAUSED" : The schedule is paused. No new runs will be created until the
  /// schedule is resumed. Already started runs will be allowed to complete.
  /// - "COMPLETED" : The Schedule is completed. No new runs will be scheduled.
  /// Already started runs will be allowed to complete. Schedules in completed
  /// state cannot be paused or resumed.
  core.String? state;

  /// Timestamp when this Schedule was updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Schedule({
    this.allowQueueing,
    this.catchUp,
    this.createPipelineJobRequest,
    this.createTime,
    this.cron,
    this.displayName,
    this.endTime,
    this.lastPauseTime,
    this.lastResumeTime,
    this.lastScheduledRunResponse,
    this.maxConcurrentRunCount,
    this.maxRunCount,
    this.name,
    this.nextRunTime,
    this.startTime,
    this.startedRunCount,
    this.state,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Schedule.fromJson(core.Map json_)
      : this(
          allowQueueing: json_.containsKey('allowQueueing')
              ? json_['allowQueueing'] as core.bool
              : null,
          catchUp: json_.containsKey('catchUp')
              ? json_['catchUp'] as core.bool
              : null,
          createPipelineJobRequest:
              json_.containsKey('createPipelineJobRequest')
                  ? GoogleCloudAiplatformV1CreatePipelineJobRequest.fromJson(
                      json_['createPipelineJobRequest']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          cron: json_.containsKey('cron') ? json_['cron'] as core.String : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          lastPauseTime: json_.containsKey('lastPauseTime')
              ? json_['lastPauseTime'] as core.String
              : null,
          lastResumeTime: json_.containsKey('lastResumeTime')
              ? json_['lastResumeTime'] as core.String
              : null,
          lastScheduledRunResponse:
              json_.containsKey('lastScheduledRunResponse')
                  ? GoogleCloudAiplatformV1ScheduleRunResponse.fromJson(
                      json_['lastScheduledRunResponse']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          maxConcurrentRunCount: json_.containsKey('maxConcurrentRunCount')
              ? json_['maxConcurrentRunCount'] as core.String
              : null,
          maxRunCount: json_.containsKey('maxRunCount')
              ? json_['maxRunCount'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          nextRunTime: json_.containsKey('nextRunTime')
              ? json_['nextRunTime'] as core.String
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          startedRunCount: json_.containsKey('startedRunCount')
              ? json_['startedRunCount'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (allowQueueing != null) 'allowQueueing': allowQueueing!,
        if (catchUp != null) 'catchUp': catchUp!,
        if (createPipelineJobRequest != null)
          'createPipelineJobRequest': createPipelineJobRequest!,
        if (createTime != null) 'createTime': createTime!,
        if (cron != null) 'cron': cron!,
        if (displayName != null) 'displayName': displayName!,
        if (endTime != null) 'endTime': endTime!,
        if (lastPauseTime != null) 'lastPauseTime': lastPauseTime!,
        if (lastResumeTime != null) 'lastResumeTime': lastResumeTime!,
        if (lastScheduledRunResponse != null)
          'lastScheduledRunResponse': lastScheduledRunResponse!,
        if (maxConcurrentRunCount != null)
          'maxConcurrentRunCount': maxConcurrentRunCount!,
        if (maxRunCount != null) 'maxRunCount': maxRunCount!,
        if (name != null) 'name': name!,
        if (nextRunTime != null) 'nextRunTime': nextRunTime!,
        if (startTime != null) 'startTime': startTime!,
        if (startedRunCount != null) 'startedRunCount': startedRunCount!,
        if (state != null) 'state': state!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// Status of a scheduled run.
class GoogleCloudAiplatformV1ScheduleRunResponse {
  /// The response of the scheduled run.
  core.String? runResponse;

  /// The scheduled run time based on the user-specified schedule.
  core.String? scheduledRunTime;

  GoogleCloudAiplatformV1ScheduleRunResponse({
    this.runResponse,
    this.scheduledRunTime,
  });

  GoogleCloudAiplatformV1ScheduleRunResponse.fromJson(core.Map json_)
      : this(
          runResponse: json_.containsKey('runResponse')
              ? json_['runResponse'] as core.String
              : null,
          scheduledRunTime: json_.containsKey('scheduledRunTime')
              ? json_['scheduledRunTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (runResponse != null) 'runResponse': runResponse!,
        if (scheduledRunTime != null) 'scheduledRunTime': scheduledRunTime!,
      };
}

/// All parameters related to queuing and scheduling of custom jobs.
class GoogleCloudAiplatformV1Scheduling {
  /// Indicates if the job should retry for internal errors after the job starts
  /// running.
  ///
  /// If true, overrides `Scheduling.restart_job_on_worker_restart` to false.
  ///
  /// Optional.
  core.bool? disableRetries;

  /// Restarts the entire CustomJob if a worker gets restarted.
  ///
  /// This feature can be used by distributed training jobs that are not
  /// resilient to workers leaving and joining a job.
  core.bool? restartJobOnWorkerRestart;

  /// The maximum job running time.
  ///
  /// The default is 7 days.
  core.String? timeout;

  GoogleCloudAiplatformV1Scheduling({
    this.disableRetries,
    this.restartJobOnWorkerRestart,
    this.timeout,
  });

  GoogleCloudAiplatformV1Scheduling.fromJson(core.Map json_)
      : this(
          disableRetries: json_.containsKey('disableRetries')
              ? json_['disableRetries'] as core.bool
              : null,
          restartJobOnWorkerRestart:
              json_.containsKey('restartJobOnWorkerRestart')
                  ? json_['restartJobOnWorkerRestart'] as core.bool
                  : null,
          timeout: json_.containsKey('timeout')
              ? json_['timeout'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (disableRetries != null) 'disableRetries': disableRetries!,
        if (restartJobOnWorkerRestart != null)
          'restartJobOnWorkerRestart': restartJobOnWorkerRestart!,
        if (timeout != null) 'timeout': timeout!,
      };
}

/// Response message for DatasetService.SearchDataItems.
class GoogleCloudAiplatformV1SearchDataItemsResponse {
  /// The DataItemViews read.
  core.List<GoogleCloudAiplatformV1DataItemView>? dataItemViews;

  /// A token to retrieve next page of results.
  ///
  /// Pass to SearchDataItemsRequest.page_token to obtain that page.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchDataItemsResponse({
    this.dataItemViews,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchDataItemsResponse.fromJson(core.Map json_)
      : this(
          dataItemViews: json_.containsKey('dataItemViews')
              ? (json_['dataItemViews'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1DataItemView.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataItemViews != null) 'dataItemViews': dataItemViews!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Response message for FeaturestoreService.SearchFeatures.
class GoogleCloudAiplatformV1SearchFeaturesResponse {
  /// The Features matching the request.
  ///
  /// Fields returned: * `name` * `description` * `labels` * `create_time` *
  /// `update_time`
  core.List<GoogleCloudAiplatformV1Feature>? features;

  /// A token, which can be sent as SearchFeaturesRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchFeaturesResponse({
    this.features,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchFeaturesResponse.fromJson(core.Map json_)
      : this(
          features: json_.containsKey('features')
              ? (json_['features'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Feature.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (features != null) 'features': features!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Request message for MigrationService.SearchMigratableResources.
class GoogleCloudAiplatformV1SearchMigratableResourcesRequest {
  /// A filter for your search.
  ///
  /// You can use the following types of filters: * Resource type filters. The
  /// following strings filter for a specific type of MigratableResource: *
  /// `ml_engine_model_version:*` * `automl_model:*` * `automl_dataset:*` *
  /// `data_labeling_dataset:*` * "Migrated or not" filters. The following
  /// strings filter for resources that either have or have not already been
  /// migrated: * `last_migrate_time:*` filters for migrated resources. * `NOT
  /// last_migrate_time:*` filters for not yet migrated resources.
  core.String? filter;

  /// The standard page size.
  ///
  /// The default and maximum value is 100.
  core.int? pageSize;

  /// The standard page token.
  core.String? pageToken;

  GoogleCloudAiplatformV1SearchMigratableResourcesRequest({
    this.filter,
    this.pageSize,
    this.pageToken,
  });

  GoogleCloudAiplatformV1SearchMigratableResourcesRequest.fromJson(
      core.Map json_)
      : this(
          filter: json_.containsKey('filter')
              ? json_['filter'] as core.String
              : null,
          pageSize: json_.containsKey('pageSize')
              ? json_['pageSize'] as core.int
              : null,
          pageToken: json_.containsKey('pageToken')
              ? json_['pageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (filter != null) 'filter': filter!,
        if (pageSize != null) 'pageSize': pageSize!,
        if (pageToken != null) 'pageToken': pageToken!,
      };
}

/// Response message for MigrationService.SearchMigratableResources.
class GoogleCloudAiplatformV1SearchMigratableResourcesResponse {
  /// All migratable resources that can be migrated to the location specified in
  /// the request.
  core.List<GoogleCloudAiplatformV1MigratableResource>? migratableResources;

  /// The standard next-page token.
  ///
  /// The migratable_resources may not fill page_size in
  /// SearchMigratableResourcesRequest even when there are subsequent pages.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchMigratableResourcesResponse({
    this.migratableResources,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchMigratableResourcesResponse.fromJson(
      core.Map json_)
      : this(
          migratableResources: json_.containsKey('migratableResources')
              ? (json_['migratableResources'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1MigratableResource.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (migratableResources != null)
          'migratableResources': migratableResources!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Request message for
/// JobService.SearchModelDeploymentMonitoringStatsAnomalies.
class GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest {
  /// The DeployedModel ID of the
  /// \[ModelDeploymentMonitoringObjectiveConfig.deployed_model_id\].
  ///
  /// Required.
  core.String? deployedModelId;

  /// The latest timestamp of stats being generated.
  ///
  /// If not set, indicates feching stats till the latest possible one.
  core.String? endTime;

  /// The feature display name.
  ///
  /// If specified, only return the stats belonging to this feature. Format:
  /// ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name,
  /// example: "user_destination".
  core.String? featureDisplayName;

  /// Objectives of the stats to retrieve.
  ///
  /// Required.
  core.List<
          GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective>?
      objectives;

  /// The standard list page size.
  core.int? pageSize;

  /// A page token received from a previous
  /// JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
  core.String? pageToken;

  /// The earliest timestamp of stats being generated.
  ///
  /// If not set, indicates fetching stats till the earliest possible one.
  core.String? startTime;

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest({
    this.deployedModelId,
    this.endTime,
    this.featureDisplayName,
    this.objectives,
    this.pageSize,
    this.pageToken,
    this.startTime,
  });

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequest.fromJson(
      core.Map json_)
      : this(
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          featureDisplayName: json_.containsKey('featureDisplayName')
              ? json_['featureDisplayName'] as core.String
              : null,
          objectives: json_.containsKey('objectives')
              ? (json_['objectives'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          pageSize: json_.containsKey('pageSize')
              ? json_['pageSize'] as core.int
              : null,
          pageToken: json_.containsKey('pageToken')
              ? json_['pageToken'] as core.String
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (endTime != null) 'endTime': endTime!,
        if (featureDisplayName != null)
          'featureDisplayName': featureDisplayName!,
        if (objectives != null) 'objectives': objectives!,
        if (pageSize != null) 'pageSize': pageSize!,
        if (pageToken != null) 'pageToken': pageToken!,
        if (startTime != null) 'startTime': startTime!,
      };
}

/// Stats requested for specific objective.
class GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective {
  /// If set, all attribution scores between
  /// SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time and
  /// SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time are fetched,
  /// and page token doesn't take effect in this case.
  ///
  /// Only used to retrieve attribution score for the top Features which has the
  /// highest attribution score in the latest monitoring run.
  core.int? topFeatureCount;

  ///
  /// Possible string values are:
  /// - "MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED" : Default
  /// value, should not be set.
  /// - "RAW_FEATURE_SKEW" : Raw feature values' stats to detect skew between
  /// Training-Prediction datasets.
  /// - "RAW_FEATURE_DRIFT" : Raw feature values' stats to detect drift between
  /// Serving-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_SKEW" : Feature attribution scores to detect skew
  /// between Training-Prediction datasets.
  /// - "FEATURE_ATTRIBUTION_DRIFT" : Feature attribution scores to detect skew
  /// between Prediction datasets collected within different time windows.
  core.String? type;

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective({
    this.topFeatureCount,
    this.type,
  });

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesRequestStatsAnomaliesObjective.fromJson(
      core.Map json_)
      : this(
          topFeatureCount: json_.containsKey('topFeatureCount')
              ? json_['topFeatureCount'] as core.int
              : null,
          type: json_.containsKey('type') ? json_['type'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (topFeatureCount != null) 'topFeatureCount': topFeatureCount!,
        if (type != null) 'type': type!,
      };
}

/// Response message for
/// JobService.SearchModelDeploymentMonitoringStatsAnomalies.
class GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse {
  /// Stats retrieved for requested objectives.
  ///
  /// There are at most 1000
  /// ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats
  /// in the response.
  core.List<GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies>?
      monitoringStats;

  /// The page token that can be used by the next
  /// JobService.SearchModelDeploymentMonitoringStatsAnomalies call.
  core.String? nextPageToken;

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse({
    this.monitoringStats,
    this.nextPageToken,
  });

  GoogleCloudAiplatformV1SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
      core.Map json_)
      : this(
          monitoringStats: json_.containsKey('monitoringStats')
              ? (json_['monitoringStats'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1ModelMonitoringStatsAnomalies
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (monitoringStats != null) 'monitoringStats': monitoringStats!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// https://arxiv.org/pdf/1706.03825.pdf
class GoogleCloudAiplatformV1SmoothGradConfig {
  /// This is similar to noise_sigma, but provides additional flexibility.
  ///
  /// A separate noise sigma can be provided for each feature, which is useful
  /// if their distributions are different. No noise is added to features that
  /// are not set. If this field is unset, noise_sigma will be used for all
  /// features.
  GoogleCloudAiplatformV1FeatureNoiseSigma? featureNoiseSigma;

  /// This is a single float value and will be used to add noise to all the
  /// features.
  ///
  /// Use this field when all features are normalized to have the same
  /// distribution: scale to range \[0, 1\], \[-1, 1\] or z-scoring, where
  /// features are normalized to have 0-mean and 1-variance. Learn more about
  /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
  /// For best results the recommended value is about 10% - 20% of the standard
  /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
  /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1. If the
  /// distribution is different per feature, set feature_noise_sigma instead for
  /// each feature.
  core.double? noiseSigma;

  /// The number of gradient samples to use for approximation.
  ///
  /// The higher this number, the more accurate the gradient is, but the runtime
  /// complexity increases by this factor as well. Valid range of its value is
  /// \[1, 50\]. Defaults to 3.
  core.int? noisySampleCount;

  GoogleCloudAiplatformV1SmoothGradConfig({
    this.featureNoiseSigma,
    this.noiseSigma,
    this.noisySampleCount,
  });

  GoogleCloudAiplatformV1SmoothGradConfig.fromJson(core.Map json_)
      : this(
          featureNoiseSigma: json_.containsKey('featureNoiseSigma')
              ? GoogleCloudAiplatformV1FeatureNoiseSigma.fromJson(
                  json_['featureNoiseSigma']
                      as core.Map<core.String, core.dynamic>)
              : null,
          noiseSigma: json_.containsKey('noiseSigma')
              ? (json_['noiseSigma'] as core.num).toDouble()
              : null,
          noisySampleCount: json_.containsKey('noisySampleCount')
              ? json_['noisySampleCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (featureNoiseSigma != null) 'featureNoiseSigma': featureNoiseSigma!,
        if (noiseSigma != null) 'noiseSigma': noiseSigma!,
        if (noisySampleCount != null) 'noisySampleCount': noisySampleCount!,
      };
}

/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs.
///
/// It includes a group of specialist managers and workers. Managers are
/// responsible for managing the workers in this pool as well as customers' data
/// labeling jobs associated with this pool. Customers create specialist pool as
/// well as start data labeling jobs on Cloud, managers and workers handle the
/// jobs using CrowdCompute console.
class GoogleCloudAiplatformV1SpecialistPool {
  /// The user-defined name of the SpecialistPool.
  ///
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters. This field should be unique on project-level.
  ///
  /// Required.
  core.String? displayName;

  /// The resource name of the SpecialistPool.
  ///
  /// Required.
  core.String? name;

  /// The resource name of the pending data labeling jobs.
  ///
  /// Output only.
  core.List<core.String>? pendingDataLabelingJobs;

  /// The email addresses of the managers in the SpecialistPool.
  core.List<core.String>? specialistManagerEmails;

  /// The number of managers in this SpecialistPool.
  ///
  /// Output only.
  core.int? specialistManagersCount;

  /// The email addresses of workers in the SpecialistPool.
  core.List<core.String>? specialistWorkerEmails;

  GoogleCloudAiplatformV1SpecialistPool({
    this.displayName,
    this.name,
    this.pendingDataLabelingJobs,
    this.specialistManagerEmails,
    this.specialistManagersCount,
    this.specialistWorkerEmails,
  });

  GoogleCloudAiplatformV1SpecialistPool.fromJson(core.Map json_)
      : this(
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          pendingDataLabelingJobs: json_.containsKey('pendingDataLabelingJobs')
              ? (json_['pendingDataLabelingJobs'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          specialistManagerEmails: json_.containsKey('specialistManagerEmails')
              ? (json_['specialistManagerEmails'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          specialistManagersCount: json_.containsKey('specialistManagersCount')
              ? json_['specialistManagersCount'] as core.int
              : null,
          specialistWorkerEmails: json_.containsKey('specialistWorkerEmails')
              ? (json_['specialistWorkerEmails'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (displayName != null) 'displayName': displayName!,
        if (name != null) 'name': name!,
        if (pendingDataLabelingJobs != null)
          'pendingDataLabelingJobs': pendingDataLabelingJobs!,
        if (specialistManagerEmails != null)
          'specialistManagerEmails': specialistManagerEmails!,
        if (specialistManagersCount != null)
          'specialistManagersCount': specialistManagersCount!,
        if (specialistWorkerEmails != null)
          'specialistWorkerEmails': specialistWorkerEmails!,
      };
}

/// Request message for NotebookService.StartNotebookRuntime.
typedef GoogleCloudAiplatformV1StartNotebookRuntimeRequest = $Empty;

/// Request message for VizierService.StopTrial.
typedef GoogleCloudAiplatformV1StopTrialRequest = $Empty;

/// Assigns input data to the training, validation, and test sets so that the
/// distribution of values found in the categorical column (as specified by the
/// `key` field) is mirrored within each split.
///
/// The fraction values determine the relative sizes of the splits. For example,
/// if the specified column has three values, with 50% of the rows having value
/// "A", 25% value "B", and 25% value "C", and the split fractions are specified
/// as 80/10/10, then the training set will constitute 80% of the training data,
/// with about 50% of the training set rows having the value "A" for the
/// specified column, about 25% having the value "B", and about 25% having the
/// value "C". Only the top 500 occurring values are used; any values not in the
/// top 500 values are randomly assigned to a split. If less than three rows
/// contain a specific value, those rows are randomly assigned. Supported only
/// for tabular Datasets.
class GoogleCloudAiplatformV1StratifiedSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The key provided must be for a categorical column.
  ///
  /// Required.
  core.String? key;

  /// The fraction of the input data that is to be used to evaluate the Model.
  core.double? testFraction;

  /// The fraction of the input data that is to be used to train the Model.
  core.double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  core.double? validationFraction;

  GoogleCloudAiplatformV1StratifiedSplit({
    this.key,
    this.testFraction,
    this.trainingFraction,
    this.validationFraction,
  });

  GoogleCloudAiplatformV1StratifiedSplit.fromJson(core.Map json_)
      : this(
          key: json_.containsKey('key') ? json_['key'] as core.String : null,
          testFraction: json_.containsKey('testFraction')
              ? (json_['testFraction'] as core.num).toDouble()
              : null,
          trainingFraction: json_.containsKey('trainingFraction')
              ? (json_['trainingFraction'] as core.num).toDouble()
              : null,
          validationFraction: json_.containsKey('validationFraction')
              ? (json_['validationFraction'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (testFraction != null) 'testFraction': testFraction!,
        if (trainingFraction != null) 'trainingFraction': trainingFraction!,
        if (validationFraction != null)
          'validationFraction': validationFraction!,
      };
}

/// Request message for PredictionService.StreamingPredict.
///
/// The first message must contain endpoint field and optionally input. The
/// subsequent messages must contain input.
class GoogleCloudAiplatformV1StreamingPredictRequest {
  /// The prediction input.
  core.List<GoogleCloudAiplatformV1Tensor>? inputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1Tensor? parameters;

  GoogleCloudAiplatformV1StreamingPredictRequest({
    this.inputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1StreamingPredictRequest.fromJson(core.Map json_)
      : this(
          inputs: json_.containsKey('inputs')
              ? (json_['inputs'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (inputs != null) 'inputs': inputs!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Response message for PredictionService.StreamingPredict.
class GoogleCloudAiplatformV1StreamingPredictResponse {
  /// The prediction output.
  core.List<GoogleCloudAiplatformV1Tensor>? outputs;

  /// The parameters that govern the prediction.
  GoogleCloudAiplatformV1Tensor? parameters;

  GoogleCloudAiplatformV1StreamingPredictResponse({
    this.outputs,
    this.parameters,
  });

  GoogleCloudAiplatformV1StreamingPredictResponse.fromJson(core.Map json_)
      : this(
          outputs: json_.containsKey('outputs')
              ? (json_['outputs'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          parameters: json_.containsKey('parameters')
              ? GoogleCloudAiplatformV1Tensor.fromJson(
                  json_['parameters'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (outputs != null) 'outputs': outputs!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// Request message for
/// FeaturestoreOnlineServingService.StreamingFeatureValuesRead.
class GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest {
  /// IDs of entities to read Feature values of.
  ///
  /// The maximum number of IDs is 100. For example, for a machine learning
  /// model predicting user clicks on a website, an entity ID could be
  /// `user_123`.
  ///
  /// Required.
  core.List<core.String>? entityIds;

  /// Selector choosing Features of the target EntityType.
  ///
  /// Feature IDs will be deduplicated.
  ///
  /// Required.
  GoogleCloudAiplatformV1FeatureSelector? featureSelector;

  GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest({
    this.entityIds,
    this.featureSelector,
  });

  GoogleCloudAiplatformV1StreamingReadFeatureValuesRequest.fromJson(
      core.Map json_)
      : this(
          entityIds: json_.containsKey('entityIds')
              ? (json_['entityIds'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          featureSelector: json_.containsKey('featureSelector')
              ? GoogleCloudAiplatformV1FeatureSelector.fromJson(
                  json_['featureSelector']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityIds != null) 'entityIds': entityIds!,
        if (featureSelector != null) 'featureSelector': featureSelector!,
      };
}

/// A list of string values.
class GoogleCloudAiplatformV1StringArray {
  /// A list of string values.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StringArray({
    this.values,
  });

  GoogleCloudAiplatformV1StringArray.fromJson(core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// A message representing a Study.
///
/// Next id: 12
class GoogleCloudAiplatformV1Study {
  /// Time at which the study was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Describes the Study, default value is empty string.
  ///
  /// Required.
  core.String? displayName;

  /// A human readable reason why the Study is inactive.
  ///
  /// This should be empty if a study is ACTIVE or COMPLETED.
  ///
  /// Output only.
  core.String? inactiveReason;

  /// The name of a study.
  ///
  /// The study's globally unique identifier. Format:
  /// `projects/{project}/locations/{location}/studies/{study}`
  ///
  /// Output only.
  core.String? name;

  /// The detailed state of a Study.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The study state is unspecified.
  /// - "ACTIVE" : The study is active.
  /// - "INACTIVE" : The study is stopped due to an internal error.
  /// - "COMPLETED" : The study is done when the service exhausts the parameter
  /// search space or max_trial_count is reached.
  core.String? state;

  /// Configuration of the Study.
  ///
  /// Required.
  GoogleCloudAiplatformV1StudySpec? studySpec;

  GoogleCloudAiplatformV1Study({
    this.createTime,
    this.displayName,
    this.inactiveReason,
    this.name,
    this.state,
    this.studySpec,
  });

  GoogleCloudAiplatformV1Study.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          inactiveReason: json_.containsKey('inactiveReason')
              ? json_['inactiveReason'] as core.String
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          studySpec: json_.containsKey('studySpec')
              ? GoogleCloudAiplatformV1StudySpec.fromJson(
                  json_['studySpec'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (inactiveReason != null) 'inactiveReason': inactiveReason!,
        if (name != null) 'name': name!,
        if (state != null) 'state': state!,
        if (studySpec != null) 'studySpec': studySpec!,
      };
}

/// Represents specification of a Study.
class GoogleCloudAiplatformV1StudySpec {
  /// The search algorithm specified for the Study.
  /// Possible string values are:
  /// - "ALGORITHM_UNSPECIFIED" : The default algorithm used by Vertex AI for
  /// [hyperparameter tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
  /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
  /// - "GRID_SEARCH" : Simple grid search within the feasible space. To use
  /// grid search, all parameters must be `INTEGER`, `CATEGORICAL`, or
  /// `DISCRETE`.
  /// - "RANDOM_SEARCH" : Simple random search within the feasible space.
  core.String? algorithm;

  /// The automated early stopping spec using convex stopping rule.
  GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec?
      convexAutomatedStoppingSpec;

  /// The automated early stopping spec using decay curve rule.
  GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec?
      decayCurveStoppingSpec;

  /// Describe which measurement selection type will be used
  /// Possible string values are:
  /// - "MEASUREMENT_SELECTION_TYPE_UNSPECIFIED" : Will be treated as
  /// LAST_MEASUREMENT.
  /// - "LAST_MEASUREMENT" : Use the last measurement reported.
  /// - "BEST_MEASUREMENT" : Use the best measurement reported.
  core.String? measurementSelectionType;

  /// The automated early stopping spec using median rule.
  GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec?
      medianAutomatedStoppingSpec;

  /// Metric specs for the Study.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1StudySpecMetricSpec>? metrics;

  /// The observation noise level of the study.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  /// Possible string values are:
  /// - "OBSERVATION_NOISE_UNSPECIFIED" : The default noise level chosen by
  /// Vertex AI.
  /// - "LOW" : Vertex AI assumes that the objective function is (nearly)
  /// perfectly reproducible, and will never repeat the same Trial parameters.
  /// - "HIGH" : Vertex AI will estimate the amount of noise in metric
  /// evaluations, it may repeat the same Trial parameters more than once.
  core.String? observationNoise;

  /// The set of parameters to tune.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1StudySpecParameterSpec>? parameters;

  /// Conditions for automated stopping of a Study.
  ///
  /// Enable automated stopping by configuring at least one condition.
  GoogleCloudAiplatformV1StudySpecStudyStoppingConfig? studyStoppingConfig;

  GoogleCloudAiplatformV1StudySpec({
    this.algorithm,
    this.convexAutomatedStoppingSpec,
    this.decayCurveStoppingSpec,
    this.measurementSelectionType,
    this.medianAutomatedStoppingSpec,
    this.metrics,
    this.observationNoise,
    this.parameters,
    this.studyStoppingConfig,
  });

  GoogleCloudAiplatformV1StudySpec.fromJson(core.Map json_)
      : this(
          algorithm: json_.containsKey('algorithm')
              ? json_['algorithm'] as core.String
              : null,
          convexAutomatedStoppingSpec:
              json_.containsKey('convexAutomatedStoppingSpec')
                  ? GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec
                      .fromJson(json_['convexAutomatedStoppingSpec']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          decayCurveStoppingSpec: json_.containsKey('decayCurveStoppingSpec')
              ? GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec
                  .fromJson(json_['decayCurveStoppingSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          measurementSelectionType:
              json_.containsKey('measurementSelectionType')
                  ? json_['measurementSelectionType'] as core.String
                  : null,
          medianAutomatedStoppingSpec:
              json_.containsKey('medianAutomatedStoppingSpec')
                  ? GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec
                      .fromJson(json_['medianAutomatedStoppingSpec']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          metrics: json_.containsKey('metrics')
              ? (json_['metrics'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1StudySpecMetricSpec.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          observationNoise: json_.containsKey('observationNoise')
              ? json_['observationNoise'] as core.String
              : null,
          parameters: json_.containsKey('parameters')
              ? (json_['parameters'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1StudySpecParameterSpec.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          studyStoppingConfig: json_.containsKey('studyStoppingConfig')
              ? GoogleCloudAiplatformV1StudySpecStudyStoppingConfig.fromJson(
                  json_['studyStoppingConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (algorithm != null) 'algorithm': algorithm!,
        if (convexAutomatedStoppingSpec != null)
          'convexAutomatedStoppingSpec': convexAutomatedStoppingSpec!,
        if (decayCurveStoppingSpec != null)
          'decayCurveStoppingSpec': decayCurveStoppingSpec!,
        if (measurementSelectionType != null)
          'measurementSelectionType': measurementSelectionType!,
        if (medianAutomatedStoppingSpec != null)
          'medianAutomatedStoppingSpec': medianAutomatedStoppingSpec!,
        if (metrics != null) 'metrics': metrics!,
        if (observationNoise != null) 'observationNoise': observationNoise!,
        if (parameters != null) 'parameters': parameters!,
        if (studyStoppingConfig != null)
          'studyStoppingConfig': studyStoppingConfig!,
      };
}

/// Configuration for ConvexAutomatedStoppingSpec.
///
/// When there are enough completed trials (configured by
/// min_measurement_count), for pending trials with enough measurements and
/// steps, the policy first computes an overestimate of the objective value at
/// max_num_steps according to the slope of the incomplete objective value
/// curve. No prediction can be made if the curve is completely flat. If the
/// overestimation is worse than the best objective value of the completed
/// trials, this pending trial will be early-stopped, but a last measurement
/// will be added to the pending trial with max_num_steps and predicted
/// objective value from the autoregression model.
class GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec {
  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate.
  ///
  /// Leave it blank if learning rate is not in a parameter in tuning. The
  /// learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  core.String? learningRateParameterName;

  /// Steps used in predicting the final objective for early stopped trials.
  ///
  /// In general, it's set to be the same as the defined steps in training /
  /// tuning. If not defined, it will learn it from the completed trials. When
  /// use_steps is false, this field is set to the maximum elapsed seconds.
  core.String? maxStepCount;

  /// The minimal number of measurements in a Trial.
  ///
  /// Early-stopping checks will not trigger if less than
  /// min_measurement_count+1 completed trials or pending trials with less than
  /// min_measurement_count measurements. If not defined, the default value is
  /// 5.
  core.String? minMeasurementCount;

  /// Minimum number of steps for a trial to complete.
  ///
  /// Trials which do not have a measurement with step_count \> min_step_count
  /// won't be considered for early stopping. It's ok to set it to 0, and a
  /// trial can be early stopped at any stage. By default, min_step_count is set
  /// to be one-tenth of the max_step_count. When use_elapsed_duration is true,
  /// this field is set to the minimum elapsed seconds.
  core.String? minStepCount;

  /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
  /// to be early stopped using a newly trained auto-regressive model.
  ///
  /// When this flag is set to True, all stopped trials from the beginning are
  /// potentially updated in terms of their `final_measurement`. Also, note that
  /// the training logic of autoregressive models is different in this case.
  /// Enabling this option has shown better results and this may be the default
  /// option in the future.
  core.bool? updateAllStoppedTrials;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps.
  ///
  /// If use_elapsed_duration==false, the early stopping decision is made
  /// according to the predicted objective values according to the target steps.
  /// If use_elapsed_duration==true, elapsed_secs is used instead of steps.
  /// Also, in this case, the parameters max_num_steps and min_num_steps are
  /// overloaded to contain max_elapsed_seconds and min_elapsed_seconds.
  core.bool? useElapsedDuration;

  GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec({
    this.learningRateParameterName,
    this.maxStepCount,
    this.minMeasurementCount,
    this.minStepCount,
    this.updateAllStoppedTrials,
    this.useElapsedDuration,
  });

  GoogleCloudAiplatformV1StudySpecConvexAutomatedStoppingSpec.fromJson(
      core.Map json_)
      : this(
          learningRateParameterName:
              json_.containsKey('learningRateParameterName')
                  ? json_['learningRateParameterName'] as core.String
                  : null,
          maxStepCount: json_.containsKey('maxStepCount')
              ? json_['maxStepCount'] as core.String
              : null,
          minMeasurementCount: json_.containsKey('minMeasurementCount')
              ? json_['minMeasurementCount'] as core.String
              : null,
          minStepCount: json_.containsKey('minStepCount')
              ? json_['minStepCount'] as core.String
              : null,
          updateAllStoppedTrials: json_.containsKey('updateAllStoppedTrials')
              ? json_['updateAllStoppedTrials'] as core.bool
              : null,
          useElapsedDuration: json_.containsKey('useElapsedDuration')
              ? json_['useElapsedDuration'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (learningRateParameterName != null)
          'learningRateParameterName': learningRateParameterName!,
        if (maxStepCount != null) 'maxStepCount': maxStepCount!,
        if (minMeasurementCount != null)
          'minMeasurementCount': minMeasurementCount!,
        if (minStepCount != null) 'minStepCount': minStepCount!,
        if (updateAllStoppedTrials != null)
          'updateAllStoppedTrials': updateAllStoppedTrials!,
        if (useElapsedDuration != null)
          'useElapsedDuration': useElapsedDuration!,
      };
}

/// The decay curve automated stopping rule builds a Gaussian Process Regressor
/// to predict the final objective value of a Trial based on the already
/// completed Trials and the intermediate measurements of the current Trial.
///
/// Early stopping is requested for the current Trial if there is very low
/// probability to exceed the optimal value found so far.
class GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec {
  /// True if Measurement.elapsed_duration is used as the x-axis of each Trials
  /// Decay Curve.
  ///
  /// Otherwise, Measurement.step_count will be used as the x-axis.
  core.bool? useElapsedDuration;

  GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec({
    this.useElapsedDuration,
  });

  GoogleCloudAiplatformV1StudySpecDecayCurveAutomatedStoppingSpec.fromJson(
      core.Map json_)
      : this(
          useElapsedDuration: json_.containsKey('useElapsedDuration')
              ? json_['useElapsedDuration'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useElapsedDuration != null)
          'useElapsedDuration': useElapsedDuration!,
      };
}

/// The median automated stopping rule stops a pending Trial if the Trial's best
/// objective_value is strictly below the median 'performance' of all completed
/// Trials reported up to the Trial's last measurement.
///
/// Currently, 'performance' refers to the running average of the objective
/// values reported by the Trial in each measurement.
class GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec {
  /// True if median automated stopping rule applies on
  /// Measurement.elapsed_duration.
  ///
  /// It means that elapsed_duration field of latest measurement of current
  /// Trial is used to compute median objective value for each completed Trials.
  core.bool? useElapsedDuration;

  GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec({
    this.useElapsedDuration,
  });

  GoogleCloudAiplatformV1StudySpecMedianAutomatedStoppingSpec.fromJson(
      core.Map json_)
      : this(
          useElapsedDuration: json_.containsKey('useElapsedDuration')
              ? json_['useElapsedDuration'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (useElapsedDuration != null)
          'useElapsedDuration': useElapsedDuration!,
      };
}

/// Represents a metric to optimize.
class GoogleCloudAiplatformV1StudySpecMetricSpec {
  /// The optimization goal of the metric.
  ///
  /// Required.
  /// Possible string values are:
  /// - "GOAL_TYPE_UNSPECIFIED" : Goal Type will default to maximize.
  /// - "MAXIMIZE" : Maximize the goal metric.
  /// - "MINIMIZE" : Minimize the goal metric.
  core.String? goal;

  /// The ID of the metric.
  ///
  /// Must not contain whitespaces and must be unique amongst all MetricSpecs.
  ///
  /// Required.
  core.String? metricId;

  /// Used for safe search.
  ///
  /// In the case, the metric will be a safety metric. You must provide a
  /// separate metric for objective metric.
  GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig? safetyConfig;

  GoogleCloudAiplatformV1StudySpecMetricSpec({
    this.goal,
    this.metricId,
    this.safetyConfig,
  });

  GoogleCloudAiplatformV1StudySpecMetricSpec.fromJson(core.Map json_)
      : this(
          goal: json_.containsKey('goal') ? json_['goal'] as core.String : null,
          metricId: json_.containsKey('metricId')
              ? json_['metricId'] as core.String
              : null,
          safetyConfig: json_.containsKey('safetyConfig')
              ? GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig
                  .fromJson(json_['safetyConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (goal != null) 'goal': goal!,
        if (metricId != null) 'metricId': metricId!,
        if (safetyConfig != null) 'safetyConfig': safetyConfig!,
      };
}

/// Used in safe optimization to specify threshold levels and risk tolerance.
class GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig {
  /// Desired minimum fraction of safe trials (over total number of trials) that
  /// should be targeted by the algorithm at any time during the study (best
  /// effort).
  ///
  /// This should be between 0.0 and 1.0 and a value of 0.0 means that there is
  /// no minimum and an algorithm proceeds without targeting any specific
  /// fraction. A value of 1.0 means that the algorithm attempts to only Suggest
  /// safe Trials.
  core.double? desiredMinSafeTrialsFraction;

  /// Safety threshold (boundary value between safe and unsafe).
  ///
  /// NOTE that if you leave SafetyMetricConfig unset, a default value of 0 will
  /// be used.
  core.double? safetyThreshold;

  GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig({
    this.desiredMinSafeTrialsFraction,
    this.safetyThreshold,
  });

  GoogleCloudAiplatformV1StudySpecMetricSpecSafetyMetricConfig.fromJson(
      core.Map json_)
      : this(
          desiredMinSafeTrialsFraction: json_
                  .containsKey('desiredMinSafeTrialsFraction')
              ? (json_['desiredMinSafeTrialsFraction'] as core.num).toDouble()
              : null,
          safetyThreshold: json_.containsKey('safetyThreshold')
              ? (json_['safetyThreshold'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (desiredMinSafeTrialsFraction != null)
          'desiredMinSafeTrialsFraction': desiredMinSafeTrialsFraction!,
        if (safetyThreshold != null) 'safetyThreshold': safetyThreshold!,
      };
}

/// Represents a single parameter to optimize.
class GoogleCloudAiplatformV1StudySpecParameterSpec {
  /// The value spec for a 'CATEGORICAL' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec?
      categoricalValueSpec;

  /// A conditional parameter node is active if the parameter's value matches
  /// the conditional node's parent_value_condition.
  ///
  /// If two items in conditional_parameter_specs have the same name, they must
  /// have disjoint parent_value_condition.
  core.List<
          GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec>?
      conditionalParameterSpecs;

  /// The value spec for a 'DISCRETE' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec?
      discreteValueSpec;

  /// The value spec for a 'DOUBLE' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec? doubleValueSpec;

  /// The value spec for an 'INTEGER' parameter.
  GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec?
      integerValueSpec;

  /// The ID of the parameter.
  ///
  /// Must not contain whitespaces and must be unique amongst all
  /// ParameterSpecs.
  ///
  /// Required.
  core.String? parameterId;

  /// How the parameter should be scaled.
  ///
  /// Leave unset for `CATEGORICAL` parameters.
  /// Possible string values are:
  /// - "SCALE_TYPE_UNSPECIFIED" : By default, no scaling is applied.
  /// - "UNIT_LINEAR_SCALE" : Scales the feasible space to (0, 1) linearly.
  /// - "UNIT_LOG_SCALE" : Scales the feasible space logarithmically to (0, 1).
  /// The entire feasible space must be strictly positive.
  /// - "UNIT_REVERSE_LOG_SCALE" : Scales the feasible space "reverse"
  /// logarithmically to (0, 1). The result is that values close to the top of
  /// the feasible space are spread out more than points near the bottom. The
  /// entire feasible space must be strictly positive.
  core.String? scaleType;

  GoogleCloudAiplatformV1StudySpecParameterSpec({
    this.categoricalValueSpec,
    this.conditionalParameterSpecs,
    this.discreteValueSpec,
    this.doubleValueSpec,
    this.integerValueSpec,
    this.parameterId,
    this.scaleType,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpec.fromJson(core.Map json_)
      : this(
          categoricalValueSpec: json_.containsKey('categoricalValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec
                  .fromJson(json_['categoricalValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          conditionalParameterSpecs: json_
                  .containsKey('conditionalParameterSpecs')
              ? (json_['conditionalParameterSpecs'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          discreteValueSpec: json_.containsKey('discreteValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec
                  .fromJson(json_['discreteValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          doubleValueSpec: json_.containsKey('doubleValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec
                  .fromJson(json_['doubleValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          integerValueSpec: json_.containsKey('integerValueSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec
                  .fromJson(json_['integerValueSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          parameterId: json_.containsKey('parameterId')
              ? json_['parameterId'] as core.String
              : null,
          scaleType: json_.containsKey('scaleType')
              ? json_['scaleType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (categoricalValueSpec != null)
          'categoricalValueSpec': categoricalValueSpec!,
        if (conditionalParameterSpecs != null)
          'conditionalParameterSpecs': conditionalParameterSpecs!,
        if (discreteValueSpec != null) 'discreteValueSpec': discreteValueSpec!,
        if (doubleValueSpec != null) 'doubleValueSpec': doubleValueSpec!,
        if (integerValueSpec != null) 'integerValueSpec': integerValueSpec!,
        if (parameterId != null) 'parameterId': parameterId!,
        if (scaleType != null) 'scaleType': scaleType!,
      };
}

/// Value specification for a parameter in `CATEGORICAL` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec {
  /// A default value for a `CATEGORICAL` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.String? defaultValue;

  /// The list of possible categories.
  ///
  /// Required.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec({
    this.defaultValue,
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecCategoricalValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: json_.containsKey('defaultValue')
              ? json_['defaultValue'] as core.String
              : null,
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (values != null) 'values': values!,
      };
}

/// Represents a parameter spec with condition from its parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec {
  /// The spec for a conditional parameter.
  ///
  /// Required.
  GoogleCloudAiplatformV1StudySpecParameterSpec? parameterSpec;

  /// The spec for matching values from a parent parameter of `CATEGORICAL`
  /// type.
  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition?
      parentCategoricalValues;

  /// The spec for matching values from a parent parameter of `DISCRETE` type.
  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition?
      parentDiscreteValues;

  /// The spec for matching values from a parent parameter of `INTEGER` type.
  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition?
      parentIntValues;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec({
    this.parameterSpec,
    this.parentCategoricalValues,
    this.parentDiscreteValues,
    this.parentIntValues,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpec.fromJson(
      core.Map json_)
      : this(
          parameterSpec: json_.containsKey('parameterSpec')
              ? GoogleCloudAiplatformV1StudySpecParameterSpec.fromJson(
                  json_['parameterSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          parentCategoricalValues: json_.containsKey('parentCategoricalValues')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition
                  .fromJson(json_['parentCategoricalValues']
                      as core.Map<core.String, core.dynamic>)
              : null,
          parentDiscreteValues: json_.containsKey('parentDiscreteValues')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition
                  .fromJson(json_['parentDiscreteValues']
                      as core.Map<core.String, core.dynamic>)
              : null,
          parentIntValues: json_.containsKey('parentIntValues')
              ? GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition
                  .fromJson(json_['parentIntValues']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parameterSpec != null) 'parameterSpec': parameterSpec!,
        if (parentCategoricalValues != null)
          'parentCategoricalValues': parentCategoricalValues!,
        if (parentDiscreteValues != null)
          'parentDiscreteValues': parentDiscreteValues!,
        if (parentIntValues != null) 'parentIntValues': parentIntValues!,
      };
}

/// Represents the spec to match categorical values from parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition {
  /// Matches values of the parent parameter of 'CATEGORICAL' type.
  ///
  /// All values must exist in `categorical_value_spec` of parent parameter.
  ///
  /// Required.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition({
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecCategoricalValueCondition.fromJson(
      core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Represents the spec to match discrete values from parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition {
  /// Matches values of the parent parameter of 'DISCRETE' type.
  ///
  /// All values must exist in `discrete_value_spec` of parent parameter. The
  /// Epsilon of the value matching is 1e-10.
  ///
  /// Required.
  core.List<core.double>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition({
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecDiscreteValueCondition.fromJson(
      core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => (value as core.num).toDouble())
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Represents the spec to match integer values from parent parameter.
class GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition {
  /// Matches values of the parent parameter of 'INTEGER' type.
  ///
  /// All values must lie in `integer_value_spec` of parent parameter.
  ///
  /// Required.
  core.List<core.String>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition({
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecConditionalParameterSpecIntValueCondition.fromJson(
      core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// Value specification for a parameter in `DISCRETE` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec {
  /// A default value for a `DISCRETE` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. It
  /// automatically rounds to the nearest feasible discrete point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.double? defaultValue;

  /// A list of possible values.
  ///
  /// The list should be in increasing order and at least 1e-10 apart. For
  /// instance, this parameter might have possible settings of 1.5, 2.5, and
  /// 4.0. This list should not contain more than 1,000 values.
  ///
  /// Required.
  core.List<core.double>? values;

  GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec({
    this.defaultValue,
    this.values,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecDiscreteValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: json_.containsKey('defaultValue')
              ? (json_['defaultValue'] as core.num).toDouble()
              : null,
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) => (value as core.num).toDouble())
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (values != null) 'values': values!,
      };
}

/// Value specification for a parameter in `DOUBLE` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec {
  /// A default value for a `DOUBLE` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.double? defaultValue;

  /// Inclusive maximum value of the parameter.
  ///
  /// Required.
  core.double? maxValue;

  /// Inclusive minimum value of the parameter.
  ///
  /// Required.
  core.double? minValue;

  GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec({
    this.defaultValue,
    this.maxValue,
    this.minValue,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecDoubleValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: json_.containsKey('defaultValue')
              ? (json_['defaultValue'] as core.num).toDouble()
              : null,
          maxValue: json_.containsKey('maxValue')
              ? (json_['maxValue'] as core.num).toDouble()
              : null,
          minValue: json_.containsKey('minValue')
              ? (json_['minValue'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (maxValue != null) 'maxValue': maxValue!,
        if (minValue != null) 'minValue': minValue!,
      };
}

/// Value specification for a parameter in `INTEGER` type.
class GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec {
  /// A default value for an `INTEGER` parameter that is assumed to be a
  /// relatively good starting point.
  ///
  /// Unset value signals that there is no offered starting point. Currently
  /// only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  core.String? defaultValue;

  /// Inclusive maximum value of the parameter.
  ///
  /// Required.
  core.String? maxValue;

  /// Inclusive minimum value of the parameter.
  ///
  /// Required.
  core.String? minValue;

  GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec({
    this.defaultValue,
    this.maxValue,
    this.minValue,
  });

  GoogleCloudAiplatformV1StudySpecParameterSpecIntegerValueSpec.fromJson(
      core.Map json_)
      : this(
          defaultValue: json_.containsKey('defaultValue')
              ? json_['defaultValue'] as core.String
              : null,
          maxValue: json_.containsKey('maxValue')
              ? json_['maxValue'] as core.String
              : null,
          minValue: json_.containsKey('minValue')
              ? json_['minValue'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (defaultValue != null) 'defaultValue': defaultValue!,
        if (maxValue != null) 'maxValue': maxValue!,
        if (minValue != null) 'minValue': minValue!,
      };
}

/// The configuration (stopping conditions) for automated stopping of a Study.
///
/// Conditions include trial budgets, time budgets, and convergence detection.
class GoogleCloudAiplatformV1StudySpecStudyStoppingConfig {
  /// If the objective value has not improved for this much time, stop the
  /// study.
  ///
  /// WARNING: Effective only for single-objective studies.
  core.String? maxDurationNoProgress;

  /// If there are more than this many trials, stop the study.
  core.int? maxNumTrials;

  /// If the objective value has not improved for this many consecutive trials,
  /// stop the study.
  ///
  /// WARNING: Effective only for single-objective studies.
  core.int? maxNumTrialsNoProgress;

  /// If the specified time or duration has passed, stop the study.
  GoogleCloudAiplatformV1StudyTimeConstraint? maximumRuntimeConstraint;

  /// If there are fewer than this many COMPLETED trials, do not stop the study.
  core.int? minNumTrials;

  /// Each "stopping rule" in this proto specifies an "if" condition.
  ///
  /// Before Vizier would generate a new suggestion, it first checks each
  /// specified stopping rule, from top to bottom in this list. Note that the
  /// first few rules (e.g. minimum_runtime_constraint, min_num_trials) will
  /// prevent other stopping rules from being evaluated until they are met. For
  /// example, setting `min_num_trials=5` and `always_stop_after= 1 hour` means
  /// that the Study will ONLY stop after it has 5 COMPLETED trials, even if
  /// more than an hour has passed since its creation. It follows the first
  /// applicable rule (whose "if" condition is satisfied) to make a stopping
  /// decision. If none of the specified rules are applicable, then Vizier
  /// decides that the study should not stop. If Vizier decides that the study
  /// should stop, the study enters STOPPING state (or STOPPING_ASAP if
  /// should_stop_asap = true). IMPORTANT: The automatic study state transition
  /// happens precisely as described above; that is, deleting trials or updating
  /// StudyConfig NEVER automatically moves the study state back to ACTIVE. If
  /// you want to _resume_ a Study that was stopped, 1) change the stopping
  /// conditions if necessary, 2) activate the study, and then 3) ask for
  /// suggestions. If the specified time or duration has not passed, do not stop
  /// the study.
  GoogleCloudAiplatformV1StudyTimeConstraint? minimumRuntimeConstraint;

  /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
  /// STOPPING state.
  ///
  /// The bottom line is: set to true if you want to interrupt on-going
  /// evaluations of Trials as soon as the study stopping condition is met.
  /// (Please see Study.State documentation for the source of truth).
  core.bool? shouldStopAsap;

  GoogleCloudAiplatformV1StudySpecStudyStoppingConfig({
    this.maxDurationNoProgress,
    this.maxNumTrials,
    this.maxNumTrialsNoProgress,
    this.maximumRuntimeConstraint,
    this.minNumTrials,
    this.minimumRuntimeConstraint,
    this.shouldStopAsap,
  });

  GoogleCloudAiplatformV1StudySpecStudyStoppingConfig.fromJson(core.Map json_)
      : this(
          maxDurationNoProgress: json_.containsKey('maxDurationNoProgress')
              ? json_['maxDurationNoProgress'] as core.String
              : null,
          maxNumTrials: json_.containsKey('maxNumTrials')
              ? json_['maxNumTrials'] as core.int
              : null,
          maxNumTrialsNoProgress: json_.containsKey('maxNumTrialsNoProgress')
              ? json_['maxNumTrialsNoProgress'] as core.int
              : null,
          maximumRuntimeConstraint:
              json_.containsKey('maximumRuntimeConstraint')
                  ? GoogleCloudAiplatformV1StudyTimeConstraint.fromJson(
                      json_['maximumRuntimeConstraint']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          minNumTrials: json_.containsKey('minNumTrials')
              ? json_['minNumTrials'] as core.int
              : null,
          minimumRuntimeConstraint:
              json_.containsKey('minimumRuntimeConstraint')
                  ? GoogleCloudAiplatformV1StudyTimeConstraint.fromJson(
                      json_['minimumRuntimeConstraint']
                          as core.Map<core.String, core.dynamic>)
                  : null,
          shouldStopAsap: json_.containsKey('shouldStopAsap')
              ? json_['shouldStopAsap'] as core.bool
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxDurationNoProgress != null)
          'maxDurationNoProgress': maxDurationNoProgress!,
        if (maxNumTrials != null) 'maxNumTrials': maxNumTrials!,
        if (maxNumTrialsNoProgress != null)
          'maxNumTrialsNoProgress': maxNumTrialsNoProgress!,
        if (maximumRuntimeConstraint != null)
          'maximumRuntimeConstraint': maximumRuntimeConstraint!,
        if (minNumTrials != null) 'minNumTrials': minNumTrials!,
        if (minimumRuntimeConstraint != null)
          'minimumRuntimeConstraint': minimumRuntimeConstraint!,
        if (shouldStopAsap != null) 'shouldStopAsap': shouldStopAsap!,
      };
}

/// Time-based Constraint for Study
class GoogleCloudAiplatformV1StudyTimeConstraint {
  /// Compares the wallclock time to this time.
  ///
  /// Must use UTC timezone.
  core.String? endTime;

  /// Counts the wallclock time passed since the creation of this Study.
  core.String? maxDuration;

  GoogleCloudAiplatformV1StudyTimeConstraint({
    this.endTime,
    this.maxDuration,
  });

  GoogleCloudAiplatformV1StudyTimeConstraint.fromJson(core.Map json_)
      : this(
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          maxDuration: json_.containsKey('maxDuration')
              ? json_['maxDuration'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (endTime != null) 'endTime': endTime!,
        if (maxDuration != null) 'maxDuration': maxDuration!,
      };
}

/// Request message for VizierService.SuggestTrials.
class GoogleCloudAiplatformV1SuggestTrialsRequest {
  /// The identifier of the client that is requesting the suggestion.
  ///
  /// If multiple SuggestTrialsRequests have the same `client_id`, the service
  /// will return the identical suggested Trial if the Trial is pending, and
  /// provide a new Trial if the last suggested Trial was completed.
  ///
  /// Required.
  core.String? clientId;

  /// This allows you to specify the "context" for a Trial; a context is a slice
  /// (a subspace) of the search space.
  ///
  /// Typical uses for contexts: 1) You are using Vizier to tune a server for
  /// best performance, but there's a strong weekly cycle. The context specifies
  /// the day-of-week. This allows Tuesday to generalize from Wednesday without
  /// assuming that everything is identical. 2) Imagine you're optimizing some
  /// medical treatment for people. As they walk in the door, you know certain
  /// facts about them (e.g. sex, weight, height, blood-pressure). Put that
  /// information in the context, and Vizier will adapt its suggestions to the
  /// patient. 3) You want to do a fair A/B test efficiently. Specify the "A"
  /// and "B" conditions as contexts, and Vizier will generalize between "A" and
  /// "B" conditions. If they are similar, this will allow Vizier to converge to
  /// the optimum faster than if "A" and "B" were separate Studies. NOTE: You
  /// can also enter contexts as REQUESTED Trials, e.g. via the CreateTrial()
  /// RPC; that's the asynchronous option where you don't need a close
  /// association between contexts and suggestions. NOTE: All the Parameters you
  /// set in a context MUST be defined in the Study. NOTE: You must supply 0 or
  /// $suggestion_count contexts. If you don't supply any contexts, Vizier will
  /// make suggestions from the full search space specified in the StudySpec; if
  /// you supply a full set of context, each suggestion will match the
  /// corresponding context. NOTE: A Context with no features set matches
  /// anything, and allows suggestions from the full search space. NOTE:
  /// Contexts MUST lie within the search space specified in the StudySpec. It's
  /// an error if they don't. NOTE: Contexts preferentially match ACTIVE then
  /// REQUESTED trials before new suggestions are generated. NOTE: Generation of
  /// suggestions involves a match between a Context and (optionally) a
  /// REQUESTED trial; if that match is not fully specified, a suggestion will
  /// be geneated in the merged subspace.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1TrialContext>? contexts;

  /// The number of suggestions requested.
  ///
  /// It must be positive.
  ///
  /// Required.
  core.int? suggestionCount;

  GoogleCloudAiplatformV1SuggestTrialsRequest({
    this.clientId,
    this.contexts,
    this.suggestionCount,
  });

  GoogleCloudAiplatformV1SuggestTrialsRequest.fromJson(core.Map json_)
      : this(
          clientId: json_.containsKey('clientId')
              ? json_['clientId'] as core.String
              : null,
          contexts: json_.containsKey('contexts')
              ? (json_['contexts'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1TrialContext.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          suggestionCount: json_.containsKey('suggestionCount')
              ? json_['suggestionCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientId != null) 'clientId': clientId!,
        if (contexts != null) 'contexts': contexts!,
        if (suggestionCount != null) 'suggestionCount': suggestionCount!,
      };
}

/// The storage details for TFRecord output content.
class GoogleCloudAiplatformV1TFRecordDestination {
  /// Google Cloud Storage location.
  ///
  /// Required.
  GoogleCloudAiplatformV1GcsDestination? gcsDestination;

  GoogleCloudAiplatformV1TFRecordDestination({
    this.gcsDestination,
  });

  GoogleCloudAiplatformV1TFRecordDestination.fromJson(core.Map json_)
      : this(
          gcsDestination: json_.containsKey('gcsDestination')
              ? GoogleCloudAiplatformV1GcsDestination.fromJson(
                  json_['gcsDestination']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (gcsDestination != null) 'gcsDestination': gcsDestination!,
      };
}

/// A tensor value type.
class GoogleCloudAiplatformV1Tensor {
  /// Type specific representations that make it easy to create tensor protos in
  /// all languages.
  ///
  /// Only the representation corresponding to "dtype" can be set. The values
  /// hold the flattened representation of the tensor in row major order. BOOL
  core.List<core.bool>? boolVal;

  /// STRING
  core.List<core.String>? bytesVal;

  /// DOUBLE
  core.List<core.double>? doubleVal;

  /// The data type of tensor.
  /// Possible string values are:
  /// - "DATA_TYPE_UNSPECIFIED" : Not a legal value for DataType. Used to
  /// indicate a DataType field has not been set.
  /// - "BOOL" : Data types that all computation devices are expected to be
  /// capable to support.
  /// - "STRING"
  /// - "FLOAT"
  /// - "DOUBLE"
  /// - "INT8"
  /// - "INT16"
  /// - "INT32"
  /// - "INT64"
  /// - "UINT8"
  /// - "UINT16"
  /// - "UINT32"
  /// - "UINT64"
  core.String? dtype;

  /// FLOAT
  core.List<core.double>? floatVal;

  /// INT64
  core.List<core.String>? int64Val;

  /// INT_8 INT_16 INT_32
  core.List<core.int>? intVal;

  /// A list of tensor values.
  core.List<GoogleCloudAiplatformV1Tensor>? listVal;

  /// Shape of the tensor.
  core.List<core.String>? shape;

  /// STRING
  core.List<core.String>? stringVal;

  /// A map of string to tensor.
  core.Map<core.String, GoogleCloudAiplatformV1Tensor>? structVal;

  /// Serialized raw tensor content.
  core.String? tensorVal;
  core.List<core.int> get tensorValAsBytes => convert.base64.decode(tensorVal!);

  set tensorValAsBytes(core.List<core.int> bytes_) {
    tensorVal =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// UINT64
  core.List<core.String>? uint64Val;

  /// UINT8 UINT16 UINT32
  core.List<core.int>? uintVal;

  GoogleCloudAiplatformV1Tensor({
    this.boolVal,
    this.bytesVal,
    this.doubleVal,
    this.dtype,
    this.floatVal,
    this.int64Val,
    this.intVal,
    this.listVal,
    this.shape,
    this.stringVal,
    this.structVal,
    this.tensorVal,
    this.uint64Val,
    this.uintVal,
  });

  GoogleCloudAiplatformV1Tensor.fromJson(core.Map json_)
      : this(
          boolVal: json_.containsKey('boolVal')
              ? (json_['boolVal'] as core.List)
                  .map((value) => value as core.bool)
                  .toList()
              : null,
          bytesVal: json_.containsKey('bytesVal')
              ? (json_['bytesVal'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          doubleVal: json_.containsKey('doubleVal')
              ? (json_['doubleVal'] as core.List)
                  .map((value) => (value as core.num).toDouble())
                  .toList()
              : null,
          dtype:
              json_.containsKey('dtype') ? json_['dtype'] as core.String : null,
          floatVal: json_.containsKey('floatVal')
              ? (json_['floatVal'] as core.List)
                  .map((value) => (value as core.num).toDouble())
                  .toList()
              : null,
          int64Val: json_.containsKey('int64Val')
              ? (json_['int64Val'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          intVal: json_.containsKey('intVal')
              ? (json_['intVal'] as core.List)
                  .map((value) => value as core.int)
                  .toList()
              : null,
          listVal: json_.containsKey('listVal')
              ? (json_['listVal'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Tensor.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          shape: json_.containsKey('shape')
              ? (json_['shape'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          stringVal: json_.containsKey('stringVal')
              ? (json_['stringVal'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          structVal: json_.containsKey('structVal')
              ? (json_['structVal'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1Tensor.fromJson(
                        value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
          tensorVal: json_.containsKey('tensorVal')
              ? json_['tensorVal'] as core.String
              : null,
          uint64Val: json_.containsKey('uint64Val')
              ? (json_['uint64Val'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          uintVal: json_.containsKey('uintVal')
              ? (json_['uintVal'] as core.List)
                  .map((value) => value as core.int)
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (boolVal != null) 'boolVal': boolVal!,
        if (bytesVal != null) 'bytesVal': bytesVal!,
        if (doubleVal != null) 'doubleVal': doubleVal!,
        if (dtype != null) 'dtype': dtype!,
        if (floatVal != null) 'floatVal': floatVal!,
        if (int64Val != null) 'int64Val': int64Val!,
        if (intVal != null) 'intVal': intVal!,
        if (listVal != null) 'listVal': listVal!,
        if (shape != null) 'shape': shape!,
        if (stringVal != null) 'stringVal': stringVal!,
        if (structVal != null) 'structVal': structVal!,
        if (tensorVal != null) 'tensorVal': tensorVal!,
        if (uint64Val != null) 'uint64Val': uint64Val!,
        if (uintVal != null) 'uintVal': uintVal!,
      };
}

/// Tensorboard is a physical database that stores users' training metrics.
///
/// A default Tensorboard is provided in each region of a Google Cloud project.
/// If needed users can also create extra Tensorboards in their projects.
class GoogleCloudAiplatformV1Tensorboard {
  /// Consumer project Cloud Storage path prefix used to store blob data, which
  /// can either be a bucket or directory.
  ///
  /// Does not end with a '/'.
  ///
  /// Output only.
  core.String? blobStoragePathPrefix;

  /// Timestamp when this Tensorboard was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this Tensorboard.
  core.String? description;

  /// User provided name of this Tensorboard.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a Tensorboard.
  ///
  /// If set, this Tensorboard and all sub-resources of this Tensorboard will be
  /// secured by this key.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Used to indicate if the TensorBoard instance is the default one.
  ///
  /// Each project & region can have at most one default TensorBoard instance.
  /// Creation of a default TensorBoard instance and updating an existing
  /// TensorBoard instance to be default will mark all other TensorBoard
  /// instances (if any) as non default.
  core.bool? isDefault;

  /// The labels with user-defined metadata to organize your Tensorboards.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Tensorboard (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// "aiplatform.googleapis.com/" and are immutable.
  core.Map<core.String, core.String>? labels;

  /// Name of the Tensorboard.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  ///
  /// Output only.
  core.String? name;

  /// The number of Runs stored in this Tensorboard.
  ///
  /// Output only.
  core.int? runCount;

  /// Timestamp when this Tensorboard was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1Tensorboard({
    this.blobStoragePathPrefix,
    this.createTime,
    this.description,
    this.displayName,
    this.encryptionSpec,
    this.etag,
    this.isDefault,
    this.labels,
    this.name,
    this.runCount,
    this.updateTime,
  });

  GoogleCloudAiplatformV1Tensorboard.fromJson(core.Map json_)
      : this(
          blobStoragePathPrefix: json_.containsKey('blobStoragePathPrefix')
              ? json_['blobStoragePathPrefix'] as core.String
              : null,
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          isDefault: json_.containsKey('isDefault')
              ? json_['isDefault'] as core.bool
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          runCount: json_.containsKey('runCount')
              ? json_['runCount'] as core.int
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blobStoragePathPrefix != null)
          'blobStoragePathPrefix': blobStoragePathPrefix!,
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (etag != null) 'etag': etag!,
        if (isDefault != null) 'isDefault': isDefault!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (runCount != null) 'runCount': runCount!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// One blob (e.g, image, graph) viewable on a blob metric plot.
class GoogleCloudAiplatformV1TensorboardBlob {
  /// The bytes of the blob is not present unless it's returned by the
  /// ReadTensorboardBlobData endpoint.
  ///
  /// Optional.
  core.String? data;
  core.List<core.int> get dataAsBytes => convert.base64.decode(data!);

  set dataAsBytes(core.List<core.int> bytes_) {
    data =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// A URI safe key uniquely identifying a blob.
  ///
  /// Can be used to locate the blob stored in the Cloud Storage bucket of the
  /// consumer project.
  ///
  /// Output only.
  core.String? id;

  GoogleCloudAiplatformV1TensorboardBlob({
    this.data,
    this.id,
  });

  GoogleCloudAiplatformV1TensorboardBlob.fromJson(core.Map json_)
      : this(
          data: json_.containsKey('data') ? json_['data'] as core.String : null,
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (data != null) 'data': data!,
        if (id != null) 'id': id!,
      };
}

/// One point viewable on a blob metric plot, but mostly just a wrapper message
/// to work around repeated fields can't be used directly within `oneof` fields.
class GoogleCloudAiplatformV1TensorboardBlobSequence {
  /// List of blobs contained within the sequence.
  core.List<GoogleCloudAiplatformV1TensorboardBlob>? values;

  GoogleCloudAiplatformV1TensorboardBlobSequence({
    this.values,
  });

  GoogleCloudAiplatformV1TensorboardBlobSequence.fromJson(core.Map json_)
      : this(
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TensorboardBlob.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (values != null) 'values': values!,
      };
}

/// A TensorboardExperiment is a group of TensorboardRuns, that are typically
/// the results of a training job run, in a Tensorboard.
class GoogleCloudAiplatformV1TensorboardExperiment {
  /// Timestamp when this TensorboardExperiment was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardExperiment.
  core.String? description;

  /// User provided name of this TensorboardExperiment.
  core.String? displayName;

  /// Used to perform consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your
  /// TensorboardExperiment.
  ///
  /// Label keys and values cannot be longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. No more than
  /// 64 user labels can be associated with one Dataset (System labels are
  /// excluded). See https://goo.gl/xmQnxf for more information and examples of
  /// labels. System reserved label keys are prefixed with
  /// `aiplatform.googleapis.com/` and are immutable. The following system
  /// labels exist for each Dataset: *
  /// `aiplatform.googleapis.com/dataset_metadata_schema`: output only. Its
  /// value is the metadata_schema's title.
  core.Map<core.String, core.String>? labels;

  /// Name of the TensorboardExperiment.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  ///
  /// Output only.
  core.String? name;

  /// Source of the TensorboardExperiment.
  ///
  /// Example: a custom training job.
  ///
  /// Immutable.
  core.String? source;

  /// Timestamp when this TensorboardExperiment was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1TensorboardExperiment({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.name,
    this.source,
    this.updateTime,
  });

  GoogleCloudAiplatformV1TensorboardExperiment.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          source: json_.containsKey('source')
              ? json_['source'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (source != null) 'source': source!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// TensorboardRun maps to a specific execution of a training job with a given
/// set of hyperparameter values, model definition, dataset, etc
class GoogleCloudAiplatformV1TensorboardRun {
  /// Timestamp when this TensorboardRun was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardRun.
  core.String? description;

  /// User provided name of this TensorboardRun.
  ///
  /// This value must be unique among all TensorboardRuns belonging to the same
  /// parent TensorboardExperiment.
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// The labels with user-defined metadata to organize your TensorboardRuns.
  ///
  /// This field will be used to filter and visualize Runs in the Tensorboard
  /// UI. For example, a Vertex AI training job can set a label
  /// aiplatform.googleapis.com/training_job_id=xxxxx to all the runs created
  /// within that job. An end user can set a label experiment_id=xxxxx for all
  /// the runs produced in a Jupyter notebook. These runs can be grouped by a
  /// label value and visualized together in the Tensorboard UI. Label keys and
  /// values can be no longer than 64 characters (Unicode codepoints), can only
  /// contain lowercase letters, numeric characters, underscores and dashes.
  /// International characters are allowed. No more than 64 user labels can be
  /// associated with one TensorboardRun (System labels are excluded). See
  /// https://goo.gl/xmQnxf for more information and examples of labels. System
  /// reserved label keys are prefixed with "aiplatform.googleapis.com/" and are
  /// immutable.
  core.Map<core.String, core.String>? labels;

  /// Name of the TensorboardRun.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Output only.
  core.String? name;

  /// Timestamp when this TensorboardRun was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1TensorboardRun({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.labels,
    this.name,
    this.updateTime,
  });

  GoogleCloudAiplatformV1TensorboardRun.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (labels != null) 'labels': labels!,
        if (name != null) 'name': name!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// One point viewable on a tensor metric plot.
class GoogleCloudAiplatformV1TensorboardTensor {
  /// Serialized form of
  /// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/tensor.proto
  ///
  /// Required.
  core.String? value;
  core.List<core.int> get valueAsBytes => convert.base64.decode(value!);

  set valueAsBytes(core.List<core.int> bytes_) {
    value =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Version number of TensorProto used to serialize value.
  ///
  /// Optional.
  core.int? versionNumber;

  GoogleCloudAiplatformV1TensorboardTensor({
    this.value,
    this.versionNumber,
  });

  GoogleCloudAiplatformV1TensorboardTensor.fromJson(core.Map json_)
      : this(
          value:
              json_.containsKey('value') ? json_['value'] as core.String : null,
          versionNumber: json_.containsKey('versionNumber')
              ? json_['versionNumber'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
        if (versionNumber != null) 'versionNumber': versionNumber!,
      };
}

/// TensorboardTimeSeries maps to times series produced in training runs
class GoogleCloudAiplatformV1TensorboardTimeSeries {
  /// Timestamp when this TensorboardTimeSeries was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Description of this TensorboardTimeSeries.
  core.String? description;

  /// User provided name of this TensorboardTimeSeries.
  ///
  /// This value should be unique among all TensorboardTimeSeries resources
  /// belonging to the same TensorboardRun resource (parent resource).
  ///
  /// Required.
  core.String? displayName;

  /// Used to perform a consistent read-modify-write updates.
  ///
  /// If not set, a blind "overwrite" update happens.
  core.String? etag;

  /// Scalar, Tensor, or Blob metadata for this TensorboardTimeSeries.
  ///
  /// Output only.
  GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata? metadata;

  /// Name of the TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? name;

  /// Data of the current plugin, with the size limited to 65KB.
  core.String? pluginData;
  core.List<core.int> get pluginDataAsBytes =>
      convert.base64.decode(pluginData!);

  set pluginDataAsBytes(core.List<core.int> bytes_) {
    pluginData =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Name of the plugin this time series pertain to.
  ///
  /// Such as Scalar, Tensor, Blob
  ///
  /// Immutable.
  core.String? pluginName;

  /// Timestamp when this TensorboardTimeSeries was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  /// Type of TensorboardTimeSeries value.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "SCALAR" : Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  /// - "TENSOR" : Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  /// - "BLOB_SEQUENCE" : Used for TensorboardTimeSeries that is a list of blob
  /// sequences. E.g. set of sample images with labels over epochs/time.
  core.String? valueType;

  GoogleCloudAiplatformV1TensorboardTimeSeries({
    this.createTime,
    this.description,
    this.displayName,
    this.etag,
    this.metadata,
    this.name,
    this.pluginData,
    this.pluginName,
    this.updateTime,
    this.valueType,
  });

  GoogleCloudAiplatformV1TensorboardTimeSeries.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          metadata: json_.containsKey('metadata')
              ? GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          pluginData: json_.containsKey('pluginData')
              ? json_['pluginData'] as core.String
              : null,
          pluginName: json_.containsKey('pluginName')
              ? json_['pluginName'] as core.String
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
          valueType: json_.containsKey('valueType')
              ? json_['valueType'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (description != null) 'description': description!,
        if (displayName != null) 'displayName': displayName!,
        if (etag != null) 'etag': etag!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (pluginData != null) 'pluginData': pluginData!,
        if (pluginName != null) 'pluginName': pluginName!,
        if (updateTime != null) 'updateTime': updateTime!,
        if (valueType != null) 'valueType': valueType!,
      };
}

/// Describes metadata for a TensorboardTimeSeries.
class GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata {
  /// The largest blob sequence length (number of blobs) of all data points in
  /// this time series, if its ValueType is BLOB_SEQUENCE.
  ///
  /// Output only.
  core.String? maxBlobSequenceLength;

  /// Max step index of all data points within a TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? maxStep;

  /// Max wall clock timestamp of all data points within a
  /// TensorboardTimeSeries.
  ///
  /// Output only.
  core.String? maxWallTime;

  GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata({
    this.maxBlobSequenceLength,
    this.maxStep,
    this.maxWallTime,
  });

  GoogleCloudAiplatformV1TensorboardTimeSeriesMetadata.fromJson(core.Map json_)
      : this(
          maxBlobSequenceLength: json_.containsKey('maxBlobSequenceLength')
              ? json_['maxBlobSequenceLength'] as core.String
              : null,
          maxStep: json_.containsKey('maxStep')
              ? json_['maxStep'] as core.String
              : null,
          maxWallTime: json_.containsKey('maxWallTime')
              ? json_['maxWallTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (maxBlobSequenceLength != null)
          'maxBlobSequenceLength': maxBlobSequenceLength!,
        if (maxStep != null) 'maxStep': maxStep!,
        if (maxWallTime != null) 'maxWallTime': maxWallTime!,
      };
}

/// The config for feature monitoring threshold.
class GoogleCloudAiplatformV1ThresholdConfig {
  /// Specify a threshold value that can trigger the alert.
  ///
  /// If this threshold config is for feature distribution distance: 1. For
  /// categorical feature, the distribution distance is calculated by
  /// L-inifinity norm. 2. For numerical feature, the distribution distance is
  /// calculated by Jensen–Shannon divergence. Each feature must have a non-zero
  /// threshold if they need to be monitored. Otherwise no alert will be
  /// triggered for that feature.
  core.double? value;

  GoogleCloudAiplatformV1ThresholdConfig({
    this.value,
  });

  GoogleCloudAiplatformV1ThresholdConfig.fromJson(core.Map json_)
      : this(
          value: json_.containsKey('value')
              ? (json_['value'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (value != null) 'value': value!,
      };
}

/// All the data stored in a TensorboardTimeSeries.
class GoogleCloudAiplatformV1TimeSeriesData {
  /// The ID of the TensorboardTimeSeries, which will become the final component
  /// of the TensorboardTimeSeries' resource name
  ///
  /// Required.
  core.String? tensorboardTimeSeriesId;

  /// The value type of this time series.
  ///
  /// All the values in this time series data must match this value type.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : The value type is unspecified.
  /// - "SCALAR" : Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  /// - "TENSOR" : Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  /// - "BLOB_SEQUENCE" : Used for TensorboardTimeSeries that is a list of blob
  /// sequences. E.g. set of sample images with labels over epochs/time.
  core.String? valueType;

  /// Data points in this time series.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TimeSeriesDataPoint>? values;

  GoogleCloudAiplatformV1TimeSeriesData({
    this.tensorboardTimeSeriesId,
    this.valueType,
    this.values,
  });

  GoogleCloudAiplatformV1TimeSeriesData.fromJson(core.Map json_)
      : this(
          tensorboardTimeSeriesId: json_.containsKey('tensorboardTimeSeriesId')
              ? json_['tensorboardTimeSeriesId'] as core.String
              : null,
          valueType: json_.containsKey('valueType')
              ? json_['valueType'] as core.String
              : null,
          values: json_.containsKey('values')
              ? (json_['values'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TimeSeriesDataPoint.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardTimeSeriesId != null)
          'tensorboardTimeSeriesId': tensorboardTimeSeriesId!,
        if (valueType != null) 'valueType': valueType!,
        if (values != null) 'values': values!,
      };
}

/// A TensorboardTimeSeries data point.
class GoogleCloudAiplatformV1TimeSeriesDataPoint {
  /// A blob sequence value.
  GoogleCloudAiplatformV1TensorboardBlobSequence? blobs;

  /// A scalar value.
  GoogleCloudAiplatformV1Scalar? scalar;

  /// Step index of this data point within the run.
  core.String? step;

  /// A tensor value.
  GoogleCloudAiplatformV1TensorboardTensor? tensor;

  /// Wall clock timestamp when this data point is generated by the end user.
  core.String? wallTime;

  GoogleCloudAiplatformV1TimeSeriesDataPoint({
    this.blobs,
    this.scalar,
    this.step,
    this.tensor,
    this.wallTime,
  });

  GoogleCloudAiplatformV1TimeSeriesDataPoint.fromJson(core.Map json_)
      : this(
          blobs: json_.containsKey('blobs')
              ? GoogleCloudAiplatformV1TensorboardBlobSequence.fromJson(
                  json_['blobs'] as core.Map<core.String, core.dynamic>)
              : null,
          scalar: json_.containsKey('scalar')
              ? GoogleCloudAiplatformV1Scalar.fromJson(
                  json_['scalar'] as core.Map<core.String, core.dynamic>)
              : null,
          step: json_.containsKey('step') ? json_['step'] as core.String : null,
          tensor: json_.containsKey('tensor')
              ? GoogleCloudAiplatformV1TensorboardTensor.fromJson(
                  json_['tensor'] as core.Map<core.String, core.dynamic>)
              : null,
          wallTime: json_.containsKey('wallTime')
              ? json_['wallTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blobs != null) 'blobs': blobs!,
        if (scalar != null) 'scalar': scalar!,
        if (step != null) 'step': step!,
        if (tensor != null) 'tensor': tensor!,
        if (wallTime != null) 'wallTime': wallTime!,
      };
}

/// Assigns input data to training, validation, and test sets based on a
/// provided timestamps.
///
/// The youngest data pieces are assigned to training set, next to validation
/// set, and the oldest to the test set. Supported only for tabular Datasets.
class GoogleCloudAiplatformV1TimestampSplit {
  /// The key is a name of one of the Dataset's data columns.
  ///
  /// The values of the key (the values in the column) must be in RFC 3339
  /// `date-time` format, where `time-offset` = `"Z"` (e.g.
  /// 1985-04-12T23:20:50.52Z). If for a piece of data the key is not present or
  /// has an invalid value, that piece is ignored by the pipeline.
  ///
  /// Required.
  core.String? key;

  /// The fraction of the input data that is to be used to evaluate the Model.
  core.double? testFraction;

  /// The fraction of the input data that is to be used to train the Model.
  core.double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  core.double? validationFraction;

  GoogleCloudAiplatformV1TimestampSplit({
    this.key,
    this.testFraction,
    this.trainingFraction,
    this.validationFraction,
  });

  GoogleCloudAiplatformV1TimestampSplit.fromJson(core.Map json_)
      : this(
          key: json_.containsKey('key') ? json_['key'] as core.String : null,
          testFraction: json_.containsKey('testFraction')
              ? (json_['testFraction'] as core.num).toDouble()
              : null,
          trainingFraction: json_.containsKey('trainingFraction')
              ? (json_['trainingFraction'] as core.num).toDouble()
              : null,
          validationFraction: json_.containsKey('validationFraction')
              ? (json_['validationFraction'] as core.num).toDouble()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (key != null) 'key': key!,
        if (testFraction != null) 'testFraction': testFraction!,
        if (trainingFraction != null) 'trainingFraction': trainingFraction!,
        if (validationFraction != null)
          'validationFraction': validationFraction!,
      };
}

/// CMLE training config.
///
/// For every active learning labeling iteration, system will train a machine
/// learning model on CMLE. The trained model will be used by data sampling
/// algorithm to select DataItems.
class GoogleCloudAiplatformV1TrainingConfig {
  /// The timeout hours for the CMLE training job, expressed in milli hours i.e.
  /// 1,000 value in this field means 1 hour.
  core.String? timeoutTrainingMilliHours;

  GoogleCloudAiplatformV1TrainingConfig({
    this.timeoutTrainingMilliHours,
  });

  GoogleCloudAiplatformV1TrainingConfig.fromJson(core.Map json_)
      : this(
          timeoutTrainingMilliHours:
              json_.containsKey('timeoutTrainingMilliHours')
                  ? json_['timeoutTrainingMilliHours'] as core.String
                  : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (timeoutTrainingMilliHours != null)
          'timeoutTrainingMilliHours': timeoutTrainingMilliHours!,
      };
}

/// The TrainingPipeline orchestrates tasks associated with training a Model.
///
/// It always executes the training task, and optionally may also export data
/// from Vertex AI's Dataset which becomes the training input, upload the Model
/// to Vertex AI, and evaluate the Model.
class GoogleCloudAiplatformV1TrainingPipeline {
  /// Time when the TrainingPipeline was created.
  ///
  /// Output only.
  core.String? createTime;

  /// The user-defined name of this TrainingPipeline.
  ///
  /// Required.
  core.String? displayName;

  /// Customer-managed encryption key spec for a TrainingPipeline.
  ///
  /// If set, this TrainingPipeline will be secured by this key. Note: Model
  /// trained by this TrainingPipeline is also secured by this key if
  /// model_to_upload is not set separately.
  GoogleCloudAiplatformV1EncryptionSpec? encryptionSpec;

  /// Time when the TrainingPipeline entered any of the following states:
  /// `PIPELINE_STATE_SUCCEEDED`, `PIPELINE_STATE_FAILED`,
  /// `PIPELINE_STATE_CANCELLED`.
  ///
  /// Output only.
  core.String? endTime;

  /// Only populated when the pipeline's state is `PIPELINE_STATE_FAILED` or
  /// `PIPELINE_STATE_CANCELLED`.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// Specifies Vertex AI owned input data that may be used for training the
  /// Model.
  ///
  /// The TrainingPipeline's training_task_definition should make clear whether
  /// this config is used and if there are any special requirements on how it
  /// should be filled. If nothing about this config is mentioned in the
  /// training_task_definition, then it should be assumed that the
  /// TrainingPipeline does not depend on this configuration.
  GoogleCloudAiplatformV1InputDataConfig? inputDataConfig;

  /// The labels with user-defined metadata to organize TrainingPipelines.
  ///
  /// Label keys and values can be no longer than 64 characters (Unicode
  /// codepoints), can only contain lowercase letters, numeric characters,
  /// underscores and dashes. International characters are allowed. See
  /// https://goo.gl/xmQnxf for more information and examples of labels.
  core.Map<core.String, core.String>? labels;

  /// The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// Describes the Model that may be uploaded (via ModelService.UploadModel) by
  /// this TrainingPipeline.
  ///
  /// The TrainingPipeline's training_task_definition should make clear whether
  /// this Model description should be populated, and if there are any special
  /// requirements regarding how it should be filled. If nothing is mentioned in
  /// the training_task_definition, then it should be assumed that this field
  /// should not be filled and the training task either uploads the Model
  /// without a need of this information, or that training task does not support
  /// uploading a Model as part of the pipeline. When the Pipeline's state
  /// becomes `PIPELINE_STATE_SUCCEEDED` and the trained Model had been uploaded
  /// into Vertex AI, then the model_to_upload's resource name is populated. The
  /// Model is always uploaded into the Project and Location in which this
  /// pipeline is.
  GoogleCloudAiplatformV1Model? modelToUpload;

  /// Resource name of the TrainingPipeline.
  ///
  /// Output only.
  core.String? name;

  /// When specify this field, the `model_to_upload` will not be uploaded as a
  /// new model, instead, it will become a new version of this `parent_model`.
  ///
  /// Optional.
  core.String? parentModel;

  /// Time when the TrainingPipeline for the first time entered the
  /// `PIPELINE_STATE_RUNNING` state.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the pipeline.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "PIPELINE_STATE_UNSPECIFIED" : The pipeline state is unspecified.
  /// - "PIPELINE_STATE_QUEUED" : The pipeline has been created or resumed, and
  /// processing has not yet begun.
  /// - "PIPELINE_STATE_PENDING" : The service is preparing to run the pipeline.
  /// - "PIPELINE_STATE_RUNNING" : The pipeline is in progress.
  /// - "PIPELINE_STATE_SUCCEEDED" : The pipeline completed successfully.
  /// - "PIPELINE_STATE_FAILED" : The pipeline failed.
  /// - "PIPELINE_STATE_CANCELLING" : The pipeline is being cancelled. From this
  /// state, the pipeline may only go to either PIPELINE_STATE_SUCCEEDED,
  /// PIPELINE_STATE_FAILED or PIPELINE_STATE_CANCELLED.
  /// - "PIPELINE_STATE_CANCELLED" : The pipeline has been cancelled.
  /// - "PIPELINE_STATE_PAUSED" : The pipeline has been stopped, and can be
  /// resumed.
  core.String? state;

  /// A Google Cloud Storage path to the YAML file that defines the training
  /// task which is responsible for producing the model artifact, and may also
  /// include additional auxiliary work.
  ///
  /// The definition files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/trainingjob/definition/. Note: The URI
  /// given on output will be immutable and probably different, including the
  /// URI scheme, than the one given on input. The output URI will point to a
  /// location where the user only has a read access.
  ///
  /// Required.
  core.String? trainingTaskDefinition;

  /// The training task's parameter(s), as specified in the
  /// training_task_definition's `inputs`.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? trainingTaskInputs;

  /// The metadata information as specified in the training_task_definition's
  /// `metadata`.
  ///
  /// This metadata is an auxiliary runtime and final information about the
  /// training task. While the pipeline is running this information is populated
  /// only at a best effort basis. Only present if the pipeline's
  /// training_task_definition contains `metadata` object.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? trainingTaskMetadata;

  /// Time when the TrainingPipeline was most recently updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudAiplatformV1TrainingPipeline({
    this.createTime,
    this.displayName,
    this.encryptionSpec,
    this.endTime,
    this.error,
    this.inputDataConfig,
    this.labels,
    this.modelId,
    this.modelToUpload,
    this.name,
    this.parentModel,
    this.startTime,
    this.state,
    this.trainingTaskDefinition,
    this.trainingTaskInputs,
    this.trainingTaskMetadata,
    this.updateTime,
  });

  GoogleCloudAiplatformV1TrainingPipeline.fromJson(core.Map json_)
      : this(
          createTime: json_.containsKey('createTime')
              ? json_['createTime'] as core.String
              : null,
          displayName: json_.containsKey('displayName')
              ? json_['displayName'] as core.String
              : null,
          encryptionSpec: json_.containsKey('encryptionSpec')
              ? GoogleCloudAiplatformV1EncryptionSpec.fromJson(
                  json_['encryptionSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          inputDataConfig: json_.containsKey('inputDataConfig')
              ? GoogleCloudAiplatformV1InputDataConfig.fromJson(
                  json_['inputDataConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          labels: json_.containsKey('labels')
              ? (json_['labels'] as core.Map<core.String, core.dynamic>).map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
          modelId: json_.containsKey('modelId')
              ? json_['modelId'] as core.String
              : null,
          modelToUpload: json_.containsKey('modelToUpload')
              ? GoogleCloudAiplatformV1Model.fromJson(
                  json_['modelToUpload'] as core.Map<core.String, core.dynamic>)
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          parentModel: json_.containsKey('parentModel')
              ? json_['parentModel'] as core.String
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          trainingTaskDefinition: json_.containsKey('trainingTaskDefinition')
              ? json_['trainingTaskDefinition'] as core.String
              : null,
          trainingTaskInputs: json_.containsKey('trainingTaskInputs')
              ? json_['trainingTaskInputs']
              : null,
          trainingTaskMetadata: json_.containsKey('trainingTaskMetadata')
              ? json_['trainingTaskMetadata']
              : null,
          updateTime: json_.containsKey('updateTime')
              ? json_['updateTime'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (createTime != null) 'createTime': createTime!,
        if (displayName != null) 'displayName': displayName!,
        if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!,
        if (endTime != null) 'endTime': endTime!,
        if (error != null) 'error': error!,
        if (inputDataConfig != null) 'inputDataConfig': inputDataConfig!,
        if (labels != null) 'labels': labels!,
        if (modelId != null) 'modelId': modelId!,
        if (modelToUpload != null) 'modelToUpload': modelToUpload!,
        if (name != null) 'name': name!,
        if (parentModel != null) 'parentModel': parentModel!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (trainingTaskDefinition != null)
          'trainingTaskDefinition': trainingTaskDefinition!,
        if (trainingTaskInputs != null)
          'trainingTaskInputs': trainingTaskInputs!,
        if (trainingTaskMetadata != null)
          'trainingTaskMetadata': trainingTaskMetadata!,
        if (updateTime != null) 'updateTime': updateTime!,
      };
}

/// A message representing a Trial.
///
/// A Trial contains a unique set of Parameters that has been or will be
/// evaluated, along with the objective metrics got by running the Trial.
class GoogleCloudAiplatformV1Trial {
  /// The identifier of the client that originally requested this Trial.
  ///
  /// Each client is identified by a unique client_id. When a client asks for a
  /// suggestion, Vertex AI Vizier will assign it a Trial. The client should
  /// evaluate the Trial, complete it, and report back to Vertex AI Vizier. If
  /// suggestion is asked again by same client_id before the Trial is completed,
  /// the same Trial will be returned. Multiple clients with different
  /// client_ids can ask for suggestions simultaneously, each of them will get
  /// their own Trial.
  ///
  /// Output only.
  core.String? clientId;

  /// The CustomJob name linked to the Trial.
  ///
  /// It's set for a HyperparameterTuningJob's Trial.
  ///
  /// Output only.
  core.String? customJob;

  /// Time when the Trial's status changed to `SUCCEEDED` or `INFEASIBLE`.
  ///
  /// Output only.
  core.String? endTime;

  /// The final measurement containing the objective value.
  ///
  /// Output only.
  GoogleCloudAiplatformV1Measurement? finalMeasurement;

  /// The identifier of the Trial assigned by the service.
  ///
  /// Output only.
  core.String? id;

  /// A human readable string describing why the Trial is infeasible.
  ///
  /// This is set only if Trial state is `INFEASIBLE`.
  ///
  /// Output only.
  core.String? infeasibleReason;

  /// A list of measurements that are strictly lexicographically ordered by
  /// their induced tuples (steps, elapsed_duration).
  ///
  /// These are used for early stopping computations.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1Measurement>? measurements;

  /// Resource name of the Trial assigned by the service.
  ///
  /// Output only.
  core.String? name;

  /// The parameters of the Trial.
  ///
  /// Output only.
  core.List<GoogleCloudAiplatformV1TrialParameter>? parameters;

  /// Time when the Trial was started.
  ///
  /// Output only.
  core.String? startTime;

  /// The detailed state of the Trial.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The Trial state is unspecified.
  /// - "REQUESTED" : Indicates that a specific Trial has been requested, but it
  /// has not yet been suggested by the service.
  /// - "ACTIVE" : Indicates that the Trial has been suggested.
  /// - "STOPPING" : Indicates that the Trial should stop according to the
  /// service.
  /// - "SUCCEEDED" : Indicates that the Trial is completed successfully.
  /// - "INFEASIBLE" : Indicates that the Trial should not be attempted again.
  /// The service will set a Trial to INFEASIBLE when it's done but missing the
  /// final_measurement.
  core.String? state;

  /// URIs for accessing
  /// [interactive shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node).
  ///
  /// Only available if this trial is part of a HyperparameterTuningJob and the
  /// job's trial_job_spec.enable_web_access field is `true`. The keys are names
  /// of each node used for the trial; for example, `workerpool0-0` for the
  /// primary node, `workerpool1-0` for the first node in the second worker
  /// pool, and `workerpool1-1` for the second node in the second worker pool.
  /// The values are the URIs for each node's interactive shell.
  ///
  /// Output only.
  core.Map<core.String, core.String>? webAccessUris;

  GoogleCloudAiplatformV1Trial({
    this.clientId,
    this.customJob,
    this.endTime,
    this.finalMeasurement,
    this.id,
    this.infeasibleReason,
    this.measurements,
    this.name,
    this.parameters,
    this.startTime,
    this.state,
    this.webAccessUris,
  });

  GoogleCloudAiplatformV1Trial.fromJson(core.Map json_)
      : this(
          clientId: json_.containsKey('clientId')
              ? json_['clientId'] as core.String
              : null,
          customJob: json_.containsKey('customJob')
              ? json_['customJob'] as core.String
              : null,
          endTime: json_.containsKey('endTime')
              ? json_['endTime'] as core.String
              : null,
          finalMeasurement: json_.containsKey('finalMeasurement')
              ? GoogleCloudAiplatformV1Measurement.fromJson(
                  json_['finalMeasurement']
                      as core.Map<core.String, core.dynamic>)
              : null,
          id: json_.containsKey('id') ? json_['id'] as core.String : null,
          infeasibleReason: json_.containsKey('infeasibleReason')
              ? json_['infeasibleReason'] as core.String
              : null,
          measurements: json_.containsKey('measurements')
              ? (json_['measurements'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1Measurement.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          parameters: json_.containsKey('parameters')
              ? (json_['parameters'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TrialParameter.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          startTime: json_.containsKey('startTime')
              ? json_['startTime'] as core.String
              : null,
          state:
              json_.containsKey('state') ? json_['state'] as core.String : null,
          webAccessUris: json_.containsKey('webAccessUris')
              ? (json_['webAccessUris'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.String,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (clientId != null) 'clientId': clientId!,
        if (customJob != null) 'customJob': customJob!,
        if (endTime != null) 'endTime': endTime!,
        if (finalMeasurement != null) 'finalMeasurement': finalMeasurement!,
        if (id != null) 'id': id!,
        if (infeasibleReason != null) 'infeasibleReason': infeasibleReason!,
        if (measurements != null) 'measurements': measurements!,
        if (name != null) 'name': name!,
        if (parameters != null) 'parameters': parameters!,
        if (startTime != null) 'startTime': startTime!,
        if (state != null) 'state': state!,
        if (webAccessUris != null) 'webAccessUris': webAccessUris!,
      };
}

/// Next ID: 3
class GoogleCloudAiplatformV1TrialContext {
  /// A human-readable field which can store a description of this context.
  ///
  /// This will become part of the resulting Trial's description field.
  core.String? description;

  /// If/when a Trial is generated or selected from this Context, its Parameters
  /// will match any parameters specified here.
  ///
  /// (I.e. if this context specifies parameter name:'a' int_value:3, then a
  /// resulting Trial will have int_value:3 for its parameter named 'a'.) Note
  /// that we first attempt to match existing REQUESTED Trials with contexts,
  /// and if there are no matches, we generate suggestions in the subspace
  /// defined by the parameters specified here. NOTE: a Context without any
  /// Parameters matches the entire feasible search space.
  core.List<GoogleCloudAiplatformV1TrialParameter>? parameters;

  GoogleCloudAiplatformV1TrialContext({
    this.description,
    this.parameters,
  });

  GoogleCloudAiplatformV1TrialContext.fromJson(core.Map json_)
      : this(
          description: json_.containsKey('description')
              ? json_['description'] as core.String
              : null,
          parameters: json_.containsKey('parameters')
              ? (json_['parameters'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TrialParameter.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (description != null) 'description': description!,
        if (parameters != null) 'parameters': parameters!,
      };
}

/// A message representing a parameter to be tuned.
class GoogleCloudAiplatformV1TrialParameter {
  /// The ID of the parameter.
  ///
  /// The parameter should be defined in StudySpec's Parameters.
  ///
  /// Output only.
  core.String? parameterId;

  /// The value of the parameter.
  ///
  /// `number_value` will be set if a parameter defined in StudySpec is in type
  /// 'INTEGER', 'DOUBLE' or 'DISCRETE'. `string_value` will be set if a
  /// parameter defined in StudySpec is in type 'CATEGORICAL'.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Object? value;

  GoogleCloudAiplatformV1TrialParameter({
    this.parameterId,
    this.value,
  });

  GoogleCloudAiplatformV1TrialParameter.fromJson(core.Map json_)
      : this(
          parameterId: json_.containsKey('parameterId')
              ? json_['parameterId'] as core.String
              : null,
          value: json_.containsKey('value') ? json_['value'] : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (parameterId != null) 'parameterId': parameterId!,
        if (value != null) 'value': value!,
      };
}

/// Request message for IndexEndpointService.UndeployIndex.
class GoogleCloudAiplatformV1UndeployIndexRequest {
  /// The ID of the DeployedIndex to be undeployed from the IndexEndpoint.
  ///
  /// Required.
  core.String? deployedIndexId;

  GoogleCloudAiplatformV1UndeployIndexRequest({
    this.deployedIndexId,
  });

  GoogleCloudAiplatformV1UndeployIndexRequest.fromJson(core.Map json_)
      : this(
          deployedIndexId: json_.containsKey('deployedIndexId')
              ? json_['deployedIndexId'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedIndexId != null) 'deployedIndexId': deployedIndexId!,
      };
}

/// Request message for EndpointService.UndeployModel.
class GoogleCloudAiplatformV1UndeployModelRequest {
  /// The ID of the DeployedModel to be undeployed from the Endpoint.
  ///
  /// Required.
  core.String? deployedModelId;

  /// If this field is provided, then the Endpoint's traffic_split will be
  /// overwritten with it.
  ///
  /// If last DeployedModel is being undeployed from the Endpoint, the
  /// \[Endpoint.traffic_split\] will always end up empty when this call
  /// returns. A DeployedModel will be successfully undeployed only if it
  /// doesn't have any traffic assigned to it when this method executes, or if
  /// this field unassigns any traffic to it.
  core.Map<core.String, core.int>? trafficSplit;

  GoogleCloudAiplatformV1UndeployModelRequest({
    this.deployedModelId,
    this.trafficSplit,
  });

  GoogleCloudAiplatformV1UndeployModelRequest.fromJson(core.Map json_)
      : this(
          deployedModelId: json_.containsKey('deployedModelId')
              ? json_['deployedModelId'] as core.String
              : null,
          trafficSplit: json_.containsKey('trafficSplit')
              ? (json_['trafficSplit'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    value as core.int,
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (deployedModelId != null) 'deployedModelId': deployedModelId!,
        if (trafficSplit != null) 'trafficSplit': trafficSplit!,
      };
}

/// Contains model information necessary to perform batch prediction without
/// requiring a full model import.
class GoogleCloudAiplatformV1UnmanagedContainerModel {
  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  core.String? artifactUri;

  /// Input only.
  ///
  /// The specification of the container that is to be used when deploying this
  /// Model.
  GoogleCloudAiplatformV1ModelContainerSpec? containerSpec;

  /// Contains the schemata used in Model's predictions and explanations
  GoogleCloudAiplatformV1PredictSchemata? predictSchemata;

  GoogleCloudAiplatformV1UnmanagedContainerModel({
    this.artifactUri,
    this.containerSpec,
    this.predictSchemata,
  });

  GoogleCloudAiplatformV1UnmanagedContainerModel.fromJson(core.Map json_)
      : this(
          artifactUri: json_.containsKey('artifactUri')
              ? json_['artifactUri'] as core.String
              : null,
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ModelContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          predictSchemata: json_.containsKey('predictSchemata')
              ? GoogleCloudAiplatformV1PredictSchemata.fromJson(
                  json_['predictSchemata']
                      as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (artifactUri != null) 'artifactUri': artifactUri!,
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (predictSchemata != null) 'predictSchemata': predictSchemata!,
      };
}

/// Request message for ModelService.UpdateExplanationDataset.
class GoogleCloudAiplatformV1UpdateExplanationDatasetRequest {
  /// The example config containing the location of the dataset.
  GoogleCloudAiplatformV1Examples? examples;

  GoogleCloudAiplatformV1UpdateExplanationDatasetRequest({
    this.examples,
  });

  GoogleCloudAiplatformV1UpdateExplanationDatasetRequest.fromJson(
      core.Map json_)
      : this(
          examples: json_.containsKey('examples')
              ? GoogleCloudAiplatformV1Examples.fromJson(
                  json_['examples'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (examples != null) 'examples': examples!,
      };
}

/// Request message for ModelService.UploadModel.
class GoogleCloudAiplatformV1UploadModelRequest {
  /// The Model to create.
  ///
  /// Required.
  GoogleCloudAiplatformV1Model? model;

  /// The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  ///
  /// Optional.
  core.String? modelId;

  /// The resource name of the model into which to upload the version.
  ///
  /// Only specify this field when uploading a new version.
  ///
  /// Optional.
  core.String? parentModel;

  /// The user-provided custom service account to use to do the model upload.
  ///
  /// If empty,
  /// [Vertex AI Service Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used. Users uploading the Model must have the
  /// `iam.serviceAccounts.actAs` permission on this service account. Also, this
  /// account must belong to the project specified in the `parent` field and
  /// have all necessary read permissions.
  ///
  /// Optional.
  core.String? serviceAccount;

  GoogleCloudAiplatformV1UploadModelRequest({
    this.model,
    this.modelId,
    this.parentModel,
    this.serviceAccount,
  });

  GoogleCloudAiplatformV1UploadModelRequest.fromJson(core.Map json_)
      : this(
          model: json_.containsKey('model')
              ? GoogleCloudAiplatformV1Model.fromJson(
                  json_['model'] as core.Map<core.String, core.dynamic>)
              : null,
          modelId: json_.containsKey('modelId')
              ? json_['modelId'] as core.String
              : null,
          parentModel: json_.containsKey('parentModel')
              ? json_['parentModel'] as core.String
              : null,
          serviceAccount: json_.containsKey('serviceAccount')
              ? json_['serviceAccount'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (model != null) 'model': model!,
        if (modelId != null) 'modelId': modelId!,
        if (parentModel != null) 'parentModel': parentModel!,
        if (serviceAccount != null) 'serviceAccount': serviceAccount!,
      };
}

/// Request message for IndexService.UpsertDatapoints
class GoogleCloudAiplatformV1UpsertDatapointsRequest {
  /// A list of datapoints to be created/updated.
  core.List<GoogleCloudAiplatformV1IndexDatapoint>? datapoints;

  GoogleCloudAiplatformV1UpsertDatapointsRequest({
    this.datapoints,
  });

  GoogleCloudAiplatformV1UpsertDatapointsRequest.fromJson(core.Map json_)
      : this(
          datapoints: json_.containsKey('datapoints')
              ? (json_['datapoints'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1IndexDatapoint.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (datapoints != null) 'datapoints': datapoints!,
      };
}

/// Response message for IndexService.UpsertDatapoints
typedef GoogleCloudAiplatformV1UpsertDatapointsResponse = $Empty;

/// References an API call.
///
/// It contains more information about long running operation and Jobs that are
/// triggered by the API call.
class GoogleCloudAiplatformV1UserActionReference {
  /// For API calls that start a LabelingJob.
  ///
  /// Resource name of the LabelingJob. Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  core.String? dataLabelingJob;

  /// The method name of the API RPC call.
  ///
  /// For example,
  /// "/google.cloud.aiplatform.{apiVersion}.DatasetService.CreateDataset"
  core.String? method;

  /// For API calls that return a long running operation.
  ///
  /// Resource name of the long running operation. Format:
  /// `projects/{project}/locations/{location}/operations/{operation}`
  core.String? operation;

  GoogleCloudAiplatformV1UserActionReference({
    this.dataLabelingJob,
    this.method,
    this.operation,
  });

  GoogleCloudAiplatformV1UserActionReference.fromJson(core.Map json_)
      : this(
          dataLabelingJob: json_.containsKey('dataLabelingJob')
              ? json_['dataLabelingJob'] as core.String
              : null,
          method: json_.containsKey('method')
              ? json_['method'] as core.String
              : null,
          operation: json_.containsKey('operation')
              ? json_['operation'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (dataLabelingJob != null) 'dataLabelingJob': dataLabelingJob!,
        if (method != null) 'method': method!,
        if (operation != null) 'operation': operation!,
      };
}

/// Value is the value of the field.
class GoogleCloudAiplatformV1Value {
  /// A double value.
  core.double? doubleValue;

  /// An integer value.
  core.String? intValue;

  /// A string value.
  core.String? stringValue;

  GoogleCloudAiplatformV1Value({
    this.doubleValue,
    this.intValue,
    this.stringValue,
  });

  GoogleCloudAiplatformV1Value.fromJson(core.Map json_)
      : this(
          doubleValue: json_.containsKey('doubleValue')
              ? (json_['doubleValue'] as core.num).toDouble()
              : null,
          intValue: json_.containsKey('intValue')
              ? json_['intValue'] as core.String
              : null,
          stringValue: json_.containsKey('stringValue')
              ? json_['stringValue'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (doubleValue != null) 'doubleValue': doubleValue!,
        if (intValue != null) 'intValue': intValue!,
        if (stringValue != null) 'stringValue': stringValue!,
      };
}

/// Represents the spec of a worker pool in a job.
class GoogleCloudAiplatformV1WorkerPoolSpec {
  /// The custom container task.
  GoogleCloudAiplatformV1ContainerSpec? containerSpec;

  /// Disk spec.
  GoogleCloudAiplatformV1DiskSpec? diskSpec;

  /// The specification of a single machine.
  ///
  /// Optional. Immutable.
  GoogleCloudAiplatformV1MachineSpec? machineSpec;

  /// List of NFS mount spec.
  ///
  /// Optional.
  core.List<GoogleCloudAiplatformV1NfsMount>? nfsMounts;

  /// The Python packaged task.
  GoogleCloudAiplatformV1PythonPackageSpec? pythonPackageSpec;

  /// The number of worker replicas to use for this worker pool.
  ///
  /// Optional.
  core.String? replicaCount;

  GoogleCloudAiplatformV1WorkerPoolSpec({
    this.containerSpec,
    this.diskSpec,
    this.machineSpec,
    this.nfsMounts,
    this.pythonPackageSpec,
    this.replicaCount,
  });

  GoogleCloudAiplatformV1WorkerPoolSpec.fromJson(core.Map json_)
      : this(
          containerSpec: json_.containsKey('containerSpec')
              ? GoogleCloudAiplatformV1ContainerSpec.fromJson(
                  json_['containerSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          diskSpec: json_.containsKey('diskSpec')
              ? GoogleCloudAiplatformV1DiskSpec.fromJson(
                  json_['diskSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          machineSpec: json_.containsKey('machineSpec')
              ? GoogleCloudAiplatformV1MachineSpec.fromJson(
                  json_['machineSpec'] as core.Map<core.String, core.dynamic>)
              : null,
          nfsMounts: json_.containsKey('nfsMounts')
              ? (json_['nfsMounts'] as core.List)
                  .map((value) => GoogleCloudAiplatformV1NfsMount.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          pythonPackageSpec: json_.containsKey('pythonPackageSpec')
              ? GoogleCloudAiplatformV1PythonPackageSpec.fromJson(
                  json_['pythonPackageSpec']
                      as core.Map<core.String, core.dynamic>)
              : null,
          replicaCount: json_.containsKey('replicaCount')
              ? json_['replicaCount'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (containerSpec != null) 'containerSpec': containerSpec!,
        if (diskSpec != null) 'diskSpec': diskSpec!,
        if (machineSpec != null) 'machineSpec': machineSpec!,
        if (nfsMounts != null) 'nfsMounts': nfsMounts!,
        if (pythonPackageSpec != null) 'pythonPackageSpec': pythonPackageSpec!,
        if (replicaCount != null) 'replicaCount': replicaCount!,
      };
}

/// Contains Feature values to be written for a specific entity.
class GoogleCloudAiplatformV1WriteFeatureValuesPayload {
  /// The ID of the entity.
  ///
  /// Required.
  core.String? entityId;

  /// Feature values to be written, mapping from Feature ID to value.
  ///
  /// Up to 100,000 `feature_values` entries may be written across all payloads.
  /// The feature generation time, aligned by days, must be no older than five
  /// years (1825 days) and no later than one year (366 days) in the future.
  ///
  /// Required.
  core.Map<core.String, GoogleCloudAiplatformV1FeatureValue>? featureValues;

  GoogleCloudAiplatformV1WriteFeatureValuesPayload({
    this.entityId,
    this.featureValues,
  });

  GoogleCloudAiplatformV1WriteFeatureValuesPayload.fromJson(core.Map json_)
      : this(
          entityId: json_.containsKey('entityId')
              ? json_['entityId'] as core.String
              : null,
          featureValues: json_.containsKey('featureValues')
              ? (json_['featureValues'] as core.Map<core.String, core.dynamic>)
                  .map(
                  (key, value) => core.MapEntry(
                    key,
                    GoogleCloudAiplatformV1FeatureValue.fromJson(
                        value as core.Map<core.String, core.dynamic>),
                  ),
                )
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (entityId != null) 'entityId': entityId!,
        if (featureValues != null) 'featureValues': featureValues!,
      };
}

/// Request message for FeaturestoreOnlineServingService.WriteFeatureValues.
class GoogleCloudAiplatformV1WriteFeatureValuesRequest {
  /// The entities to be written.
  ///
  /// Up to 100,000 feature values can be written across all `payloads`.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1WriteFeatureValuesPayload>? payloads;

  GoogleCloudAiplatformV1WriteFeatureValuesRequest({
    this.payloads,
  });

  GoogleCloudAiplatformV1WriteFeatureValuesRequest.fromJson(core.Map json_)
      : this(
          payloads: json_.containsKey('payloads')
              ? (json_['payloads'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1WriteFeatureValuesPayload.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (payloads != null) 'payloads': payloads!,
      };
}

/// Response message for FeaturestoreOnlineServingService.WriteFeatureValues.
typedef GoogleCloudAiplatformV1WriteFeatureValuesResponse = $Empty;

/// Request message for TensorboardService.WriteTensorboardExperimentData.
class GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest {
  /// Requests containing per-run TensorboardTimeSeries data to write.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1WriteTensorboardRunDataRequest>?
      writeRunDataRequests;

  GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest({
    this.writeRunDataRequests,
  });

  GoogleCloudAiplatformV1WriteTensorboardExperimentDataRequest.fromJson(
      core.Map json_)
      : this(
          writeRunDataRequests: json_.containsKey('writeRunDataRequests')
              ? (json_['writeRunDataRequests'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1WriteTensorboardRunDataRequest
                          .fromJson(
                              value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (writeRunDataRequests != null)
          'writeRunDataRequests': writeRunDataRequests!,
      };
}

/// Response message for TensorboardService.WriteTensorboardExperimentData.
typedef GoogleCloudAiplatformV1WriteTensorboardExperimentDataResponse = $Empty;

/// Request message for TensorboardService.WriteTensorboardRunData.
class GoogleCloudAiplatformV1WriteTensorboardRunDataRequest {
  /// The resource name of the TensorboardRun to write data to.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  ///
  /// Required.
  core.String? tensorboardRun;

  /// The TensorboardTimeSeries data to write.
  ///
  /// Values with in a time series are indexed by their step value. Repeated
  /// writes to the same step will overwrite the existing value for that step.
  /// The upper limit of data points per write request is 5000.
  ///
  /// Required.
  core.List<GoogleCloudAiplatformV1TimeSeriesData>? timeSeriesData;

  GoogleCloudAiplatformV1WriteTensorboardRunDataRequest({
    this.tensorboardRun,
    this.timeSeriesData,
  });

  GoogleCloudAiplatformV1WriteTensorboardRunDataRequest.fromJson(core.Map json_)
      : this(
          tensorboardRun: json_.containsKey('tensorboardRun')
              ? json_['tensorboardRun'] as core.String
              : null,
          timeSeriesData: json_.containsKey('timeSeriesData')
              ? (json_['timeSeriesData'] as core.List)
                  .map((value) =>
                      GoogleCloudAiplatformV1TimeSeriesData.fromJson(
                          value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!,
        if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!,
      };
}

/// Response message for TensorboardService.WriteTensorboardRunData.
typedef GoogleCloudAiplatformV1WriteTensorboardRunDataResponse = $Empty;

/// An explanation method that redistributes Integrated Gradients attributions
/// to segmented regions, taking advantage of the model's fully differentiable
/// structure.
///
/// Refer to this paper for more details: https://arxiv.org/abs/1906.02825
/// Supported only by image Models.
class GoogleCloudAiplatformV1XraiAttribution {
  /// Config for XRAI with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image)
  /// is motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  GoogleCloudAiplatformV1BlurBaselineConfig? blurBaselineConfig;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding noise can help
  /// improve the computed gradients. Refer to this paper for more details:
  /// https://arxiv.org/pdf/1706.03825.pdf
  GoogleCloudAiplatformV1SmoothGradConfig? smoothGradConfig;

  /// The number of steps for approximating the path integral.
  ///
  /// A good value to start is 50 and gradually increase until the sum to diff
  /// property is met within the desired error range. Valid range of its value
  /// is \[1, 100\], inclusively.
  ///
  /// Required.
  core.int? stepCount;

  GoogleCloudAiplatformV1XraiAttribution({
    this.blurBaselineConfig,
    this.smoothGradConfig,
    this.stepCount,
  });

  GoogleCloudAiplatformV1XraiAttribution.fromJson(core.Map json_)
      : this(
          blurBaselineConfig: json_.containsKey('blurBaselineConfig')
              ? GoogleCloudAiplatformV1BlurBaselineConfig.fromJson(
                  json_['blurBaselineConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          smoothGradConfig: json_.containsKey('smoothGradConfig')
              ? GoogleCloudAiplatformV1SmoothGradConfig.fromJson(
                  json_['smoothGradConfig']
                      as core.Map<core.String, core.dynamic>)
              : null,
          stepCount: json_.containsKey('stepCount')
              ? json_['stepCount'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (blurBaselineConfig != null)
          'blurBaselineConfig': blurBaselineConfig!,
        if (smoothGradConfig != null) 'smoothGradConfig': smoothGradConfig!,
        if (stepCount != null) 'stepCount': stepCount!,
      };
}

/// The response message for Locations.ListLocations.
class GoogleCloudLocationListLocationsResponse {
  /// A list of locations that matches the specified filter in the request.
  core.List<GoogleCloudLocationLocation>? locations;

  /// The standard List next-page token.
  core.String? nextPageToken;

  GoogleCloudLocationListLocationsResponse({
    this.locations,
    this.nextPageToken,
  });

  GoogleCloudLocationListLocationsResponse.fromJson(core.Map json_)
      : this(
          locations: json_.containsKey('locations')
              ? (json_['locations'] as core.List)
                  .map((value) => GoogleCloudLocationLocation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (locations != null) 'locations': locations!,
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
      };
}

/// A resource that represents a Google Cloud location.
typedef GoogleCloudLocationLocation = $Location00;

/// Associates `members`, or principals, with a `role`.
class GoogleIamV1Binding {
  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request. If the condition evaluates to `false`, then this binding
  /// does not apply to the current request. However, a different role binding
  /// might grant the same role to one or more of the principals in this
  /// binding. To learn which resources support conditions in their IAM
  /// policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  GoogleTypeExpr? condition;

  /// Specifies the principals requesting access for a Google Cloud resource.
  ///
  /// `members` can have the following values: * `allUsers`: A special
  /// identifier that represents anyone who is on the internet; with or without
  /// a Google account. * `allAuthenticatedUsers`: A special identifier that
  /// represents anyone who is authenticated with a Google account or a service
  /// account. Does not include identities that come from external identity
  /// providers (IdPs) through identity federation. * `user:{emailid}`: An email
  /// address that represents a specific Google account. For example,
  /// `alice@example.com` . * `serviceAccount:{emailid}`: An email address that
  /// represents a Google service account. For example,
  /// `my-other-app@appspot.gserviceaccount.com`. *
  /// `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
  /// identifier for a
  /// [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
  /// For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. *
  /// `group:{emailid}`: An email address that represents a Google group. For
  /// example, `admins@example.com`. * `domain:{domain}`: The G Suite domain
  /// (primary) that represents all the users of that domain. For example,
  /// `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`:
  /// An email address (plus unique identifier) representing a user that has
  /// been recently deleted. For example,
  /// `alice@example.com?uid=123456789012345678901`. If the user is recovered,
  /// this value reverts to `user:{emailid}` and the recovered user retains the
  /// role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`:
  /// An email address (plus unique identifier) representing a service account
  /// that has been recently deleted. For example,
  /// `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If
  /// the service account is undeleted, this value reverts to
  /// `serviceAccount:{emailid}` and the undeleted service account retains the
  /// role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email
  /// address (plus unique identifier) representing a Google group that has been
  /// recently deleted. For example,
  /// `admins@example.com?uid=123456789012345678901`. If the group is recovered,
  /// this value reverts to `group:{emailid}` and the recovered group retains
  /// the role in the binding.
  core.List<core.String>? members;

  /// Role that is assigned to the list of `members`, or principals.
  ///
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  core.String? role;

  GoogleIamV1Binding({
    this.condition,
    this.members,
    this.role,
  });

  GoogleIamV1Binding.fromJson(core.Map json_)
      : this(
          condition: json_.containsKey('condition')
              ? GoogleTypeExpr.fromJson(
                  json_['condition'] as core.Map<core.String, core.dynamic>)
              : null,
          members: json_.containsKey('members')
              ? (json_['members'] as core.List)
                  .map((value) => value as core.String)
                  .toList()
              : null,
          role: json_.containsKey('role') ? json_['role'] as core.String : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (condition != null) 'condition': condition!,
        if (members != null) 'members': members!,
        if (role != null) 'role': role!,
      };
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role. For some types of Google Cloud
/// resources, a `binding` can also specify a `condition`, which is a logical
/// expression that allows access to a resource only if the expression evaluates
/// to `true`. A condition can add constraints based on attributes of the
/// request, the resource, or both. To learn which resources support conditions
/// in their IAM policies, see the
/// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
/// **JSON example:** ``` { "bindings": [ { "role":
/// "roles/resourcemanager.organizationAdmin", "members": [
/// "user:mike@example.com", "group:admins@example.com", "domain:google.com",
/// "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role":
/// "roles/resourcemanager.organizationViewer", "members": [
/// "user:eve@example.com" ], "condition": { "title": "expirable access",
/// "description": "Does not grant access after Sep 2020", "expression":
/// "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag":
/// "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: -
/// members: - user:mike@example.com - group:admins@example.com -
/// domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com
/// role: roles/resourcemanager.organizationAdmin - members: -
/// user:eve@example.com role: roles/resourcemanager.organizationViewer
/// condition: title: expirable access description: Does not grant access after
/// Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
/// etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features,
/// see the [IAM documentation](https://cloud.google.com/iam/docs/).
class GoogleIamV1Policy {
  /// Associates a list of `members`, or principals, with a `role`.
  ///
  /// Optionally, may specify a `condition` that determines how and when the
  /// `bindings` are applied. Each of the `bindings` must contain at least one
  /// principal. The `bindings` in a `Policy` can refer to up to 1,500
  /// principals; up to 250 of these principals can be Google groups. Each
  /// occurrence of a principal counts towards these limits. For example, if the
  /// `bindings` grant 50 different roles to `user:alice@example.com`, and not
  /// to any other principal, then you can add another 1,450 principals to the
  /// `bindings` in the `Policy`.
  core.List<GoogleIamV1Binding>? bindings;

  /// `etag` is used for optimistic concurrency control as a way to help prevent
  /// simultaneous updates of a policy from overwriting each other.
  ///
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the
  /// policy. **Important:** If you use IAM Conditions, you must include the
  /// `etag` field whenever you call `setIamPolicy`. If you omit this field,
  /// then IAM allows you to overwrite a version `3` policy with a version `1`
  /// policy, and all of the conditions in the version `3` policy are lost.
  core.String? etag;
  core.List<core.int> get etagAsBytes => convert.base64.decode(etag!);

  set etagAsBytes(core.List<core.int> bytes_) {
    etag =
        convert.base64.encode(bytes_).replaceAll('/', '_').replaceAll('+', '-');
  }

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected. Any operation that affects conditional role bindings must
  /// specify version `3`. This requirement applies to the following operations:
  /// * Getting a policy that includes a conditional role binding * Adding a
  /// conditional role binding to a policy * Changing a conditional role binding
  /// in a policy * Removing any role binding, with or without a condition, from
  /// a policy that includes conditions **Important:** If you use IAM
  /// Conditions, you must include the `etag` field whenever you call
  /// `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a
  /// version `3` policy with a version `1` policy, and all of the conditions in
  /// the version `3` policy are lost. If a policy does not include any
  /// conditions, operations on that policy may specify any valid version or
  /// leave the field unset. To learn which resources support conditions in
  /// their IAM policies, see the
  /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  core.int? version;

  GoogleIamV1Policy({
    this.bindings,
    this.etag,
    this.version,
  });

  GoogleIamV1Policy.fromJson(core.Map json_)
      : this(
          bindings: json_.containsKey('bindings')
              ? (json_['bindings'] as core.List)
                  .map((value) => GoogleIamV1Binding.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
          etag: json_.containsKey('etag') ? json_['etag'] as core.String : null,
          version: json_.containsKey('version')
              ? json_['version'] as core.int
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (bindings != null) 'bindings': bindings!,
        if (etag != null) 'etag': etag!,
        if (version != null) 'version': version!,
      };
}

/// Request message for `SetIamPolicy` method.
class GoogleIamV1SetIamPolicyRequest {
  /// REQUIRED: The complete policy to be applied to the `resource`.
  ///
  /// The size of the policy is limited to a few 10s of KB. An empty policy is a
  /// valid policy but certain Google Cloud services (such as Projects) might
  /// reject them.
  GoogleIamV1Policy? policy;

  GoogleIamV1SetIamPolicyRequest({
    this.policy,
  });

  GoogleIamV1SetIamPolicyRequest.fromJson(core.Map json_)
      : this(
          policy: json_.containsKey('policy')
              ? GoogleIamV1Policy.fromJson(
                  json_['policy'] as core.Map<core.String, core.dynamic>)
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (policy != null) 'policy': policy!,
      };
}

/// Response message for `TestIamPermissions` method.
typedef GoogleIamV1TestIamPermissionsResponse = $PermissionsResponse;

/// The response message for Operations.ListOperations.
class GoogleLongrunningListOperationsResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of operations that matches the specified filter in the request.
  core.List<GoogleLongrunningOperation>? operations;

  GoogleLongrunningListOperationsResponse({
    this.nextPageToken,
    this.operations,
  });

  GoogleLongrunningListOperationsResponse.fromJson(core.Map json_)
      : this(
          nextPageToken: json_.containsKey('nextPageToken')
              ? json_['nextPageToken'] as core.String
              : null,
          operations: json_.containsKey('operations')
              ? (json_['operations'] as core.List)
                  .map((value) => GoogleLongrunningOperation.fromJson(
                      value as core.Map<core.String, core.dynamic>))
                  .toList()
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (nextPageToken != null) 'nextPageToken': nextPageToken!,
        if (operations != null) 'operations': operations!,
      };
}

/// This resource represents a long-running operation that is the result of a
/// network API call.
class GoogleLongrunningOperation {
  /// If the value is `false`, it means the operation is still in progress.
  ///
  /// If `true`, the operation is completed, and either `error` or `response` is
  /// available.
  core.bool? done;

  /// The error result of the operation in case of failure or cancellation.
  GoogleRpcStatus? error;

  /// Service-specific metadata associated with the operation.
  ///
  /// It typically contains progress information and common metadata such as
  /// create time. Some services might not provide such metadata. Any method
  /// that returns a long-running operation should document the metadata type,
  /// if any.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The server-assigned name, which is only unique within the same service
  /// that originally returns it.
  ///
  /// If you use the default HTTP mapping, the `name` should be a resource name
  /// ending with `operations/{unique_id}`.
  core.String? name;

  /// The normal, successful response of the operation.
  ///
  /// If the original method returns no data on success, such as `Delete`, the
  /// response is `google.protobuf.Empty`. If the original method is standard
  /// `Get`/`Create`/`Update`, the response should be the resource. For other
  /// methods, the response should have the type `XxxResponse`, where `Xxx` is
  /// the original method name. For example, if the original method name is
  /// `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? response;

  GoogleLongrunningOperation({
    this.done,
    this.error,
    this.metadata,
    this.name,
    this.response,
  });

  GoogleLongrunningOperation.fromJson(core.Map json_)
      : this(
          done: json_.containsKey('done') ? json_['done'] as core.bool : null,
          error: json_.containsKey('error')
              ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>)
              : null,
          metadata: json_.containsKey('metadata')
              ? json_['metadata'] as core.Map<core.String, core.dynamic>
              : null,
          name: json_.containsKey('name') ? json_['name'] as core.String : null,
          response: json_.containsKey('response')
              ? json_['response'] as core.Map<core.String, core.dynamic>
              : null,
        );

  core.Map<core.String, core.dynamic> toJson() => {
        if (done != null) 'done': done!,
        if (error != null) 'error': error!,
        if (metadata != null) 'metadata': metadata!,
        if (name != null) 'name': name!,
        if (response != null) 'response': response!,
      };
}

/// A generic empty message that you can re-use to avoid defining duplicated
/// empty messages in your APIs.
///
/// A typical example is to use it as the request or the response type of an API
/// method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns
/// (google.protobuf.Empty); }
typedef GoogleProtobufEmpty = $Empty;

/// The `Status` type defines a logical error model that is suitable for
/// different programming environments, including REST APIs and RPC APIs.
///
/// It is used by [gRPC](https://github.com/grpc). Each `Status` message
/// contains three pieces of data: error code, error message, and error details.
/// You can find out more about this error model and how to work with it in the
/// [API Design Guide](https://cloud.google.com/apis/design/errors).
typedef GoogleRpcStatus = $Status;

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax.
///
/// CEL is a C-like expression language. The syntax and semantics of CEL are
/// documented at https://github.com/google/cel-spec. Example (Comparison):
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() \< 100" Example
/// (Equality): title: "Requestor is owner" description: "Determines if
/// requestor is the document owner" expression: "document.owner ==
/// request.auth.claims.email" Example (Logic): title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// Example (Data Manipulation): title: "Notification string" description:
/// "Create a notification string with a timestamp." expression: "'New message
/// received at ' + string(document.create_time)" The exact variables and
/// functions that may be referenced within an expression are determined by the
/// service that evaluates it. See the service documentation for additional
/// information.
typedef GoogleTypeExpr = $Expr;

/// Represents a time interval, encoded as a Timestamp start (inclusive) and a
/// Timestamp end (exclusive).
///
/// The start must be less than or equal to the end. When the start equals the
/// end, the interval is empty (matches no time). When both start and end are
/// unspecified, the interval matches any time.
typedef GoogleTypeInterval = $Interval;

/// Represents an amount of money with its currency type.
typedef GoogleTypeMoney = $Money;
