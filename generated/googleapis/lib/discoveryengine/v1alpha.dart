// This is a generated file (see the discoveryapis_generator project).

// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: doc_directive_unknown
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: prefer_interpolation_to_compose_strings
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_brace_in_string_interps
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: unnecessary_string_interpolations

/// Discovery Engine API - v1alpha
///
/// Discovery Engine API.
///
/// For more information, see
/// <https://cloud.google.com/generative-ai-app-builder/docs/>
///
/// Create an instance of [DiscoveryEngineApi] to access these resources:
///
/// - [MediaResource]
/// - [ProjectsResource]
///   - [ProjectsLocationsResource]
///     - [ProjectsLocationsCmekConfigsResource]
///     - [ProjectsLocationsCollectionsResource]
///       - [ProjectsLocationsCollectionsDataConnectorResource]
///         - [ProjectsLocationsCollectionsDataConnectorConnectorRunsResource]
///         - [ProjectsLocationsCollectionsDataConnectorOperationsResource]
///       - [ProjectsLocationsCollectionsDataStoresResource]
///         - [ProjectsLocationsCollectionsDataStoresBranchesResource]
/// - [ProjectsLocationsCollectionsDataStoresBranchesDocumentsResource]
/// - [ProjectsLocationsCollectionsDataStoresBranchesDocumentsChunksResource]
/// - [ProjectsLocationsCollectionsDataStoresBranchesOperationsResource]
///         - [ProjectsLocationsCollectionsDataStoresCompletionConfigResource]
/// - [ProjectsLocationsCollectionsDataStoresCompletionSuggestionsResource]
///         - [ProjectsLocationsCollectionsDataStoresControlsResource]
///         - [ProjectsLocationsCollectionsDataStoresConversationsResource]
///         - [ProjectsLocationsCollectionsDataStoresCustomModelsResource]
///         - [ProjectsLocationsCollectionsDataStoresModelsResource]
/// - [ProjectsLocationsCollectionsDataStoresModelsOperationsResource]
///         - [ProjectsLocationsCollectionsDataStoresOperationsResource]
///         - [ProjectsLocationsCollectionsDataStoresSchemasResource]
/// - [ProjectsLocationsCollectionsDataStoresSchemasOperationsResource]
///         - [ProjectsLocationsCollectionsDataStoresServingConfigsResource]
///         - [ProjectsLocationsCollectionsDataStoresSessionsResource]
///           - [ProjectsLocationsCollectionsDataStoresSessionsAnswersResource]
///         - [ProjectsLocationsCollectionsDataStoresSiteSearchEngineResource]
/// - [ProjectsLocationsCollectionsDataStoresSiteSearchEngineOperationsResource]
/// - [ProjectsLocationsCollectionsDataStoresSiteSearchEngineSitemapsResource]
/// -
/// [ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesResource]
/// -
/// [ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesOperationsResource]
/// - [ProjectsLocationsCollectionsDataStoresSuggestionDenyListEntriesResource]
///         - [ProjectsLocationsCollectionsDataStoresUserEventsResource]
///         - [ProjectsLocationsCollectionsDataStoresWidgetConfigsResource]
///       - [ProjectsLocationsCollectionsEnginesResource]
///         - [ProjectsLocationsCollectionsEnginesAnalyticsResource]
///         - [ProjectsLocationsCollectionsEnginesAssistantsResource]
///         - [ProjectsLocationsCollectionsEnginesCompletionConfigResource]
///         - [ProjectsLocationsCollectionsEnginesControlsResource]
///         - [ProjectsLocationsCollectionsEnginesConversationsResource]
///         - [ProjectsLocationsCollectionsEnginesOperationsResource]
///         - [ProjectsLocationsCollectionsEnginesServingConfigsResource]
///         - [ProjectsLocationsCollectionsEnginesSessionsResource]
///           - [ProjectsLocationsCollectionsEnginesSessionsAnswersResource]
///           - [ProjectsLocationsCollectionsEnginesSessionsFilesResource]
///         - [ProjectsLocationsCollectionsEnginesWidgetConfigsResource]
///       - [ProjectsLocationsCollectionsOperationsResource]
///     - [ProjectsLocationsDataStoresResource]
///       - [ProjectsLocationsDataStoresBranchesResource]
///         - [ProjectsLocationsDataStoresBranchesDocumentsResource]
///           - [ProjectsLocationsDataStoresBranchesDocumentsChunksResource]
///         - [ProjectsLocationsDataStoresBranchesOperationsResource]
///       - [ProjectsLocationsDataStoresCompletionConfigResource]
///       - [ProjectsLocationsDataStoresCompletionSuggestionsResource]
///       - [ProjectsLocationsDataStoresControlsResource]
///       - [ProjectsLocationsDataStoresConversationsResource]
///       - [ProjectsLocationsDataStoresModelsResource]
///         - [ProjectsLocationsDataStoresModelsOperationsResource]
///       - [ProjectsLocationsDataStoresOperationsResource]
///       - [ProjectsLocationsDataStoresSchemasResource]
///       - [ProjectsLocationsDataStoresServingConfigsResource]
///       - [ProjectsLocationsDataStoresSessionsResource]
///         - [ProjectsLocationsDataStoresSessionsAnswersResource]
///       - [ProjectsLocationsDataStoresSiteSearchEngineResource]
///         - [ProjectsLocationsDataStoresSiteSearchEngineSitemapsResource]
///         - [ProjectsLocationsDataStoresSiteSearchEngineTargetSitesResource]
///       - [ProjectsLocationsDataStoresSuggestionDenyListEntriesResource]
///       - [ProjectsLocationsDataStoresUserEventsResource]
///       - [ProjectsLocationsDataStoresWidgetConfigsResource]
///     - [ProjectsLocationsEvaluationsResource]
///       - [ProjectsLocationsEvaluationsOperationsResource]
///     - [ProjectsLocationsGroundingConfigsResource]
///     - [ProjectsLocationsIdentityMappingStoresResource]
///       - [ProjectsLocationsIdentityMappingStoresOperationsResource]
///     - [ProjectsLocationsNotebooksResource]
///       - [ProjectsLocationsNotebooksSourcesResource]
///     - [ProjectsLocationsOperationsResource]
///     - [ProjectsLocationsPodcastsResource]
///       - [ProjectsLocationsPodcastsOperationsResource]
///     - [ProjectsLocationsRankingConfigsResource]
///     - [ProjectsLocationsRequirementsResource]
///     - [ProjectsLocationsSampleQuerySetsResource]
///       - [ProjectsLocationsSampleQuerySetsOperationsResource]
///       - [ProjectsLocationsSampleQuerySetsSampleQueriesResource]
///     - [ProjectsLocationsUserEventsResource]
///     - [ProjectsLocationsUserStoresResource]
///       - [ProjectsLocationsUserStoresOperationsResource]
///       - [ProjectsLocationsUserStoresUserLicensesResource]
///   - [ProjectsOperationsResource]
library;

import 'dart:async' as async;
import 'dart:convert' as convert;
import 'dart:core' as core;

import 'package:_discoveryapis_commons/_discoveryapis_commons.dart' as commons;
import 'package:http/http.dart' as http;

import '../shared.dart';
import '../src/user_agent.dart';

export 'package:_discoveryapis_commons/_discoveryapis_commons.dart'
    show
        ApiRequestError,
        ByteRange,
        DetailedApiRequestError,
        DownloadOptions,
        Media,
        PartialDownloadOptions,
        ResumableUploadOptions,
        UploadOptions;

/// Discovery Engine API.
class DiscoveryEngineApi {
  /// See, edit, configure, and delete your Google Cloud data and see the email
  /// address for your Google Account.
  static const cloudPlatformScope =
      'https://www.googleapis.com/auth/cloud-platform';

  /// Search your organization's data in the Cloud Search index
  static const cloudSearchQueryScope =
      'https://www.googleapis.com/auth/cloud_search.query';

  final commons.ApiRequester _requester;

  MediaResource get media => MediaResource(_requester);
  ProjectsResource get projects => ProjectsResource(_requester);

  DiscoveryEngineApi(
    http.Client client, {
    core.String rootUrl = 'https://discoveryengine.googleapis.com/',
    core.String servicePath = '',
  }) : _requester = commons.ApiRequester(
         client,
         rootUrl,
         servicePath,
         requestHeaders,
       );
}

class MediaResource {
  final commons.ApiRequester _requester;

  MediaResource(commons.ApiRequester client) : _requester = client;

  /// Downloads a file from the session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Session. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [fileId] - Required. The ID of the file to be downloaded.
  ///
  /// [viewId] - Optional. The ID of the view to be downloaded.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// [downloadOptions] - Options for downloading. A download can be either a
  /// Metadata (default) or Media download. Partial Media downloads are possible
  /// as well.
  ///
  /// Completes with a
  ///
  /// - [GdataMedia] for Metadata downloads (see [downloadOptions]).
  ///
  /// - [commons.Media] for Media downloads (see [downloadOptions]).
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<core.Object> download(
    core.String name, {
    core.String? fileId,
    core.String? viewId,
    core.String? $fields,
    commons.DownloadOptions downloadOptions = commons.DownloadOptions.metadata,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (fileId != null) 'fileId': [fileId],
      if (viewId != null) 'viewId': [viewId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':downloadFile';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
      downloadOptions: downloadOptions,
    );
    if (downloadOptions.isMetadataDownload) {
      return GdataMedia.fromJson(
        response_ as core.Map<core.String, core.dynamic>,
      );
    } else {
      return response_ as commons.Media;
    }
  }
}

class ProjectsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsResource get locations =>
      ProjectsLocationsResource(_requester);
  ProjectsOperationsResource get operations =>
      ProjectsOperationsResource(_requester);

  ProjectsResource(commons.ApiRequester client) : _requester = client;

  /// Gets a Project.
  ///
  /// Returns NOT_FOUND when the project is not yet created.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of a Project, such as
  /// `projects/{project_id_or_number}`.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaProject].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaProject> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaProject.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Provisions the project resource.
  ///
  /// During the process, related systems will get prepared and initialized.
  /// Caller must read the
  /// [Terms for data use](https://cloud.google.com/retail/data-use-terms), and
  /// optionally specify in request to provide consent to that service terms.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of a Project, such as
  /// `projects/{project_id_or_number}`.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> provision(
    GoogleCloudDiscoveryengineV1alphaProvisionProjectRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':provision';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates service terms for this project.
  ///
  /// This method can be used to retroactively accept the latest terms. Terms
  /// available for update: *
  /// [Terms for data use](https://cloud.google.com/retail/data-use-terms)
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [project] - Required. Full resource name of a Project, such as
  /// `projects/{project_id_or_number}`.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaProject].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaProject> reportConsentChange(
    GoogleCloudDiscoveryengineV1alphaReportConsentChangeRequest request,
    core.String project, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$project') + ':reportConsentChange';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaProject.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCmekConfigsResource get cmekConfigs =>
      ProjectsLocationsCmekConfigsResource(_requester);
  ProjectsLocationsCollectionsResource get collections =>
      ProjectsLocationsCollectionsResource(_requester);
  ProjectsLocationsDataStoresResource get dataStores =>
      ProjectsLocationsDataStoresResource(_requester);
  ProjectsLocationsEvaluationsResource get evaluations =>
      ProjectsLocationsEvaluationsResource(_requester);
  ProjectsLocationsGroundingConfigsResource get groundingConfigs =>
      ProjectsLocationsGroundingConfigsResource(_requester);
  ProjectsLocationsIdentityMappingStoresResource get identityMappingStores =>
      ProjectsLocationsIdentityMappingStoresResource(_requester);
  ProjectsLocationsNotebooksResource get notebooks =>
      ProjectsLocationsNotebooksResource(_requester);
  ProjectsLocationsOperationsResource get operations =>
      ProjectsLocationsOperationsResource(_requester);
  ProjectsLocationsPodcastsResource get podcasts =>
      ProjectsLocationsPodcastsResource(_requester);
  ProjectsLocationsRankingConfigsResource get rankingConfigs =>
      ProjectsLocationsRankingConfigsResource(_requester);
  ProjectsLocationsRequirementsResource get requirements =>
      ProjectsLocationsRequirementsResource(_requester);
  ProjectsLocationsSampleQuerySetsResource get sampleQuerySets =>
      ProjectsLocationsSampleQuerySetsResource(_requester);
  ProjectsLocationsUserEventsResource get userEvents =>
      ProjectsLocationsUserEventsResource(_requester);
  ProjectsLocationsUserStoresResource get userStores =>
      ProjectsLocationsUserStoresResource(_requester);

  ProjectsLocationsResource(commons.ApiRequester client) : _requester = client;

  /// Estimates the data size to be used by a customer.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. Full resource name of the location, such as
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> estimateDataSize(
    GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$location') + ':estimateDataSize';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the AclConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Resource name of AclConfig, such as `projects / *
  /// /locations / * /aclConfig`. If the caller does not have permission to
  /// access the AclConfig, regardless of whether or not it exists, a
  /// PERMISSION_DENIED error is returned.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+/aclConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAclConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAclConfig> getAclConfig(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAclConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the CmekConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Resource name of CmekConfig, such as `projects / *
  /// /locations / * /cmekConfig` or `projects / * /locations / * /cmekConfigs /
  /// * `. If the caller does not have permission to access the CmekConfig,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+/cmekConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaCmekConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaCmekConfig> getCmekConfig(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaCmekConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Obtains the time series data of organic or dedicated crawl rate for
  /// monitoring.
  ///
  /// When dedicated crawl rate is not set, it will return vertex AI's organic
  /// crawl rate time series. Organic crawl means Google automatically crawl the
  /// internet at its own convenience. When dedicated crawl rate is set, it will
  /// return vertex AI's dedicated crawl rate time series.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The location resource where crawl rate management
  /// will be performed. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaObtainCrawlRateResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaObtainCrawlRateResponse>
  obtainCrawlRate(
    GoogleCloudDiscoveryengineV1alphaObtainCrawlRateRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$location') + ':obtainCrawlRate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaObtainCrawlRateResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Removes the dedicated crawl rate for a craw_rate_scope.
  ///
  /// If the dedicated crawl rate was set, this will disable vertex AI's crawl
  /// bot from using the dedicated crawl rate for crawling. If the dedicated
  /// crawl rate was not set, this is a no-op.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The location resource where crawl rate management
  /// will be performed. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> removeDedicatedCrawlRate(
    GoogleCloudDiscoveryengineV1alphaRemoveDedicatedCrawlRateRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$location') +
        ':removeDedicatedCrawlRate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the dedicated crawl rate for a crawl_rate_scope.
  ///
  /// If the dedicated crawl rate was not set, this will enable vertex AI's
  /// crawl bot to use the new dedicated crawl rate for crawling. If the
  /// dedicated crawl rate was set, vertex AI's crawl bot will try to update the
  /// rate to the new value. If the new value is too high, the crawl bot may
  /// crawl at a lower rate to avoid overloading the user's website.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. The location resource where crawl rate management
  /// will be performed. Format: `projects/{project}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> setDedicatedCrawlRate(
    GoogleCloudDiscoveryengineV1alphaSetDedicatedCrawlRateRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$location') +
        ':setDedicatedCrawlRate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a Collection and sets up the DataConnector for it.
  ///
  /// To stop a DataConnector after setup, use the
  /// CollectionService.DeleteCollection method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of Collection, in the format of
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> setUpDataConnector(
    GoogleCloudDiscoveryengineV1alphaSetUpDataConnectorRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + ':setUpDataConnector';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Default ACL configuration for use in a location of a customer's project.
  ///
  /// Updates will only reflect to new data stores. Existing data stores will
  /// still use the old value.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The full resource name of the acl configuration.
  /// Format: `projects/{project}/locations/{location}/aclConfig`. This field
  /// must be a UTF-8 encoded string with a length limit of 1024 characters.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+/aclConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAclConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAclConfig> updateAclConfig(
    GoogleCloudDiscoveryengineV1alphaAclConfig request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAclConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Provisions a CMEK key for use in a location of a customer's project.
  ///
  /// This method will also conduct location validation on the provided
  /// cmekConfig to make sure the key is valid and can be used in the selected
  /// location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CmekConfig of the form
  /// `projects/{project}/locations/{location}/cmekConfig` or
  /// `projects/{project}/locations/{location}/cmekConfigs/{cmek_config}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+/cmekConfig$`.
  ///
  /// [setDefault] - Set the following CmekConfig as the default to be used for
  /// child resources if one is not specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> updateCmekConfig(
    GoogleCloudDiscoveryengineV1alphaCmekConfig request,
    core.String name, {
    core.bool? setDefault,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (setDefault != null) 'setDefault': ['${setDefault}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCmekConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCmekConfigsResource(commons.ApiRequester client)
    : _requester = client;

  /// De-provisions a CmekConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the CmekConfig to delete, such as
  /// `projects/{project}/locations/{location}/cmekConfigs/{cmek_config}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cmekConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the CmekConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Resource name of CmekConfig, such as `projects / *
  /// /locations / * /cmekConfig` or `projects / * /locations / * /cmekConfigs /
  /// * `. If the caller does not have permission to access the CmekConfig,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cmekConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaCmekConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaCmekConfig> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaCmekConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all the CmekConfigs with the project.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent location resource name, such as
  /// `projects/{project}/locations/{location}`. If the caller does not have
  /// permission to list CmekConfigs under this location, regardless of whether
  /// or not a CmekConfig exists, a PERMISSION_DENIED error is returned.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListCmekConfigsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListCmekConfigsResponse> list(
    core.String parent, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/cmekConfigs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListCmekConfigsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Provisions a CMEK key for use in a location of a customer's project.
  ///
  /// This method will also conduct location validation on the provided
  /// cmekConfig to make sure the key is valid and can be used in the selected
  /// location.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the CmekConfig of the form
  /// `projects/{project}/locations/{location}/cmekConfig` or
  /// `projects/{project}/locations/{location}/cmekConfigs/{cmek_config}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/cmekConfigs/\[^/\]+$`.
  ///
  /// [setDefault] - Set the following CmekConfig as the default to be used for
  /// child resources if one is not specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudDiscoveryengineV1alphaCmekConfig request,
    core.String name, {
    core.bool? setDefault,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (setDefault != null) 'setDefault': ['${setDefault}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataConnectorResource get dataConnector =>
      ProjectsLocationsCollectionsDataConnectorResource(_requester);
  ProjectsLocationsCollectionsDataStoresResource get dataStores =>
      ProjectsLocationsCollectionsDataStoresResource(_requester);
  ProjectsLocationsCollectionsEnginesResource get engines =>
      ProjectsLocationsCollectionsEnginesResource(_requester);
  ProjectsLocationsCollectionsOperationsResource get operations =>
      ProjectsLocationsCollectionsOperationsResource(_requester);

  ProjectsLocationsCollectionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Deletes a Collection.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The full resource name of the Collection, in the format
  /// of `projects/{project}/locations/{location}/collections/{collection}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Collection.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The full resource name, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaCollection].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaCollection> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaCollection.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the DataConnector.
  ///
  /// DataConnector is a singleton resource for each Collection.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of DataConnector, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataConnector`.
  /// If the caller does not have permission to access the DataConnector,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned. If the requested DataConnector does not exist, a NOT_FOUND error
  /// is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDataConnector].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDataConnector> getDataConnector(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDataConnector.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Collections.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name, in the format of
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Filter returned collections by associated data connector data
  /// sources. For example: `filter = 'data_source:jira confluence'`. If the
  /// filter is empty, we return all collections under a project and location.
  ///
  /// [pageSize] - The maximum number of Collections to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Collections will
  /// be returned. The maximum value is 1000; values above 1000 will be coerced
  /// to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// CollectionService.ListCollections call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// CollectionService.ListCollections must match the call that provided the
  /// page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListCollectionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListCollectionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/collections';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListCollectionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Collection.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The full resource name of the Collection. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. The list of fields to be updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudDiscoveryengineV1alphaCollection request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a DataConnector.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The full resource name of the Data Connector.
  /// Format: `projects / * /locations / * /collections / * /dataConnector`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector$`.
  ///
  /// [updateMask] - Indicates which fields in the provided DataConnector to
  /// update. Supported field paths include: - refresh_interval - params -
  /// auto_run_disabled - action_config - action_config.action_params -
  /// action_config.service_name - destination_configs - blocking_reasons -
  /// sync_mode - incremental_sync_disabled - incremental_refresh_interval Note:
  /// Support for these fields may vary depending on the connector type. For
  /// example, not all connectors support `destination_configs`. If an
  /// unsupported or unknown field path is provided, the request will return an
  /// INVALID_ARGUMENT error.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDataConnector].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDataConnector>
  updateDataConnector(
    GoogleCloudDiscoveryengineV1alphaDataConnector request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDataConnector.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataConnectorResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataConnectorConnectorRunsResource
  get connectorRuns =>
      ProjectsLocationsCollectionsDataConnectorConnectorRunsResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataConnectorOperationsResource get operations =>
      ProjectsLocationsCollectionsDataConnectorOperationsResource(_requester);

  ProjectsLocationsCollectionsDataConnectorResource(commons.ApiRequester client)
    : _requester = client;

  /// Uses the per-user refresh token minted with AcquireAndStoreRefreshToken to
  /// generate and return a new access token and its details.
  ///
  /// Takes the access token from cache if available. Rotates the stored refresh
  /// token if needed. Uses the end user identity to return the user specific
  /// access token. Does *not* return the credentials configured by the
  /// administrator. Used by Agentspace action execution and Agentspace UI.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the connector for which a token is
  /// queried.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenResponse>
  acquireAccessToken(
    GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$name') + ':acquireAccessToken';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Get the secret for the associated connector.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The full resource name of the associated data
  /// connector.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaGetConnectorSecretResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaGetConnectorSecretResponse>
  getConnectorSecret(core.String name, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$name') + ':getConnectorSecret';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaGetConnectorSecretResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Starts an immediate synchronization process for a DataConnector.
  ///
  /// Third Party Connector Users must specify which entities should be synced.
  /// FHIR Connectors must provide a timestamp to indicate the point in time
  /// from which data should be synced.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Connector name of the form
  /// projects/{project}/locations/{location}/collections/
  /// {collection_id}/dataConnector
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConnectorRun].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConnectorRun> startConnectorRun(
    GoogleCloudDiscoveryengineV1alphaStartConnectorRunRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + ':startConnectorRun';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConnectorRun.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataConnectorConnectorRunsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataConnectorConnectorRunsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Lists the ConnectorRuns of a DataConnector.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent DataConnector resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataConnector`.
  /// If the caller does not have permission to list ConnectorRuns under this
  /// DataConnector, regardless of whether or not this DataConnector exists, a
  /// PERMISSION_DENIED error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector$`.
  ///
  /// [pageSize] - Requested page size. Server may return fewer items than
  /// requested. If unspecified, defaults to 10. The maximum value is 50; values
  /// above 50 will be coerced to 50. If this field is negative, an
  /// INVALID_ARGUMENT error is returned.
  ///
  /// [pageToken] - A page token, received from a previous `ListConnectorRuns`
  /// call. Provide this to retrieve the subsequent page. When paginating, all
  /// other parameters provided to `ListConnectorRuns` must match the call that
  /// provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListConnectorRunsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListConnectorRunsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/connectorRuns';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListConnectorRunsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataConnectorOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataConnectorOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataConnector$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresBranchesResource get branches =>
      ProjectsLocationsCollectionsDataStoresBranchesResource(_requester);
  ProjectsLocationsCollectionsDataStoresCompletionConfigResource
  get completionConfig =>
      ProjectsLocationsCollectionsDataStoresCompletionConfigResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataStoresCompletionSuggestionsResource
  get completionSuggestions =>
      ProjectsLocationsCollectionsDataStoresCompletionSuggestionsResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataStoresControlsResource get controls =>
      ProjectsLocationsCollectionsDataStoresControlsResource(_requester);
  ProjectsLocationsCollectionsDataStoresConversationsResource
  get conversations =>
      ProjectsLocationsCollectionsDataStoresConversationsResource(_requester);
  ProjectsLocationsCollectionsDataStoresCustomModelsResource get customModels =>
      ProjectsLocationsCollectionsDataStoresCustomModelsResource(_requester);
  ProjectsLocationsCollectionsDataStoresModelsResource get models =>
      ProjectsLocationsCollectionsDataStoresModelsResource(_requester);
  ProjectsLocationsCollectionsDataStoresOperationsResource get operations =>
      ProjectsLocationsCollectionsDataStoresOperationsResource(_requester);
  ProjectsLocationsCollectionsDataStoresSchemasResource get schemas =>
      ProjectsLocationsCollectionsDataStoresSchemasResource(_requester);
  ProjectsLocationsCollectionsDataStoresServingConfigsResource
  get servingConfigs =>
      ProjectsLocationsCollectionsDataStoresServingConfigsResource(_requester);
  ProjectsLocationsCollectionsDataStoresSessionsResource get sessions =>
      ProjectsLocationsCollectionsDataStoresSessionsResource(_requester);
  ProjectsLocationsCollectionsDataStoresSiteSearchEngineResource
  get siteSearchEngine =>
      ProjectsLocationsCollectionsDataStoresSiteSearchEngineResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataStoresSuggestionDenyListEntriesResource
  get suggestionDenyListEntries =>
      ProjectsLocationsCollectionsDataStoresSuggestionDenyListEntriesResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataStoresUserEventsResource get userEvents =>
      ProjectsLocationsCollectionsDataStoresUserEventsResource(_requester);
  ProjectsLocationsCollectionsDataStoresWidgetConfigsResource
  get widgetConfigs =>
      ProjectsLocationsCollectionsDataStoresWidgetConfigsResource(_requester);

  ProjectsLocationsCollectionsDataStoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Completes the specified user input with keyword suggestions.
  ///
  /// Request parameters:
  ///
  /// [dataStore] - Required. The parent data store resource name for which the
  /// completion is performed, such as `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [includeTailSuggestions] - Indicates if tail suggestions should be
  /// returned if there are no suggestions that match the full query. Even if
  /// set to true, if there are suggestions that match the full query, those are
  /// returned and no tail suggestions are returned.
  ///
  /// [query] - Required. The typeahead input used to fetch suggestions. Maximum
  /// length is 128 characters.
  ///
  /// [queryModel] - Specifies the autocomplete data model. This overrides any
  /// model specified in the Configuration \> Autocomplete section of the Cloud
  /// console. Currently supported values: * `document` - Using suggestions
  /// generated from user-imported documents. * `search-history` - Using
  /// suggestions generated from the past history of SearchService.Search API
  /// calls. Do not use it when there is no traffic for Search API. *
  /// `user-event` - Using suggestions generated from user-imported search
  /// events. * `document-completable` - Using suggestions taken directly from
  /// user-imported document fields marked as completable. Default values: *
  /// `document` is the default model for regular dataStores. * `search-history`
  /// is the default model for site search dataStores.
  ///
  /// [userPseudoId] - A unique identifier for tracking visitors. For example,
  /// this could be implemented with an HTTP cookie, which should be able to
  /// uniquely identify a visitor on a single device. This unique identifier
  /// should not change if the visitor logs in or out of the website. This field
  /// should NOT have a fixed value such as `unknown_visitor`. This should be
  /// the same identifier as UserEvent.user_pseudo_id and
  /// SearchRequest.user_pseudo_id. The field must be a UTF-8 encoded string
  /// with a length limit of 128 characters. Otherwise, an `INVALID_ARGUMENT`
  /// error is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse>
  completeQuery(
    core.String dataStore, {
    core.bool? includeTailSuggestions,
    core.String? query,
    core.String? queryModel,
    core.String? userPseudoId,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (includeTailSuggestions != null)
        'includeTailSuggestions': ['${includeTailSuggestions}'],
      if (query != null) 'query': [query],
      if (queryModel != null) 'queryModel': [queryModel],
      if (userPseudoId != null) 'userPseudoId': [userPseudoId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$dataStore') + ':completeQuery';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a DataStore.
  ///
  /// DataStore is for storing Documents. To serve these documents for Search,
  /// or Recommendation use case, an Engine needs to be created separately.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [cmekConfigName] - Resource name of the CmekConfig to use for protecting
  /// this DataStore.
  ///
  /// [createAdvancedSiteSearch] - A boolean flag indicating whether user want
  /// to directly create an advanced data store for site search. If the data
  /// store is not configured as site search (GENERIC vertical and
  /// PUBLIC_WEBSITE content_config), this flag will be ignored.
  ///
  /// [dataStoreId] - Required. The ID to use for the DataStore, which will
  /// become the final component of the DataStore's resource name. This field
  /// must conform to \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard
  /// with a length limit of 63 characters. Otherwise, an INVALID_ARGUMENT error
  /// is returned.
  ///
  /// [disableCmek] - DataStore without CMEK protections. If a default
  /// CmekConfig is set for the project, setting this field will override the
  /// default CmekConfig as well.
  ///
  /// [skipDefaultSchemaCreation] - A boolean flag indicating whether to skip
  /// the default schema creation for the data store. Only enable this flag if
  /// you are certain that the default schema is incompatible with your use
  /// case. If set to true, you must manually create a schema for the data store
  /// before any documents can be ingested. This flag cannot be specified if
  /// `data_store.starting_schema` is specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaDataStore request,
    core.String parent, {
    core.String? cmekConfigName,
    core.bool? createAdvancedSiteSearch,
    core.String? dataStoreId,
    core.bool? disableCmek,
    core.bool? skipDefaultSchemaCreation,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (cmekConfigName != null) 'cmekConfigName': [cmekConfigName],
      if (createAdvancedSiteSearch != null)
        'createAdvancedSiteSearch': ['${createAdvancedSiteSearch}'],
      if (dataStoreId != null) 'dataStoreId': [dataStoreId],
      if (disableCmek != null) 'disableCmek': ['${disableCmek}'],
      if (skipDefaultSchemaCreation != null)
        'skipDefaultSchemaCreation': ['${skipDefaultSchemaCreation}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/dataStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a DataStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of DataStore, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// If the caller does not have permission to delete the DataStore, regardless
  /// of whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// DataStore to delete does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a DataStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of DataStore, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// If the caller does not have permission to access the DataStore, regardless
  /// of whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// requested DataStore does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDataStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDataStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDataStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a DocumentProcessingConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full DocumentProcessingConfig resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/documentProcessingConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig>
  getDocumentProcessingConfig(core.String name, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the SiteSearchEngine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Resource name of SiteSearchEngine, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// If the caller does not have permission to access the \[SiteSearchEngine\],
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSiteSearchEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSiteSearchEngine>
  getSiteSearchEngine(core.String name, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSiteSearchEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all the DataStores associated with the project.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}`. If
  /// the caller does not have permission to list DataStores under this
  /// location, regardless of whether or not this data store exists, a
  /// PERMISSION_DENIED error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [filter] - Filter by solution type . For example: `filter =
  /// 'solution_type:SOLUTION_TYPE_SEARCH'`
  ///
  /// [pageSize] - Maximum number of DataStores to return. If unspecified,
  /// defaults to 10. The maximum allowed value is 50. Values above 50 will be
  /// coerced to 50. If this field is negative, an INVALID_ARGUMENT is returned.
  ///
  /// [pageToken] - A page token ListDataStoresResponse.next_page_token,
  /// received from a previous DataStoreService.ListDataStores call. Provide
  /// this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to DataStoreService.ListDataStores must match the call
  /// that provided the page token. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListDataStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListDataStoresResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/dataStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListDataStoresResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a DataStore
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Identifier. The full resource name of the data store.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided DataStore to update.
  /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
  /// is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDataStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDataStore> patch(
    GoogleCloudDiscoveryengineV1alphaDataStore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDataStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Trains a custom model.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [dataStore] - Required. The resource name of the Data Store, such as
  /// `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store`.
  /// This field is used to identify the data store where to train the models.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> trainCustomModel(
    GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequest request,
    core.String dataStore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$dataStore') + ':trainCustomModel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the DocumentProcessingConfig.
  ///
  /// DocumentProcessingConfig is a singleon resource of DataStore. It's empty
  /// when DataStore is created. The first call to this method will set up
  /// DocumentProcessingConfig.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The full resource name of the Document Processing Config. Format:
  /// `projects / * /locations / * /collections / * /dataStores / *
  /// /documentProcessingConfig`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/documentProcessingConfig$`.
  ///
  /// [updateMask] - Indicates which fields in the provided
  /// DocumentProcessingConfig to update. The following are the only supported
  /// fields: * DocumentProcessingConfig.ocr_config If not set, all supported
  /// fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig>
  updateDocumentProcessingConfig(
    GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresBranchesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresBranchesDocumentsResource
  get documents =>
      ProjectsLocationsCollectionsDataStoresBranchesDocumentsResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataStoresBranchesOperationsResource
  get operations =>
      ProjectsLocationsCollectionsDataStoresBranchesOperationsResource(
        _requester,
      );

  ProjectsLocationsCollectionsDataStoresBranchesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets index freshness metadata for Documents.
  ///
  /// Supported for website search only.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [matcher_fhirMatcher_fhirResources] - Required. The FHIR resources to
  /// match by. Format:
  /// projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}/fhir/{resource_type}/{fhir_resource_id}
  ///
  /// [matcher_urisMatcher_uris] - The exact URIs to match by.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse
  >
  batchGetDocumentsMetadata(
    core.String parent, {
    core.List<core.String>? matcher_fhirMatcher_fhirResources,
    core.List<core.String>? matcher_urisMatcher_uris,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (matcher_fhirMatcher_fhirResources != null)
        'matcher.fhirMatcher.fhirResources': matcher_fhirMatcher_fhirResources,
      if (matcher_urisMatcher_uris != null)
        'matcher.urisMatcher.uris': matcher_urisMatcher_uris,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/batchGetDocumentsMetadata';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresBranchesDocumentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresBranchesDocumentsChunksResource
  get chunks =>
      ProjectsLocationsCollectionsDataStoresBranchesDocumentsChunksResource(
        _requester,
      );

  ProjectsLocationsCollectionsDataStoresBranchesDocumentsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Document.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [documentId] - Required. The ID to use for the Document, which becomes the
  /// final component of the Document.name. If the caller does not have
  /// permission to create the Document, regardless of whether or not it exists,
  /// a `PERMISSION_DENIED` error is returned. This field must be unique among
  /// all Documents with the same parent. Otherwise, an `ALREADY_EXISTS` error
  /// is returned. This field must conform to
  /// \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a length
  /// limit of 128 characters. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocument> create(
    GoogleCloudDiscoveryengineV1alphaDocument request,
    core.String parent, {
    core.String? documentId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (documentId != null) 'documentId': [documentId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Document, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to delete the Document, regardless
  /// of whether or not it exists, a `PERMISSION_DENIED` error is returned. If
  /// the Document to delete does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Document, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to access the Document, regardless
  /// of whether or not it exists, a `PERMISSION_DENIED` error is returned. If
  /// the requested Document does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocument> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the parsed layout information for a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Document, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to access the Document, regardless
  /// of whether or not it exists, a `PERMISSION_DENIED` error is returned. If
  /// the requested Document does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [imageId] - Optional. Specifies config for IMAGE_BYTES.
  ///
  /// [processedDocumentFormat] - What format output should be. If unspecified,
  /// defaults to JSON.
  /// Possible string values are:
  /// - "PROCESSED_DOCUMENT_FORMAT_UNSPECIFIED" : Default value.
  /// - "JSON" : Output format is a JSON string representation of processed
  /// document.
  ///
  /// [processedDocumentType] - Required. What type of processing to return.
  /// Possible string values are:
  /// - "PROCESSED_DOCUMENT_TYPE_UNSPECIFIED" : Default value.
  /// - "PARSED_DOCUMENT" : Available for all data store parsing configs.
  /// - "CHUNKED_DOCUMENT" : Only available if ChunkingConfig is enabled on the
  /// data store.
  /// - "IMAGE_CONVERTED_DOCUMENT" : Returns the converted Image bytes (as JPEG
  /// or PNG) if available.
  /// - "IMAGE_BYTES" : Return image bytes in base64 encoded format if image_id
  /// of a document is provided, only supported for enabling
  /// shareholder-structure in layout parsing config for now.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaProcessedDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaProcessedDocument>
  getProcessedDocument(
    core.String name, {
    core.String? imageId,
    core.String? processedDocumentFormat,
    core.String? processedDocumentType,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (imageId != null) 'imageId': [imageId],
      if (processedDocumentFormat != null)
        'processedDocumentFormat': [processedDocumentFormat],
      if (processedDocumentType != null)
        'processedDocumentType': [processedDocumentType],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$name') + ':getProcessedDocument';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaProcessedDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bulk import of multiple Documents.
  ///
  /// Request processing may be synchronous. Non-existing items are created.
  /// Note: It is possible for a subset of the Documents to be successfully
  /// updated.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Requires create/update permission.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportDocumentsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Documents.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Use `default_branch` as the branch ID, to list documents under the default
  /// branch. If the caller does not have permission to list Documents under
  /// this branch, regardless of whether or not this branch exists, a
  /// `PERMISSION_DENIED` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of Documents to return. If unspecified,
  /// defaults to 100. The maximum allowed value is 1000. Values above 1000 are
  /// set to 1000. If this field is negative, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [pageToken] - A page token ListDocumentsResponse.next_page_token, received
  /// from a previous DocumentService.ListDocuments call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to DocumentService.ListDocuments must match the call that
  /// provided the page token. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListDocumentsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListDocumentsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListDocumentsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Document.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The full resource name of the document. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to `true` and the Document is not found, a new
  /// Document is be created.
  ///
  /// [updateMask] - Indicates which fields in the provided imported 'document'
  /// to update. If not set, by default updates all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocument> patch(
    GoogleCloudDiscoveryengineV1alphaDocument request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Permanently deletes all selected Documents in a branch.
  ///
  /// This process is asynchronous. Depending on the number of Documents to be
  /// deleted, this operation can take hours to complete. Before the delete
  /// operation completes, some Documents might still be returned by
  /// DocumentService.GetDocument or DocumentService.ListDocuments. To get a
  /// list of the Documents to be deleted, set PurgeDocumentsRequest.force to
  /// false.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresBranchesDocumentsChunksResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresBranchesDocumentsChunksResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Chunk, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}/chunks/{chunk}`.
  /// If the caller does not have permission to access the Chunk, regardless of
  /// whether or not it exists, a `PERMISSION_DENIED` error is returned. If the
  /// requested Chunk does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+/chunks/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaChunk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaChunk> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaChunk.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Chunks.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent document resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to list Chunks under this document,
  /// regardless of whether or not this document exists, a `PERMISSION_DENIED`
  /// error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of Chunks to return. If unspecified, defaults
  /// to 100. The maximum allowed value is 1000. Values above 1000 will be
  /// coerced to 1000. If this field is negative, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [pageToken] - A page token ListChunksResponse.next_page_token, received
  /// from a previous ChunkService.ListChunks call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// ChunkService.ListChunks must match the call that provided the page token.
  /// Otherwise, an `INVALID_ARGUMENT` error is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListChunksResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListChunksResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/chunks';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListChunksResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresBranchesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresBranchesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleLongrunningCancelOperationRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresCompletionConfigResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresCompletionConfigResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Completes the user input with advanced keyword suggestions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [completionConfig] - Required. The completion_config of the parent
  /// dataStore or engine resource name for which the completion is performed,
  /// such as `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /completionConfig` `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /completionConfig`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/completionConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse>
  completeQuery(
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequest request,
    core.String completionConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$completionConfig') +
        ':completeQuery';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresCompletionSuggestionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresCompletionSuggestionsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Imports CompletionSuggestions for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// import customer autocomplete suggestions. Follows pattern `projects / *
  /// /locations / * /collections / * /dataStores / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/completionSuggestions:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Permanently deletes all CompletionSuggestions for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// purge completion suggestions. Follows pattern projects / * /locations / *
  /// /collections / * /dataStores / * .
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeCompletionSuggestionsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/completionSuggestions:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresControlsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresControlsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Control.
  ///
  /// By default 1000 controls are allowed for a data store. A request can be
  /// submitted to adjust this limit. If the Control to create already exists,
  /// an ALREADY_EXISTS error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [controlId] - Required. The ID to use for the Control, which will become
  /// the final component of the Control's resource name. This value must be
  /// within 1-63 characters. Valid characters are /a-z-_/.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> create(
    GoogleCloudDiscoveryengineV1alphaControl request,
    core.String parent, {
    core.String? controlId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (controlId != null) 'controlId': [controlId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/controls';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Control.
  ///
  /// If the Control to delete does not exist, a NOT_FOUND error is returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Control to delete. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Control.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Control to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Controls by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - Optional. A filter to apply on the list results. Supported
  /// features: * List all the products under the parent branch if filter is
  /// unset. Currently this field is unsupported.
  ///
  /// [pageSize] - Optional. Maximum number of results to return. If
  /// unspecified, defaults to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListControls` call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListControlsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListControlsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/controls';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListControlsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Control.
  ///
  /// Control action type cannot be changed. If the Control to update does not
  /// exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name `projects / *
  /// /locations/global/dataStore / * /controls / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Indicates which fields in the provided Control to
  /// update. The following are NOT supported: * Control.name *
  /// Control.solution_type If not set or empty, all supported fields are
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> patch(
    GoogleCloudDiscoveryengineV1alphaControl request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresConversationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresConversationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Converses a conversation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`.
  /// Use
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/-`
  /// to activate auto session mode, which automatically creates a new
  /// conversation inside a ConverseConversation session.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaConverseConversationResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConverseConversationResponse>
  converse(
    GoogleCloudDiscoveryengineV1alphaConverseConversationRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':converse';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConverseConversationResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a Conversation.
  ///
  /// If the Conversation to create already exists, an ALREADY_EXISTS error is
  /// returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> create(
    GoogleCloudDiscoveryengineV1alphaConversation request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/conversations';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Conversation.
  ///
  /// If the Conversation to delete does not exist, a NOT_FOUND error is
  /// returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Conversation.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Conversations by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - A filter to apply on the list results. The supported features
  /// are: user_pseudo_id, state. Example: "user_pseudo_id = some_id"
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `update_time` * `create_time` * `conversation_name` Example:
  /// "update_time desc" "create_time"
  ///
  /// [pageSize] - Maximum number of results to return. If unspecified, defaults
  /// to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - A page token, received from a previous `ListConversations`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListConversationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListConversationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/conversations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListConversationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Conversation.
  ///
  /// Conversation action type cannot be changed. If the Conversation to update
  /// does not exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/dataStore /
  /// * /conversations / * ` or
  /// `projects/{project}/locations/global/collections/{collection}/engines / *
  /// /conversations / * `.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided Conversation to
  /// update. The following are NOT supported: * Conversation.name If not set or
  /// empty, all supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> patch(
    GoogleCloudDiscoveryengineV1alphaConversation request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresCustomModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresCustomModelsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a list of all the custom models.
  ///
  /// Request parameters:
  ///
  /// [dataStore] - Required. The resource name of the parent Data Store, such
  /// as `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store`.
  /// This field is used to identify the data store where to fetch the models
  /// from.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListCustomModelsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListCustomModelsResponse> list(
    core.String dataStore, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$dataStore') + '/customModels';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListCustomModelsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresModelsOperationsResource
  get operations =>
      ProjectsLocationsCollectionsDataStoresModelsOperationsResource(
        _requester,
      );

  ProjectsLocationsCollectionsDataStoresModelsResource(
    commons.ApiRequester client,
  ) : _requester = client;
}

class ProjectsLocationsCollectionsDataStoresModelsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresModelsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSchemasResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSchemasOperationsResource
  get operations =>
      ProjectsLocationsCollectionsDataStoresSchemasOperationsResource(
        _requester,
      );

  ProjectsLocationsCollectionsDataStoresSchemasResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Schema.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [schemaId] - Required. The ID to use for the Schema, which becomes the
  /// final component of the Schema.name. This field should conform to
  /// \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a length
  /// limit of 63 characters.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaSchema request,
    core.String parent, {
    core.String? schemaId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (schemaId != null) 'schemaId': [schemaId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/schemas';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Schema.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Schema.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSchema> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSchema.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Schemas.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Schemas to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Schemas are
  /// returned. The maximum value is 1000; values above 1000 are set to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// SchemaService.ListSchemas call. Provide this to retrieve the subsequent
  /// page. When paginating, all other parameters provided to
  /// SchemaService.ListSchemas must match the call that provided the page
  /// token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListSchemasResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListSchemasResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/schemas';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListSchemasResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Schema.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Schema is not found, a new Schema
  /// is created. In this situation, `update_mask` is ignored.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudDiscoveryengineV1alphaSchema request,
    core.String name, {
    core.bool? allowMissing,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSchemasOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSchemasOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresServingConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresServingConfigsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Answer query method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /servingConfigs/default_serving_config`. This field is used to identify
  /// the serving configuration name, set of models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse> answer(
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':answer';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a ServingConfig.
  ///
  /// Returns a NotFound error if the ServingConfig does not exist.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ServingConfig to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaServingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaServingConfig> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all ServingConfigs linked to this dataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of the parent resource. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. Maximum number of results to return. If
  /// unspecified, defaults to 100. If a value greater than 100 is provided, at
  /// most 100 results are returned.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListServingConfigs` call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse>
  list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/servingConfigs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a ServingConfig.
  ///
  /// Returns a NOT_FOUND error if the ServingConfig does not exist.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided ServingConfig to
  /// update. The following are NOT supported: * ServingConfig.name If not set,
  /// all supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaServingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaServingConfig> patch(
    GoogleCloudDiscoveryengineV1alphaServingConfig request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Makes a recommendation, which requires a contextual user event.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. Full resource name of a ServingConfig:
  /// `projects / * /locations/global/collections / * /engines / *
  /// /servingConfigs / * `, or `projects / * /locations/global/collections / *
  /// /dataStores / * /servingConfigs / * ` One default serving config is
  /// created along with your recommendation engine creation. The engine ID is
  /// used as the ID of the default serving config. For example, for Engine
  /// `projects / * /locations/global/collections / * /engines/my-engine`, you
  /// can use `projects / * /locations/global/collections / *
  /// /engines/my-engine/servingConfigs/my-engine` for your
  /// RecommendationService.Recommend requests.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaRecommendResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaRecommendResponse> recommend(
    GoogleCloudDiscoveryengineV1alphaRecommendRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':recommend';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaRecommendResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Performs a search.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
  /// This field is used to identify the serving configuration name, set of
  /// models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSearchResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSearchResponse> search(
    GoogleCloudDiscoveryengineV1alphaSearchRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':search';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSearchResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Performs a search.
  ///
  /// Similar to the SearchService.Search method, but a lite version that allows
  /// API key for authentication, where OAuth and IAM checks are not required.
  /// Only public website search is supported by this method. If data stores and
  /// engines not associated with public website search are specified, a
  /// `FAILED_PRECONDITION` error is returned. This method can be used for easy
  /// onboarding without having to implement an authentication backend. However,
  /// it is strongly recommended to use SearchService.Search instead with
  /// required OAuth and IAM checks to provide better data security.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
  /// This field is used to identify the serving configuration name, set of
  /// models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSearchResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSearchResponse> searchLite(
    GoogleCloudDiscoveryengineV1alphaSearchRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':searchLite';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSearchResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Answer query method (streaming).
  ///
  /// It takes one AnswerQueryRequest and returns multiple AnswerQueryResponse
  /// messages in a stream.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /servingConfigs/default_serving_config`. This field is used to identify
  /// the serving configuration name, set of models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse>
  streamAnswer(
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':streamAnswer';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSessionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSessionsAnswersResource get answers =>
      ProjectsLocationsCollectionsDataStoresSessionsAnswersResource(_requester);

  ProjectsLocationsCollectionsDataStoresSessionsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Session.
  ///
  /// If the Session to create already exists, an ALREADY_EXISTS error is
  /// returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> create(
    GoogleCloudDiscoveryengineV1alphaSession request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Session.
  ///
  /// If the Session to delete does not exist, a NOT_FOUND error is returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Session to delete. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Session to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [includeAnswerDetails] - Optional. If set to true, the full session
  /// including all answer details will be returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> get(
    core.String name, {
    core.bool? includeAnswerDetails,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (includeAnswerDetails != null)
        'includeAnswerDetails': ['${includeAnswerDetails}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Sessions by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - A comma-separated list of fields to filter by, in EBNF grammar.
  /// The supported fields are: * `user_pseudo_id` * `state` * `display_name` *
  /// `starred` * `is_pinned` * `labels` * `create_time` * `update_time`
  /// Examples: * `user_pseudo_id = some_id` * `display_name = "some_name"` *
  /// `starred = true` * `is_pinned=true AND (NOT labels:hidden)` * `create_time
  /// > "1970-01-01T12:00:00Z"`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `update_time` * `create_time` * `session_name` * `is_pinned`
  /// Example: * "update_time desc" * "create_time" * "is_pinned
  /// desc,update_time desc": list sessions by is_pinned first, then by
  /// update_time.
  ///
  /// [pageSize] - Maximum number of results to return. If unspecified, defaults
  /// to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - A page token, received from a previous `ListSessions` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListSessionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListSessionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListSessionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Session.
  ///
  /// Session action type cannot be changed. If the Session to update does not
  /// exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions
  /// / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided Session to update.
  /// The following are NOT supported: * Session.name If not set or empty, all
  /// supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> patch(
    GoogleCloudDiscoveryengineV1alphaSession request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSessionsAnswersResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSessionsAnswersResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a Answer.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Answer to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine_id}/sessions/{session_id}/answers/{answer_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+/answers/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswer].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswer> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswer.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSiteSearchEngineResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSiteSearchEngineOperationsResource
  get operations =>
      ProjectsLocationsCollectionsDataStoresSiteSearchEngineOperationsResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataStoresSiteSearchEngineSitemapsResource
  get sitemaps =>
      ProjectsLocationsCollectionsDataStoresSiteSearchEngineSitemapsResource(
        _requester,
      );
  ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesResource
  get targetSites =>
      ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesResource(
        _requester,
      );

  ProjectsLocationsCollectionsDataStoresSiteSearchEngineResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Verify target sites' ownership and validity.
  ///
  /// This API sends all the target sites under site search engine for
  /// verification.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource shared by all TargetSites being
  /// verified.
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchVerifyTargetSites(
    GoogleCloudDiscoveryengineV1alphaBatchVerifyTargetSitesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + ':batchVerifyTargetSites';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Downgrade from advanced site search to basic site search.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as
  /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> disableAdvancedSiteSearch(
    GoogleCloudDiscoveryengineV1alphaDisableAdvancedSiteSearchRequest request,
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$siteSearchEngine') +
        ':disableAdvancedSiteSearch';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Upgrade from basic site search to advanced site search.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as
  /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> enableAdvancedSiteSearch(
    GoogleCloudDiscoveryengineV1alphaEnableAdvancedSiteSearchRequest request,
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$siteSearchEngine') +
        ':enableAdvancedSiteSearch';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Returns list of target sites with its domain verification status.
  ///
  /// This method can only be called under data store with BASIC_SITE_SEARCH
  /// state at the moment.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. The site search engine resource under which
  /// we fetch all the domain verification status.
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [pageSize] - Requested page size. Server may return fewer items than
  /// requested. If unspecified, server will pick an appropriate default. The
  /// maximum value is 1000; values above 1000 will be coerced to 1000. If this
  /// field is negative, an INVALID_ARGUMENT error is returned.
  ///
  /// [pageToken] - A page token, received from a previous
  /// `FetchDomainVerificationStatus` call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// `FetchDomainVerificationStatus` must match the call that provided the page
  /// token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaFetchDomainVerificationStatusResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudDiscoveryengineV1alphaFetchDomainVerificationStatusResponse
  >
  fetchDomainVerificationStatus(
    core.String siteSearchEngine, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$siteSearchEngine') +
        ':fetchDomainVerificationStatus';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaFetchDomainVerificationStatusResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the URI Pattern to Document data mapping for an Advanced Site Search
  /// DataStore.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaGetUriPatternDocumentDataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudDiscoveryengineV1alphaGetUriPatternDocumentDataResponse
  >
  getUriPatternDocumentData(
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$siteSearchEngine') +
        ':getUriPatternDocumentData';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaGetUriPatternDocumentDataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Request on-demand recrawl for a list of URIs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> recrawlUris(
    GoogleCloudDiscoveryengineV1alphaRecrawlUrisRequest request,
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$siteSearchEngine') + ':recrawlUris';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Sets the URI Pattern to Document data mapping for an Advanced Site Search
  /// DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> setUriPatternDocumentData(
    GoogleCloudDiscoveryengineV1alphaSetUriPatternDocumentDataRequest request,
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$siteSearchEngine') +
        ':setUriPatternDocumentData';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSiteSearchEngineOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSiteSearchEngineOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSiteSearchEngineSitemapsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSiteSearchEngineSitemapsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Sitemap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent resource name of the SiteSearchEngine, such as
  /// `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaSitemap request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sitemaps';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Sitemap.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Sitemap, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/sitemaps/{sitemap}`.
  /// If the caller does not have permission to access the Sitemap, regardless
  /// of whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// requested Sitemap does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/sitemaps/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetch Sitemaps in a DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent resource name of the SiteSearchEngine, such as
  /// `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [matcher_urisMatcher_uris] - The Sitemap uris.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse> fetch(
    core.String parent, {
    core.List<core.String>? matcher_urisMatcher_uris,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (matcher_urisMatcher_uris != null)
        'matcher.urisMatcher.uris': matcher_urisMatcher_uris,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/sitemaps:fetch';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesOperationsResource
  get operations =>
      ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesOperationsResource(
        _requester,
      );

  ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates TargetSite in a batch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource shared by all TargetSites being
  /// created.
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// The parent field in the CreateBookRequest messages must either be empty or
  /// match this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCreate(
    GoogleCloudDiscoveryengineV1alphaBatchCreateTargetSitesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/targetSites:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a TargetSite.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent resource name of TargetSite, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaTargetSite request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/targetSites';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a TargetSite.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of TargetSite, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
  /// If the caller does not have permission to access the TargetSite,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned. If the requested TargetSite does not exist, a NOT_FOUND error is
  /// returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a TargetSite.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of TargetSite, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
  /// If the caller does not have permission to access the TargetSite,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned. If the requested TargetSite does not exist, a NOT_FOUND error is
  /// returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaTargetSite].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaTargetSite> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaTargetSite.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of TargetSites.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent site search engine resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// If the caller does not have permission to list TargetSites under this site
  /// search engine, regardless of whether or not this branch exists, a
  /// PERMISSION_DENIED error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [pageSize] - Requested page size. Server may return fewer items than
  /// requested. If unspecified, server will pick an appropriate default. The
  /// maximum value is 1000; values above 1000 will be coerced to 1000. If this
  /// field is negative, an INVALID_ARGUMENT error is returned.
  ///
  /// [pageToken] - A page token, received from a previous `ListTargetSites`
  /// call. Provide this to retrieve the subsequent page. When paginating, all
  /// other parameters provided to `ListTargetSites` must match the call that
  /// provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/targetSites';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a TargetSite.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The fully qualified resource name of the target
  /// site.
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`
  /// The `target_site_id` is system-generated.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudDiscoveryengineV1alphaTargetSite request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSiteSearchEngineTargetSitesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresSuggestionDenyListEntriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresSuggestionDenyListEntriesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Imports all SuggestionDenyListEntry for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// import denylist entries. Follows pattern projects / * /locations / *
  /// /collections / * /dataStores / * .
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequest
    request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/suggestionDenyListEntries:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Permanently deletes all SuggestionDenyListEntry for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// import denylist entries. Follows pattern projects / * /locations / *
  /// /collections / * /dataStores / * .
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeSuggestionDenyListEntriesRequest
    request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/suggestionDenyListEntries:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresUserEventsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresUserEventsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Writes a single user event from the browser.
  ///
  /// This uses a GET request to due to browser restriction of POST-ing to a
  /// third-party domain. This method is used only by the Discovery Engine API
  /// JavaScript pixel and Google Tag Manager. Users should not call this method
  /// directly.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name. If the collect user event
  /// action is applied in DataStore level, the format is:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// If the collect user event action is applied in Location level, for
  /// example, the event with Document across multiple DataStore, the format is:
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [ets] - The event timestamp in milliseconds. This prevents browser caching
  /// of otherwise identical get requests. The name is abbreviated to reduce the
  /// payload bytes.
  ///
  /// [uri] - The URL including cgi-parameters but excluding the hash fragment
  /// with a length limit of 5,000 characters. This is often more useful than
  /// the referer URL, because many browsers only send the domain for
  /// third-party requests.
  ///
  /// [userEvent] - Required. URL encoded UserEvent proto with a length limit of
  /// 2,000,000 characters.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> collect(
    core.String parent, {
    core.String? ets,
    core.String? uri,
    core.String? userEvent,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (ets != null) 'ets': [ets],
      if (uri != null) 'uri': [uri],
      if (userEvent != null) 'userEvent': [userEvent],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:collect';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bulk import of user events.
  ///
  /// Request processing might be synchronous. Events that already exist are
  /// skipped. Use this method for backfilling historical user events.
  /// Operation.response is of type ImportResponse. Note that it is possible for
  /// a subset of the items to be successfully inserted. Operation.metadata is
  /// of type ImportMetadata.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent DataStore resource name, of the form
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportUserEventsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes permanently all user events specified by the filter provided.
  ///
  /// Depending on the number of events specified by the filter, this operation
  /// could take hours or days to complete. To test a filter, use the list
  /// command first.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the catalog under which the
  /// events are created. The format is
  /// `projects/{project}/locations/global/collections/{collection}/dataStores/{dataStore}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeUserEventsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Writes a single user event.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name. If the write user event
  /// action is applied in DataStore level, the format is:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// If the write user event action is applied in Location level, for example,
  /// the event with Document across multiple DataStore, the format is:
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [writeAsync] - If set to true, the user event is written asynchronously
  /// after validation, and the API responds without waiting for the write.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaUserEvent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaUserEvent> write(
    GoogleCloudDiscoveryengineV1alphaUserEvent request,
    core.String parent, {
    core.bool? writeAsync,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (writeAsync != null) 'writeAsync': ['${writeAsync}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaUserEvent.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsDataStoresWidgetConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsDataStoresWidgetConfigsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a WidgetConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full WidgetConfig resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/widgetConfigs/{widget_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/dataStores/\[^/\]+/widgetConfigs/\[^/\]+$`.
  ///
  /// [acceptCache] - Optional. Whether it's acceptable to load the widget
  /// config from cache. If set to true, recent changes on widget configs may
  /// take a few minutes to reflect on the end user's view. It's recommended to
  /// set to true for maturely developed widgets, as it improves widget
  /// performance. Set to false to see changes reflected in prod right away, if
  /// your widget is under development.
  ///
  /// [getWidgetConfigRequestOption_turnOffCollectionComponents] - Optional.
  /// Whether to turn off collection_components in WidgetConfig to reduce
  /// latency and data transmission.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaWidgetConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaWidgetConfig> get(
    core.String name, {
    core.bool? acceptCache,
    core.bool? getWidgetConfigRequestOption_turnOffCollectionComponents,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (acceptCache != null) 'acceptCache': ['${acceptCache}'],
      if (getWidgetConfigRequestOption_turnOffCollectionComponents != null)
        'getWidgetConfigRequestOption.turnOffCollectionComponents': [
          '${getWidgetConfigRequestOption_turnOffCollectionComponents}',
        ],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaWidgetConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesAnalyticsResource get analytics =>
      ProjectsLocationsCollectionsEnginesAnalyticsResource(_requester);
  ProjectsLocationsCollectionsEnginesAssistantsResource get assistants =>
      ProjectsLocationsCollectionsEnginesAssistantsResource(_requester);
  ProjectsLocationsCollectionsEnginesCompletionConfigResource
  get completionConfig =>
      ProjectsLocationsCollectionsEnginesCompletionConfigResource(_requester);
  ProjectsLocationsCollectionsEnginesControlsResource get controls =>
      ProjectsLocationsCollectionsEnginesControlsResource(_requester);
  ProjectsLocationsCollectionsEnginesConversationsResource get conversations =>
      ProjectsLocationsCollectionsEnginesConversationsResource(_requester);
  ProjectsLocationsCollectionsEnginesOperationsResource get operations =>
      ProjectsLocationsCollectionsEnginesOperationsResource(_requester);
  ProjectsLocationsCollectionsEnginesServingConfigsResource
  get servingConfigs =>
      ProjectsLocationsCollectionsEnginesServingConfigsResource(_requester);
  ProjectsLocationsCollectionsEnginesSessionsResource get sessions =>
      ProjectsLocationsCollectionsEnginesSessionsResource(_requester);
  ProjectsLocationsCollectionsEnginesWidgetConfigsResource get widgetConfigs =>
      ProjectsLocationsCollectionsEnginesWidgetConfigsResource(_requester);

  ProjectsLocationsCollectionsEnginesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a Engine.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [engineId] - Required. The ID to use for the Engine, which will become the
  /// final component of the Engine's resource name. This field must conform to
  /// \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a length
  /// limit of 63 characters. Otherwise, an INVALID_ARGUMENT error is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaEngine request,
    core.String parent, {
    core.String? engineId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (engineId != null) 'engineId': [engineId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/engines';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Engine, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// If the caller does not have permission to delete the Engine, regardless of
  /// whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// Engine to delete does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Engine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Engine, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaEngine> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all the Engines associated with the project.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [filter] - Optional. Filter by solution type. For example:
  /// solution_type=SOLUTION_TYPE_SEARCH
  ///
  /// [pageSize] - Optional. Not supported.
  ///
  /// [pageToken] - Optional. Not supported.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListEnginesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListEnginesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/engines';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListEnginesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an Engine
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Identifier. The fully qualified resource name of the
  /// engine. This field must be a UTF-8 encoded string with a length limit of
  /// 1024 characters. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  /// engine should be 1-63 characters, and valid characters are /a-z0-9 * / .
  /// Otherwise, an INVALID_ARGUMENT error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided Engine to update. If
  /// an unsupported or unknown field is provided, an INVALID_ARGUMENT error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaEngine> patch(
    GoogleCloudDiscoveryengineV1alphaEngine request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Pauses the training of an existing engine.
  ///
  /// Only applicable if SolutionType is SOLUTION_TYPE_RECOMMENDATION.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the engine to pause. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaEngine> pause(
    GoogleCloudDiscoveryengineV1alphaPauseEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':pause';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Resumes the training of an existing engine.
  ///
  /// Only applicable if SolutionType is SOLUTION_TYPE_RECOMMENDATION.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the engine to resume. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaEngine> resume(
    GoogleCloudDiscoveryengineV1alphaResumeEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':resume';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Tunes an existing engine.
  ///
  /// Only applicable if SolutionType is SOLUTION_TYPE_RECOMMENDATION.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the engine to tune. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> tune(
    GoogleCloudDiscoveryengineV1alphaTuneEngineRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':tune';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesAnalyticsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesAnalyticsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Exports metrics.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [analytics] - Required. The analytics resource name under the engine where
  /// the metrics are created. The format is
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/analytics`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/analytics$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> exportMetrics(
    GoogleCloudDiscoveryengineV1alphaExportMetricsRequest request,
    core.String analytics, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$analytics') + ':exportMetrics';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesAssistantsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesAssistantsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets an Assistant.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Resource name of Assistant. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/assistants/{assistant}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/assistants/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAssistant].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAssistant> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAssistant.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates an Assistant
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Resource name of the assistant. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/assistants/{assistant}`
  /// It must be a UTF-8 encoded string with a length limit of 1024 characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/assistants/\[^/\]+$`.
  ///
  /// [updateMask] - The list of fields to update.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAssistant].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAssistant> patch(
    GoogleCloudDiscoveryengineV1alphaAssistant request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAssistant.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Assists the user with a query in a streaming fashion.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Assistant. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/assistants/{assistant}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/assistants/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaStreamAssistResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaStreamAssistResponse>
  streamAssist(
    GoogleCloudDiscoveryengineV1alphaStreamAssistRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':streamAssist';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaStreamAssistResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesCompletionConfigResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesCompletionConfigResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Completes the user input with advanced keyword suggestions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [completionConfig] - Required. The completion_config of the parent
  /// dataStore or engine resource name for which the completion is performed,
  /// such as `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /completionConfig` `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /completionConfig`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/completionConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse>
  completeQuery(
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequest request,
    core.String completionConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$completionConfig') +
        ':completeQuery';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Removes the search history suggestion in an engine for a user.
  ///
  /// This will remove the suggestion from being returned in the
  /// AdvancedCompleteQueryResponse.recent_search_suggestions for this user. If
  /// the user searches the same suggestion again, the new history will override
  /// and suggest this suggestion again.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [completionConfig] - Required. The completion_config of the parent engine
  /// resource name for which the search history suggestion is to be removed,
  /// such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /completionConfig`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/completionConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaRemoveSuggestionResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaRemoveSuggestionResponse>
  removeSuggestion(
    GoogleCloudDiscoveryengineV1alphaRemoveSuggestionRequest request,
    core.String completionConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$completionConfig') +
        ':removeSuggestion';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaRemoveSuggestionResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesControlsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesControlsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Control.
  ///
  /// By default 1000 controls are allowed for a data store. A request can be
  /// submitted to adjust this limit. If the Control to create already exists,
  /// an ALREADY_EXISTS error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [controlId] - Required. The ID to use for the Control, which will become
  /// the final component of the Control's resource name. This value must be
  /// within 1-63 characters. Valid characters are /a-z-_/.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> create(
    GoogleCloudDiscoveryengineV1alphaControl request,
    core.String parent, {
    core.String? controlId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (controlId != null) 'controlId': [controlId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/controls';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Control.
  ///
  /// If the Control to delete does not exist, a NOT_FOUND error is returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Control to delete. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Control.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Control to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Controls by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [filter] - Optional. A filter to apply on the list results. Supported
  /// features: * List all the products under the parent branch if filter is
  /// unset. Currently this field is unsupported.
  ///
  /// [pageSize] - Optional. Maximum number of results to return. If
  /// unspecified, defaults to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListControls` call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListControlsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListControlsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/controls';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListControlsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Control.
  ///
  /// Control action type cannot be changed. If the Control to update does not
  /// exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name `projects / *
  /// /locations/global/dataStore / * /controls / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Indicates which fields in the provided Control to
  /// update. The following are NOT supported: * Control.name *
  /// Control.solution_type If not set or empty, all supported fields are
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> patch(
    GoogleCloudDiscoveryengineV1alphaControl request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesConversationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesConversationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Converses a conversation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`.
  /// Use
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/-`
  /// to activate auto session mode, which automatically creates a new
  /// conversation inside a ConverseConversation session.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaConverseConversationResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConverseConversationResponse>
  converse(
    GoogleCloudDiscoveryengineV1alphaConverseConversationRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':converse';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConverseConversationResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a Conversation.
  ///
  /// If the Conversation to create already exists, an ALREADY_EXISTS error is
  /// returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> create(
    GoogleCloudDiscoveryengineV1alphaConversation request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/conversations';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Conversation.
  ///
  /// If the Conversation to delete does not exist, a NOT_FOUND error is
  /// returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Conversation.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Conversations by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [filter] - A filter to apply on the list results. The supported features
  /// are: user_pseudo_id, state. Example: "user_pseudo_id = some_id"
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `update_time` * `create_time` * `conversation_name` Example:
  /// "update_time desc" "create_time"
  ///
  /// [pageSize] - Maximum number of results to return. If unspecified, defaults
  /// to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - A page token, received from a previous `ListConversations`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListConversationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListConversationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/conversations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListConversationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Conversation.
  ///
  /// Conversation action type cannot be changed. If the Conversation to update
  /// does not exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/dataStore /
  /// * /conversations / * ` or
  /// `projects/{project}/locations/global/collections/{collection}/engines / *
  /// /conversations / * `.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided Conversation to
  /// update. The following are NOT supported: * Conversation.name If not set or
  /// empty, all supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> patch(
    GoogleCloudDiscoveryengineV1alphaConversation request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesServingConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesServingConfigsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Answer query method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /servingConfigs/default_serving_config`. This field is used to identify
  /// the serving configuration name, set of models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse> answer(
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':answer';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a ServingConfig.
  ///
  /// Returns a NotFound error if the ServingConfig does not exist.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ServingConfig to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaServingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaServingConfig> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all ServingConfigs linked to this dataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of the parent resource. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. Maximum number of results to return. If
  /// unspecified, defaults to 100. If a value greater than 100 is provided, at
  /// most 100 results are returned.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListServingConfigs` call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse>
  list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/servingConfigs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a ServingConfig.
  ///
  /// Returns a NOT_FOUND error if the ServingConfig does not exist.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided ServingConfig to
  /// update. The following are NOT supported: * ServingConfig.name If not set,
  /// all supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaServingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaServingConfig> patch(
    GoogleCloudDiscoveryengineV1alphaServingConfig request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Makes a recommendation, which requires a contextual user event.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. Full resource name of a ServingConfig:
  /// `projects / * /locations/global/collections / * /engines / *
  /// /servingConfigs / * `, or `projects / * /locations/global/collections / *
  /// /dataStores / * /servingConfigs / * ` One default serving config is
  /// created along with your recommendation engine creation. The engine ID is
  /// used as the ID of the default serving config. For example, for Engine
  /// `projects / * /locations/global/collections / * /engines/my-engine`, you
  /// can use `projects / * /locations/global/collections / *
  /// /engines/my-engine/servingConfigs/my-engine` for your
  /// RecommendationService.Recommend requests.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaRecommendResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaRecommendResponse> recommend(
    GoogleCloudDiscoveryengineV1alphaRecommendRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':recommend';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaRecommendResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Performs a search.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
  /// This field is used to identify the serving configuration name, set of
  /// models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSearchResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSearchResponse> search(
    GoogleCloudDiscoveryengineV1alphaSearchRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':search';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSearchResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Performs a search.
  ///
  /// Similar to the SearchService.Search method, but a lite version that allows
  /// API key for authentication, where OAuth and IAM checks are not required.
  /// Only public website search is supported by this method. If data stores and
  /// engines not associated with public website search are specified, a
  /// `FAILED_PRECONDITION` error is returned. This method can be used for easy
  /// onboarding without having to implement an authentication backend. However,
  /// it is strongly recommended to use SearchService.Search instead with
  /// required OAuth and IAM checks to provide better data security.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
  /// This field is used to identify the serving configuration name, set of
  /// models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSearchResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSearchResponse> searchLite(
    GoogleCloudDiscoveryengineV1alphaSearchRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':searchLite';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSearchResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Answer query method (streaming).
  ///
  /// It takes one AnswerQueryRequest and returns multiple AnswerQueryResponse
  /// messages in a stream.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /servingConfigs/default_serving_config`. This field is used to identify
  /// the serving configuration name, set of models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse>
  streamAnswer(
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':streamAnswer';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesSessionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesSessionsAnswersResource get answers =>
      ProjectsLocationsCollectionsEnginesSessionsAnswersResource(_requester);
  ProjectsLocationsCollectionsEnginesSessionsFilesResource get files =>
      ProjectsLocationsCollectionsEnginesSessionsFilesResource(_requester);

  ProjectsLocationsCollectionsEnginesSessionsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Session.
  ///
  /// If the Session to create already exists, an ALREADY_EXISTS error is
  /// returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> create(
    GoogleCloudDiscoveryengineV1alphaSession request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Session.
  ///
  /// If the Session to delete does not exist, a NOT_FOUND error is returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Session to delete. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Session to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [includeAnswerDetails] - Optional. If set to true, the full session
  /// including all answer details will be returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> get(
    core.String name, {
    core.bool? includeAnswerDetails,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (includeAnswerDetails != null)
        'includeAnswerDetails': ['${includeAnswerDetails}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Sessions by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+$`.
  ///
  /// [filter] - A comma-separated list of fields to filter by, in EBNF grammar.
  /// The supported fields are: * `user_pseudo_id` * `state` * `display_name` *
  /// `starred` * `is_pinned` * `labels` * `create_time` * `update_time`
  /// Examples: * `user_pseudo_id = some_id` * `display_name = "some_name"` *
  /// `starred = true` * `is_pinned=true AND (NOT labels:hidden)` * `create_time
  /// > "1970-01-01T12:00:00Z"`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `update_time` * `create_time` * `session_name` * `is_pinned`
  /// Example: * "update_time desc" * "create_time" * "is_pinned
  /// desc,update_time desc": list sessions by is_pinned first, then by
  /// update_time.
  ///
  /// [pageSize] - Maximum number of results to return. If unspecified, defaults
  /// to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - A page token, received from a previous `ListSessions` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListSessionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListSessionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListSessionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Session.
  ///
  /// Session action type cannot be changed. If the Session to update does not
  /// exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions
  /// / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided Session to update.
  /// The following are NOT supported: * Session.name If not set or empty, all
  /// supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> patch(
    GoogleCloudDiscoveryengineV1alphaSession request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesSessionsAnswersResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesSessionsAnswersResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a Answer.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Answer to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine_id}/sessions/{session_id}/answers/{answer_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/sessions/\[^/\]+/answers/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswer].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswer> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswer.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesSessionsFilesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesSessionsFilesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Lists metadata for all files in the current session.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the Session. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}`
  /// Name of the session resource to which the file belong.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [filter] - Optional. The filter syntax consists of an expression language
  /// for constructing a predicate from one or more fields of the files being
  /// filtered. Filter expression is case-sensitive. Currently supported field
  /// names are: * upload_time * last_add_time * last_use_time * file_name *
  /// mime_type Some examples of filters would be: * "file_name = 'file_1'" *
  /// "file_name = 'file_1' AND mime_type = 'text/plain'" * "last_use_time \>
  /// '2025-06-14T12:00:00Z'" For a full description of the filter format,
  /// please see https://google.aip.dev/160.
  ///
  /// [pageSize] - Optional. The maximum number of files to return. The service
  /// may return fewer than this value. If unspecified, at most 100 files will
  /// be returned. The maximum value is 1000; values above 1000 will be coerced
  /// to 1000. If user specifies a value less than or equal to 0 - the request
  /// will be rejected with an INVALID_ARGUMENT error.
  ///
  /// [pageToken] - Optional. A page token received from a previous `ListFiles`
  /// call. Provide this to retrieve the subsequent page. When paginating, all
  /// other parameters provided to `ListFiles` must match the call that provided
  /// the page token (except `page_size`, which may differ).
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListFilesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListFilesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/files';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListFilesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsEnginesWidgetConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsEnginesWidgetConfigsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a WidgetConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full WidgetConfig resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/widgetConfigs/{widget_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/engines/\[^/\]+/widgetConfigs/\[^/\]+$`.
  ///
  /// [acceptCache] - Optional. Whether it's acceptable to load the widget
  /// config from cache. If set to true, recent changes on widget configs may
  /// take a few minutes to reflect on the end user's view. It's recommended to
  /// set to true for maturely developed widgets, as it improves widget
  /// performance. Set to false to see changes reflected in prod right away, if
  /// your widget is under development.
  ///
  /// [getWidgetConfigRequestOption_turnOffCollectionComponents] - Optional.
  /// Whether to turn off collection_components in WidgetConfig to reduce
  /// latency and data transmission.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaWidgetConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaWidgetConfig> get(
    core.String name, {
    core.bool? acceptCache,
    core.bool? getWidgetConfigRequestOption_turnOffCollectionComponents,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (acceptCache != null) 'acceptCache': ['${acceptCache}'],
      if (getWidgetConfigRequestOption_turnOffCollectionComponents != null)
        'getWidgetConfigRequestOption.turnOffCollectionComponents': [
          '${getWidgetConfigRequestOption_turnOffCollectionComponents}',
        ],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaWidgetConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsCollectionsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsCollectionsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/collections/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresBranchesResource get branches =>
      ProjectsLocationsDataStoresBranchesResource(_requester);
  ProjectsLocationsDataStoresCompletionConfigResource get completionConfig =>
      ProjectsLocationsDataStoresCompletionConfigResource(_requester);
  ProjectsLocationsDataStoresCompletionSuggestionsResource
  get completionSuggestions =>
      ProjectsLocationsDataStoresCompletionSuggestionsResource(_requester);
  ProjectsLocationsDataStoresControlsResource get controls =>
      ProjectsLocationsDataStoresControlsResource(_requester);
  ProjectsLocationsDataStoresConversationsResource get conversations =>
      ProjectsLocationsDataStoresConversationsResource(_requester);
  ProjectsLocationsDataStoresModelsResource get models =>
      ProjectsLocationsDataStoresModelsResource(_requester);
  ProjectsLocationsDataStoresOperationsResource get operations =>
      ProjectsLocationsDataStoresOperationsResource(_requester);
  ProjectsLocationsDataStoresSchemasResource get schemas =>
      ProjectsLocationsDataStoresSchemasResource(_requester);
  ProjectsLocationsDataStoresServingConfigsResource get servingConfigs =>
      ProjectsLocationsDataStoresServingConfigsResource(_requester);
  ProjectsLocationsDataStoresSessionsResource get sessions =>
      ProjectsLocationsDataStoresSessionsResource(_requester);
  ProjectsLocationsDataStoresSiteSearchEngineResource get siteSearchEngine =>
      ProjectsLocationsDataStoresSiteSearchEngineResource(_requester);
  ProjectsLocationsDataStoresSuggestionDenyListEntriesResource
  get suggestionDenyListEntries =>
      ProjectsLocationsDataStoresSuggestionDenyListEntriesResource(_requester);
  ProjectsLocationsDataStoresUserEventsResource get userEvents =>
      ProjectsLocationsDataStoresUserEventsResource(_requester);
  ProjectsLocationsDataStoresWidgetConfigsResource get widgetConfigs =>
      ProjectsLocationsDataStoresWidgetConfigsResource(_requester);

  ProjectsLocationsDataStoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Completes the specified user input with keyword suggestions.
  ///
  /// Request parameters:
  ///
  /// [dataStore] - Required. The parent data store resource name for which the
  /// completion is performed, such as `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [includeTailSuggestions] - Indicates if tail suggestions should be
  /// returned if there are no suggestions that match the full query. Even if
  /// set to true, if there are suggestions that match the full query, those are
  /// returned and no tail suggestions are returned.
  ///
  /// [query] - Required. The typeahead input used to fetch suggestions. Maximum
  /// length is 128 characters.
  ///
  /// [queryModel] - Specifies the autocomplete data model. This overrides any
  /// model specified in the Configuration \> Autocomplete section of the Cloud
  /// console. Currently supported values: * `document` - Using suggestions
  /// generated from user-imported documents. * `search-history` - Using
  /// suggestions generated from the past history of SearchService.Search API
  /// calls. Do not use it when there is no traffic for Search API. *
  /// `user-event` - Using suggestions generated from user-imported search
  /// events. * `document-completable` - Using suggestions taken directly from
  /// user-imported document fields marked as completable. Default values: *
  /// `document` is the default model for regular dataStores. * `search-history`
  /// is the default model for site search dataStores.
  ///
  /// [userPseudoId] - A unique identifier for tracking visitors. For example,
  /// this could be implemented with an HTTP cookie, which should be able to
  /// uniquely identify a visitor on a single device. This unique identifier
  /// should not change if the visitor logs in or out of the website. This field
  /// should NOT have a fixed value such as `unknown_visitor`. This should be
  /// the same identifier as UserEvent.user_pseudo_id and
  /// SearchRequest.user_pseudo_id. The field must be a UTF-8 encoded string
  /// with a length limit of 128 characters. Otherwise, an `INVALID_ARGUMENT`
  /// error is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse>
  completeQuery(
    core.String dataStore, {
    core.bool? includeTailSuggestions,
    core.String? query,
    core.String? queryModel,
    core.String? userPseudoId,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (includeTailSuggestions != null)
        'includeTailSuggestions': ['${includeTailSuggestions}'],
      if (query != null) 'query': [query],
      if (queryModel != null) 'queryModel': [queryModel],
      if (userPseudoId != null) 'userPseudoId': [userPseudoId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$dataStore') + ':completeQuery';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a DataStore.
  ///
  /// DataStore is for storing Documents. To serve these documents for Search,
  /// or Recommendation use case, an Engine needs to be created separately.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [cmekConfigName] - Resource name of the CmekConfig to use for protecting
  /// this DataStore.
  ///
  /// [createAdvancedSiteSearch] - A boolean flag indicating whether user want
  /// to directly create an advanced data store for site search. If the data
  /// store is not configured as site search (GENERIC vertical and
  /// PUBLIC_WEBSITE content_config), this flag will be ignored.
  ///
  /// [dataStoreId] - Required. The ID to use for the DataStore, which will
  /// become the final component of the DataStore's resource name. This field
  /// must conform to \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard
  /// with a length limit of 63 characters. Otherwise, an INVALID_ARGUMENT error
  /// is returned.
  ///
  /// [disableCmek] - DataStore without CMEK protections. If a default
  /// CmekConfig is set for the project, setting this field will override the
  /// default CmekConfig as well.
  ///
  /// [skipDefaultSchemaCreation] - A boolean flag indicating whether to skip
  /// the default schema creation for the data store. Only enable this flag if
  /// you are certain that the default schema is incompatible with your use
  /// case. If set to true, you must manually create a schema for the data store
  /// before any documents can be ingested. This flag cannot be specified if
  /// `data_store.starting_schema` is specified.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaDataStore request,
    core.String parent, {
    core.String? cmekConfigName,
    core.bool? createAdvancedSiteSearch,
    core.String? dataStoreId,
    core.bool? disableCmek,
    core.bool? skipDefaultSchemaCreation,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (cmekConfigName != null) 'cmekConfigName': [cmekConfigName],
      if (createAdvancedSiteSearch != null)
        'createAdvancedSiteSearch': ['${createAdvancedSiteSearch}'],
      if (dataStoreId != null) 'dataStoreId': [dataStoreId],
      if (disableCmek != null) 'disableCmek': ['${disableCmek}'],
      if (skipDefaultSchemaCreation != null)
        'skipDefaultSchemaCreation': ['${skipDefaultSchemaCreation}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/dataStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a DataStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of DataStore, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// If the caller does not have permission to delete the DataStore, regardless
  /// of whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// DataStore to delete does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a DataStore.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of DataStore, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// If the caller does not have permission to access the DataStore, regardless
  /// of whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// requested DataStore does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDataStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDataStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDataStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a DocumentProcessingConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full DocumentProcessingConfig resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/documentProcessingConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig>
  getDocumentProcessingConfig(core.String name, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the SiteSearchEngine.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Resource name of SiteSearchEngine, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// If the caller does not have permission to access the \[SiteSearchEngine\],
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSiteSearchEngine].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSiteSearchEngine>
  getSiteSearchEngine(core.String name, {core.String? $fields}) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSiteSearchEngine.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all the DataStores associated with the project.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}`. If
  /// the caller does not have permission to list DataStores under this
  /// location, regardless of whether or not this data store exists, a
  /// PERMISSION_DENIED error is returned.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - Filter by solution type . For example: `filter =
  /// 'solution_type:SOLUTION_TYPE_SEARCH'`
  ///
  /// [pageSize] - Maximum number of DataStores to return. If unspecified,
  /// defaults to 10. The maximum allowed value is 50. Values above 50 will be
  /// coerced to 50. If this field is negative, an INVALID_ARGUMENT is returned.
  ///
  /// [pageToken] - A page token ListDataStoresResponse.next_page_token,
  /// received from a previous DataStoreService.ListDataStores call. Provide
  /// this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to DataStoreService.ListDataStores must match the call
  /// that provided the page token. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListDataStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListDataStoresResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/dataStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListDataStoresResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a DataStore
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Identifier. The full resource name of the data store.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided DataStore to update.
  /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
  /// is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDataStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDataStore> patch(
    GoogleCloudDiscoveryengineV1alphaDataStore request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDataStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates the DocumentProcessingConfig.
  ///
  /// DocumentProcessingConfig is a singleon resource of DataStore. It's empty
  /// when DataStore is created. The first call to this method will set up
  /// DocumentProcessingConfig.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The full resource name of the Document Processing Config. Format:
  /// `projects / * /locations / * /collections / * /dataStores / *
  /// /documentProcessingConfig`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/documentProcessingConfig$`.
  ///
  /// [updateMask] - Indicates which fields in the provided
  /// DocumentProcessingConfig to update. The following are the only supported
  /// fields: * DocumentProcessingConfig.ocr_config If not set, all supported
  /// fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig>
  updateDocumentProcessingConfig(
    GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresBranchesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresBranchesDocumentsResource get documents =>
      ProjectsLocationsDataStoresBranchesDocumentsResource(_requester);
  ProjectsLocationsDataStoresBranchesOperationsResource get operations =>
      ProjectsLocationsDataStoresBranchesOperationsResource(_requester);

  ProjectsLocationsDataStoresBranchesResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets index freshness metadata for Documents.
  ///
  /// Supported for website search only.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [matcher_fhirMatcher_fhirResources] - Required. The FHIR resources to
  /// match by. Format:
  /// projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}/fhir/{resource_type}/{fhir_resource_id}
  ///
  /// [matcher_urisMatcher_uris] - The exact URIs to match by.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse
  >
  batchGetDocumentsMetadata(
    core.String parent, {
    core.List<core.String>? matcher_fhirMatcher_fhirResources,
    core.List<core.String>? matcher_urisMatcher_uris,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (matcher_fhirMatcher_fhirResources != null)
        'matcher.fhirMatcher.fhirResources': matcher_fhirMatcher_fhirResources,
      if (matcher_urisMatcher_uris != null)
        'matcher.urisMatcher.uris': matcher_urisMatcher_uris,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/batchGetDocumentsMetadata';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresBranchesDocumentsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresBranchesDocumentsChunksResource get chunks =>
      ProjectsLocationsDataStoresBranchesDocumentsChunksResource(_requester);

  ProjectsLocationsDataStoresBranchesDocumentsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Document.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [documentId] - Required. The ID to use for the Document, which becomes the
  /// final component of the Document.name. If the caller does not have
  /// permission to create the Document, regardless of whether or not it exists,
  /// a `PERMISSION_DENIED` error is returned. This field must be unique among
  /// all Documents with the same parent. Otherwise, an `ALREADY_EXISTS` error
  /// is returned. This field must conform to
  /// \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a length
  /// limit of 128 characters. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocument> create(
    GoogleCloudDiscoveryengineV1alphaDocument request,
    core.String parent, {
    core.String? documentId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (documentId != null) 'documentId': [documentId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Document, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to delete the Document, regardless
  /// of whether or not it exists, a `PERMISSION_DENIED` error is returned. If
  /// the Document to delete does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Document, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to access the Document, regardless
  /// of whether or not it exists, a `PERMISSION_DENIED` error is returned. If
  /// the requested Document does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocument> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the parsed layout information for a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Document, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to access the Document, regardless
  /// of whether or not it exists, a `PERMISSION_DENIED` error is returned. If
  /// the requested Document does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [imageId] - Optional. Specifies config for IMAGE_BYTES.
  ///
  /// [processedDocumentFormat] - What format output should be. If unspecified,
  /// defaults to JSON.
  /// Possible string values are:
  /// - "PROCESSED_DOCUMENT_FORMAT_UNSPECIFIED" : Default value.
  /// - "JSON" : Output format is a JSON string representation of processed
  /// document.
  ///
  /// [processedDocumentType] - Required. What type of processing to return.
  /// Possible string values are:
  /// - "PROCESSED_DOCUMENT_TYPE_UNSPECIFIED" : Default value.
  /// - "PARSED_DOCUMENT" : Available for all data store parsing configs.
  /// - "CHUNKED_DOCUMENT" : Only available if ChunkingConfig is enabled on the
  /// data store.
  /// - "IMAGE_CONVERTED_DOCUMENT" : Returns the converted Image bytes (as JPEG
  /// or PNG) if available.
  /// - "IMAGE_BYTES" : Return image bytes in base64 encoded format if image_id
  /// of a document is provided, only supported for enabling
  /// shareholder-structure in layout parsing config for now.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaProcessedDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaProcessedDocument>
  getProcessedDocument(
    core.String name, {
    core.String? imageId,
    core.String? processedDocumentFormat,
    core.String? processedDocumentType,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (imageId != null) 'imageId': [imageId],
      if (processedDocumentFormat != null)
        'processedDocumentFormat': [processedDocumentFormat],
      if (processedDocumentType != null)
        'processedDocumentType': [processedDocumentType],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$name') + ':getProcessedDocument';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaProcessedDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bulk import of multiple Documents.
  ///
  /// Request processing may be synchronous. Non-existing items are created.
  /// Note: It is possible for a subset of the Documents to be successfully
  /// updated.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Requires create/update permission.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportDocumentsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Documents.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Use `default_branch` as the branch ID, to list documents under the default
  /// branch. If the caller does not have permission to list Documents under
  /// this branch, regardless of whether or not this branch exists, a
  /// `PERMISSION_DENIED` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of Documents to return. If unspecified,
  /// defaults to 100. The maximum allowed value is 1000. Values above 1000 are
  /// set to 1000. If this field is negative, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [pageToken] - A page token ListDocumentsResponse.next_page_token, received
  /// from a previous DocumentService.ListDocuments call. Provide this to
  /// retrieve the subsequent page. When paginating, all other parameters
  /// provided to DocumentService.ListDocuments must match the call that
  /// provided the page token. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListDocumentsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListDocumentsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListDocumentsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Document.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The full resource name of the document. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to `true` and the Document is not found, a new
  /// Document is be created.
  ///
  /// [updateMask] - Indicates which fields in the provided imported 'document'
  /// to update. If not set, by default updates all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaDocument].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaDocument> patch(
    GoogleCloudDiscoveryengineV1alphaDocument request,
    core.String name, {
    core.bool? allowMissing,
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Permanently deletes all selected Documents in a branch.
  ///
  /// This process is asynchronous. Depending on the number of Documents to be
  /// deleted, this operation can take hours to complete. Before the delete
  /// operation completes, some Documents might still be returned by
  /// DocumentService.GetDocument or DocumentService.ListDocuments. To get a
  /// list of the Documents to be deleted, set PurgeDocumentsRequest.force to
  /// false.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/documents:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresBranchesDocumentsChunksResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresBranchesDocumentsChunksResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a Document.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Chunk, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}/chunks/{chunk}`.
  /// If the caller does not have permission to access the Chunk, regardless of
  /// whether or not it exists, a `PERMISSION_DENIED` error is returned. If the
  /// requested Chunk does not exist, a `NOT_FOUND` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+/chunks/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaChunk].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaChunk> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaChunk.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Chunks.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent document resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
  /// If the caller does not have permission to list Chunks under this document,
  /// regardless of whether or not this document exists, a `PERMISSION_DENIED`
  /// error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/documents/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of Chunks to return. If unspecified, defaults
  /// to 100. The maximum allowed value is 1000. Values above 1000 will be
  /// coerced to 1000. If this field is negative, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [pageToken] - A page token ListChunksResponse.next_page_token, received
  /// from a previous ChunkService.ListChunks call. Provide this to retrieve the
  /// subsequent page. When paginating, all other parameters provided to
  /// ChunkService.ListChunks must match the call that provided the page token.
  /// Otherwise, an `INVALID_ARGUMENT` error is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListChunksResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListChunksResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/chunks';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListChunksResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresBranchesOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresBranchesOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Starts asynchronous cancellation on a long-running operation.
  ///
  /// The server makes a best effort to cancel the operation, but success is not
  /// guaranteed. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation
  /// or other methods to check whether the cancellation succeeded or whether
  /// the operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with an
  /// Operation.error value with a google.rpc.Status.code of `1`, corresponding
  /// to `Code.CANCELLED`.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource to be cancelled.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> cancel(
    GoogleLongrunningCancelOperationRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':cancel';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/branches/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresCompletionConfigResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresCompletionConfigResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Completes the user input with advanced keyword suggestions.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [completionConfig] - Required. The completion_config of the parent
  /// dataStore or engine resource name for which the completion is performed,
  /// such as `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /completionConfig` `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /completionConfig`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/completionConfig$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse>
  completeQuery(
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequest request,
    core.String completionConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$completionConfig') +
        ':completeQuery';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresCompletionSuggestionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresCompletionSuggestionsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Imports CompletionSuggestions for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// import customer autocomplete suggestions. Follows pattern `projects / *
  /// /locations / * /collections / * /dataStores / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/completionSuggestions:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Permanently deletes all CompletionSuggestions for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// purge completion suggestions. Follows pattern projects / * /locations / *
  /// /collections / * /dataStores / * .
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeCompletionSuggestionsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/completionSuggestions:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresControlsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresControlsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a Control.
  ///
  /// By default 1000 controls are allowed for a data store. A request can be
  /// submitted to adjust this limit. If the Control to create already exists,
  /// an ALREADY_EXISTS error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [controlId] - Required. The ID to use for the Control, which will become
  /// the final component of the Control's resource name. This value must be
  /// within 1-63 characters. Valid characters are /a-z-_/.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> create(
    GoogleCloudDiscoveryengineV1alphaControl request,
    core.String parent, {
    core.String? controlId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (controlId != null) 'controlId': [controlId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/controls';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Control.
  ///
  /// If the Control to delete does not exist, a NOT_FOUND error is returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Control to delete. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Control.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Control to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Controls by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - Optional. A filter to apply on the list results. Supported
  /// features: * List all the products under the parent branch if filter is
  /// unset. Currently this field is unsupported.
  ///
  /// [pageSize] - Optional. Maximum number of results to return. If
  /// unspecified, defaults to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListControls` call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListControlsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListControlsResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/controls';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListControlsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Control.
  ///
  /// Control action type cannot be changed. If the Control to update does not
  /// exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name `projects / *
  /// /locations/global/dataStore / * /controls / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/controls/\[^/\]+$`.
  ///
  /// [updateMask] - Optional. Indicates which fields in the provided Control to
  /// update. The following are NOT supported: * Control.name *
  /// Control.solution_type If not set or empty, all supported fields are
  /// updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaControl].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaControl> patch(
    GoogleCloudDiscoveryengineV1alphaControl request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaControl.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresConversationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresConversationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Converses a conversation.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`.
  /// Use
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/-`
  /// to activate auto session mode, which automatically creates a new
  /// conversation inside a ConverseConversation session.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaConverseConversationResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConverseConversationResponse>
  converse(
    GoogleCloudDiscoveryengineV1alphaConverseConversationRequest request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + ':converse';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConverseConversationResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a Conversation.
  ///
  /// If the Conversation to create already exists, an ALREADY_EXISTS error is
  /// returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> create(
    GoogleCloudDiscoveryengineV1alphaConversation request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/conversations';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Conversation.
  ///
  /// If the Conversation to delete does not exist, a NOT_FOUND error is
  /// returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Conversation.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Conversation to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Conversations by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - A filter to apply on the list results. The supported features
  /// are: user_pseudo_id, state. Example: "user_pseudo_id = some_id"
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `update_time` * `create_time` * `conversation_name` Example:
  /// "update_time desc" "create_time"
  ///
  /// [pageSize] - Maximum number of results to return. If unspecified, defaults
  /// to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - A page token, received from a previous `ListConversations`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListConversationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListConversationsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/conversations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListConversationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Conversation.
  ///
  /// Conversation action type cannot be changed. If the Conversation to update
  /// does not exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/dataStore /
  /// * /conversations / * ` or
  /// `projects/{project}/locations/global/collections/{collection}/engines / *
  /// /conversations / * `.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/conversations/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided Conversation to
  /// update. The following are NOT supported: * Conversation.name If not set or
  /// empty, all supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaConversation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaConversation> patch(
    GoogleCloudDiscoveryengineV1alphaConversation request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresModelsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresModelsOperationsResource get operations =>
      ProjectsLocationsDataStoresModelsOperationsResource(_requester);

  ProjectsLocationsDataStoresModelsResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsDataStoresModelsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresModelsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/models/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/models/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresSchemasResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresSchemasResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a Schema.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [schemaId] - Required. The ID to use for the Schema, which becomes the
  /// final component of the Schema.name. This field should conform to
  /// \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a length
  /// limit of 63 characters.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaSchema request,
    core.String parent, {
    core.String? schemaId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (schemaId != null) 'schemaId': [schemaId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/schemas';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Schema.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Schema.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSchema].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSchema> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSchema.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Schemas.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [pageSize] - The maximum number of Schemas to return. The service may
  /// return fewer than this value. If unspecified, at most 100 Schemas are
  /// returned. The maximum value is 1000; values above 1000 are set to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// SchemaService.ListSchemas call. Provide this to retrieve the subsequent
  /// page. When paginating, all other parameters provided to
  /// SchemaService.ListSchemas must match the call that provided the page
  /// token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListSchemasResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListSchemasResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/schemas';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListSchemasResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Schema.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/schemas/\[^/\]+$`.
  ///
  /// [allowMissing] - If set to true, and the Schema is not found, a new Schema
  /// is created. In this situation, `update_mask` is ignored.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudDiscoveryengineV1alphaSchema request,
    core.String name, {
    core.bool? allowMissing,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (allowMissing != null) 'allowMissing': ['${allowMissing}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresServingConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresServingConfigsResource(commons.ApiRequester client)
    : _requester = client;

  /// Answer query method.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /servingConfigs/default_serving_config`. This field is used to identify
  /// the serving configuration name, set of models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse> answer(
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':answer';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a ServingConfig.
  ///
  /// Returns a NotFound error if the ServingConfig does not exist.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the ServingConfig to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaServingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaServingConfig> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all ServingConfigs linked to this dataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of the parent resource. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. Maximum number of results to return. If
  /// unspecified, defaults to 100. If a value greater than 100 is provided, at
  /// most 100 results are returned.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListServingConfigs` call. Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse>
  list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/servingConfigs';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a ServingConfig.
  ///
  /// Returns a NOT_FOUND error if the ServingConfig does not exist.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided ServingConfig to
  /// update. The following are NOT supported: * ServingConfig.name If not set,
  /// all supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaServingConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaServingConfig> patch(
    GoogleCloudDiscoveryengineV1alphaServingConfig request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Makes a recommendation, which requires a contextual user event.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. Full resource name of a ServingConfig:
  /// `projects / * /locations/global/collections / * /engines / *
  /// /servingConfigs / * `, or `projects / * /locations/global/collections / *
  /// /dataStores / * /servingConfigs / * ` One default serving config is
  /// created along with your recommendation engine creation. The engine ID is
  /// used as the ID of the default serving config. For example, for Engine
  /// `projects / * /locations/global/collections / * /engines/my-engine`, you
  /// can use `projects / * /locations/global/collections / *
  /// /engines/my-engine/servingConfigs/my-engine` for your
  /// RecommendationService.Recommend requests.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaRecommendResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaRecommendResponse> recommend(
    GoogleCloudDiscoveryengineV1alphaRecommendRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':recommend';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaRecommendResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Performs a search.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
  /// This field is used to identify the serving configuration name, set of
  /// models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSearchResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSearchResponse> search(
    GoogleCloudDiscoveryengineV1alphaSearchRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':search';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSearchResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Performs a search.
  ///
  /// Similar to the SearchService.Search method, but a lite version that allows
  /// API key for authentication, where OAuth and IAM checks are not required.
  /// Only public website search is supported by this method. If data stores and
  /// engines not associated with public website search are specified, a
  /// `FAILED_PRECONDITION` error is returned. This method can be used for easy
  /// onboarding without having to implement an authentication backend. However,
  /// it is strongly recommended to use SearchService.Search instead with
  /// required OAuth and IAM checks to provide better data security.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
  /// This field is used to identify the serving configuration name, set of
  /// models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSearchResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSearchResponse> searchLite(
    GoogleCloudDiscoveryengineV1alphaSearchRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':searchLite';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSearchResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Answer query method (streaming).
  ///
  /// It takes one AnswerQueryRequest and returns multiple AnswerQueryResponse
  /// messages in a stream.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [servingConfig] - Required. The resource name of the Search serving
  /// config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores / *
  /// /servingConfigs/default_serving_config`. This field is used to identify
  /// the serving configuration name, set of models used to make the search.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/servingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse>
  streamAnswer(
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest request,
    core.String servingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$servingConfig') + ':streamAnswer';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresSessionsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresSessionsAnswersResource get answers =>
      ProjectsLocationsDataStoresSessionsAnswersResource(_requester);

  ProjectsLocationsDataStoresSessionsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a Session.
  ///
  /// If the Session to create already exists, an ALREADY_EXISTS error is
  /// returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Full resource name of parent data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> create(
    GoogleCloudDiscoveryengineV1alphaSession request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Session.
  ///
  /// If the Session to delete does not exist, a NOT_FOUND error is returned.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Session to delete. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Session.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Session to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [includeAnswerDetails] - Optional. If set to true, the full session
  /// including all answer details will be returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> get(
    core.String name, {
    core.bool? includeAnswerDetails,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (includeAnswerDetails != null)
        'includeAnswerDetails': ['${includeAnswerDetails}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Sessions by their parent DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The data store resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [filter] - A comma-separated list of fields to filter by, in EBNF grammar.
  /// The supported fields are: * `user_pseudo_id` * `state` * `display_name` *
  /// `starred` * `is_pinned` * `labels` * `create_time` * `update_time`
  /// Examples: * `user_pseudo_id = some_id` * `display_name = "some_name"` *
  /// `starred = true` * `is_pinned=true AND (NOT labels:hidden)` * `create_time
  /// > "1970-01-01T12:00:00Z"`
  ///
  /// [orderBy] - A comma-separated list of fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Supported
  /// fields: * `update_time` * `create_time` * `session_name` * `is_pinned`
  /// Example: * "update_time desc" * "create_time" * "is_pinned
  /// desc,update_time desc": list sessions by is_pinned first, then by
  /// update_time.
  ///
  /// [pageSize] - Maximum number of results to return. If unspecified, defaults
  /// to 50. Max allowed value is 1000.
  ///
  /// [pageToken] - A page token, received from a previous `ListSessions` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaListSessionsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListSessionsResponse> list(
    core.String parent, {
    core.String? filter,
    core.String? orderBy,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (orderBy != null) 'orderBy': [orderBy],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sessions';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListSessionsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a Session.
  ///
  /// Session action type cannot be changed. If the Session to update does not
  /// exist, a NOT_FOUND error is returned.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Immutable. Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions
  /// / * `
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided Session to update.
  /// The following are NOT supported: * Session.name If not set or empty, all
  /// supported fields are updated.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSession].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSession> patch(
    GoogleCloudDiscoveryengineV1alphaSession request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSession.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresSessionsAnswersResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresSessionsAnswersResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets a Answer.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The resource name of the Answer to get. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine_id}/sessions/{session_id}/answers/{answer_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/sessions/\[^/\]+/answers/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaAnswer].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaAnswer> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaAnswer.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresSiteSearchEngineResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresSiteSearchEngineSitemapsResource get sitemaps =>
      ProjectsLocationsDataStoresSiteSearchEngineSitemapsResource(_requester);
  ProjectsLocationsDataStoresSiteSearchEngineTargetSitesResource
  get targetSites =>
      ProjectsLocationsDataStoresSiteSearchEngineTargetSitesResource(
        _requester,
      );

  ProjectsLocationsDataStoresSiteSearchEngineResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Downgrade from advanced site search to basic site search.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as
  /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> disableAdvancedSiteSearch(
    GoogleCloudDiscoveryengineV1alphaDisableAdvancedSiteSearchRequest request,
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$siteSearchEngine') +
        ':disableAdvancedSiteSearch';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Upgrade from basic site search to advanced site search.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as
  /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> enableAdvancedSiteSearch(
    GoogleCloudDiscoveryengineV1alphaEnableAdvancedSiteSearchRequest request,
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$siteSearchEngine') +
        ':enableAdvancedSiteSearch';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Request on-demand recrawl for a list of URIs.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [siteSearchEngine] - Required. Full resource name of the SiteSearchEngine,
  /// such as `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> recrawlUris(
    GoogleCloudDiscoveryengineV1alphaRecrawlUrisRequest request,
    core.String siteSearchEngine, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$siteSearchEngine') + ':recrawlUris';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresSiteSearchEngineSitemapsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresSiteSearchEngineSitemapsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a Sitemap.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent resource name of the SiteSearchEngine, such as
  /// `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaSitemap request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sitemaps';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a Sitemap.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Sitemap, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/sitemaps/{sitemap}`.
  /// If the caller does not have permission to access the Sitemap, regardless
  /// of whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// requested Sitemap does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/sitemaps/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Fetch Sitemaps in a DataStore.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent resource name of the SiteSearchEngine, such as
  /// `projects / * /locations / * /collections / * /dataStores / *
  /// /siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [matcher_urisMatcher_uris] - The Sitemap uris.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse> fetch(
    core.String parent, {
    core.List<core.String>? matcher_urisMatcher_uris,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (matcher_urisMatcher_uris != null)
        'matcher.urisMatcher.uris': matcher_urisMatcher_uris,
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/sitemaps:fetch';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresSiteSearchEngineTargetSitesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresSiteSearchEngineTargetSitesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates TargetSite in a batch.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource shared by all TargetSites being
  /// created.
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// The parent field in the CreateBookRequest messages must either be empty or
  /// match this field.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchCreate(
    GoogleCloudDiscoveryengineV1alphaBatchCreateTargetSitesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/targetSites:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Creates a TargetSite.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent resource name of TargetSite, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaTargetSite request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/targetSites';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a TargetSite.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of TargetSite, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
  /// If the caller does not have permission to access the TargetSite,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned. If the requested TargetSite does not exist, a NOT_FOUND error is
  /// returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a TargetSite.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of TargetSite, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
  /// If the caller does not have permission to access the TargetSite,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned. If the requested TargetSite does not exist, a NOT_FOUND error is
  /// returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaTargetSite].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaTargetSite> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaTargetSite.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of TargetSites.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent site search engine resource name, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  /// If the caller does not have permission to list TargetSites under this site
  /// search engine, regardless of whether or not this branch exists, a
  /// PERMISSION_DENIED error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine$`.
  ///
  /// [pageSize] - Requested page size. Server may return fewer items than
  /// requested. If unspecified, server will pick an appropriate default. The
  /// maximum value is 1000; values above 1000 will be coerced to 1000. If this
  /// field is negative, an INVALID_ARGUMENT error is returned.
  ///
  /// [pageToken] - A page token, received from a previous `ListTargetSites`
  /// call. Provide this to retrieve the subsequent page. When paginating, all
  /// other parameters provided to `ListTargetSites` must match the call that
  /// provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/targetSites';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a TargetSite.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Output only. The fully qualified resource name of the target
  /// site.
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`
  /// The `target_site_id` is system-generated.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/siteSearchEngine/targetSites/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> patch(
    GoogleCloudDiscoveryengineV1alphaTargetSite request,
    core.String name, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresSuggestionDenyListEntriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresSuggestionDenyListEntriesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Imports all SuggestionDenyListEntry for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// import denylist entries. Follows pattern projects / * /locations / *
  /// /collections / * /dataStores / * .
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequest
    request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/suggestionDenyListEntries:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Permanently deletes all SuggestionDenyListEntry for a DataStore.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent data store resource name for which to
  /// import denylist entries. Follows pattern projects / * /locations / *
  /// /collections / * /dataStores / * .
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/.*$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeSuggestionDenyListEntriesRequest
    request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/suggestionDenyListEntries:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresUserEventsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresUserEventsResource(commons.ApiRequester client)
    : _requester = client;

  /// Writes a single user event from the browser.
  ///
  /// This uses a GET request to due to browser restriction of POST-ing to a
  /// third-party domain. This method is used only by the Discovery Engine API
  /// JavaScript pixel and Google Tag Manager. Users should not call this method
  /// directly.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name. If the collect user event
  /// action is applied in DataStore level, the format is:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// If the collect user event action is applied in Location level, for
  /// example, the event with Document across multiple DataStore, the format is:
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [ets] - The event timestamp in milliseconds. This prevents browser caching
  /// of otherwise identical get requests. The name is abbreviated to reduce the
  /// payload bytes.
  ///
  /// [uri] - The URL including cgi-parameters but excluding the hash fragment
  /// with a length limit of 5,000 characters. This is often more useful than
  /// the referer URL, because many browsers only send the domain for
  /// third-party requests.
  ///
  /// [userEvent] - Required. URL encoded UserEvent proto with a length limit of
  /// 2,000,000 characters.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> collect(
    core.String parent, {
    core.String? ets,
    core.String? uri,
    core.String? userEvent,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (ets != null) 'ets': [ets],
      if (uri != null) 'uri': [uri],
      if (userEvent != null) 'userEvent': [userEvent],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:collect';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bulk import of user events.
  ///
  /// Request processing might be synchronous. Events that already exist are
  /// skipped. Use this method for backfilling historical user events.
  /// Operation.response is of type ImportResponse. Note that it is possible for
  /// a subset of the items to be successfully inserted. Operation.metadata is
  /// of type ImportMetadata.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent DataStore resource name, of the form
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportUserEventsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes permanently all user events specified by the filter provided.
  ///
  /// Depending on the number of events specified by the filter, this operation
  /// could take hours or days to complete. To test a filter, use the list
  /// command first.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The resource name of the catalog under which the
  /// events are created. The format is
  /// `projects/{project}/locations/global/collections/{collection}/dataStores/{dataStore}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purge(
    GoogleCloudDiscoveryengineV1alphaPurgeUserEventsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:purge';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Writes a single user event.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name. If the write user event
  /// action is applied in DataStore level, the format is:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// If the write user event action is applied in Location level, for example,
  /// the event with Document across multiple DataStore, the format is:
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+$`.
  ///
  /// [writeAsync] - If set to true, the user event is written asynchronously
  /// after validation, and the API responds without waiting for the write.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaUserEvent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaUserEvent> write(
    GoogleCloudDiscoveryengineV1alphaUserEvent request,
    core.String parent, {
    core.bool? writeAsync,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (writeAsync != null) 'writeAsync': ['${writeAsync}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaUserEvent.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsDataStoresWidgetConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsDataStoresWidgetConfigsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets a WidgetConfig.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full WidgetConfig resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/widgetConfigs/{widget_config_id}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/dataStores/\[^/\]+/widgetConfigs/\[^/\]+$`.
  ///
  /// [acceptCache] - Optional. Whether it's acceptable to load the widget
  /// config from cache. If set to true, recent changes on widget configs may
  /// take a few minutes to reflect on the end user's view. It's recommended to
  /// set to true for maturely developed widgets, as it improves widget
  /// performance. Set to false to see changes reflected in prod right away, if
  /// your widget is under development.
  ///
  /// [getWidgetConfigRequestOption_turnOffCollectionComponents] - Optional.
  /// Whether to turn off collection_components in WidgetConfig to reduce
  /// latency and data transmission.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaWidgetConfig].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaWidgetConfig> get(
    core.String name, {
    core.bool? acceptCache,
    core.bool? getWidgetConfigRequestOption_turnOffCollectionComponents,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (acceptCache != null) 'acceptCache': ['${acceptCache}'],
      if (getWidgetConfigRequestOption_turnOffCollectionComponents != null)
        'getWidgetConfigRequestOption.turnOffCollectionComponents': [
          '${getWidgetConfigRequestOption_turnOffCollectionComponents}',
        ],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaWidgetConfig.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEvaluationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationsOperationsResource get operations =>
      ProjectsLocationsEvaluationsOperationsResource(_requester);

  ProjectsLocationsEvaluationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a Evaluation.
  ///
  /// Upon creation, the evaluation will be automatically triggered and begin
  /// execution.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> create(
    GoogleCloudDiscoveryengineV1alphaEvaluation request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/evaluations';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a Evaluation.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of Evaluation, such as
  /// `projects/{project}/locations/{location}/evaluations/{evaluation}`. If the
  /// caller does not have permission to access the Evaluation, regardless of
  /// whether or not it exists, a PERMISSION_DENIED error is returned. If the
  /// requested Evaluation does not exist, a NOT_FOUND error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaEvaluation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaEvaluation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaEvaluation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of Evaluations.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent location resource name, such as
  /// `projects/{project}/locations/{location}`. If the caller does not have
  /// permission to list Evaluations under this location, regardless of whether
  /// or not this location exists, a `PERMISSION_DENIED` error is returned.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of Evaluations to return. If unspecified,
  /// defaults to 100. The maximum allowed value is 1000. Values above 1000 will
  /// be coerced to 1000. If this field is negative, an `INVALID_ARGUMENT` error
  /// is returned.
  ///
  /// [pageToken] - A page token ListEvaluationsResponse.next_page_token,
  /// received from a previous EvaluationService.ListEvaluations call. Provide
  /// this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to EvaluationService.ListEvaluations must match the
  /// call that provided the page token. Otherwise, an `INVALID_ARGUMENT` error
  /// is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListEvaluationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListEvaluationsResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/evaluations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListEvaluationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of results for a given a Evaluation.
  ///
  /// Request parameters:
  ///
  /// [evaluation] - Required. The evaluation resource name, such as
  /// `projects/{project}/locations/{location}/evaluations/{evaluation}`. If the
  /// caller does not have permission to list
  /// ListEvaluationResultsResponse.EvaluationResult under this evaluation,
  /// regardless of whether or not this evaluation set exists, a
  /// `PERMISSION_DENIED` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluations/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of
  /// ListEvaluationResultsResponse.EvaluationResult to return. If unspecified,
  /// defaults to 100. The maximum allowed value is 1000. Values above 1000 will
  /// be coerced to 1000. If this field is negative, an `INVALID_ARGUMENT` error
  /// is returned.
  ///
  /// [pageToken] - A page token ListEvaluationResultsResponse.next_page_token,
  /// received from a previous EvaluationService.ListEvaluationResults call.
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to EvaluationService.ListEvaluationResults must match
  /// the call that provided the page token. Otherwise, an `INVALID_ARGUMENT`
  /// error is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponse>
  listResults(
    core.String evaluation, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$evaluation') + ':listResults';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsEvaluationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsEvaluationsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/evaluations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsGroundingConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsGroundingConfigsResource(commons.ApiRequester client)
    : _requester = client;

  /// Performs a grounding check.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [groundingConfig] - Required. The resource name of the grounding config,
  /// such as `projects / *
  /// /locations/global/groundingConfigs/default_grounding_config`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/groundingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaCheckGroundingResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaCheckGroundingResponse> check(
    GoogleCloudDiscoveryengineV1alphaCheckGroundingRequest request,
    core.String groundingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$groundingConfig') + ':check';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaCheckGroundingResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsIdentityMappingStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIdentityMappingStoresOperationsResource get operations =>
      ProjectsLocationsIdentityMappingStoresOperationsResource(_requester);

  ProjectsLocationsIdentityMappingStoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a new Identity Mapping Store.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent collection resource name, such as
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [cmekConfigName] - Resource name of the CmekConfig to use for protecting
  /// this Identity Mapping Store.
  ///
  /// [disableCmek] - Identity Mapping Store without CMEK protections. If a
  /// default CmekConfig is set for the project, setting this field will
  /// override the default CmekConfig as well.
  ///
  /// [identityMappingStoreId] - Required. The ID of the Identity Mapping Store
  /// to create. The ID must contain only letters (a-z, A-Z), numbers (0-9),
  /// underscores (_), and hyphens (-). The maximum length is 63 characters.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaIdentityMappingStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaIdentityMappingStore> create(
    GoogleCloudDiscoveryengineV1alphaIdentityMappingStore request,
    core.String parent, {
    core.String? cmekConfigName,
    core.bool? disableCmek,
    core.String? identityMappingStoreId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (cmekConfigName != null) 'cmekConfigName': [cmekConfigName],
      if (disableCmek != null) 'disableCmek': ['${disableCmek}'],
      if (identityMappingStoreId != null)
        'identityMappingStoreId': [identityMappingStoreId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/identityMappingStores';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaIdentityMappingStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes the Identity Mapping Store.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Identity Mapping Store to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/identityMappingStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets the Identity Mapping Store.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. The name of the Identity Mapping Store to get. Format:
  /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/identityMappingStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaIdentityMappingStore].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaIdentityMappingStore> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaIdentityMappingStore.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Imports a list of Identity Mapping Entries to an Identity Mapping Store.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [identityMappingStore] - Required. The name of the Identity Mapping Store
  /// to import Identity Mapping Entries to. Format:
  /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/identityMappingStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> importIdentityMappings(
    GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequest request,
    core.String identityMappingStore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$identityMappingStore') +
        ':importIdentityMappings';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists all Identity Mapping Stores.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent of the Identity Mapping Stores to list.
  /// Format: `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of IdentityMappingStores to return. If
  /// unspecified, defaults to 100. The maximum allowed value is 1000. Values
  /// above 1000 will be coerced to 1000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// `ListIdentityMappingStores` call. Provide this to retrieve the subsequent
  /// page. When paginating, all other parameters provided to
  /// `ListIdentityMappingStores` must match the call that provided the page
  /// token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListIdentityMappingStoresResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<
    GoogleCloudDiscoveryengineV1alphaListIdentityMappingStoresResponse
  >
  list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/identityMappingStores';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListIdentityMappingStoresResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists Identity Mappings in an Identity Mapping Store.
  ///
  /// Request parameters:
  ///
  /// [identityMappingStore] - Required. The name of the Identity Mapping Store
  /// to list Identity Mapping Entries in. Format:
  /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/identityMappingStores/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of IdentityMappings to return. If unspecified,
  /// defaults to 2000. The maximum allowed value is 10000. Values above 10000
  /// will be coerced to 10000.
  ///
  /// [pageToken] - A page token, received from a previous
  /// `ListIdentityMappings` call. Provide this to retrieve the subsequent page.
  /// When paginating, all other parameters provided to `ListIdentityMappings`
  /// must match the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListIdentityMappingsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListIdentityMappingsResponse>
  listIdentityMappings(
    core.String identityMappingStore, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$identityMappingStore') +
        ':listIdentityMappings';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListIdentityMappingsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Purges specified or all Identity Mapping Entries from an Identity Mapping
  /// Store.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [identityMappingStore] - Required. The name of the Identity Mapping Store
  /// to purge Identity Mapping Entries from. Format:
  /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/identityMappingStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> purgeIdentityMappings(
    GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequest request,
    core.String identityMappingStore, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$identityMappingStore') +
        ':purgeIdentityMappings';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsIdentityMappingStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsIdentityMappingStoresOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/identityMappingStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/identityMappingStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebooksResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebooksSourcesResource get sources =>
      ProjectsLocationsNotebooksSourcesResource(_requester);

  ProjectsLocationsNotebooksResource(commons.ApiRequester client)
    : _requester = client;

  /// Lists the recently viewed notebooks.
  ///
  /// Needs a side channel with the user's EUC.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent branch resource name, such as
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Optional. Maximum number of Notebooks to return. If
  /// unspecified, defaults to "200". The maximum allowed value is "500". If
  /// this field is negative, will use the default value.
  ///
  /// [pageToken] - Optional. The page token, provide this to retrieve the
  /// subsequent page.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudNotebooklmV1alphaListRecentlyViewedNotebooksResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudNotebooklmV1alphaListRecentlyViewedNotebooksResponse>
  listRecentlyViewed(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/notebooks:listRecentlyViewed';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudNotebooklmV1alphaListRecentlyViewedNotebooksResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsNotebooksSourcesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsNotebooksSourcesResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a list of Sources.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource where the sources will be
  /// created. Format:
  /// projects/{project}/locations/{location}/notebooks/{notebook}
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebooks/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudNotebooklmV1alphaBatchCreateSourcesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudNotebooklmV1alphaBatchCreateSourcesResponse>
  batchCreate(
    GoogleCloudNotebooklmV1alphaBatchCreateSourcesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/sources:batchCreate';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudNotebooklmV1alphaBatchCreateSourcesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Uploads a file for Notebook LM to use.
  ///
  /// Creates a Source.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource where the sources will be
  /// created. Format:
  /// projects/{project}/locations/{location}/notebooks/{notebook}
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/notebooks/\[^/\]+$`.
  ///
  /// [sourceId] - The source id of the associated file. If not set, a source id
  /// will be generated and a new tentative source will be created.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudNotebooklmV1alphaUploadSourceFileResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudNotebooklmV1alphaUploadSourceFileResponse> uploadFile(
    GoogleCloudNotebooklmV1alphaUploadSourceFileRequest request,
    core.String parent,
    core.String sourceId, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        '/sources/' +
        commons.escapeVariable('$sourceId') +
        ':uploadFile';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudNotebooklmV1alphaUploadSourceFileResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsPodcastsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPodcastsOperationsResource get operations =>
      ProjectsLocationsPodcastsOperationsResource(_requester);

  ProjectsLocationsPodcastsResource(commons.ApiRequester client)
    : _requester = client;
}

class ProjectsLocationsPodcastsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsPodcastsOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/podcasts/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsRankingConfigsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRankingConfigsResource(commons.ApiRequester client)
    : _requester = client;

  /// Ranks a list of text records based on the given input query.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [rankingConfig] - Required. The resource name of the rank service config,
  /// such as
  /// `projects/{project_num}/locations/{location}/rankingConfigs/default_ranking_config`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/rankingConfigs/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaRankResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaRankResponse> rank(
    GoogleCloudDiscoveryengineV1alphaRankRequest request,
    core.String rankingConfig, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$rankingConfig') + ':rank';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaRankResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsRequirementsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsRequirementsResource(commons.ApiRequester client)
    : _requester = client;

  /// Check a particular requirement.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [location] - Required. Full resource name of the location. Format
  /// `projects/{project_number_or_id}/locations/{location}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaCheckRequirementResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaCheckRequirementResponse>
  checkRequirement(
    GoogleCloudDiscoveryengineV1alphaCheckRequirementRequest request,
    core.String location, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$location') +
        '/requirements:checkRequirement';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaCheckRequirementResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSampleQuerySetsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSampleQuerySetsOperationsResource get operations =>
      ProjectsLocationsSampleQuerySetsOperationsResource(_requester);
  ProjectsLocationsSampleQuerySetsSampleQueriesResource get sampleQueries =>
      ProjectsLocationsSampleQuerySetsSampleQueriesResource(_requester);

  ProjectsLocationsSampleQuerySetsResource(commons.ApiRequester client)
    : _requester = client;

  /// Creates a SampleQuerySet
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [sampleQuerySetId] - Required. The ID to use for the SampleQuerySet, which
  /// will become the final component of the SampleQuerySet.name. If the caller
  /// does not have permission to create the SampleQuerySet, regardless of
  /// whether or not it exists, a `PERMISSION_DENIED` error is returned. This
  /// field must be unique among all SampleQuerySets with the same parent.
  /// Otherwise, an `ALREADY_EXISTS` error is returned. This field must conform
  /// to \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a
  /// length limit of 63 characters. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSampleQuerySet].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSampleQuerySet> create(
    GoogleCloudDiscoveryengineV1alphaSampleQuerySet request,
    core.String parent, {
    core.String? sampleQuerySetId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (sampleQuerySetId != null) 'sampleQuerySetId': [sampleQuerySetId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/sampleQuerySets';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSampleQuerySet.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a SampleQuerySet.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of SampleQuerySet, such as
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}`.
  /// If the caller does not have permission to delete the SampleQuerySet,
  /// regardless of whether or not it exists, a `PERMISSION_DENIED` error is
  /// returned. If the SampleQuerySet to delete does not exist, a `NOT_FOUND`
  /// error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a SampleQuerySet.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of SampleQuerySet, such as
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}`.
  /// If the caller does not have permission to access the SampleQuerySet,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned. If the requested SampleQuerySet does not exist, a NOT_FOUND
  /// error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSampleQuerySet].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSampleQuerySet> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSampleQuerySet.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of SampleQuerySets.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent location resource name, such as
  /// `projects/{project}/locations/{location}`. If the caller does not have
  /// permission to list SampleQuerySets under this location, regardless of
  /// whether or not this location exists, a `PERMISSION_DENIED` error is
  /// returned.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of SampleQuerySets to return. If unspecified,
  /// defaults to 100. The maximum allowed value is 1000. Values above 1000 will
  /// be coerced to 1000. If this field is negative, an `INVALID_ARGUMENT` error
  /// is returned.
  ///
  /// [pageToken] - A page token ListSampleQuerySetsResponse.next_page_token,
  /// received from a previous SampleQuerySetService.ListSampleQuerySets call.
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to SampleQuerySetService.ListSampleQuerySets must
  /// match the call that provided the page token. Otherwise, an
  /// `INVALID_ARGUMENT` error is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListSampleQuerySetsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListSampleQuerySetsResponse>
  list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/sampleQuerySets';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListSampleQuerySetsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a SampleQuerySet.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The full resource name of the SampleQuerySet, in the
  /// format of
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided imported 'sample
  /// query set' to update. If not set, will by default update all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSampleQuerySet].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSampleQuerySet> patch(
    GoogleCloudDiscoveryengineV1alphaSampleQuerySet request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSampleQuerySet.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSampleQuerySetsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSampleQuerySetsOperationsResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsSampleQuerySetsSampleQueriesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsSampleQuerySetsSampleQueriesResource(
    commons.ApiRequester client,
  ) : _requester = client;

  /// Creates a SampleQuery
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name, such as
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sampleQuerySet}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+$`.
  ///
  /// [sampleQueryId] - Required. The ID to use for the SampleQuery, which will
  /// become the final component of the SampleQuery.name. If the caller does not
  /// have permission to create the SampleQuery, regardless of whether or not it
  /// exists, a `PERMISSION_DENIED` error is returned. This field must be unique
  /// among all SampleQuerys with the same parent. Otherwise, an
  /// `ALREADY_EXISTS` error is returned. This field must conform to
  /// \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a length
  /// limit of 63 characters. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSampleQuery].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSampleQuery> create(
    GoogleCloudDiscoveryengineV1alphaSampleQuery request,
    core.String parent, {
    core.String? sampleQueryId,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (sampleQueryId != null) 'sampleQueryId': [sampleQueryId],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sampleQueries';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSampleQuery.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Deletes a SampleQuery.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of SampleQuery, such as
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}/sampleQueries/{sample_query}`.
  /// If the caller does not have permission to delete the SampleQuery,
  /// regardless of whether or not it exists, a `PERMISSION_DENIED` error is
  /// returned. If the SampleQuery to delete does not exist, a `NOT_FOUND` error
  /// is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+/sampleQueries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleProtobufEmpty].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleProtobufEmpty> delete(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'DELETE',
      queryParams: queryParams_,
    );
    return GoogleProtobufEmpty.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a SampleQuery.
  ///
  /// Request parameters:
  ///
  /// [name] - Required. Full resource name of SampleQuery, such as
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}/sampleQueries/{sample_query}`.
  /// If the caller does not have permission to access the SampleQuery,
  /// regardless of whether or not it exists, a PERMISSION_DENIED error is
  /// returned. If the requested SampleQuery does not exist, a NOT_FOUND error
  /// is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+/sampleQueries/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSampleQuery].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSampleQuery> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSampleQuery.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bulk import of multiple SampleQuerys.
  ///
  /// Sample queries that already exist may be deleted. Note: It is possible for
  /// a subset of the SampleQuerys to be successfully imported.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent sample query set resource name, such as
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sampleQuerySet}`.
  /// If the caller does not have permission to list SampleQuerys under this
  /// sample query set, regardless of whether or not this sample query set
  /// exists, a `PERMISSION_DENIED` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/sampleQueries:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Gets a list of SampleQuerys.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent sample query set resource name, such as
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sampleQuerySet}`.
  /// If the caller does not have permission to list SampleQuerys under this
  /// sample query set, regardless of whether or not this sample query set
  /// exists, a `PERMISSION_DENIED` error is returned.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+$`.
  ///
  /// [pageSize] - Maximum number of SampleQuerys to return. If unspecified,
  /// defaults to 100. The maximum allowed value is 1000. Values above 1000 will
  /// be coerced to 1000. If this field is negative, an `INVALID_ARGUMENT` error
  /// is returned.
  ///
  /// [pageToken] - A page token ListSampleQueriesResponse.next_page_token,
  /// received from a previous SampleQueryService.ListSampleQueries call.
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to SampleQueryService.ListSampleQueries must match the
  /// call that provided the page token. Otherwise, an `INVALID_ARGUMENT` error
  /// is returned.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListSampleQueriesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListSampleQueriesResponse> list(
    core.String parent, {
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/sampleQueries';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListSampleQueriesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Updates a SampleQuery.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [name] - Identifier. The full resource name of the sample query, in the
  /// format of
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}/sampleQueries/{sample_query}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/sampleQuerySets/\[^/\]+/sampleQueries/\[^/\]+$`.
  ///
  /// [updateMask] - Indicates which fields in the provided imported 'simple
  /// query' to update. If not set, will by default update all fields.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaSampleQuery].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaSampleQuery> patch(
    GoogleCloudDiscoveryengineV1alphaSampleQuery request,
    core.String name, {
    core.String? updateMask,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (updateMask != null) 'updateMask': [updateMask],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'PATCH',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaSampleQuery.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsUserEventsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsUserEventsResource(commons.ApiRequester client)
    : _requester = client;

  /// Writes a single user event from the browser.
  ///
  /// This uses a GET request to due to browser restriction of POST-ing to a
  /// third-party domain. This method is used only by the Discovery Engine API
  /// JavaScript pixel and Google Tag Manager. Users should not call this method
  /// directly.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name. If the collect user event
  /// action is applied in DataStore level, the format is:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// If the collect user event action is applied in Location level, for
  /// example, the event with Document across multiple DataStore, the format is:
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [ets] - The event timestamp in milliseconds. This prevents browser caching
  /// of otherwise identical get requests. The name is abbreviated to reduce the
  /// payload bytes.
  ///
  /// [uri] - The URL including cgi-parameters but excluding the hash fragment
  /// with a length limit of 5,000 characters. This is often more useful than
  /// the referer URL, because many browsers only send the domain for
  /// third-party requests.
  ///
  /// [userEvent] - Required. URL encoded UserEvent proto with a length limit of
  /// 2,000,000 characters.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleApiHttpBody].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleApiHttpBody> collect(
    core.String parent, {
    core.String? ets,
    core.String? uri,
    core.String? userEvent,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (ets != null) 'ets': [ets],
      if (uri != null) 'uri': [uri],
      if (userEvent != null) 'userEvent': [userEvent],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:collect';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleApiHttpBody.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Bulk import of user events.
  ///
  /// Request processing might be synchronous. Events that already exist are
  /// skipped. Use this method for backfilling historical user events.
  /// Operation.response is of type ImportResponse. Note that it is possible for
  /// a subset of the items to be successfully inserted. Operation.metadata is
  /// of type ImportMetadata.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. Parent DataStore resource name, of the form
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> import(
    GoogleCloudDiscoveryengineV1alphaImportUserEventsRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:import';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Writes a single user event.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent resource name. If the write user event
  /// action is applied in DataStore level, the format is:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
  /// If the write user event action is applied in Location level, for example,
  /// the event with Document across multiple DataStore, the format is:
  /// `projects/{project}/locations/{location}`.
  /// Value must have pattern `^projects/\[^/\]+/locations/\[^/\]+$`.
  ///
  /// [writeAsync] - If set to true, the user event is written asynchronously
  /// after validation, and the API responds without waiting for the write.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleCloudDiscoveryengineV1alphaUserEvent].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaUserEvent> write(
    GoogleCloudDiscoveryengineV1alphaUserEvent request,
    core.String parent, {
    core.bool? writeAsync,
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if (writeAsync != null) 'writeAsync': ['${writeAsync}'],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' + core.Uri.encodeFull('$parent') + '/userEvents:write';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaUserEvent.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsUserStoresResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsUserStoresOperationsResource get operations =>
      ProjectsLocationsUserStoresOperationsResource(_requester);
  ProjectsLocationsUserStoresUserLicensesResource get userLicenses =>
      ProjectsLocationsUserStoresUserLicensesResource(_requester);

  ProjectsLocationsUserStoresResource(commons.ApiRequester client)
    : _requester = client;

  /// Updates the User License.
  ///
  /// This method is used for batch assign/unassign licenses to users.
  ///
  /// [request] - The metadata request object.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent UserStore resource name, format:
  /// `projects/{project}/locations/{location}/userStores/{user_store_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/userStores/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> batchUpdateUserLicenses(
    GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequest request,
    core.String parent, {
    core.String? $fields,
  }) async {
    final body_ = convert.json.encode(request);
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ =
        'v1alpha/' +
        core.Uri.encodeFull('$parent') +
        ':batchUpdateUserLicenses';

    final response_ = await _requester.request(
      url_,
      'POST',
      body: body_,
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsUserStoresOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsUserStoresOperationsResource(commons.ApiRequester client)
    : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/userStores/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/userStores/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsLocationsUserStoresUserLicensesResource {
  final commons.ApiRequester _requester;

  ProjectsLocationsUserStoresUserLicensesResource(commons.ApiRequester client)
    : _requester = client;

  /// Lists the User Licenses.
  ///
  /// Request parameters:
  ///
  /// [parent] - Required. The parent UserStore resource name, format:
  /// `projects/{project}/locations/{location}/userStores/{user_store_id}`.
  /// Value must have pattern
  /// `^projects/\[^/\]+/locations/\[^/\]+/userStores/\[^/\]+$`.
  ///
  /// [filter] - Optional. Filter for the list request. Supported fields: *
  /// `license_assignment_state` Examples: * `license_assignment_state =
  /// ASSIGNED` to list assigned user licenses. * `license_assignment_state =
  /// NO_LICENSE` to list not licensed users. * `license_assignment_state =
  /// NO_LICENSE_ATTEMPTED_LOGIN` to list users who attempted login but no
  /// license assigned. * `license_assignment_state !=
  /// NO_LICENSE_ATTEMPTED_LOGIN` to filter out users who attempted login but no
  /// license assigned.
  ///
  /// [pageSize] - Optional. Requested page size. Server may return fewer items
  /// than requested. If unspecified, defaults to 10. The maximum value is 50;
  /// values above 50 will be coerced to 50. If this field is negative, an
  /// INVALID_ARGUMENT error is returned.
  ///
  /// [pageToken] - Optional. A page token, received from a previous
  /// `ListUserLicenses` call. Provide this to retrieve the subsequent page.
  /// When paginating, all other parameters provided to `ListUserLicenses` must
  /// match the call that provided the page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a
  /// [GoogleCloudDiscoveryengineV1alphaListUserLicensesResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleCloudDiscoveryengineV1alphaListUserLicensesResponse> list(
    core.String parent, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$parent') + '/userLicenses';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleCloudDiscoveryengineV1alphaListUserLicensesResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

class ProjectsOperationsResource {
  final commons.ApiRequester _requester;

  ProjectsOperationsResource(commons.ApiRequester client) : _requester = client;

  /// Gets the latest state of a long-running operation.
  ///
  /// Clients can use this method to poll the operation result at intervals as
  /// recommended by the API service.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation resource.
  /// Value must have pattern `^projects/\[^/\]+/operations/\[^/\]+$`.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningOperation].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningOperation> get(
    core.String name, {
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name');

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningOperation.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// If the server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Request parameters:
  ///
  /// [name] - The name of the operation's parent resource.
  /// Value must have pattern `^projects/\[^/\]+$`.
  ///
  /// [filter] - The standard list filter.
  ///
  /// [pageSize] - The standard list page size.
  ///
  /// [pageToken] - The standard list page token.
  ///
  /// [$fields] - Selector specifying which fields to include in a partial
  /// response.
  ///
  /// Completes with a [GoogleLongrunningListOperationsResponse].
  ///
  /// Completes with a [commons.ApiRequestError] if the API endpoint returned an
  /// error.
  ///
  /// If the used [http.Client] completes with an error when making a REST call,
  /// this method will complete with the same error.
  async.Future<GoogleLongrunningListOperationsResponse> list(
    core.String name, {
    core.String? filter,
    core.int? pageSize,
    core.String? pageToken,
    core.String? $fields,
  }) async {
    final queryParams_ = <core.String, core.List<core.String>>{
      if (filter != null) 'filter': [filter],
      if (pageSize != null) 'pageSize': ['${pageSize}'],
      if (pageToken != null) 'pageToken': [pageToken],
      if ($fields != null) 'fields': [$fields],
    };

    final url_ = 'v1alpha/' + core.Uri.encodeFull('$name') + '/operations';

    final response_ = await _requester.request(
      url_,
      'GET',
      queryParams: queryParams_,
    );
    return GoogleLongrunningListOperationsResponse.fromJson(
      response_ as core.Map<core.String, core.dynamic>,
    );
  }
}

/// Extra information added to operations that support Scotty media requests.
typedef ApiservingMediaRequestInfo = $MediaRequestInfo;

/// This message is for backends to pass their scotty media specific fields to
/// ESF.
///
/// Backend will include this in their response message to ESF. Example:
/// ExportFile is an rpc defined for upload using scotty from ESF. rpc
/// ExportFile(ExportFileRequest) returns (ExportFileResponse) Message
/// ExportFileResponse will include apiserving.MediaResponseInfo to tell ESF
/// about data like dynamic_dropzone it needs to pass to Scotty. message
/// ExportFileResponse { optional gdata.Media blob = 1; optional
/// apiserving.MediaResponseInfo media_response_info = 2 }
class ApiservingMediaResponseInfo {
  /// Data to copy from backend response to the next backend requests.
  ///
  /// Custom data is returned to Scotty in the agent_state field, which Scotty
  /// will then provide in subsequent upload notifications.
  core.String? customData;

  /// Specifies any transformation to be applied to data before persisting it or
  /// retrieving from storage.
  ///
  /// E.g., encryption options for blobstore2. This should be of the form
  /// uploader_service.DataStorageTransform.
  core.String? dataStorageTransform;
  core.List<core.int> get dataStorageTransformAsBytes =>
      convert.base64.decode(dataStorageTransform!);

  set dataStorageTransformAsBytes(core.List<core.int> bytes_) {
    dataStorageTransform = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// For the first notification of a |diff_encoded| HttpRequestInfo, this is
  /// the index of the blob mint that Scotty should use when writing the
  /// resulting blob.
  ///
  /// This field is optional. It's not required ever, even if
  /// `original_object_blob_mint_index` is set. In situations like that, we will
  /// use the destination blob's mint for the destination blob and regular blob
  /// ACL checks for the original object. Note: This field is only for use by
  /// Drive API for diff uploads.
  core.int? destinationBlobMintIndex;

  /// Specifies the Scotty Drop Target to use for uploads.
  ///
  /// If present in a media response, Scotty does not upload to a standard drop
  /// zone. Instead, Scotty saves the upload directly to the location specified
  /// in this drop target. Unlike drop zones, the drop target is the final
  /// storage location for an upload. So, the agent does not need to clone the
  /// blob at the end of the upload. The agent is responsible for garbage
  /// collecting any orphaned blobs that may occur due to aborted uploads. For
  /// more information, see the drop target design doc here:
  /// http://goto/ScottyDropTarget This field will be preferred to
  /// dynamicDropzone. If provided, the identified field in the response must be
  /// of the type uploader.agent.DropTarget.
  core.String? dynamicDropTarget;
  core.List<core.int> get dynamicDropTargetAsBytes =>
      convert.base64.decode(dynamicDropTarget!);

  set dynamicDropTargetAsBytes(core.List<core.int> bytes_) {
    dynamicDropTarget = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Specifies the Scotty dropzone to use for uploads.
  core.String? dynamicDropzone;

  /// Diff Updates must respond to a START notification with this Media proto to
  /// tell Scotty to decode the diff encoded payload and apply the diff against
  /// this field.
  ///
  /// If the request was diff encoded, but this field is not set, Scotty will
  /// treat the encoding as identity. This is corresponding to Apiary's
  /// DiffUploadResponse.original_object
  /// (//depot/google3/gdata/rosy/proto/data.proto?l=413). See
  /// go/esf-scotty-diff-upload for more information.
  GdataMedia? mediaForDiff;

  /// For the first notification of a |diff_encoded| HttpRequestInfo, this is
  /// the index of the blob mint that Scotty should use when reading the
  /// original blob.
  ///
  /// This field is optional. It's not required ever, even if
  /// `destination_blob_mint_index` is set. In situations like that, we will use
  /// the destination blob's mint for the destination blob and regular blob ACL
  /// checks for the original object. Note: This field is only for use by Drive
  /// API for diff uploads.
  core.int? originalObjectBlobMintIndex;

  /// Request class to use for all Blobstore operations for this request.
  /// Possible string values are:
  /// - "UNKNOWN_REQUEST_CLASS" : Unpopulated request_class in log files will be
  /// taken as 0 in dremel query. GoogleSQL will try to cast it to enum by
  /// default. An unused 0 value is added to avoid GoogleSQL casting error.
  /// Please refer to b/69677280.
  /// - "LATENCY_SENSITIVE" : A latency-sensitive request.
  /// - "PRODUCTION_BATCH" : A request generated by a batch process.
  /// - "BEST_EFFORT" : A best-effort request.
  core.String? requestClass;

  /// Requester ID passed along to be recorded in the Scotty logs
  core.String? scottyAgentUserId;

  /// Customer-specific data to be recorded in the Scotty logs type is
  /// logs_proto_scotty.CustomerLog
  core.String? scottyCustomerLog;
  core.List<core.int> get scottyCustomerLogAsBytes =>
      convert.base64.decode(scottyCustomerLog!);

  set scottyCustomerLogAsBytes(core.List<core.int> bytes_) {
    scottyCustomerLog = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Specifies the TrafficClass that Scotty should use for any RPCs to fetch
  /// the response bytes.
  ///
  /// Will override the traffic class GTOS of the incoming http request. This is
  /// a temporary field to facilitate whitelisting and experimentation by the
  /// bigstore agent only. For instance, this does not apply to RTMP reads.
  /// WARNING: DO NOT USE WITHOUT PERMISSION FROM THE SCOTTY TEAM.
  /// Possible string values are:
  /// - "BE1" : Application-selectable traffic classes Best effort
  /// - "AF1" : Assured forwarding priority 1
  /// - "AF2" : Assured forwarding priority 2
  /// - "AF3" : Assured forwarding priority 3
  /// - "AF4" : Assured forwarding priority 4
  /// - "NC1" : Network control
  /// - "NC0" : Network control
  /// - "BE0" : Best effort at high packet loss
  /// - "LLQ" : Low-latency queue (LLQ) best effort (go/llq)
  /// - "LLQ1" : LLQ assured forwarding priority 1 (go/llq2)
  /// - "LLQ2" : LLQ assured forwarding priority 2 (go/llq2)
  /// - "LLQ3" : LLQ assured forwarding priority 3 (go/llq3)
  core.String? trafficClassField;

  /// Tells Scotty to verify hashes on the agent's behalf by parsing out the
  /// X-Goog-Hash header.
  core.bool? verifyHashFromHeader;

  ApiservingMediaResponseInfo({
    this.customData,
    this.dataStorageTransform,
    this.destinationBlobMintIndex,
    this.dynamicDropTarget,
    this.dynamicDropzone,
    this.mediaForDiff,
    this.originalObjectBlobMintIndex,
    this.requestClass,
    this.scottyAgentUserId,
    this.scottyCustomerLog,
    this.trafficClassField,
    this.verifyHashFromHeader,
  });

  ApiservingMediaResponseInfo.fromJson(core.Map json_)
    : this(
        customData: json_['customData'] as core.String?,
        dataStorageTransform: json_['dataStorageTransform'] as core.String?,
        destinationBlobMintIndex:
            json_['destinationBlobMintIndex'] as core.int?,
        dynamicDropTarget: json_['dynamicDropTarget'] as core.String?,
        dynamicDropzone: json_['dynamicDropzone'] as core.String?,
        mediaForDiff:
            json_.containsKey('mediaForDiff')
                ? GdataMedia.fromJson(
                  json_['mediaForDiff'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        originalObjectBlobMintIndex:
            json_['originalObjectBlobMintIndex'] as core.int?,
        requestClass: json_['requestClass'] as core.String?,
        scottyAgentUserId: json_['scottyAgentUserId'] as core.String?,
        scottyCustomerLog: json_['scottyCustomerLog'] as core.String?,
        trafficClassField: json_['trafficClassField'] as core.String?,
        verifyHashFromHeader: json_['verifyHashFromHeader'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (customData != null) 'customData': customData!,
    if (dataStorageTransform != null)
      'dataStorageTransform': dataStorageTransform!,
    if (destinationBlobMintIndex != null)
      'destinationBlobMintIndex': destinationBlobMintIndex!,
    if (dynamicDropTarget != null) 'dynamicDropTarget': dynamicDropTarget!,
    if (dynamicDropzone != null) 'dynamicDropzone': dynamicDropzone!,
    if (mediaForDiff != null) 'mediaForDiff': mediaForDiff!,
    if (originalObjectBlobMintIndex != null)
      'originalObjectBlobMintIndex': originalObjectBlobMintIndex!,
    if (requestClass != null) 'requestClass': requestClass!,
    if (scottyAgentUserId != null) 'scottyAgentUserId': scottyAgentUserId!,
    if (scottyCustomerLog != null) 'scottyCustomerLog': scottyCustomerLog!,
    if (trafficClassField != null) 'trafficClassField': trafficClassField!,
    if (verifyHashFromHeader != null)
      'verifyHashFromHeader': verifyHashFromHeader!,
  };
}

/// Information to read/write to blobstore2.
typedef GdataBlobstore2Info = $Blobstore2Info00;

/// A sequence of media data references representing composite data.
///
/// Introduced to support Bigstore composite objects. For details, visit
/// http://go/bigstore-composites.
class GdataCompositeMedia {
  /// Blobstore v1 reference, set if reference_type is BLOBSTORE_REF This should
  /// be the byte representation of a blobstore.BlobRef.
  ///
  /// Since Blobstore is deprecating v1, use blobstore2_info instead. For now,
  /// any v2 blob will also be represented in this field as v1 BlobRef.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? blobRef;
  core.List<core.int> get blobRefAsBytes => convert.base64.decode(blobRef!);

  set blobRefAsBytes(core.List<core.int> bytes_) {
    blobRef = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Blobstore v2 info, set if reference_type is BLOBSTORE_REF and it refers to
  /// a v2 blob.
  GdataBlobstore2Info? blobstore2Info;

  /// A binary data reference for a media download.
  ///
  /// Serves as a technology-agnostic binary reference in some Google
  /// infrastructure. This value is a serialized storage_cosmo.BinaryReference
  /// proto. Storing it as bytes is a hack to get around the fact that the cosmo
  /// proto (as well as others it includes) doesn't support JavaScript. This
  /// prevents us from including the actual type of this field.
  core.String? cosmoBinaryReference;
  core.List<core.int> get cosmoBinaryReferenceAsBytes =>
      convert.base64.decode(cosmoBinaryReference!);

  set cosmoBinaryReferenceAsBytes(core.List<core.int> bytes_) {
    cosmoBinaryReference = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// crc32.c hash for the payload.
  core.int? crc32cHash;

  /// Media data, set if reference_type is INLINE
  core.String? inline;
  core.List<core.int> get inlineAsBytes => convert.base64.decode(inline!);

  set inlineAsBytes(core.List<core.int> bytes_) {
    inline = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Size of the data, in bytes
  core.String? length;

  /// MD5 hash for the payload.
  core.String? md5Hash;
  core.List<core.int> get md5HashAsBytes => convert.base64.decode(md5Hash!);

  set md5HashAsBytes(core.List<core.int> bytes_) {
    md5Hash = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Reference to a TI Blob, set if reference_type is BIGSTORE_REF.
  GdataObjectId? objectId;

  /// Path to the data, set if reference_type is PATH
  core.String? path;

  /// Describes what the field reference contains.
  /// Possible string values are:
  /// - "PATH" : Reference contains a GFS path or a local path.
  /// - "BLOB_REF" : Reference points to a blobstore object. This could be
  /// either a v1 blob_ref or a v2 blobstore2_info. Clients should check
  /// blobstore2_info first, since v1 is being deprecated.
  /// - "INLINE" : Data is included into this proto buffer
  /// - "BIGSTORE_REF" : Reference points to a bigstore object
  /// - "COSMO_BINARY_REFERENCE" : Indicates the data is stored in
  /// cosmo_binary_reference.
  core.String? referenceType;

  /// SHA-1 hash for the payload.
  core.String? sha1Hash;
  core.List<core.int> get sha1HashAsBytes => convert.base64.decode(sha1Hash!);

  set sha1HashAsBytes(core.List<core.int> bytes_) {
    sha1Hash = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  GdataCompositeMedia({
    this.blobRef,
    this.blobstore2Info,
    this.cosmoBinaryReference,
    this.crc32cHash,
    this.inline,
    this.length,
    this.md5Hash,
    this.objectId,
    this.path,
    this.referenceType,
    this.sha1Hash,
  });

  GdataCompositeMedia.fromJson(core.Map json_)
    : this(
        blobRef: json_['blobRef'] as core.String?,
        blobstore2Info:
            json_.containsKey('blobstore2Info')
                ? GdataBlobstore2Info.fromJson(
                  json_['blobstore2Info']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        cosmoBinaryReference: json_['cosmoBinaryReference'] as core.String?,
        crc32cHash: json_['crc32cHash'] as core.int?,
        inline: json_['inline'] as core.String?,
        length: json_['length'] as core.String?,
        md5Hash: json_['md5Hash'] as core.String?,
        objectId:
            json_.containsKey('objectId')
                ? GdataObjectId.fromJson(
                  json_['objectId'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        path: json_['path'] as core.String?,
        referenceType: json_['referenceType'] as core.String?,
        sha1Hash: json_['sha1Hash'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobRef != null) 'blobRef': blobRef!,
    if (blobstore2Info != null) 'blobstore2Info': blobstore2Info!,
    if (cosmoBinaryReference != null)
      'cosmoBinaryReference': cosmoBinaryReference!,
    if (crc32cHash != null) 'crc32cHash': crc32cHash!,
    if (inline != null) 'inline': inline!,
    if (length != null) 'length': length!,
    if (md5Hash != null) 'md5Hash': md5Hash!,
    if (objectId != null) 'objectId': objectId!,
    if (path != null) 'path': path!,
    if (referenceType != null) 'referenceType': referenceType!,
    if (sha1Hash != null) 'sha1Hash': sha1Hash!,
  };
}

/// Detailed Content-Type information from Scotty.
///
/// The Content-Type of the media will typically be filled in by the header or
/// Scotty's best_guess, but this extended information provides the backend with
/// more information so that it can make a better decision if needed. This is
/// only used on media upload requests from Scotty.
typedef GdataContentTypeInfo = $ContentTypeInfo00;

/// Backend response for a Diff get checksums response.
///
/// For details on the Scotty Diff protocol, visit
/// http://go/scotty-diff-protocol.
class GdataDiffChecksumsResponse {
  /// Exactly one of these fields must be populated.
  ///
  /// If checksums_location is filled, the server will return the corresponding
  /// contents to the user. If object_location is filled, the server will
  /// calculate the checksums based on the content there and return that to the
  /// user. For details on the format of the checksums, see
  /// http://go/scotty-diff-protocol.
  GdataCompositeMedia? checksumsLocation;

  /// The chunk size of checksums.
  ///
  /// Must be a multiple of 256KB.
  core.String? chunkSizeBytes;

  /// If set, calculate the checksums based on the contents and return them to
  /// the caller.
  GdataCompositeMedia? objectLocation;

  /// The total size of the server object.
  core.String? objectSizeBytes;

  /// The object version of the object the checksums are being returned for.
  core.String? objectVersion;

  GdataDiffChecksumsResponse({
    this.checksumsLocation,
    this.chunkSizeBytes,
    this.objectLocation,
    this.objectSizeBytes,
    this.objectVersion,
  });

  GdataDiffChecksumsResponse.fromJson(core.Map json_)
    : this(
        checksumsLocation:
            json_.containsKey('checksumsLocation')
                ? GdataCompositeMedia.fromJson(
                  json_['checksumsLocation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        chunkSizeBytes: json_['chunkSizeBytes'] as core.String?,
        objectLocation:
            json_.containsKey('objectLocation')
                ? GdataCompositeMedia.fromJson(
                  json_['objectLocation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        objectSizeBytes: json_['objectSizeBytes'] as core.String?,
        objectVersion: json_['objectVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checksumsLocation != null) 'checksumsLocation': checksumsLocation!,
    if (chunkSizeBytes != null) 'chunkSizeBytes': chunkSizeBytes!,
    if (objectLocation != null) 'objectLocation': objectLocation!,
    if (objectSizeBytes != null) 'objectSizeBytes': objectSizeBytes!,
    if (objectVersion != null) 'objectVersion': objectVersion!,
  };
}

/// Backend response for a Diff download response.
///
/// For details on the Scotty Diff protocol, visit
/// http://go/scotty-diff-protocol.
class GdataDiffDownloadResponse {
  /// The original object location.
  GdataCompositeMedia? objectLocation;

  GdataDiffDownloadResponse({this.objectLocation});

  GdataDiffDownloadResponse.fromJson(core.Map json_)
    : this(
        objectLocation:
            json_.containsKey('objectLocation')
                ? GdataCompositeMedia.fromJson(
                  json_['objectLocation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (objectLocation != null) 'objectLocation': objectLocation!,
  };
}

/// A Diff upload request.
///
/// For details on the Scotty Diff protocol, visit
/// http://go/scotty-diff-protocol.
class GdataDiffUploadRequest {
  /// The location of the checksums for the new object.
  ///
  /// Agents must clone the object located here, as the upload server will
  /// delete the contents once a response is received. For details on the format
  /// of the checksums, see http://go/scotty-diff-protocol.
  GdataCompositeMedia? checksumsInfo;

  /// The location of the new object.
  ///
  /// Agents must clone the object located here, as the upload server will
  /// delete the contents once a response is received.
  GdataCompositeMedia? objectInfo;

  /// The object version of the object that is the base version the incoming
  /// diff script will be applied to.
  ///
  /// This field will always be filled in.
  core.String? objectVersion;

  GdataDiffUploadRequest({
    this.checksumsInfo,
    this.objectInfo,
    this.objectVersion,
  });

  GdataDiffUploadRequest.fromJson(core.Map json_)
    : this(
        checksumsInfo:
            json_.containsKey('checksumsInfo')
                ? GdataCompositeMedia.fromJson(
                  json_['checksumsInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        objectInfo:
            json_.containsKey('objectInfo')
                ? GdataCompositeMedia.fromJson(
                  json_['objectInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        objectVersion: json_['objectVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (checksumsInfo != null) 'checksumsInfo': checksumsInfo!,
    if (objectInfo != null) 'objectInfo': objectInfo!,
    if (objectVersion != null) 'objectVersion': objectVersion!,
  };
}

/// Backend response for a Diff upload request.
///
/// For details on the Scotty Diff protocol, visit
/// http://go/scotty-diff-protocol.
class GdataDiffUploadResponse {
  /// The object version of the object at the server.
  ///
  /// Must be included in the end notification response. The version in the end
  /// notification response must correspond to the new version of the object
  /// that is now stored at the server, after the upload.
  core.String? objectVersion;

  /// The location of the original file for a diff upload request.
  ///
  /// Must be filled in if responding to an upload start notification.
  GdataCompositeMedia? originalObject;

  GdataDiffUploadResponse({this.objectVersion, this.originalObject});

  GdataDiffUploadResponse.fromJson(core.Map json_)
    : this(
        objectVersion: json_['objectVersion'] as core.String?,
        originalObject:
            json_.containsKey('originalObject')
                ? GdataCompositeMedia.fromJson(
                  json_['originalObject']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (objectVersion != null) 'objectVersion': objectVersion!,
    if (originalObject != null) 'originalObject': originalObject!,
  };
}

/// Backend response for a Diff get version response.
///
/// For details on the Scotty Diff protocol, visit
/// http://go/scotty-diff-protocol.
typedef GdataDiffVersionResponse = $DiffVersionResponse00;

/// Parameters specific to media downloads.
typedef GdataDownloadParameters = $DownloadParameters00;

/// A reference to data stored on the filesystem, on GFS or in blobstore.
class GdataMedia {
  /// Deprecated, use one of explicit hash type fields instead.
  ///
  /// Algorithm used for calculating the hash. As of 2011/01/21, "MD5" is the
  /// only possible value for this field. New values may be added at any time.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? algorithm;

  /// Use object_id instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? bigstoreObjectRef;
  core.List<core.int> get bigstoreObjectRefAsBytes =>
      convert.base64.decode(bigstoreObjectRef!);

  set bigstoreObjectRefAsBytes(core.List<core.int> bytes_) {
    bigstoreObjectRef = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Blobstore v1 reference, set if reference_type is BLOBSTORE_REF This should
  /// be the byte representation of a blobstore.BlobRef.
  ///
  /// Since Blobstore is deprecating v1, use blobstore2_info instead. For now,
  /// any v2 blob will also be represented in this field as v1 BlobRef.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? blobRef;
  core.List<core.int> get blobRefAsBytes => convert.base64.decode(blobRef!);

  set blobRefAsBytes(core.List<core.int> bytes_) {
    blobRef = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Blobstore v2 info, set if reference_type is BLOBSTORE_REF and it refers to
  /// a v2 blob.
  GdataBlobstore2Info? blobstore2Info;

  /// A composite media composed of one or more media objects, set if
  /// reference_type is COMPOSITE_MEDIA.
  ///
  /// The media length field must be set to the sum of the lengths of all
  /// composite media objects. Note: All composite media must have length
  /// specified.
  core.List<GdataCompositeMedia>? compositeMedia;

  /// MIME type of the data
  core.String? contentType;

  /// Extended content type information provided for Scotty uploads.
  GdataContentTypeInfo? contentTypeInfo;

  /// A binary data reference for a media download.
  ///
  /// Serves as a technology-agnostic binary reference in some Google
  /// infrastructure. This value is a serialized storage_cosmo.BinaryReference
  /// proto. Storing it as bytes is a hack to get around the fact that the cosmo
  /// proto (as well as others it includes) doesn't support JavaScript. This
  /// prevents us from including the actual type of this field.
  core.String? cosmoBinaryReference;
  core.List<core.int> get cosmoBinaryReferenceAsBytes =>
      convert.base64.decode(cosmoBinaryReference!);

  set cosmoBinaryReferenceAsBytes(core.List<core.int> bytes_) {
    cosmoBinaryReference = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// For Scotty Uploads: Scotty-provided hashes for uploads For Scotty
  /// Downloads: (WARNING: DO NOT USE WITHOUT PERMISSION FROM THE SCOTTY TEAM.)
  /// A Hash provided by the agent to be used to verify the data being
  /// downloaded.
  ///
  /// Currently only supported for inline payloads. Further, only crc32c_hash is
  /// currently supported.
  core.int? crc32cHash;

  /// Set if reference_type is DIFF_CHECKSUMS_RESPONSE.
  GdataDiffChecksumsResponse? diffChecksumsResponse;

  /// Set if reference_type is DIFF_DOWNLOAD_RESPONSE.
  GdataDiffDownloadResponse? diffDownloadResponse;

  /// Set if reference_type is DIFF_UPLOAD_REQUEST.
  GdataDiffUploadRequest? diffUploadRequest;

  /// Set if reference_type is DIFF_UPLOAD_RESPONSE.
  GdataDiffUploadResponse? diffUploadResponse;

  /// Set if reference_type is DIFF_VERSION_RESPONSE.
  GdataDiffVersionResponse? diffVersionResponse;

  /// Parameters for a media download.
  GdataDownloadParameters? downloadParameters;

  /// Original file name
  core.String? filename;

  /// Deprecated, use one of explicit hash type fields instead.
  ///
  /// These two hash related fields will only be populated on Scotty based media
  /// uploads and will contain the content of the hash group in the
  /// NotificationRequest:
  /// http://cs/#google3/blobstore2/api/scotty/service/proto/upload_listener.proto&q=class:Hash
  /// Hex encoded hash value of the uploaded media.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? hash;

  /// For Scotty uploads only.
  ///
  /// If a user sends a hash code and the backend has requested that Scotty
  /// verify the upload against the client hash, Scotty will perform the check
  /// on behalf of the backend and will reject it if the hashes don't match.
  /// This is set to true if Scotty performed this verification.
  core.bool? hashVerified;

  /// Media data, set if reference_type is INLINE
  core.String? inline;
  core.List<core.int> get inlineAsBytes => convert.base64.decode(inline!);

  set inlineAsBytes(core.List<core.int> bytes_) {
    inline = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// |is_potential_retry| is set false only when Scotty is certain that it has
  /// not sent the request before.
  ///
  /// When a client resumes an upload, this field must be set true in agent
  /// calls, because Scotty cannot be certain that it has never sent the request
  /// before due to potential failure in the session state persistence.
  core.bool? isPotentialRetry;

  /// Size of the data, in bytes
  core.String? length;

  /// Scotty-provided MD5 hash for an upload.
  core.String? md5Hash;
  core.List<core.int> get md5HashAsBytes => convert.base64.decode(md5Hash!);

  set md5HashAsBytes(core.List<core.int> bytes_) {
    md5Hash = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Media id to forward to the operation GetMedia.
  ///
  /// Can be set if reference_type is GET_MEDIA.
  core.String? mediaId;
  core.List<core.int> get mediaIdAsBytes => convert.base64.decode(mediaId!);

  set mediaIdAsBytes(core.List<core.int> bytes_) {
    mediaId = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Reference to a TI Blob, set if reference_type is BIGSTORE_REF.
  GdataObjectId? objectId;

  /// Path to the data, set if reference_type is PATH
  core.String? path;

  /// Describes what the field reference contains.
  /// Possible string values are:
  /// - "PATH" : Reference contains a GFS path or a local path.
  /// - "BLOB_REF" : Reference points to a blobstore object. This could be
  /// either a v1 blob_ref or a v2 blobstore2_info. Clients should check
  /// blobstore2_info first, since v1 is being deprecated.
  /// - "INLINE" : Data is included into this proto buffer
  /// - "GET_MEDIA" : Data should be accessed from the current service using the
  /// operation GetMedia.
  /// - "COMPOSITE_MEDIA" : The content for this media object is stored across
  /// multiple partial media objects under the composite_media field.
  /// - "BIGSTORE_REF" : Reference points to a bigstore object
  /// - "DIFF_VERSION_RESPONSE" : Indicates the data is stored in
  /// diff_version_response.
  /// - "DIFF_CHECKSUMS_RESPONSE" : Indicates the data is stored in
  /// diff_checksums_response.
  /// - "DIFF_DOWNLOAD_RESPONSE" : Indicates the data is stored in
  /// diff_download_response.
  /// - "DIFF_UPLOAD_REQUEST" : Indicates the data is stored in
  /// diff_upload_request.
  /// - "DIFF_UPLOAD_RESPONSE" : Indicates the data is stored in
  /// diff_upload_response.
  /// - "COSMO_BINARY_REFERENCE" : Indicates the data is stored in
  /// cosmo_binary_reference.
  /// - "ARBITRARY_BYTES" : Informs Scotty to generate a response payload with
  /// the size specified in the length field. The contents of the payload are
  /// generated by Scotty and are undefined. This is useful for testing download
  /// speeds between the user and Scotty without involving a real payload
  /// source. Note: range is not supported when using arbitrary_bytes.
  core.String? referenceType;

  /// Scotty-provided SHA1 hash for an upload.
  core.String? sha1Hash;
  core.List<core.int> get sha1HashAsBytes => convert.base64.decode(sha1Hash!);

  set sha1HashAsBytes(core.List<core.int> bytes_) {
    sha1Hash = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Scotty-provided SHA256 hash for an upload.
  core.String? sha256Hash;
  core.List<core.int> get sha256HashAsBytes =>
      convert.base64.decode(sha256Hash!);

  set sha256HashAsBytes(core.List<core.int> bytes_) {
    sha256Hash = convert.base64
        .encode(bytes_)
        .replaceAll('/', '_')
        .replaceAll('+', '-');
  }

  /// Time at which the media data was last updated, in milliseconds since UNIX
  /// epoch
  core.String? timestamp;

  /// A unique fingerprint/version id for the media data
  core.String? token;

  GdataMedia({
    this.algorithm,
    this.bigstoreObjectRef,
    this.blobRef,
    this.blobstore2Info,
    this.compositeMedia,
    this.contentType,
    this.contentTypeInfo,
    this.cosmoBinaryReference,
    this.crc32cHash,
    this.diffChecksumsResponse,
    this.diffDownloadResponse,
    this.diffUploadRequest,
    this.diffUploadResponse,
    this.diffVersionResponse,
    this.downloadParameters,
    this.filename,
    this.hash,
    this.hashVerified,
    this.inline,
    this.isPotentialRetry,
    this.length,
    this.md5Hash,
    this.mediaId,
    this.objectId,
    this.path,
    this.referenceType,
    this.sha1Hash,
    this.sha256Hash,
    this.timestamp,
    this.token,
  });

  GdataMedia.fromJson(core.Map json_)
    : this(
        algorithm: json_['algorithm'] as core.String?,
        bigstoreObjectRef: json_['bigstoreObjectRef'] as core.String?,
        blobRef: json_['blobRef'] as core.String?,
        blobstore2Info:
            json_.containsKey('blobstore2Info')
                ? GdataBlobstore2Info.fromJson(
                  json_['blobstore2Info']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        compositeMedia:
            (json_['compositeMedia'] as core.List?)
                ?.map(
                  (value) => GdataCompositeMedia.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        contentType: json_['contentType'] as core.String?,
        contentTypeInfo:
            json_.containsKey('contentTypeInfo')
                ? GdataContentTypeInfo.fromJson(
                  json_['contentTypeInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        cosmoBinaryReference: json_['cosmoBinaryReference'] as core.String?,
        crc32cHash: json_['crc32cHash'] as core.int?,
        diffChecksumsResponse:
            json_.containsKey('diffChecksumsResponse')
                ? GdataDiffChecksumsResponse.fromJson(
                  json_['diffChecksumsResponse']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        diffDownloadResponse:
            json_.containsKey('diffDownloadResponse')
                ? GdataDiffDownloadResponse.fromJson(
                  json_['diffDownloadResponse']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        diffUploadRequest:
            json_.containsKey('diffUploadRequest')
                ? GdataDiffUploadRequest.fromJson(
                  json_['diffUploadRequest']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        diffUploadResponse:
            json_.containsKey('diffUploadResponse')
                ? GdataDiffUploadResponse.fromJson(
                  json_['diffUploadResponse']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        diffVersionResponse:
            json_.containsKey('diffVersionResponse')
                ? GdataDiffVersionResponse.fromJson(
                  json_['diffVersionResponse']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        downloadParameters:
            json_.containsKey('downloadParameters')
                ? GdataDownloadParameters.fromJson(
                  json_['downloadParameters']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        filename: json_['filename'] as core.String?,
        hash: json_['hash'] as core.String?,
        hashVerified: json_['hashVerified'] as core.bool?,
        inline: json_['inline'] as core.String?,
        isPotentialRetry: json_['isPotentialRetry'] as core.bool?,
        length: json_['length'] as core.String?,
        md5Hash: json_['md5Hash'] as core.String?,
        mediaId: json_['mediaId'] as core.String?,
        objectId:
            json_.containsKey('objectId')
                ? GdataObjectId.fromJson(
                  json_['objectId'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        path: json_['path'] as core.String?,
        referenceType: json_['referenceType'] as core.String?,
        sha1Hash: json_['sha1Hash'] as core.String?,
        sha256Hash: json_['sha256Hash'] as core.String?,
        timestamp: json_['timestamp'] as core.String?,
        token: json_['token'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (algorithm != null) 'algorithm': algorithm!,
    if (bigstoreObjectRef != null) 'bigstoreObjectRef': bigstoreObjectRef!,
    if (blobRef != null) 'blobRef': blobRef!,
    if (blobstore2Info != null) 'blobstore2Info': blobstore2Info!,
    if (compositeMedia != null) 'compositeMedia': compositeMedia!,
    if (contentType != null) 'contentType': contentType!,
    if (contentTypeInfo != null) 'contentTypeInfo': contentTypeInfo!,
    if (cosmoBinaryReference != null)
      'cosmoBinaryReference': cosmoBinaryReference!,
    if (crc32cHash != null) 'crc32cHash': crc32cHash!,
    if (diffChecksumsResponse != null)
      'diffChecksumsResponse': diffChecksumsResponse!,
    if (diffDownloadResponse != null)
      'diffDownloadResponse': diffDownloadResponse!,
    if (diffUploadRequest != null) 'diffUploadRequest': diffUploadRequest!,
    if (diffUploadResponse != null) 'diffUploadResponse': diffUploadResponse!,
    if (diffVersionResponse != null)
      'diffVersionResponse': diffVersionResponse!,
    if (downloadParameters != null) 'downloadParameters': downloadParameters!,
    if (filename != null) 'filename': filename!,
    if (hash != null) 'hash': hash!,
    if (hashVerified != null) 'hashVerified': hashVerified!,
    if (inline != null) 'inline': inline!,
    if (isPotentialRetry != null) 'isPotentialRetry': isPotentialRetry!,
    if (length != null) 'length': length!,
    if (md5Hash != null) 'md5Hash': md5Hash!,
    if (mediaId != null) 'mediaId': mediaId!,
    if (objectId != null) 'objectId': objectId!,
    if (path != null) 'path': path!,
    if (referenceType != null) 'referenceType': referenceType!,
    if (sha1Hash != null) 'sha1Hash': sha1Hash!,
    if (sha256Hash != null) 'sha256Hash': sha256Hash!,
    if (timestamp != null) 'timestamp': timestamp!,
    if (token != null) 'token': token!,
  };
}

/// This is a copy of the tech.blob.ObjectId proto, which could not be used
/// directly here due to transitive closure issues with JavaScript support; see
/// http://b/8801763.
typedef GdataObjectId = $ObjectId00;

/// `Distribution` contains summary statistics for a population of values.
///
/// It optionally contains a histogram representing the distribution of those
/// values across a set of buckets. The summary statistics are the count, mean,
/// sum of the squared deviation from the mean, the minimum, and the maximum of
/// the set of population of values. The histogram is based on a sequence of
/// buckets and gives a count of values that fall into each bucket. The
/// boundaries of the buckets are given either explicitly or by formulas for
/// buckets of fixed or exponentially increasing widths. Although it is not
/// forbidden, it is generally a bad idea to include non-finite values
/// (infinities or NaNs) in the population of values, as this will render the
/// `mean` and `sum_of_squared_deviation` fields meaningless.
class GoogleApiDistribution {
  /// The number of values in each bucket of the histogram, as described in
  /// `bucket_options`.
  ///
  /// If the distribution does not have a histogram, then omit this field. If
  /// there is a histogram, then the sum of the values in `bucket_counts` must
  /// equal the value in the `count` field of the distribution. If present,
  /// `bucket_counts` should contain N values, where N is the number of buckets
  /// specified in `bucket_options`. If you supply fewer than N values, the
  /// remaining values are assumed to be 0. The order of the values in
  /// `bucket_counts` follows the bucket numbering schemes described for the
  /// three bucket types. The first value must be the count for the underflow
  /// bucket (number 0). The next N-2 values are the counts for the finite
  /// buckets (number 1 through N-2). The N'th value in `bucket_counts` is the
  /// count for the overflow bucket (number N-1).
  core.List<core.String>? bucketCounts;

  /// Defines the histogram bucket boundaries.
  ///
  /// If the distribution does not contain a histogram, then omit this field.
  GoogleApiDistributionBucketOptions? bucketOptions;

  /// The number of values in the population.
  ///
  /// Must be non-negative. This value must equal the sum of the values in
  /// `bucket_counts` if a histogram is provided.
  core.String? count;

  /// Must be in increasing order of `value` field.
  core.List<GoogleApiDistributionExemplar>? exemplars;

  /// The arithmetic mean of the values in the population.
  ///
  /// If `count` is zero then this field must be zero.
  core.double? mean;

  /// If specified, contains the range of the population values.
  ///
  /// The field must not be present if the `count` is zero.
  GoogleApiDistributionRange? range;

  /// The sum of squared deviations from the mean of the values in the
  /// population.
  ///
  /// For values x_i this is: Sum\[i=1..n\]((x_i - mean)^2) Knuth, "The Art of
  /// Computer Programming", Vol. 2, page 232, 3rd edition describes Welford's
  /// method for accumulating this sum in one pass. If `count` is zero then this
  /// field must be zero.
  core.double? sumOfSquaredDeviation;

  GoogleApiDistribution({
    this.bucketCounts,
    this.bucketOptions,
    this.count,
    this.exemplars,
    this.mean,
    this.range,
    this.sumOfSquaredDeviation,
  });

  GoogleApiDistribution.fromJson(core.Map json_)
    : this(
        bucketCounts:
            (json_['bucketCounts'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        bucketOptions:
            json_.containsKey('bucketOptions')
                ? GoogleApiDistributionBucketOptions.fromJson(
                  json_['bucketOptions'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        count: json_['count'] as core.String?,
        exemplars:
            (json_['exemplars'] as core.List?)
                ?.map(
                  (value) => GoogleApiDistributionExemplar.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        mean: (json_['mean'] as core.num?)?.toDouble(),
        range:
            json_.containsKey('range')
                ? GoogleApiDistributionRange.fromJson(
                  json_['range'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        sumOfSquaredDeviation:
            (json_['sumOfSquaredDeviation'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bucketCounts != null) 'bucketCounts': bucketCounts!,
    if (bucketOptions != null) 'bucketOptions': bucketOptions!,
    if (count != null) 'count': count!,
    if (exemplars != null) 'exemplars': exemplars!,
    if (mean != null) 'mean': mean!,
    if (range != null) 'range': range!,
    if (sumOfSquaredDeviation != null)
      'sumOfSquaredDeviation': sumOfSquaredDeviation!,
  };
}

/// `BucketOptions` describes the bucket boundaries used to create a histogram
/// for the distribution.
///
/// The buckets can be in a linear sequence, an exponential sequence, or each
/// bucket can be specified explicitly. `BucketOptions` does not include the
/// number of values in each bucket. A bucket has an inclusive lower bound and
/// exclusive upper bound for the values that are counted for that bucket. The
/// upper bound of a bucket must be strictly greater than the lower bound. The
/// sequence of N buckets for a distribution consists of an underflow bucket
/// (number 0), zero or more finite buckets (number 1 through N - 2) and an
/// overflow bucket (number N - 1). The buckets are contiguous: the lower bound
/// of bucket i (i \> 0) is the same as the upper bound of bucket i - 1. The
/// buckets span the whole range of finite values: lower bound of the underflow
/// bucket is -infinity and the upper bound of the overflow bucket is +infinity.
/// The finite buckets are so-called because both bounds are finite.
class GoogleApiDistributionBucketOptions {
  /// The explicit buckets.
  GoogleApiDistributionBucketOptionsExplicit? explicitBuckets;

  /// The exponential buckets.
  GoogleApiDistributionBucketOptionsExponential? exponentialBuckets;

  /// The linear bucket.
  GoogleApiDistributionBucketOptionsLinear? linearBuckets;

  GoogleApiDistributionBucketOptions({
    this.explicitBuckets,
    this.exponentialBuckets,
    this.linearBuckets,
  });

  GoogleApiDistributionBucketOptions.fromJson(core.Map json_)
    : this(
        explicitBuckets:
            json_.containsKey('explicitBuckets')
                ? GoogleApiDistributionBucketOptionsExplicit.fromJson(
                  json_['explicitBuckets']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        exponentialBuckets:
            json_.containsKey('exponentialBuckets')
                ? GoogleApiDistributionBucketOptionsExponential.fromJson(
                  json_['exponentialBuckets']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        linearBuckets:
            json_.containsKey('linearBuckets')
                ? GoogleApiDistributionBucketOptionsLinear.fromJson(
                  json_['linearBuckets'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (explicitBuckets != null) 'explicitBuckets': explicitBuckets!,
    if (exponentialBuckets != null) 'exponentialBuckets': exponentialBuckets!,
    if (linearBuckets != null) 'linearBuckets': linearBuckets!,
  };
}

/// Specifies a set of buckets with arbitrary widths.
///
/// There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following
/// boundaries: Upper bound (0 \<= i \< N-1): bounds\[i\] Lower bound (1 \<= i
/// \< N); bounds\[i - 1\] The `bounds` field must contain at least one element.
/// If `bounds` has only one element, then there are no finite buckets, and that
/// single element is the common boundary of the overflow and underflow buckets.
typedef GoogleApiDistributionBucketOptionsExplicit = $Explicit;

/// Specifies an exponential sequence of buckets that have a width that is
/// proportional to the value of the lower bound.
///
/// Each bucket represents a constant relative uncertainty on a specific value
/// in the bucket. There are `num_finite_buckets + 2` (= N) buckets. Bucket `i`
/// has the following boundaries: Upper bound (0 \<= i \< N-1): scale *
/// (growth_factor ^ i). Lower bound (1 \<= i \< N): scale * (growth_factor ^ (i
/// - 1)).
typedef GoogleApiDistributionBucketOptionsExponential = $Exponential;

/// Specifies a linear sequence of buckets that all have the same width (except
/// overflow and underflow).
///
/// Each bucket represents a constant absolute uncertainty on the specific value
/// in the bucket. There are `num_finite_buckets + 2` (= N) buckets. Bucket `i`
/// has the following boundaries: Upper bound (0 \<= i \< N-1): offset + (width
/// * i). Lower bound (1 \<= i \< N): offset + (width * (i - 1)).
typedef GoogleApiDistributionBucketOptionsLinear = $Linear;

/// Exemplars are example points that may be used to annotate aggregated
/// distribution values.
///
/// They are metadata that gives information about a particular value added to a
/// Distribution bucket, such as a trace ID that was active when a value was
/// added. They may contain further information, such as a example values and
/// timestamps, origin, etc.
typedef GoogleApiDistributionExemplar = $Exemplar;

/// The range of the population values.
typedef GoogleApiDistributionRange = $Range;

/// Message that represents an arbitrary HTTP body.
///
/// It should only be used for payload formats that can't be represented as
/// JSON, such as raw binary or an HTML page. This message can be used both in
/// streaming and non-streaming API methods in the request as well as the
/// response. It can be used as a top-level request field, which is convenient
/// if one wants to extract parameters from either the URL or HTTP template into
/// the request fields and also want access to the raw HTTP body. Example:
/// message GetResourceRequest { // A unique request id. string request_id = 1;
/// // The raw HTTP body is bound to this field. google.api.HttpBody http_body =
/// 2; } service ResourceService { rpc GetResource(GetResourceRequest) returns
/// (google.api.HttpBody); rpc UpdateResource(google.api.HttpBody) returns
/// (google.protobuf.Empty); } Example with streaming methods: service
/// CaldavService { rpc GetCalendar(stream google.api.HttpBody) returns (stream
/// google.api.HttpBody); rpc UpdateCalendar(stream google.api.HttpBody) returns
/// (stream google.api.HttpBody); } Use of this type only changes how the
/// request and response bodies are handled, all other features will continue to
/// work unchanged.
typedef GoogleApiHttpBody = $HttpBody;

/// A specific metric, identified by specifying values for all of the labels of
/// a `MetricDescriptor`.
typedef GoogleApiMetric = $GoogleApiMetric;

/// An object representing a resource that can be used for monitoring, logging,
/// billing, or other purposes.
///
/// Examples include virtual machine instances, databases, and storage devices
/// such as disks. The `type` field identifies a MonitoredResourceDescriptor
/// object that describes the resource's schema. Information in the `labels`
/// field identifies the actual resource and its attributes according to the
/// schema. For example, a particular Compute Engine VM instance could be
/// represented by the following object, because the MonitoredResourceDescriptor
/// for `"gce_instance"` has labels `"project_id"`, `"instance_id"` and
/// `"zone"`: { "type": "gce_instance", "labels": { "project_id": "my-project",
/// "instance_id": "12345678901234", "zone": "us-central1-a" }}
typedef GoogleApiMonitoredResource = $GoogleApiMonitoredResource;

/// Auxiliary metadata for a MonitoredResource object.
///
/// MonitoredResource objects contain the minimum set of information to uniquely
/// identify a monitored resource instance. There is some other useful auxiliary
/// metadata. Monitoring and Logging use an ingestion pipeline to extract
/// metadata for cloud resources of all types, and store the metadata in this
/// message.
typedef GoogleApiMonitoredResourceMetadata =
    $GoogleApiMonitoredResourceMetadata;

/// Access Control Configuration.
class GoogleCloudDiscoveryengineV1alphaAclConfig {
  /// Identity provider config.
  GoogleCloudDiscoveryengineV1alphaIdpConfig? idpConfig;

  /// The full resource name of the acl configuration.
  ///
  /// Format: `projects/{project}/locations/{location}/aclConfig`. This field
  /// must be a UTF-8 encoded string with a length limit of 1024 characters.
  ///
  /// Immutable.
  core.String? name;

  GoogleCloudDiscoveryengineV1alphaAclConfig({this.idpConfig, this.name});

  GoogleCloudDiscoveryengineV1alphaAclConfig.fromJson(core.Map json_)
    : this(
        idpConfig:
            json_.containsKey('idpConfig')
                ? GoogleCloudDiscoveryengineV1alphaIdpConfig.fromJson(
                  json_['idpConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (idpConfig != null) 'idpConfig': idpConfig!,
    if (name != null) 'name': name!,
  };
}

/// Request message for the DataConnectorService.AcquireAccessToken method.
typedef GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenRequest = $Empty;

/// Response message for the DataConnectorService.AcquireAccessToken method.
class GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenResponse {
  /// The created access token.
  core.String? accessToken;

  /// Info about the stored refresh token used to create the access token.
  GoogleCloudDiscoveryengineV1alphaRefreshTokenInfo? refreshTokenInfo;

  GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenResponse({
    this.accessToken,
    this.refreshTokenInfo,
  });

  GoogleCloudDiscoveryengineV1alphaAcquireAccessTokenResponse.fromJson(
    core.Map json_,
  ) : this(
        accessToken: json_['accessToken'] as core.String?,
        refreshTokenInfo:
            json_.containsKey('refreshTokenInfo')
                ? GoogleCloudDiscoveryengineV1alphaRefreshTokenInfo.fromJson(
                  json_['refreshTokenInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessToken != null) 'accessToken': accessToken!,
    if (refreshTokenInfo != null) 'refreshTokenInfo': refreshTokenInfo!,
  };
}

/// Informations to support actions on the connector.
class GoogleCloudDiscoveryengineV1alphaActionConfig {
  /// Params needed to support actions in the format of (Key, Value) pairs.
  ///
  /// Required parameters for sources that support OAUTH, i.e. `gmail`,
  /// `google_calendar`, `jira`, `workday`, `salesforce`, `confluence`: * Key:
  /// `client_id` * Value: type STRING. The client ID for the service provider
  /// to identify your application. * Key: `client_secret` * Value:type STRING.
  /// The client secret generated by the application's authorization server.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? actionParams;

  /// The connector contains the necessary parameters and is configured to
  /// support actions.
  ///
  /// Output only.
  core.bool? isActionConfigured;

  /// The Service Directory resource name (projects / * /locations / *
  /// /namespaces / * /services / * ) representing a VPC network endpoint used
  /// to connect to the data source's `instance_uri`, defined in
  /// DataConnector.params.
  ///
  /// Required when VPC Service Controls are enabled.
  ///
  /// Optional.
  core.String? serviceName;

  GoogleCloudDiscoveryengineV1alphaActionConfig({
    this.actionParams,
    this.isActionConfigured,
    this.serviceName,
  });

  GoogleCloudDiscoveryengineV1alphaActionConfig.fromJson(core.Map json_)
    : this(
        actionParams:
            json_.containsKey('actionParams')
                ? json_['actionParams'] as core.Map<core.String, core.dynamic>
                : null,
        isActionConfigured: json_['isActionConfigured'] as core.bool?,
        serviceName: json_['serviceName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actionParams != null) 'actionParams': actionParams!,
    if (isActionConfigured != null) 'isActionConfigured': isActionConfigured!,
    if (serviceName != null) 'serviceName': serviceName!,
  };
}

/// Request message for CompletionService.AdvancedCompleteQuery method.
///
/// .
class GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequest {
  /// Specification to boost suggestions matching the condition.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpec?
  boostSpec;

  /// Experiment ids for this request.
  ///
  /// Optional.
  core.List<core.String>? experimentIds;

  /// Indicates if tail suggestions should be returned if there are no
  /// suggestions that match the full query.
  ///
  /// Even if set to true, if there are suggestions that match the full query,
  /// those are returned and no tail suggestions are returned.
  core.bool? includeTailSuggestions;

  /// The typeahead input used to fetch suggestions.
  ///
  /// Maximum length is 128 characters. The query can not be empty for most of
  /// the suggestion types. If it is empty, an `INVALID_ARGUMENT` error is
  /// returned. The exception is when the suggestion_types contains only the
  /// type `RECENT_SEARCH`, the query can be an empty string. The is called
  /// "zero prefix" feature, which returns user's recently searched queries
  /// given the empty query.
  ///
  /// Required.
  core.String? query;

  /// Specifies the autocomplete query model, which only applies to the QUERY
  /// SuggestionType.
  ///
  /// This overrides any model specified in the Configuration \> Autocomplete
  /// section of the Cloud console. Currently supported values: * `document` -
  /// Using suggestions generated from user-imported documents. *
  /// `search-history` - Using suggestions generated from the past history of
  /// SearchService.Search API calls. Do not use it when there is no traffic for
  /// Search API. * `user-event` - Using suggestions generated from
  /// user-imported search events. * `document-completable` - Using suggestions
  /// taken directly from user-imported document fields marked as completable.
  /// Default values: * `document` is the default model for regular dataStores.
  /// * `search-history` is the default model for site search dataStores.
  core.String? queryModel;

  /// Specification of each suggestion type.
  ///
  /// Optional.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestSuggestionTypeSpec
  >?
  suggestionTypeSpecs;

  /// Suggestion types to return.
  ///
  /// If empty or unspecified, query suggestions are returned. Only one
  /// suggestion type is supported at the moment.
  ///
  /// Optional.
  core.List<core.String>? suggestionTypes;

  /// Information about the end user.
  ///
  /// This should be the same identifier information as UserEvent.user_info and
  /// SearchRequest.user_info.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaUserInfo? userInfo;

  /// A unique identifier for tracking visitors.
  ///
  /// For example, this could be implemented with an HTTP cookie, which should
  /// be able to uniquely identify a visitor on a single device. This unique
  /// identifier should not change if the visitor logs in or out of the website.
  /// This field should NOT have a fixed value such as `unknown_visitor`. This
  /// should be the same identifier as UserEvent.user_pseudo_id and
  /// SearchRequest.user_pseudo_id. The field must be a UTF-8 encoded string
  /// with a length limit of 128
  core.String? userPseudoId;

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequest({
    this.boostSpec,
    this.experimentIds,
    this.includeTailSuggestions,
    this.query,
    this.queryModel,
    this.suggestionTypeSpecs,
    this.suggestionTypes,
    this.userInfo,
    this.userPseudoId,
  });

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequest.fromJson(
    core.Map json_,
  ) : this(
        boostSpec:
            json_.containsKey('boostSpec')
                ? GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpec.fromJson(
                  json_['boostSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        experimentIds:
            (json_['experimentIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        includeTailSuggestions: json_['includeTailSuggestions'] as core.bool?,
        query: json_['query'] as core.String?,
        queryModel: json_['queryModel'] as core.String?,
        suggestionTypeSpecs:
            (json_['suggestionTypeSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestSuggestionTypeSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        suggestionTypes:
            (json_['suggestionTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        userInfo:
            json_.containsKey('userInfo')
                ? GoogleCloudDiscoveryengineV1alphaUserInfo.fromJson(
                  json_['userInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userPseudoId: json_['userPseudoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boostSpec != null) 'boostSpec': boostSpec!,
    if (experimentIds != null) 'experimentIds': experimentIds!,
    if (includeTailSuggestions != null)
      'includeTailSuggestions': includeTailSuggestions!,
    if (query != null) 'query': query!,
    if (queryModel != null) 'queryModel': queryModel!,
    if (suggestionTypeSpecs != null)
      'suggestionTypeSpecs': suggestionTypeSpecs!,
    if (suggestionTypes != null) 'suggestionTypes': suggestionTypes!,
    if (userInfo != null) 'userInfo': userInfo!,
    if (userPseudoId != null) 'userPseudoId': userPseudoId!,
  };
}

/// Specification to boost suggestions based on the condtion of the suggestion.
class GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpec {
  /// Condition boost specifications.
  ///
  /// If a suggestion matches multiple conditions in the specifications, boost
  /// values from these specifications are all applied and combined in a
  /// non-linear way. Maximum number of specifications is 20. Note: Currently
  /// only support language condition boost.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpecConditionBoostSpec
  >?
  conditionBoostSpecs;

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpec({
    this.conditionBoostSpecs,
  });

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpec.fromJson(
    core.Map json_,
  ) : this(
        conditionBoostSpecs:
            (json_['conditionBoostSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpecConditionBoostSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (conditionBoostSpecs != null)
      'conditionBoostSpecs': conditionBoostSpecs!,
  };
}

/// Boost applies to suggestions which match a condition.
typedef GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestBoostSpecConditionBoostSpec =
    $AdvancedCompleteQueryRequestBoostSpecConditionBoostSpec;

/// Specification of each suggestion type.
typedef GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryRequestSuggestionTypeSpec =
    $AdvancedCompleteQueryRequestSuggestionTypeSpec;

/// Response message for CompletionService.AdvancedCompleteQuery method.
class GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse {
  /// Results of the matched content suggestions.
  ///
  /// The result list is ordered and the first result is the top suggestion.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseContentSuggestion
  >?
  contentSuggestions;

  /// Results of the matched people suggestions.
  ///
  /// The result list is ordered and the first result is the top suggestion.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponsePersonSuggestion
  >?
  peopleSuggestions;

  /// Results of the matched query suggestions.
  ///
  /// The result list is ordered and the first result is a top suggestion.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseQuerySuggestion
  >?
  querySuggestions;

  /// Results of the matched "recent search" suggestions.
  ///
  /// The result list is ordered and the first result is the top suggestion.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseRecentSearchSuggestion
  >?
  recentSearchSuggestions;

  /// True if the returned suggestions are all tail suggestions.
  ///
  /// For tail matching to be triggered, include_tail_suggestions in the request
  /// must be true and there must be no suggestions that match the full query.
  core.bool? tailMatchTriggered;

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse({
    this.contentSuggestions,
    this.peopleSuggestions,
    this.querySuggestions,
    this.recentSearchSuggestions,
    this.tailMatchTriggered,
  });

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponse.fromJson(
    core.Map json_,
  ) : this(
        contentSuggestions:
            (json_['contentSuggestions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseContentSuggestion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        peopleSuggestions:
            (json_['peopleSuggestions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponsePersonSuggestion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        querySuggestions:
            (json_['querySuggestions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseQuerySuggestion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        recentSearchSuggestions:
            (json_['recentSearchSuggestions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseRecentSearchSuggestion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        tailMatchTriggered: json_['tailMatchTriggered'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentSuggestions != null) 'contentSuggestions': contentSuggestions!,
    if (peopleSuggestions != null) 'peopleSuggestions': peopleSuggestions!,
    if (querySuggestions != null) 'querySuggestions': querySuggestions!,
    if (recentSearchSuggestions != null)
      'recentSearchSuggestions': recentSearchSuggestions!,
    if (tailMatchTriggered != null) 'tailMatchTriggered': tailMatchTriggered!,
  };
}

/// Suggestions as content.
class GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseContentSuggestion {
  /// The type of the content suggestion.
  /// Possible string values are:
  /// - "CONTENT_TYPE_UNSPECIFIED" : Default value.
  /// - "GOOGLE_WORKSPACE" : The suggestion is from a Google Workspace source.
  /// - "THIRD_PARTY" : The suggestion is from a third party source.
  core.String? contentType;

  /// The name of the dataStore that this suggestion belongs to.
  core.String? dataStore;

  /// The destination uri of the content suggestion.
  core.String? destinationUri;

  /// The document data snippet in the suggestion.
  ///
  /// Only a subset of fields will be populated.
  GoogleCloudDiscoveryengineV1alphaDocument? document;

  /// The icon uri of the content suggestion.
  core.String? iconUri;

  /// The score of each suggestion.
  ///
  /// The score is in the range of \[0, 1\].
  core.double? score;

  /// The suggestion for the query.
  core.String? suggestion;

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseContentSuggestion({
    this.contentType,
    this.dataStore,
    this.destinationUri,
    this.document,
    this.iconUri,
    this.score,
    this.suggestion,
  });

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseContentSuggestion.fromJson(
    core.Map json_,
  ) : this(
        contentType: json_['contentType'] as core.String?,
        dataStore: json_['dataStore'] as core.String?,
        destinationUri: json_['destinationUri'] as core.String?,
        document:
            json_.containsKey('document')
                ? GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
                  json_['document'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        iconUri: json_['iconUri'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
        suggestion: json_['suggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentType != null) 'contentType': contentType!,
    if (dataStore != null) 'dataStore': dataStore!,
    if (destinationUri != null) 'destinationUri': destinationUri!,
    if (document != null) 'document': document!,
    if (iconUri != null) 'iconUri': iconUri!,
    if (score != null) 'score': score!,
    if (suggestion != null) 'suggestion': suggestion!,
  };
}

/// Suggestions as people.
class GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponsePersonSuggestion {
  /// The name of the dataStore that this suggestion belongs to.
  core.String? dataStore;

  /// The destination uri of the person suggestion.
  core.String? destinationUri;

  /// The photo uri of the person suggestion.
  core.String? displayPhotoUri;

  /// The document data snippet in the suggestion.
  ///
  /// Only a subset of fields is populated.
  GoogleCloudDiscoveryengineV1alphaDocument? document;

  /// The type of the person.
  /// Possible string values are:
  /// - "PERSON_TYPE_UNSPECIFIED" : Default value.
  /// - "CLOUD_IDENTITY" : The suggestion is from a GOOGLE_IDENTITY source.
  /// - "THIRD_PARTY_IDENTITY" : The suggestion is from a THIRD_PARTY_IDENTITY
  /// source.
  core.String? personType;

  /// The score of each suggestion.
  ///
  /// The score is in the range of \[0, 1\].
  core.double? score;

  /// The suggestion for the query.
  core.String? suggestion;

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponsePersonSuggestion({
    this.dataStore,
    this.destinationUri,
    this.displayPhotoUri,
    this.document,
    this.personType,
    this.score,
    this.suggestion,
  });

  GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponsePersonSuggestion.fromJson(
    core.Map json_,
  ) : this(
        dataStore: json_['dataStore'] as core.String?,
        destinationUri: json_['destinationUri'] as core.String?,
        displayPhotoUri: json_['displayPhotoUri'] as core.String?,
        document:
            json_.containsKey('document')
                ? GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
                  json_['document'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        personType: json_['personType'] as core.String?,
        score: (json_['score'] as core.num?)?.toDouble(),
        suggestion: json_['suggestion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStore != null) 'dataStore': dataStore!,
    if (destinationUri != null) 'destinationUri': destinationUri!,
    if (displayPhotoUri != null) 'displayPhotoUri': displayPhotoUri!,
    if (document != null) 'document': document!,
    if (personType != null) 'personType': personType!,
    if (score != null) 'score': score!,
    if (suggestion != null) 'suggestion': suggestion!,
  };
}

/// Suggestions as search queries.
typedef GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseQuerySuggestion =
    $AdvancedCompleteQueryResponseQuerySuggestion;

/// Suggestions from recent search history.
typedef GoogleCloudDiscoveryengineV1alphaAdvancedCompleteQueryResponseRecentSearchSuggestion =
    $AdvancedCompleteQueryResponseRecentSearchSuggestion;

/// Configuration data for advance site search.
typedef GoogleCloudDiscoveryengineV1alphaAdvancedSiteSearchConfig =
    $AdvancedSiteSearchConfig;

/// The connector level alert config.
class GoogleCloudDiscoveryengineV1alphaAlertPolicyConfig {
  /// The enrollment states of each alert.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaAlertPolicyConfigAlertEnrollment>?
  alertEnrollments;

  /// The fully qualified resource name of the AlertPolicy.
  ///
  /// Immutable.
  core.String? alertPolicyName;

  GoogleCloudDiscoveryengineV1alphaAlertPolicyConfig({
    this.alertEnrollments,
    this.alertPolicyName,
  });

  GoogleCloudDiscoveryengineV1alphaAlertPolicyConfig.fromJson(core.Map json_)
    : this(
        alertEnrollments:
            (json_['alertEnrollments'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAlertPolicyConfigAlertEnrollment.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        alertPolicyName: json_['alertPolicyName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alertEnrollments != null) 'alertEnrollments': alertEnrollments!,
    if (alertPolicyName != null) 'alertPolicyName': alertPolicyName!,
  };
}

/// The alert enrollment status.
class GoogleCloudDiscoveryengineV1alphaAlertPolicyConfigAlertEnrollment {
  /// The id of an alert.
  ///
  /// Immutable.
  core.String? alertId;

  /// The enrollment status of a customer.
  ///
  /// Required.
  /// Possible string values are:
  /// - "ENROLL_STATES_UNSPECIFIED" : Default value. Used for customers who have
  /// not responded to the alert policy.
  /// - "ENROLLED" : Customer is enrolled in this policy.
  /// - "DECLINED" : Customer declined this policy.
  core.String? enrollState;

  GoogleCloudDiscoveryengineV1alphaAlertPolicyConfigAlertEnrollment({
    this.alertId,
    this.enrollState,
  });

  GoogleCloudDiscoveryengineV1alphaAlertPolicyConfigAlertEnrollment.fromJson(
    core.Map json_,
  ) : this(
        alertId: json_['alertId'] as core.String?,
        enrollState: json_['enrollState'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alertId != null) 'alertId': alertId!,
    if (enrollState != null) 'enrollState': enrollState!,
  };
}

/// AlloyDB source import data from.
typedef GoogleCloudDiscoveryengineV1alphaAlloyDbSource = $AlloyDbSource;

/// Defines an answer.
class GoogleCloudDiscoveryengineV1alphaAnswer {
  /// Additional answer-skipped reasons.
  ///
  /// This provides the reason for ignored cases. If nothing is skipped, this
  /// field is not set.
  core.List<core.String>? answerSkippedReasons;

  /// The textual answer.
  core.String? answerText;

  /// List of blob attachments in the answer.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachment>?
  blobAttachments;

  /// Citations.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerCitation>? citations;

  /// Answer completed timestamp.
  ///
  /// Output only.
  core.String? completeTime;

  /// Answer creation timestamp.
  ///
  /// Output only.
  core.String? createTime;

  /// A score in the range of \[0, 1\] describing how grounded the answer is by
  /// the reference chunks.
  core.double? groundingScore;

  /// Grounding supports.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerGroundingSupport>?
  groundingSupports;

  /// Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions
  /// / * /answers / * `
  ///
  /// Immutable.
  core.String? name;

  /// Query understanding information.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfo?
  queryUnderstandingInfo;

  /// References.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerReference>? references;

  /// Suggested related questions.
  core.List<core.String>? relatedQuestions;

  /// Safety ratings.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaSafetyRating>? safetyRatings;

  /// The state of the answer generation.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unknown.
  /// - "IN_PROGRESS" : Answer generation is currently in progress.
  /// - "FAILED" : Answer generation currently failed.
  /// - "SUCCEEDED" : Answer generation has succeeded.
  /// - "STREAMING" : Answer generation is currently in progress.
  core.String? state;

  /// Answer generation steps.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerStep>? steps;

  GoogleCloudDiscoveryengineV1alphaAnswer({
    this.answerSkippedReasons,
    this.answerText,
    this.blobAttachments,
    this.citations,
    this.completeTime,
    this.createTime,
    this.groundingScore,
    this.groundingSupports,
    this.name,
    this.queryUnderstandingInfo,
    this.references,
    this.relatedQuestions,
    this.safetyRatings,
    this.state,
    this.steps,
  });

  GoogleCloudDiscoveryengineV1alphaAnswer.fromJson(core.Map json_)
    : this(
        answerSkippedReasons:
            (json_['answerSkippedReasons'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        answerText: json_['answerText'] as core.String?,
        blobAttachments:
            (json_['blobAttachments'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachment.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        citations:
            (json_['citations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerCitation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        completeTime: json_['completeTime'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        groundingScore: (json_['groundingScore'] as core.num?)?.toDouble(),
        groundingSupports:
            (json_['groundingSupports'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerGroundingSupport.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        name: json_['name'] as core.String?,
        queryUnderstandingInfo:
            json_.containsKey('queryUnderstandingInfo')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfo.fromJson(
                  json_['queryUnderstandingInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        references:
            (json_['references'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerReference.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        relatedQuestions:
            (json_['relatedQuestions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        safetyRatings:
            (json_['safetyRatings'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSafetyRating.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        state: json_['state'] as core.String?,
        steps:
            (json_['steps'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerStep.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerSkippedReasons != null)
      'answerSkippedReasons': answerSkippedReasons!,
    if (answerText != null) 'answerText': answerText!,
    if (blobAttachments != null) 'blobAttachments': blobAttachments!,
    if (citations != null) 'citations': citations!,
    if (completeTime != null) 'completeTime': completeTime!,
    if (createTime != null) 'createTime': createTime!,
    if (groundingScore != null) 'groundingScore': groundingScore!,
    if (groundingSupports != null) 'groundingSupports': groundingSupports!,
    if (name != null) 'name': name!,
    if (queryUnderstandingInfo != null)
      'queryUnderstandingInfo': queryUnderstandingInfo!,
    if (references != null) 'references': references!,
    if (relatedQuestions != null) 'relatedQuestions': relatedQuestions!,
    if (safetyRatings != null) 'safetyRatings': safetyRatings!,
    if (state != null) 'state': state!,
    if (steps != null) 'steps': steps!,
  };
}

/// Stores binarydata attached to text answer, e.g. image, video, audio, etc.
class GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachment {
  /// The attribution type of the blob.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ATTRIBUTION_TYPE_UNSPECIFIED" : Unspecified attribution type.
  /// - "CORPUS" : The attachment data is from the corpus.
  /// - "GENERATED" : The attachment data is generated by the model through code
  /// generation.
  core.String? attributionType;

  /// The mime type and data of the blob.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachmentBlob? data;

  GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachment({
    this.attributionType,
    this.data,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachment.fromJson(core.Map json_)
    : this(
        attributionType: json_['attributionType'] as core.String?,
        data:
            json_.containsKey('data')
                ? GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachmentBlob.fromJson(
                  json_['data'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributionType != null) 'attributionType': attributionType!,
    if (data != null) 'data': data!,
  };
}

/// The media type and data of the blob.
typedef GoogleCloudDiscoveryengineV1alphaAnswerBlobAttachmentBlob =
    $AnswerBlobAttachmentBlob;

/// Citation info for a segment.
class GoogleCloudDiscoveryengineV1alphaAnswerCitation {
  /// End of the attributed segment, exclusive.
  ///
  /// Measured in bytes (UTF-8 unicode). If there are multi-byte characters,such
  /// as non-ASCII characters, the index measurement is longer than the string
  /// length.
  core.String? endIndex;

  /// Citation sources for the attributed segment.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerCitationSource>? sources;

  /// Index indicates the start of the segment, measured in bytes (UTF-8
  /// unicode).
  ///
  /// If there are multi-byte characters,such as non-ASCII characters, the index
  /// measurement is longer than the string length.
  core.String? startIndex;

  GoogleCloudDiscoveryengineV1alphaAnswerCitation({
    this.endIndex,
    this.sources,
    this.startIndex,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerCitation.fromJson(core.Map json_)
    : this(
        endIndex: json_['endIndex'] as core.String?,
        sources:
            (json_['sources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerCitationSource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        startIndex: json_['startIndex'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (sources != null) 'sources': sources!,
    if (startIndex != null) 'startIndex': startIndex!,
  };
}

/// Citation source.
typedef GoogleCloudDiscoveryengineV1alphaAnswerCitationSource =
    $AnswerCitationSource;

/// The specification for answer generation.
class GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpec {
  /// The specification for user specified classifier spec.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpecUserDefinedClassifierSpec?
  userDefinedClassifierSpec;

  GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpec({
    this.userDefinedClassifierSpec,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpec.fromJson(core.Map json_)
    : this(
        userDefinedClassifierSpec:
            json_.containsKey('userDefinedClassifierSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpecUserDefinedClassifierSpec.fromJson(
                  json_['userDefinedClassifierSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (userDefinedClassifierSpec != null)
      'userDefinedClassifierSpec': userDefinedClassifierSpec!,
  };
}

/// The specification for user defined classifier.
typedef GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpecUserDefinedClassifierSpec =
    $AnswerGenerationSpecUserDefinedClassifierSpec;

/// Grounding support for a claim in `answer_text`.
class GoogleCloudDiscoveryengineV1alphaAnswerGroundingSupport {
  /// End of the claim, exclusive.
  ///
  /// Required.
  core.String? endIndex;

  /// Indicates that this claim required grounding check.
  ///
  /// When the system decided this claim didn't require attribution/grounding
  /// check, this field is set to false. In that case, no grounding check was
  /// done for the claim and therefore `grounding_score`, `sources` is not
  /// returned.
  core.bool? groundingCheckRequired;

  /// A score in the range of \[0, 1\] describing how grounded is a specific
  /// claim by the references.
  ///
  /// Higher value means that the claim is better supported by the reference
  /// chunks.
  core.double? groundingScore;

  /// Citation sources for the claim.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerCitationSource>? sources;

  /// Index indicates the start of the claim, measured in bytes (UTF-8 unicode).
  ///
  /// Required.
  core.String? startIndex;

  GoogleCloudDiscoveryengineV1alphaAnswerGroundingSupport({
    this.endIndex,
    this.groundingCheckRequired,
    this.groundingScore,
    this.sources,
    this.startIndex,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerGroundingSupport.fromJson(
    core.Map json_,
  ) : this(
        endIndex: json_['endIndex'] as core.String?,
        groundingCheckRequired: json_['groundingCheckRequired'] as core.bool?,
        groundingScore: (json_['groundingScore'] as core.num?)?.toDouble(),
        sources:
            (json_['sources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerCitationSource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        startIndex: json_['startIndex'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (groundingCheckRequired != null)
      'groundingCheckRequired': groundingCheckRequired!,
    if (groundingScore != null) 'groundingScore': groundingScore!,
    if (sources != null) 'sources': sources!,
    if (startIndex != null) 'startIndex': startIndex!,
  };
}

/// Request message for ConversationalSearchService.AnswerQuery method.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest {
  /// Answer generation specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpec?
  answerGenerationSpec;

  /// Deprecated: This field is deprecated.
  ///
  /// Streaming Answer API will be supported. Asynchronous mode control. If
  /// enabled, the response will be returned with answer/session resource name
  /// without final answer. The API users need to do the polling to get the
  /// latest status of answer/session by calling
  /// ConversationalSearchService.GetAnswer or
  /// ConversationalSearchService.GetSession method.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? asynchronousMode;

  /// End user specification.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpec? endUserSpec;

  /// Grounding specification.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestGroundingSpec?
  groundingSpec;

  /// Current user query.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaQuery? query;

  /// Query understanding specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpec?
  queryUnderstandingSpec;

  /// Related questions specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestRelatedQuestionsSpec?
  relatedQuestionsSpec;

  /// Model specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpec? safetySpec;

  /// Search specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpec? searchSpec;

  /// The session resource name.
  ///
  /// Not required. When session field is not set, the API is in sessionless
  /// mode. We support auto session mode: users can use the wildcard symbol `-`
  /// as session ID. A new ID will be automatically generated and assigned.
  core.String? session;

  /// The user labels applied to a resource must meet the following
  /// requirements: * Each resource can have multiple labels, up to a maximum of
  /// 64.
  ///
  /// * Each label must be a key-value pair. * Keys have a minimum length of 1
  /// character and a maximum length of 63 characters and cannot be empty.
  /// Values can be empty and have a maximum length of 63 characters. * Keys and
  /// values can contain only lowercase letters, numeric characters,
  /// underscores, and dashes. All characters must use UTF-8 encoding, and
  /// international characters are allowed. * The key portion of a label must be
  /// unique. However, you can use the same key with multiple resources. * Keys
  /// must start with a lowercase letter or international character. See
  /// [Google Cloud Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
  /// for more details.
  core.Map<core.String, core.String>? userLabels;

  /// A unique identifier for tracking visitors.
  ///
  /// For example, this could be implemented with an HTTP cookie, which should
  /// be able to uniquely identify a visitor on a single device. This unique
  /// identifier should not change if the visitor logs in or out of the website.
  /// This field should NOT have a fixed value such as `unknown_visitor`. The
  /// field must be a UTF-8 encoded string with a length limit of 128
  /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
  core.String? userPseudoId;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest({
    this.answerGenerationSpec,
    this.asynchronousMode,
    this.endUserSpec,
    this.groundingSpec,
    this.query,
    this.queryUnderstandingSpec,
    this.relatedQuestionsSpec,
    this.safetySpec,
    this.searchSpec,
    this.session,
    this.userLabels,
    this.userPseudoId,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequest.fromJson(core.Map json_)
    : this(
        answerGenerationSpec:
            json_.containsKey('answerGenerationSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpec.fromJson(
                  json_['answerGenerationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        asynchronousMode: json_['asynchronousMode'] as core.bool?,
        endUserSpec:
            json_.containsKey('endUserSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpec.fromJson(
                  json_['endUserSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        groundingSpec:
            json_.containsKey('groundingSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestGroundingSpec.fromJson(
                  json_['groundingSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        query:
            json_.containsKey('query')
                ? GoogleCloudDiscoveryengineV1alphaQuery.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        queryUnderstandingSpec:
            json_.containsKey('queryUnderstandingSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpec.fromJson(
                  json_['queryUnderstandingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        relatedQuestionsSpec:
            json_.containsKey('relatedQuestionsSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestRelatedQuestionsSpec.fromJson(
                  json_['relatedQuestionsSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        safetySpec:
            json_.containsKey('safetySpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpec.fromJson(
                  json_['safetySpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchSpec:
            json_.containsKey('searchSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpec.fromJson(
                  json_['searchSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        session: json_['session'] as core.String?,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        userPseudoId: json_['userPseudoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerGenerationSpec != null)
      'answerGenerationSpec': answerGenerationSpec!,
    if (asynchronousMode != null) 'asynchronousMode': asynchronousMode!,
    if (endUserSpec != null) 'endUserSpec': endUserSpec!,
    if (groundingSpec != null) 'groundingSpec': groundingSpec!,
    if (query != null) 'query': query!,
    if (queryUnderstandingSpec != null)
      'queryUnderstandingSpec': queryUnderstandingSpec!,
    if (relatedQuestionsSpec != null)
      'relatedQuestionsSpec': relatedQuestionsSpec!,
    if (safetySpec != null) 'safetySpec': safetySpec!,
    if (searchSpec != null) 'searchSpec': searchSpec!,
    if (session != null) 'session': session!,
    if (userLabels != null) 'userLabels': userLabels!,
    if (userPseudoId != null) 'userPseudoId': userPseudoId!,
  };
}

/// Answer generation specification.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpec {
  /// Language code for Answer.
  ///
  /// Use language tags defined by
  /// [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This is an
  /// experimental feature.
  core.String? answerLanguageCode;

  /// Specifies whether to filter out adversarial queries.
  ///
  /// The default value is `false`. Google employs search-query classification
  /// to detect adversarial queries. No answer is returned if the search query
  /// is classified as an adversarial query. For example, a user might ask a
  /// question regarding negative comments about the company or submit a query
  /// designed to generate unsafe, policy-violating output. If this field is set
  /// to `true`, we skip generating answers for adversarial queries and return
  /// fallback messages instead.
  core.bool? ignoreAdversarialQuery;

  /// Specifies whether to filter out jail-breaking queries.
  ///
  /// The default value is `false`. Google employs search-query classification
  /// to detect jail-breaking queries. No summary is returned if the search
  /// query is classified as a jail-breaking query. A user might add
  /// instructions to the query to change the tone, style, language, content of
  /// the answer, or ask the model to act as a different entity, e.g. "Reply in
  /// the tone of a competing company's CEO". If this field is set to `true`, we
  /// skip generating summaries for jail-breaking queries and return fallback
  /// messages instead.
  ///
  /// Optional.
  core.bool? ignoreJailBreakingQuery;

  /// Specifies whether to filter out queries that have low relevance.
  ///
  /// If this field is set to `false`, all search results are used regardless of
  /// relevance to generate answers. If set to `true` or unset, the behavior
  /// will be determined automatically by the service.
  core.bool? ignoreLowRelevantContent;

  /// Specifies whether to filter out queries that are not answer-seeking.
  ///
  /// The default value is `false`. Google employs search-query classification
  /// to detect answer-seeking queries. No answer is returned if the search
  /// query is classified as a non-answer seeking query. If this field is set to
  /// `true`, we skip generating answers for non-answer seeking queries and
  /// return fallback messages instead.
  core.bool? ignoreNonAnswerSeekingQuery;

  /// Specifies whether to include citation metadata in the answer.
  ///
  /// The default value is `false`.
  core.bool? includeCitations;

  /// Answer generation model specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecModelSpec?
  modelSpec;

  /// Multimodal specification.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecMultimodalSpec?
  multimodalSpec;

  /// Answer generation prompt specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecPromptSpec?
  promptSpec;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpec({
    this.answerLanguageCode,
    this.ignoreAdversarialQuery,
    this.ignoreJailBreakingQuery,
    this.ignoreLowRelevantContent,
    this.ignoreNonAnswerSeekingQuery,
    this.includeCitations,
    this.modelSpec,
    this.multimodalSpec,
    this.promptSpec,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpec.fromJson(
    core.Map json_,
  ) : this(
        answerLanguageCode: json_['answerLanguageCode'] as core.String?,
        ignoreAdversarialQuery: json_['ignoreAdversarialQuery'] as core.bool?,
        ignoreJailBreakingQuery: json_['ignoreJailBreakingQuery'] as core.bool?,
        ignoreLowRelevantContent:
            json_['ignoreLowRelevantContent'] as core.bool?,
        ignoreNonAnswerSeekingQuery:
            json_['ignoreNonAnswerSeekingQuery'] as core.bool?,
        includeCitations: json_['includeCitations'] as core.bool?,
        modelSpec:
            json_.containsKey('modelSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecModelSpec.fromJson(
                  json_['modelSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        multimodalSpec:
            json_.containsKey('multimodalSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecMultimodalSpec.fromJson(
                  json_['multimodalSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        promptSpec:
            json_.containsKey('promptSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecPromptSpec.fromJson(
                  json_['promptSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerLanguageCode != null) 'answerLanguageCode': answerLanguageCode!,
    if (ignoreAdversarialQuery != null)
      'ignoreAdversarialQuery': ignoreAdversarialQuery!,
    if (ignoreJailBreakingQuery != null)
      'ignoreJailBreakingQuery': ignoreJailBreakingQuery!,
    if (ignoreLowRelevantContent != null)
      'ignoreLowRelevantContent': ignoreLowRelevantContent!,
    if (ignoreNonAnswerSeekingQuery != null)
      'ignoreNonAnswerSeekingQuery': ignoreNonAnswerSeekingQuery!,
    if (includeCitations != null) 'includeCitations': includeCitations!,
    if (modelSpec != null) 'modelSpec': modelSpec!,
    if (multimodalSpec != null) 'multimodalSpec': multimodalSpec!,
    if (promptSpec != null) 'promptSpec': promptSpec!,
  };
}

/// Answer Generation Model specification.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecModelSpec =
    $AnswerQueryRequestAnswerGenerationSpecModelSpec;

/// Multimodal specification: Will return an image from specified source.
///
/// If multiple sources are specified, the pick is a quality based decision.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecMultimodalSpec =
    $Spec02;

/// Answer generation prompt specification.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestAnswerGenerationSpecPromptSpec =
    $AnswerQueryRequestAnswerGenerationSpecPromptSpec;

/// End user specification.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpec {
  /// End user metadata.
  ///
  /// Optional.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaData
  >?
  endUserMetadata;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpec({
    this.endUserMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpec.fromJson(
    core.Map json_,
  ) : this(
        endUserMetadata:
            (json_['endUserMetadata'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaData.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endUserMetadata != null) 'endUserMetadata': endUserMetadata!,
  };
}

/// End user metadata.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaData {
  /// Chunk information.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfo?
  chunkInfo;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaData({
    this.chunkInfo,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaData.fromJson(
    core.Map json_,
  ) : this(
        chunkInfo:
            json_.containsKey('chunkInfo')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfo.fromJson(
                  json_['chunkInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkInfo != null) 'chunkInfo': chunkInfo!,
  };
}

/// Chunk information.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfo {
  /// Chunk textual content.
  ///
  /// It is limited to 8000 characters.
  core.String? content;

  /// Metadata of the document from the current chunk.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata?
  documentMetadata;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfo({
    this.content,
    this.documentMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfo.fromJson(
    core.Map json_,
  ) : this(
        content: json_['content'] as core.String?,
        documentMetadata:
            json_.containsKey('documentMetadata')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata.fromJson(
                  json_['documentMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (documentMetadata != null) 'documentMetadata': documentMetadata!,
  };
}

/// Document metadata contains the information of the document of the current
/// chunk.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata =
    $AnswerQueryRequestEndUserSpecEndUserMetaDataChunkInfoDocumentMetadata;

/// Grounding specification.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestGroundingSpec =
    $AnswerQueryRequestGroundingSpec;

/// Query understanding specification.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpec {
  /// Whether to disable spell correction.
  ///
  /// The default value is `false`.
  ///
  /// Optional.
  core.bool? disableSpellCorrection;

  /// Query classification specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec?
  queryClassificationSpec;

  /// Query rephraser specification.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpec?
  queryRephraserSpec;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpec({
    this.disableSpellCorrection,
    this.queryClassificationSpec,
    this.queryRephraserSpec,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpec.fromJson(
    core.Map json_,
  ) : this(
        disableSpellCorrection: json_['disableSpellCorrection'] as core.bool?,
        queryClassificationSpec:
            json_.containsKey('queryClassificationSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec.fromJson(
                  json_['queryClassificationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        queryRephraserSpec:
            json_.containsKey('queryRephraserSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpec.fromJson(
                  json_['queryRephraserSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableSpellCorrection != null)
      'disableSpellCorrection': disableSpellCorrection!,
    if (queryClassificationSpec != null)
      'queryClassificationSpec': queryClassificationSpec!,
    if (queryRephraserSpec != null) 'queryRephraserSpec': queryRephraserSpec!,
  };
}

/// Query classification specification.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec =
    $AnswerQueryRequestQueryUnderstandingSpecQueryClassificationSpec;

/// Query rephraser specification.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpec {
  /// Disable query rephraser.
  core.bool? disable;

  /// Max rephrase steps.
  ///
  /// The max number is 5 steps. If not set or set to \< 1, it will be set to 1
  /// by default.
  core.int? maxRephraseSteps;

  /// Query Rephraser Model specification.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec?
  modelSpec;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpec({
    this.disable,
    this.maxRephraseSteps,
    this.modelSpec,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpec.fromJson(
    core.Map json_,
  ) : this(
        disable: json_['disable'] as core.bool?,
        maxRephraseSteps: json_['maxRephraseSteps'] as core.int?,
        modelSpec:
            json_.containsKey('modelSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec.fromJson(
                  json_['modelSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disable != null) 'disable': disable!,
    if (maxRephraseSteps != null) 'maxRephraseSteps': maxRephraseSteps!,
    if (modelSpec != null) 'modelSpec': modelSpec!,
  };
}

/// Query Rephraser Model specification.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec =
    $AnswerQueryRequestQueryUnderstandingSpecQueryRephraserSpecModelSpec;

/// Related questions specification.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestRelatedQuestionsSpec =
    $AnswerQueryRequestRelatedQuestionsSpec;

/// Safety specification.
///
/// There are two use cases: 1. when only safety_spec.enable is set, the
/// BLOCK_LOW_AND_ABOVE threshold will be applied for all categories. 2. when
/// safety_spec.enable is set and some safety_settings are set, only specified
/// safety_settings are applied.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpec {
  /// Enable the safety filtering on the answer response.
  ///
  /// It is false by default.
  core.bool? enable;

  /// Safety settings.
  ///
  /// This settings are effective only when the safety_spec.enable is true.
  ///
  /// Optional.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpecSafetySetting
  >?
  safetySettings;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpec({
    this.enable,
    this.safetySettings,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpec.fromJson(
    core.Map json_,
  ) : this(
        enable: json_['enable'] as core.bool?,
        safetySettings:
            (json_['safetySettings'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpecSafetySetting.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enable != null) 'enable': enable!,
    if (safetySettings != null) 'safetySettings': safetySettings!,
  };
}

/// Safety settings.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSafetySpecSafetySetting =
    $AnswerQueryRequestSafetySpecSafetySetting;

/// Search specification.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpec {
  /// Search parameters.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchParams?
  searchParams;

  /// Search result list.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultList?
  searchResultList;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpec({
    this.searchParams,
    this.searchResultList,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpec.fromJson(
    core.Map json_,
  ) : this(
        searchParams:
            json_.containsKey('searchParams')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchParams.fromJson(
                  json_['searchParams'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchResultList:
            json_.containsKey('searchResultList')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultList.fromJson(
                  json_['searchResultList']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (searchParams != null) 'searchParams': searchParams!,
    if (searchResultList != null) 'searchResultList': searchResultList!,
  };
}

/// Search parameters.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchParams {
  /// Boost specification to boost certain documents in search results which may
  /// affect the answer query response.
  ///
  /// For more information on boosting, see
  /// [Boosting](https://cloud.google.com/retail/docs/boosting#boost)
  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec? boostSpec;

  /// Custom fine tuning configs.
  GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec? customFineTuningSpec;

  /// Specs defining dataStores to filter on in a search call and configurations
  /// for those dataStores.
  ///
  /// This is only considered for engines with multiple dataStores use case. For
  /// single dataStore within an engine, they should use the specs at the top
  /// level.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec>?
  dataStoreSpecs;

  /// The filter syntax consists of an expression language for constructing a
  /// predicate from one or more fields of the documents being filtered.
  ///
  /// Filter expression is case-sensitive. This will be used to filter search
  /// results which may affect the Answer response. If this field is
  /// unrecognizable, an `INVALID_ARGUMENT` is returned. Filtering in Vertex AI
  /// Search is done by mapping the LHS filter key to a key property defined in
  /// the Vertex AI Search backend -- this mapping is defined by the customer in
  /// their schema. For example a media customers might have a field 'name' in
  /// their schema. In this case the filter would look like this: filter --\>
  /// name:'ANY("king kong")' For more information about filtering including
  /// syntax and filter operators, see
  /// [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  core.String? filter;

  /// Number of search results to return.
  ///
  /// The default value is 10.
  core.int? maxReturnResults;

  /// Specification to enable natural language understanding capabilities for
  /// search requests.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaSearchRequestNaturalLanguageQueryUnderstandingSpec?
  naturalLanguageQueryUnderstandingSpec;

  /// The order in which documents are returned.
  ///
  /// Documents can be ordered by a field in an Document object. Leave it unset
  /// if ordered by relevance. `order_by` expression is case-sensitive. For more
  /// information on ordering, see
  /// [Ordering](https://cloud.google.com/retail/docs/filter-and-order#order) If
  /// this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
  core.String? orderBy;

  /// Specifies the search result mode.
  ///
  /// If unspecified, the search result mode defaults to `DOCUMENTS`. See
  /// [parse and chunk documents](https://cloud.google.com/generative-ai-app-builder/docs/parse-chunk-documents)
  /// Possible string values are:
  /// - "SEARCH_RESULT_MODE_UNSPECIFIED" : Default value.
  /// - "DOCUMENTS" : Returns documents in the search result.
  /// - "CHUNKS" : Returns chunks in the search result. Only available if the
  /// DocumentProcessingConfig.chunking_config is specified.
  core.String? searchResultMode;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchParams({
    this.boostSpec,
    this.customFineTuningSpec,
    this.dataStoreSpecs,
    this.filter,
    this.maxReturnResults,
    this.naturalLanguageQueryUnderstandingSpec,
    this.orderBy,
    this.searchResultMode,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchParams.fromJson(
    core.Map json_,
  ) : this(
        boostSpec:
            json_.containsKey('boostSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec.fromJson(
                  json_['boostSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        customFineTuningSpec:
            json_.containsKey('customFineTuningSpec')
                ? GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec.fromJson(
                  json_['customFineTuningSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        dataStoreSpecs:
            (json_['dataStoreSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        filter: json_['filter'] as core.String?,
        maxReturnResults: json_['maxReturnResults'] as core.int?,
        naturalLanguageQueryUnderstandingSpec:
            json_.containsKey('naturalLanguageQueryUnderstandingSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestNaturalLanguageQueryUnderstandingSpec.fromJson(
                  json_['naturalLanguageQueryUnderstandingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        orderBy: json_['orderBy'] as core.String?,
        searchResultMode: json_['searchResultMode'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boostSpec != null) 'boostSpec': boostSpec!,
    if (customFineTuningSpec != null)
      'customFineTuningSpec': customFineTuningSpec!,
    if (dataStoreSpecs != null) 'dataStoreSpecs': dataStoreSpecs!,
    if (filter != null) 'filter': filter!,
    if (maxReturnResults != null) 'maxReturnResults': maxReturnResults!,
    if (naturalLanguageQueryUnderstandingSpec != null)
      'naturalLanguageQueryUnderstandingSpec':
          naturalLanguageQueryUnderstandingSpec!,
    if (orderBy != null) 'orderBy': orderBy!,
    if (searchResultMode != null) 'searchResultMode': searchResultMode!,
  };
}

/// Search result list.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultList {
  /// Search results.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResult
  >?
  searchResults;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultList({
    this.searchResults,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultList.fromJson(
    core.Map json_,
  ) : this(
        searchResults:
            (json_['searchResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (searchResults != null) 'searchResults': searchResults!,
  };
}

/// Search result.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResult {
  /// Chunk information.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfo?
  chunkInfo;

  /// Unstructured document information.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfo?
  unstructuredDocumentInfo;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResult({
    this.chunkInfo,
    this.unstructuredDocumentInfo,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResult.fromJson(
    core.Map json_,
  ) : this(
        chunkInfo:
            json_.containsKey('chunkInfo')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfo.fromJson(
                  json_['chunkInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        unstructuredDocumentInfo:
            json_.containsKey('unstructuredDocumentInfo')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfo.fromJson(
                  json_['unstructuredDocumentInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkInfo != null) 'chunkInfo': chunkInfo!,
    if (unstructuredDocumentInfo != null)
      'unstructuredDocumentInfo': unstructuredDocumentInfo!,
  };
}

/// Chunk information.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfo {
  /// Chunk resource name.
  core.String? chunk;

  /// Chunk textual content.
  core.String? content;

  /// Metadata of the document from the current chunk.
  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata?
  documentMetadata;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfo({
    this.chunk,
    this.content,
    this.documentMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfo.fromJson(
    core.Map json_,
  ) : this(
        chunk: json_['chunk'] as core.String?,
        content: json_['content'] as core.String?,
        documentMetadata:
            json_.containsKey('documentMetadata')
                ? GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata.fromJson(
                  json_['documentMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunk != null) 'chunk': chunk!,
    if (content != null) 'content': content!,
    if (documentMetadata != null) 'documentMetadata': documentMetadata!,
  };
}

/// Document metadata contains the information of the document of the current
/// chunk.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata =
    $AnswerQueryRequestSearchSpecSearchResultListSearchResultChunkInfoDocumentMetadata;

/// Unstructured document information.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfo {
  /// Document resource name.
  core.String? document;

  /// List of document contexts.
  ///
  /// The content will be used for Answer Generation. This is supposed to be the
  /// main content of the document that can be long and comprehensive.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext
  >?
  documentContexts;

  /// Deprecated: This field is deprecated and will have no effect on the Answer
  /// generation.
  ///
  /// Please use document_contexts and extractive_segments fields. List of
  /// extractive answers.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer
  >?
  extractiveAnswers;

  /// List of extractive segments.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment
  >?
  extractiveSegments;

  /// Title.
  core.String? title;

  /// URI for the document.
  core.String? uri;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfo({
    this.document,
    this.documentContexts,
    this.extractiveAnswers,
    this.extractiveSegments,
    this.title,
    this.uri,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfo.fromJson(
    core.Map json_,
  ) : this(
        document: json_['document'] as core.String?,
        documentContexts:
            (json_['documentContexts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        extractiveAnswers:
            (json_['extractiveAnswers'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        extractiveSegments:
            (json_['extractiveSegments'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (documentContexts != null) 'documentContexts': documentContexts!,
    if (extractiveAnswers != null) 'extractiveAnswers': extractiveAnswers!,
    if (extractiveSegments != null) 'extractiveSegments': extractiveSegments!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Document context.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext =
    $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoDocumentContext;

/// Extractive answer.
///
/// [Guide](https://cloud.google.com/generative-ai-app-builder/docs/snippets#get-answers)
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer =
    $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveAnswer;

/// Extractive segment.
///
/// [Guide](https://cloud.google.com/generative-ai-app-builder/docs/snippets#extractive-segments)
/// Answer generation will only use it if document_contexts is empty. This is
/// supposed to be shorter snippets.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment =
    $AnswerQueryRequestSearchSpecSearchResultListSearchResultUnstructuredDocumentInfoExtractiveSegment;

/// Response message for ConversationalSearchService.AnswerQuery method.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse {
  /// Answer resource object.
  ///
  /// If
  /// AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.max_rephrase_steps
  /// is greater than 1, use Answer.name to fetch answer information using
  /// ConversationalSearchService.GetAnswer API.
  GoogleCloudDiscoveryengineV1alphaAnswer? answer;

  /// A global unique ID used for logging.
  core.String? answerQueryToken;

  /// Session resource object.
  ///
  /// It will be only available when session field is set and valid in the
  /// AnswerQueryRequest request.
  GoogleCloudDiscoveryengineV1alphaSession? session;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse({
    this.answer,
    this.answerQueryToken,
    this.session,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryResponse.fromJson(core.Map json_)
    : this(
        answer:
            json_.containsKey('answer')
                ? GoogleCloudDiscoveryengineV1alphaAnswer.fromJson(
                  json_['answer'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        answerQueryToken: json_['answerQueryToken'] as core.String?,
        session:
            json_.containsKey('session')
                ? GoogleCloudDiscoveryengineV1alphaSession.fromJson(
                  json_['session'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answer != null) 'answer': answer!,
    if (answerQueryToken != null) 'answerQueryToken': answerQueryToken!,
    if (session != null) 'session': session!,
  };
}

/// Query understanding information.
class GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfo {
  /// Query classification information.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfoQueryClassificationInfo
  >?
  queryClassificationInfo;

  GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfo({
    this.queryClassificationInfo,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfo.fromJson(
    core.Map json_,
  ) : this(
        queryClassificationInfo:
            (json_['queryClassificationInfo'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfoQueryClassificationInfo.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (queryClassificationInfo != null)
      'queryClassificationInfo': queryClassificationInfo!,
  };
}

/// Query classification information.
typedef GoogleCloudDiscoveryengineV1alphaAnswerQueryUnderstandingInfoQueryClassificationInfo =
    $AnswerQueryUnderstandingInfoQueryClassificationInfo;

/// Reference.
class GoogleCloudDiscoveryengineV1alphaAnswerReference {
  /// Chunk information.
  GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfo? chunkInfo;

  /// Structured document information.
  GoogleCloudDiscoveryengineV1alphaAnswerReferenceStructuredDocumentInfo?
  structuredDocumentInfo;

  /// Unstructured document information.
  GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfo?
  unstructuredDocumentInfo;

  GoogleCloudDiscoveryengineV1alphaAnswerReference({
    this.chunkInfo,
    this.structuredDocumentInfo,
    this.unstructuredDocumentInfo,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerReference.fromJson(core.Map json_)
    : this(
        chunkInfo:
            json_.containsKey('chunkInfo')
                ? GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfo.fromJson(
                  json_['chunkInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        structuredDocumentInfo:
            json_.containsKey('structuredDocumentInfo')
                ? GoogleCloudDiscoveryengineV1alphaAnswerReferenceStructuredDocumentInfo.fromJson(
                  json_['structuredDocumentInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        unstructuredDocumentInfo:
            json_.containsKey('unstructuredDocumentInfo')
                ? GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfo.fromJson(
                  json_['unstructuredDocumentInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkInfo != null) 'chunkInfo': chunkInfo!,
    if (structuredDocumentInfo != null)
      'structuredDocumentInfo': structuredDocumentInfo!,
    if (unstructuredDocumentInfo != null)
      'unstructuredDocumentInfo': unstructuredDocumentInfo!,
  };
}

/// Chunk information.
class GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfo {
  /// Stores indexes of blobattachments linked to this chunk.
  ///
  /// Output only.
  core.List<core.String>? blobAttachmentIndexes;

  /// Chunk resource name.
  core.String? chunk;

  /// Chunk textual content.
  core.String? content;

  /// Document metadata.
  GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfoDocumentMetadata?
  documentMetadata;

  /// The relevance of the chunk for a given query.
  ///
  /// Values range from 0.0 (completely irrelevant) to 1.0 (completely
  /// relevant). This value is for informational purpose only. It may change for
  /// the same query and chunk at any time due to a model retraining or change
  /// in implementation.
  core.double? relevanceScore;

  GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfo({
    this.blobAttachmentIndexes,
    this.chunk,
    this.content,
    this.documentMetadata,
    this.relevanceScore,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfo.fromJson(
    core.Map json_,
  ) : this(
        blobAttachmentIndexes:
            (json_['blobAttachmentIndexes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        chunk: json_['chunk'] as core.String?,
        content: json_['content'] as core.String?,
        documentMetadata:
            json_.containsKey('documentMetadata')
                ? GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfoDocumentMetadata.fromJson(
                  json_['documentMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        relevanceScore: (json_['relevanceScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobAttachmentIndexes != null)
      'blobAttachmentIndexes': blobAttachmentIndexes!,
    if (chunk != null) 'chunk': chunk!,
    if (content != null) 'content': content!,
    if (documentMetadata != null) 'documentMetadata': documentMetadata!,
    if (relevanceScore != null) 'relevanceScore': relevanceScore!,
  };
}

/// Document metadata.
typedef GoogleCloudDiscoveryengineV1alphaAnswerReferenceChunkInfoDocumentMetadata =
    $AnswerReferenceChunkInfoDocumentMetadata;

/// Structured search information.
typedef GoogleCloudDiscoveryengineV1alphaAnswerReferenceStructuredDocumentInfo =
    $AnswerReferenceStructuredDocumentInfo;

/// Unstructured document information.
class GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfo {
  /// List of cited chunk contents derived from document content.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfoChunkContent
  >?
  chunkContents;

  /// Document resource name.
  core.String? document;

  /// The structured JSON metadata for the document.
  ///
  /// It is populated from the struct data from the Chunk in search result.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structData;

  /// Title.
  core.String? title;

  /// URI for the document.
  core.String? uri;

  GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfo({
    this.chunkContents,
    this.document,
    this.structData,
    this.title,
    this.uri,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfo.fromJson(
    core.Map json_,
  ) : this(
        chunkContents:
            (json_['chunkContents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfoChunkContent.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        document: json_['document'] as core.String?,
        structData:
            json_.containsKey('structData')
                ? json_['structData'] as core.Map<core.String, core.dynamic>
                : null,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkContents != null) 'chunkContents': chunkContents!,
    if (document != null) 'document': document!,
    if (structData != null) 'structData': structData!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Chunk content.
typedef GoogleCloudDiscoveryengineV1alphaAnswerReferenceUnstructuredDocumentInfoChunkContent =
    $AnswerReferenceUnstructuredDocumentInfoChunkContent;

/// Step information.
class GoogleCloudDiscoveryengineV1alphaAnswerStep {
  /// Actions.
  core.List<GoogleCloudDiscoveryengineV1alphaAnswerStepAction>? actions;

  /// The description of the step.
  core.String? description;

  /// The state of the step.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unknown.
  /// - "IN_PROGRESS" : Step is currently in progress.
  /// - "FAILED" : Step currently failed.
  /// - "SUCCEEDED" : Step has succeeded.
  core.String? state;

  /// The thought of the step.
  core.String? thought;

  GoogleCloudDiscoveryengineV1alphaAnswerStep({
    this.actions,
    this.description,
    this.state,
    this.thought,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerStep.fromJson(core.Map json_)
    : this(
        actions:
            (json_['actions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerStepAction.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        description: json_['description'] as core.String?,
        state: json_['state'] as core.String?,
        thought: json_['thought'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (actions != null) 'actions': actions!,
    if (description != null) 'description': description!,
    if (state != null) 'state': state!,
    if (thought != null) 'thought': thought!,
  };
}

/// Action.
class GoogleCloudDiscoveryengineV1alphaAnswerStepAction {
  /// Observation.
  GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservation? observation;

  /// Search action.
  GoogleCloudDiscoveryengineV1alphaAnswerStepActionSearchAction? searchAction;

  GoogleCloudDiscoveryengineV1alphaAnswerStepAction({
    this.observation,
    this.searchAction,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerStepAction.fromJson(core.Map json_)
    : this(
        observation:
            json_.containsKey('observation')
                ? GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservation.fromJson(
                  json_['observation'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchAction:
            json_.containsKey('searchAction')
                ? GoogleCloudDiscoveryengineV1alphaAnswerStepActionSearchAction.fromJson(
                  json_['searchAction'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (observation != null) 'observation': observation!,
    if (searchAction != null) 'searchAction': searchAction!,
  };
}

/// Observation.
class GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservation {
  /// Search results observed by the search action, it can be snippets info or
  /// chunk info, depending on the citation type set by the user.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResult
  >?
  searchResults;

  GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservation({
    this.searchResults,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservation.fromJson(
    core.Map json_,
  ) : this(
        searchResults:
            (json_['searchResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (searchResults != null) 'searchResults': searchResults!,
  };
}

class GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResult {
  /// If citation_type is CHUNK_LEVEL_CITATION and chunk mode is on, populate
  /// chunk info.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultChunkInfo
  >?
  chunkInfo;

  /// Document resource name.
  core.String? document;

  /// If citation_type is DOCUMENT_LEVEL_CITATION, populate document level
  /// snippets.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultSnippetInfo
  >?
  snippetInfo;

  /// Data representation.
  ///
  /// The structured JSON data for the document. It's populated from the struct
  /// data from the Document, or the Chunk in search result.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structData;

  /// Title.
  core.String? title;

  /// URI for the document.
  core.String? uri;

  GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResult({
    this.chunkInfo,
    this.document,
    this.snippetInfo,
    this.structData,
    this.title,
    this.uri,
  });

  GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResult.fromJson(
    core.Map json_,
  ) : this(
        chunkInfo:
            (json_['chunkInfo'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultChunkInfo.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        document: json_['document'] as core.String?,
        snippetInfo:
            (json_['snippetInfo'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultSnippetInfo.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        structData:
            json_.containsKey('structData')
                ? json_['structData'] as core.Map<core.String, core.dynamic>
                : null,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkInfo != null) 'chunkInfo': chunkInfo!,
    if (document != null) 'document': document!,
    if (snippetInfo != null) 'snippetInfo': snippetInfo!,
    if (structData != null) 'structData': structData!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Chunk information.
typedef GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultChunkInfo =
    $AnswerStepActionObservationSearchResultChunkInfo;

/// Snippet information.
typedef GoogleCloudDiscoveryengineV1alphaAnswerStepActionObservationSearchResultSnippetInfo =
    $AnswerStepActionObservationSearchResultSnippetInfo;

/// Search action.
typedef GoogleCloudDiscoveryengineV1alphaAnswerStepActionSearchAction =
    $AnswerStepActionSearchAction;

/// AssistAnswer resource, main part of AssistResponse.
class GoogleCloudDiscoveryengineV1alphaAssistAnswer {
  /// Reasons for not answering the assist call.
  core.List<core.String>? assistSkippedReasons;

  /// Identifier.
  ///
  /// Resource name of the `AssistAnswer`. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}/assistAnswers/{assist_answer}`
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  /// Replies of the assistant.
  core.List<GoogleCloudDiscoveryengineV1alphaAssistAnswerReply>? replies;

  /// State of the answer generation.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unknown.
  /// - "IN_PROGRESS" : Assist operation is currently in progress.
  /// - "FAILED" : Assist operation has failed.
  /// - "SUCCEEDED" : Assist operation has succeeded.
  /// - "SKIPPED" : Assist operation has been skipped.
  core.String? state;

  GoogleCloudDiscoveryengineV1alphaAssistAnswer({
    this.assistSkippedReasons,
    this.name,
    this.replies,
    this.state,
  });

  GoogleCloudDiscoveryengineV1alphaAssistAnswer.fromJson(core.Map json_)
    : this(
        assistSkippedReasons:
            (json_['assistSkippedReasons'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        name: json_['name'] as core.String?,
        replies:
            (json_['replies'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAssistAnswerReply.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (assistSkippedReasons != null)
      'assistSkippedReasons': assistSkippedReasons!,
    if (name != null) 'name': name!,
    if (replies != null) 'replies': replies!,
    if (state != null) 'state': state!,
  };
}

/// One part of the multi-part response of the assist call.
class GoogleCloudDiscoveryengineV1alphaAssistAnswerReply {
  /// Possibly grounded response text or media from the assistant.
  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContent? groundedContent;

  GoogleCloudDiscoveryengineV1alphaAssistAnswerReply({this.groundedContent});

  GoogleCloudDiscoveryengineV1alphaAssistAnswerReply.fromJson(core.Map json_)
    : this(
        groundedContent:
            json_.containsKey('groundedContent')
                ? GoogleCloudDiscoveryengineV1alphaAssistantGroundedContent.fromJson(
                  json_['groundedContent']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (groundedContent != null) 'groundedContent': groundedContent!,
  };
}

/// User metadata of the request.
typedef GoogleCloudDiscoveryengineV1alphaAssistUserMetadata =
    $AssistUserMetadata;

/// Discovery Engine Assistant resource.
typedef GoogleCloudDiscoveryengineV1alphaAssistant = $Assistant;

/// Multi-modal content.
class GoogleCloudDiscoveryengineV1alphaAssistantContent {
  /// Result of executing an ExecutableCode.
  GoogleCloudDiscoveryengineV1alphaAssistantContentCodeExecutionResult?
  codeExecutionResult;

  /// Code generated by the model that is meant to be executed.
  GoogleCloudDiscoveryengineV1alphaAssistantContentExecutableCode?
  executableCode;

  /// A file, e.g., an audio summary.
  GoogleCloudDiscoveryengineV1alphaAssistantContentFile? file;

  /// Inline binary data.
  GoogleCloudDiscoveryengineV1alphaAssistantContentBlob? inlineData;

  /// The producer of the content.
  ///
  /// Can be "model" or "user".
  core.String? role;

  /// Inline text.
  core.String? text;

  /// Indicates if the part is thought from the model.
  ///
  /// Optional.
  core.bool? thought;

  GoogleCloudDiscoveryengineV1alphaAssistantContent({
    this.codeExecutionResult,
    this.executableCode,
    this.file,
    this.inlineData,
    this.role,
    this.text,
    this.thought,
  });

  GoogleCloudDiscoveryengineV1alphaAssistantContent.fromJson(core.Map json_)
    : this(
        codeExecutionResult:
            json_.containsKey('codeExecutionResult')
                ? GoogleCloudDiscoveryengineV1alphaAssistantContentCodeExecutionResult.fromJson(
                  json_['codeExecutionResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        executableCode:
            json_.containsKey('executableCode')
                ? GoogleCloudDiscoveryengineV1alphaAssistantContentExecutableCode.fromJson(
                  json_['executableCode']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        file:
            json_.containsKey('file')
                ? GoogleCloudDiscoveryengineV1alphaAssistantContentFile.fromJson(
                  json_['file'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineData:
            json_.containsKey('inlineData')
                ? GoogleCloudDiscoveryengineV1alphaAssistantContentBlob.fromJson(
                  json_['inlineData'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        role: json_['role'] as core.String?,
        text: json_['text'] as core.String?,
        thought: json_['thought'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (codeExecutionResult != null)
      'codeExecutionResult': codeExecutionResult!,
    if (executableCode != null) 'executableCode': executableCode!,
    if (file != null) 'file': file!,
    if (inlineData != null) 'inlineData': inlineData!,
    if (role != null) 'role': role!,
    if (text != null) 'text': text!,
    if (thought != null) 'thought': thought!,
  };
}

/// Inline blob.
typedef GoogleCloudDiscoveryengineV1alphaAssistantContentBlob =
    $AssistantContentBlob;

/// Result of executing ExecutableCode.
typedef GoogleCloudDiscoveryengineV1alphaAssistantContentCodeExecutionResult =
    $CodeExecutionResult;

/// Code generated by the model that is meant to be executed by the model.
typedef GoogleCloudDiscoveryengineV1alphaAssistantContentExecutableCode =
    $AssistantContentExecutableCode;

/// A file, e.g., an audio summary.
typedef GoogleCloudDiscoveryengineV1alphaAssistantContentFile =
    $AssistantContentFile;

/// A piece of content and possibly its grounding information.
///
/// Not all content needs grounding. Phrases like "Of course, I will gladly
/// search it for you." do not need grounding.
class GoogleCloudDiscoveryengineV1alphaAssistantGroundedContent {
  /// The content.
  GoogleCloudDiscoveryengineV1alphaAssistantContent? content;

  /// Metadata for grounding based on text sources.
  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadata?
  textGroundingMetadata;

  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContent({
    this.content,
    this.textGroundingMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContent.fromJson(
    core.Map json_,
  ) : this(
        content:
            json_.containsKey('content')
                ? GoogleCloudDiscoveryengineV1alphaAssistantContent.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        textGroundingMetadata:
            json_.containsKey('textGroundingMetadata')
                ? GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadata.fromJson(
                  json_['textGroundingMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (textGroundingMetadata != null)
      'textGroundingMetadata': textGroundingMetadata!,
  };
}

/// Grounding details for text sources.
class GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadata {
  /// References for the grounded text.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReference
  >?
  references;

  /// Grounding information for parts of the text.
  core.List<
    GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataSegment
  >?
  segments;

  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadata({
    this.references,
    this.segments,
  });

  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadata.fromJson(
    core.Map json_,
  ) : this(
        references:
            (json_['references'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReference.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        segments:
            (json_['segments'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataSegment.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (references != null) 'references': references!,
    if (segments != null) 'segments': segments!,
  };
}

/// Referenced content and related document metadata.
class GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReference {
  /// Referenced text content.
  core.String? content;

  /// Document metadata.
  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata?
  documentMetadata;

  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReference({
    this.content,
    this.documentMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReference.fromJson(
    core.Map json_,
  ) : this(
        content: json_['content'] as core.String?,
        documentMetadata:
            json_.containsKey('documentMetadata')
                ? GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata.fromJson(
                  json_['documentMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (content != null) 'content': content!,
    if (documentMetadata != null) 'documentMetadata': documentMetadata!,
  };
}

/// Document metadata.
typedef GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata =
    $AssistantGroundedContentTextGroundingMetadataReferenceDocumentMetadata;

/// Grounding information for a segment of the text.
typedef GoogleCloudDiscoveryengineV1alphaAssistantGroundedContentTextGroundingMetadataSegment =
    $AssistantGroundedContentTextGroundingMetadataSegment;

/// The configuration for the BAP connector.
class GoogleCloudDiscoveryengineV1alphaBAPConfig {
  /// The supported connector modes for the associated BAP connection.
  ///
  /// Required.
  core.List<core.String>? supportedConnectorModes;

  GoogleCloudDiscoveryengineV1alphaBAPConfig({this.supportedConnectorModes});

  GoogleCloudDiscoveryengineV1alphaBAPConfig.fromJson(core.Map json_)
    : this(
        supportedConnectorModes:
            (json_['supportedConnectorModes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (supportedConnectorModes != null)
      'supportedConnectorModes': supportedConnectorModes!,
  };
}

/// Request message for SiteSearchEngineService.BatchCreateTargetSites method.
class GoogleCloudDiscoveryengineV1alphaBatchCreateTargetSitesRequest {
  /// The request message specifying the resources to create.
  ///
  /// A maximum of 20 TargetSites can be created in a batch.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaCreateTargetSiteRequest>? requests;

  GoogleCloudDiscoveryengineV1alphaBatchCreateTargetSitesRequest({
    this.requests,
  });

  GoogleCloudDiscoveryengineV1alphaBatchCreateTargetSitesRequest.fromJson(
    core.Map json_,
  ) : this(
        requests:
            (json_['requests'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCreateTargetSiteRequest.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requests != null) 'requests': requests!,
  };
}

/// Response message for DocumentService.BatchGetDocumentsMetadata method.
class GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse {
  /// The metadata of the Documents.
  core.List<
    GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadata
  >?
  documentsMetadata;

  GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse({
    this.documentsMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponse.fromJson(
    core.Map json_,
  ) : this(
        documentsMetadata:
            (json_['documentsMetadata'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadata.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentsMetadata != null) 'documentsMetadata': documentsMetadata!,
  };
}

/// The metadata of a Document.
class GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadata {
  /// The data ingestion source of the Document.
  ///
  /// Allowed values are: * `batch`: Data ingested via Batch API, e.g.,
  /// ImportDocuments. * `streaming` Data ingested via Streaming API, e.g., FHIR
  /// streaming.
  core.String? dataIngestionSource;

  /// The timestamp of the last time the Document was last indexed.
  core.String? lastRefreshedTime;

  /// The value of the matcher that was used to match the Document.
  GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue?
  matcherValue;

  /// The state of the document.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Should never be set.
  /// - "INDEXED" : The Document is indexed.
  /// - "NOT_IN_TARGET_SITE" : The Document is not indexed because its URI is
  /// not in the TargetSite.
  /// - "NOT_IN_INDEX" : The Document is not indexed.
  core.String? state;

  GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadata({
    this.dataIngestionSource,
    this.lastRefreshedTime,
    this.matcherValue,
    this.state,
  });

  GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadata.fromJson(
    core.Map json_,
  ) : this(
        dataIngestionSource: json_['dataIngestionSource'] as core.String?,
        lastRefreshedTime: json_['lastRefreshedTime'] as core.String?,
        matcherValue:
            json_.containsKey('matcherValue')
                ? GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue.fromJson(
                  json_['matcherValue'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataIngestionSource != null)
      'dataIngestionSource': dataIngestionSource!,
    if (lastRefreshedTime != null) 'lastRefreshedTime': lastRefreshedTime!,
    if (matcherValue != null) 'matcherValue': matcherValue!,
    if (state != null) 'state': state!,
  };
}

/// The value of the matcher that was used to match the Document.
typedef GoogleCloudDiscoveryengineV1alphaBatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue =
    $BatchGetDocumentsMetadataResponseDocumentMetadataMatcherValue;

/// Request message for UserLicenseService.BatchUpdateUserLicenses method.
class GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequest {
  /// If true, if user licenses removed associated license config, the user
  /// license will be deleted.
  ///
  /// By default which is false, the user license will be updated to unassigned
  /// state.
  ///
  /// Optional.
  core.bool? deleteUnassignedUserLicenses;

  /// The inline source for the input content for document embeddings.
  GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequest({
    this.deleteUnassignedUserLicenses,
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequest.fromJson(
    core.Map json_,
  ) : this(
        deleteUnassignedUserLicenses:
            json_['deleteUnassignedUserLicenses'] as core.bool?,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deleteUnassignedUserLicenses != null)
      'deleteUnassignedUserLicenses': deleteUnassignedUserLicenses!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source for the input config for BatchUpdateUserLicenses method.
class GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequestInlineSource {
  /// The list of fields to update.
  ///
  /// Optional.
  core.String? updateMask;

  /// A list of user licenses to update.
  ///
  /// Each user license must have a valid UserLicense.user_principal.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaUserLicense>? userLicenses;

  GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequestInlineSource({
    this.updateMask,
    this.userLicenses,
  });

  GoogleCloudDiscoveryengineV1alphaBatchUpdateUserLicensesRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        updateMask: json_['updateMask'] as core.String?,
        userLicenses:
            (json_['userLicenses'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaUserLicense.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (updateMask != null) 'updateMask': updateMask!,
    if (userLicenses != null) 'userLicenses': userLicenses!,
  };
}

/// Request message for SiteSearchEngineService.BatchVerifyTargetSites method.
typedef GoogleCloudDiscoveryengineV1alphaBatchVerifyTargetSitesRequest = $Empty;

/// The BigQuery output destination configuration.
class GoogleCloudDiscoveryengineV1alphaBigQueryDestination {
  /// The ID of a BigQuery Dataset.
  ///
  /// Required.
  core.String? datasetId;

  /// The table_id of exported BigQuery table.
  ///
  /// Required.
  core.String? tableId;

  GoogleCloudDiscoveryengineV1alphaBigQueryDestination({
    this.datasetId,
    this.tableId,
  });

  GoogleCloudDiscoveryengineV1alphaBigQueryDestination.fromJson(core.Map json_)
    : this(
        datasetId: json_['datasetId'] as core.String?,
        tableId: json_['tableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (datasetId != null) 'datasetId': datasetId!,
    if (tableId != null) 'tableId': tableId!,
  };
}

/// BigQuery source import data from.
class GoogleCloudDiscoveryengineV1alphaBigQuerySource {
  /// The schema to use when parsing the data from the source.
  ///
  /// Supported values for user event imports: * `user_event` (default): One
  /// UserEvent per row. Supported values for document imports: * `document`
  /// (default): One Document format per row. Each document must have a valid
  /// Document.id and one of Document.json_data or Document.struct_data. *
  /// `custom`: One custom data per row in arbitrary format that conforms to the
  /// defined Schema of the data store. This can only be used by the GENERIC
  /// Data Store vertical.
  core.String? dataSchema;

  /// The BigQuery data set to copy the data from with a length limit of 1,024
  /// characters.
  ///
  /// Required.
  core.String? datasetId;

  /// Intermediate Cloud Storage directory used for the import with a length
  /// limit of 2,000 characters.
  ///
  /// Can be specified if one wants to have the BigQuery export to a specific
  /// Cloud Storage directory.
  core.String? gcsStagingDir;

  /// BigQuery time partitioned table's _PARTITIONDATE in YYYY-MM-DD format.
  GoogleTypeDate? partitionDate;

  /// The project ID or the project number that contains the BigQuery source.
  ///
  /// Has a length limit of 128 characters. If not specified, inherits the
  /// project ID from the parent request.
  core.String? projectId;

  /// The BigQuery table to copy the data from with a length limit of 1,024
  /// characters.
  ///
  /// Required.
  core.String? tableId;

  GoogleCloudDiscoveryengineV1alphaBigQuerySource({
    this.dataSchema,
    this.datasetId,
    this.gcsStagingDir,
    this.partitionDate,
    this.projectId,
    this.tableId,
  });

  GoogleCloudDiscoveryengineV1alphaBigQuerySource.fromJson(core.Map json_)
    : this(
        dataSchema: json_['dataSchema'] as core.String?,
        datasetId: json_['datasetId'] as core.String?,
        gcsStagingDir: json_['gcsStagingDir'] as core.String?,
        partitionDate:
            json_.containsKey('partitionDate')
                ? GoogleTypeDate.fromJson(
                  json_['partitionDate'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        projectId: json_['projectId'] as core.String?,
        tableId: json_['tableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataSchema != null) 'dataSchema': dataSchema!,
    if (datasetId != null) 'datasetId': datasetId!,
    if (gcsStagingDir != null) 'gcsStagingDir': gcsStagingDir!,
    if (partitionDate != null) 'partitionDate': partitionDate!,
    if (projectId != null) 'projectId': projectId!,
    if (tableId != null) 'tableId': tableId!,
  };
}

/// The Bigtable Options object that contains information to support the import.
class GoogleCloudDiscoveryengineV1alphaBigtableOptions {
  /// The mapping from family names to an object that contains column families
  /// level information for the given column family.
  ///
  /// If a family is not present in this map it will be ignored.
  core.Map<
    core.String,
    GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumnFamily
  >?
  families;

  /// The field name used for saving row key value in the document.
  ///
  /// The name has to match the pattern `a-zA-Z0-9*`.
  core.String? keyFieldName;

  GoogleCloudDiscoveryengineV1alphaBigtableOptions({
    this.families,
    this.keyFieldName,
  });

  GoogleCloudDiscoveryengineV1alphaBigtableOptions.fromJson(core.Map json_)
    : this(
        families: (json_['families'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumnFamily.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
        keyFieldName: json_['keyFieldName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (families != null) 'families': families!,
    if (keyFieldName != null) 'keyFieldName': keyFieldName!,
  };
}

/// The column of the Bigtable.
typedef GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumn =
    $BigtableOptionsBigtableColumn;

/// The column family of the Bigtable.
class GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumnFamily {
  /// The list of objects that contains column level information for each
  /// column.
  ///
  /// If a column is not present in this list it will be ignored.
  core.List<GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumn>?
  columns;

  /// The encoding mode of the values when the type is not STRING.
  ///
  /// Acceptable encoding values are: * `TEXT`: indicates values are
  /// alphanumeric text strings. * `BINARY`: indicates values are encoded using
  /// `HBase Bytes.toBytes` family of functions. This can be overridden for a
  /// specific column by listing that column in `columns` and specifying an
  /// encoding for it.
  /// Possible string values are:
  /// - "ENCODING_UNSPECIFIED" : The encoding is unspecified.
  /// - "TEXT" : Text encoding.
  /// - "BINARY" : Binary encoding.
  core.String? encoding;

  /// The field name to use for this column family in the document.
  ///
  /// The name has to match the pattern `a-zA-Z0-9*`. If not set, it is parsed
  /// from the family name with best effort. However, due to different naming
  /// patterns, field name collisions could happen, where parsing behavior is
  /// undefined.
  core.String? fieldName;

  /// The type of values in this column family.
  ///
  /// The values are expected to be encoded using `HBase Bytes.toBytes` function
  /// when the encoding value is set to `BINARY`.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : The type is unspecified.
  /// - "STRING" : String type.
  /// - "NUMBER" : Numerical type.
  /// - "INTEGER" : Integer type.
  /// - "VAR_INTEGER" : Variable length integer type.
  /// - "BIG_NUMERIC" : BigDecimal type.
  /// - "BOOLEAN" : Boolean type.
  /// - "JSON" : JSON type.
  core.String? type;

  GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumnFamily({
    this.columns,
    this.encoding,
    this.fieldName,
    this.type,
  });

  GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumnFamily.fromJson(
    core.Map json_,
  ) : this(
        columns:
            (json_['columns'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaBigtableOptionsBigtableColumn.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        encoding: json_['encoding'] as core.String?,
        fieldName: json_['fieldName'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (columns != null) 'columns': columns!,
    if (encoding != null) 'encoding': encoding!,
    if (fieldName != null) 'fieldName': fieldName!,
    if (type != null) 'type': type!,
  };
}

/// The Cloud Bigtable source for importing data.
class GoogleCloudDiscoveryengineV1alphaBigtableSource {
  /// Bigtable options that contains information needed when parsing data into
  /// typed structures.
  ///
  /// For example, column type annotations.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaBigtableOptions? bigtableOptions;

  /// The instance ID of the Cloud Bigtable that needs to be imported.
  ///
  /// Required.
  core.String? instanceId;

  /// The project ID that contains the Bigtable source.
  ///
  /// Has a length limit of 128 characters. If not specified, inherits the
  /// project ID from the parent request.
  core.String? projectId;

  /// The table ID of the Cloud Bigtable that needs to be imported.
  ///
  /// Required.
  core.String? tableId;

  GoogleCloudDiscoveryengineV1alphaBigtableSource({
    this.bigtableOptions,
    this.instanceId,
    this.projectId,
    this.tableId,
  });

  GoogleCloudDiscoveryengineV1alphaBigtableSource.fromJson(core.Map json_)
    : this(
        bigtableOptions:
            json_.containsKey('bigtableOptions')
                ? GoogleCloudDiscoveryengineV1alphaBigtableOptions.fromJson(
                  json_['bigtableOptions']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        instanceId: json_['instanceId'] as core.String?,
        projectId: json_['projectId'] as core.String?,
        tableId: json_['tableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigtableOptions != null) 'bigtableOptions': bigtableOptions!,
    if (instanceId != null) 'instanceId': instanceId!,
    if (projectId != null) 'projectId': projectId!,
    if (tableId != null) 'tableId': tableId!,
  };
}

/// Request message for GroundedGenerationService.CheckGrounding method.
class GoogleCloudDiscoveryengineV1alphaCheckGroundingRequest {
  /// Answer candidate to check.
  ///
  /// It can have a maximum length of 4096 tokens.
  core.String? answerCandidate;

  /// List of facts for the grounding check.
  ///
  /// We support up to 200 facts.
  core.List<GoogleCloudDiscoveryengineV1alphaGroundingFact>? facts;

  /// Configuration of the grounding check.
  GoogleCloudDiscoveryengineV1alphaCheckGroundingSpec? groundingSpec;

  /// The user labels applied to a resource must meet the following
  /// requirements: * Each resource can have multiple labels, up to a maximum of
  /// 64.
  ///
  /// * Each label must be a key-value pair. * Keys have a minimum length of 1
  /// character and a maximum length of 63 characters and cannot be empty.
  /// Values can be empty and have a maximum length of 63 characters. * Keys and
  /// values can contain only lowercase letters, numeric characters,
  /// underscores, and dashes. All characters must use UTF-8 encoding, and
  /// international characters are allowed. * The key portion of a label must be
  /// unique. However, you can use the same key with multiple resources. * Keys
  /// must start with a lowercase letter or international character. See
  /// [Google Cloud Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
  /// for more details.
  core.Map<core.String, core.String>? userLabels;

  GoogleCloudDiscoveryengineV1alphaCheckGroundingRequest({
    this.answerCandidate,
    this.facts,
    this.groundingSpec,
    this.userLabels,
  });

  GoogleCloudDiscoveryengineV1alphaCheckGroundingRequest.fromJson(
    core.Map json_,
  ) : this(
        answerCandidate: json_['answerCandidate'] as core.String?,
        facts:
            (json_['facts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaGroundingFact.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        groundingSpec:
            json_.containsKey('groundingSpec')
                ? GoogleCloudDiscoveryengineV1alphaCheckGroundingSpec.fromJson(
                  json_['groundingSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerCandidate != null) 'answerCandidate': answerCandidate!,
    if (facts != null) 'facts': facts!,
    if (groundingSpec != null) 'groundingSpec': groundingSpec!,
    if (userLabels != null) 'userLabels': userLabels!,
  };
}

/// Response message for the GroundedGenerationService.CheckGrounding method.
class GoogleCloudDiscoveryengineV1alphaCheckGroundingResponse {
  /// List of facts cited across all claims in the answer candidate.
  ///
  /// These are derived from the facts supplied in the request.
  core.List<GoogleCloudDiscoveryengineV1alphaFactChunk>? citedChunks;

  /// List of facts cited across all claims in the answer candidate.
  ///
  /// These are derived from the facts supplied in the request.
  core.List<
    GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseCheckGroundingFactChunk
  >?
  citedFacts;

  /// Claim texts and citation info across all claims in the answer candidate.
  core.List<GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseClaim>?
  claims;

  /// The support score for the input answer candidate.
  ///
  /// Higher the score, higher is the fraction of claims that are supported by
  /// the provided facts. This is always set when a response is returned.
  core.double? supportScore;

  GoogleCloudDiscoveryengineV1alphaCheckGroundingResponse({
    this.citedChunks,
    this.citedFacts,
    this.claims,
    this.supportScore,
  });

  GoogleCloudDiscoveryengineV1alphaCheckGroundingResponse.fromJson(
    core.Map json_,
  ) : this(
        citedChunks:
            (json_['citedChunks'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaFactChunk.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        citedFacts:
            (json_['citedFacts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseCheckGroundingFactChunk.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        claims:
            (json_['claims'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseClaim.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        supportScore: (json_['supportScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (citedChunks != null) 'citedChunks': citedChunks!,
    if (citedFacts != null) 'citedFacts': citedFacts!,
    if (claims != null) 'claims': claims!,
    if (supportScore != null) 'supportScore': supportScore!,
  };
}

/// Fact chunk for grounding check.
typedef GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseCheckGroundingFactChunk =
    $CheckGroundingResponseCheckGroundingFactChunk;

/// Text and citation info for a claim in the answer candidate.
typedef GoogleCloudDiscoveryengineV1alphaCheckGroundingResponseClaim =
    $CheckGroundingResponseClaim;

/// Specification for the grounding check.
typedef GoogleCloudDiscoveryengineV1alphaCheckGroundingSpec =
    $CheckGroundingSpec;

/// Request for CheckRequirement method.
class GoogleCloudDiscoveryengineV1alphaCheckRequirementRequest {
  /// The type specifying the requirement to check.
  ///
  /// The supported types are: *
  /// `discoveryengine.googleapis.com/media_recs/general/all/warning` *
  /// `discoveryengine.googleapis.com/media_recs/oyml/cvr/warning` *
  /// `discoveryengine.googleapis.com/media_recs/rfy/cvr/warning` *
  /// `discoveryengine.googleapis.com/media_recs/mlt/cvr/warning` *
  /// `discoveryengine.googleapis.com/media_recs/mp/cvr/warning` *
  /// `discoveryengine.googleapis.com/media_recs/oyml/wdps/warning` *
  /// `discoveryengine.googleapis.com/media_recs/rfy/wdps/warning` *
  /// `discoveryengine.googleapis.com/media_recs/mlt/wdps/warning`
  core.String? requirementType;

  /// The resources to be checked for this requirement.
  ///
  /// The type needed for the monitored resources: *
  /// `discoveryengine.googleapis.com/Branch`. * The labels needed for this
  /// resource: * `project_number` * `location_id` * `collection_id` *
  /// `datastore_id` * `branch_id` * `discoveryengine.googleapis.com/DataStore`
  /// * The labels needed for this resource: * `project_number` * `location_id`
  /// * `collection_id` * `datastore_id`
  core.List<GoogleApiMonitoredResource>? resources;

  GoogleCloudDiscoveryengineV1alphaCheckRequirementRequest({
    this.requirementType,
    this.resources,
  });

  GoogleCloudDiscoveryengineV1alphaCheckRequirementRequest.fromJson(
    core.Map json_,
  ) : this(
        requirementType: json_['requirementType'] as core.String?,
        resources:
            (json_['resources'] as core.List?)
                ?.map(
                  (value) => GoogleApiMonitoredResource.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (requirementType != null) 'requirementType': requirementType!,
    if (resources != null) 'resources': resources!,
  };
}

/// Response for the CheckRequirement method.
class GoogleCloudDiscoveryengineV1alphaCheckRequirementResponse {
  /// Metric results.
  core.List<
    GoogleCloudDiscoveryengineV1alphaCheckRequirementResponseMetricQueryResult
  >?
  metricResults;

  /// Timestamp of the oldest calculated metric (i.e. the most stale metric).
  ///
  /// Indicates that the `result` may not accurately reflect any Event and
  /// Product Catalog updates performed after this time.
  core.String? oldestMetricTimestamp;

  /// Requirement definition.
  GoogleCloudDiscoveryengineV1alphaRequirement? requirement;

  /// The condition for evaluating the requirement result.
  GoogleTypeExpr? requirementCondition;

  /// The result of the requirement.
  ///
  /// It should be one of the `severity` fields in the requirement definition.
  /// If any error happens during the evaluation, it will be `UNKNOWN`.
  core.String? result;

  GoogleCloudDiscoveryengineV1alphaCheckRequirementResponse({
    this.metricResults,
    this.oldestMetricTimestamp,
    this.requirement,
    this.requirementCondition,
    this.result,
  });

  GoogleCloudDiscoveryengineV1alphaCheckRequirementResponse.fromJson(
    core.Map json_,
  ) : this(
        metricResults:
            (json_['metricResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCheckRequirementResponseMetricQueryResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        oldestMetricTimestamp: json_['oldestMetricTimestamp'] as core.String?,
        requirement:
            json_.containsKey('requirement')
                ? GoogleCloudDiscoveryengineV1alphaRequirement.fromJson(
                  json_['requirement'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        requirementCondition:
            json_.containsKey('requirementCondition')
                ? GoogleTypeExpr.fromJson(
                  json_['requirementCondition']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        result: json_['result'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricResults != null) 'metricResults': metricResults!,
    if (oldestMetricTimestamp != null)
      'oldestMetricTimestamp': oldestMetricTimestamp!,
    if (requirement != null) 'requirement': requirement!,
    if (requirementCondition != null)
      'requirementCondition': requirementCondition!,
    if (result != null) 'result': result!,
  };
}

/// Metric result.
///
/// The metric are in the requirement_condition.
class GoogleCloudDiscoveryengineV1alphaCheckRequirementResponseMetricQueryResult {
  /// Type identifier of the metric corresponding to this query result.
  core.String? metricType;

  /// This metric query name is mapping to variables in the
  /// requirement_condition.
  core.String? name;

  /// Time corresponding to when this metric value was calculated.
  core.String? timestamp;

  /// The unit in which this metric is reported.
  ///
  /// Follows
  /// [The Unified Code for Units of Measure](https://unitsofmeasure.org/ucum.html)
  /// standard.
  core.String? unit;

  /// Value of the metric query.
  GoogleMonitoringV3TypedValue? value;

  GoogleCloudDiscoveryengineV1alphaCheckRequirementResponseMetricQueryResult({
    this.metricType,
    this.name,
    this.timestamp,
    this.unit,
    this.value,
  });

  GoogleCloudDiscoveryengineV1alphaCheckRequirementResponseMetricQueryResult.fromJson(
    core.Map json_,
  ) : this(
        metricType: json_['metricType'] as core.String?,
        name: json_['name'] as core.String?,
        timestamp: json_['timestamp'] as core.String?,
        unit: json_['unit'] as core.String?,
        value:
            json_.containsKey('value')
                ? GoogleMonitoringV3TypedValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metricType != null) 'metricType': metricType!,
    if (name != null) 'name': name!,
    if (timestamp != null) 'timestamp': timestamp!,
    if (unit != null) 'unit': unit!,
    if (value != null) 'value': value!,
  };
}

/// Chunk captures all raw metadata information of items to be recommended or
/// searched in the chunk mode.
class GoogleCloudDiscoveryengineV1alphaChunk {
  /// Annotation contents if the current chunk contains annotations.
  ///
  /// Output only.
  core.List<core.String>? annotationContents;

  /// The annotation metadata includes structured content in the current chunk.
  ///
  /// Output only.
  core.List<GoogleCloudDiscoveryengineV1alphaChunkAnnotationMetadata>?
  annotationMetadata;

  /// Metadata of the current chunk.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaChunkChunkMetadata? chunkMetadata;

  /// Content is a string from a document (parsed content).
  core.String? content;

  /// Image Data URLs if the current chunk contains images.
  ///
  /// Data URLs are composed of four parts: a prefix (data:), a MIME type
  /// indicating the type of data, an optional base64 token if non-textual, and
  /// the data itself: data:,
  ///
  /// Output only.
  core.List<core.String>? dataUrls;

  /// This field is OUTPUT_ONLY.
  ///
  /// It contains derived data that are not in the original input document.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? derivedStructData;

  /// Metadata of the document from the current chunk.
  GoogleCloudDiscoveryengineV1alphaChunkDocumentMetadata? documentMetadata;

  /// Unique chunk ID of the current chunk.
  core.String? id;

  /// The full resource name of the chunk.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}/chunks/{chunk_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  core.String? name;

  /// Page span of the chunk.
  GoogleCloudDiscoveryengineV1alphaChunkPageSpan? pageSpan;

  /// Represents the relevance score based on similarity.
  ///
  /// Higher score indicates higher chunk relevance. The score is in range
  /// \[-1.0, 1.0\]. Only populated on SearchResponse.
  ///
  /// Output only.
  core.double? relevanceScore;

  GoogleCloudDiscoveryengineV1alphaChunk({
    this.annotationContents,
    this.annotationMetadata,
    this.chunkMetadata,
    this.content,
    this.dataUrls,
    this.derivedStructData,
    this.documentMetadata,
    this.id,
    this.name,
    this.pageSpan,
    this.relevanceScore,
  });

  GoogleCloudDiscoveryengineV1alphaChunk.fromJson(core.Map json_)
    : this(
        annotationContents:
            (json_['annotationContents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        annotationMetadata:
            (json_['annotationMetadata'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaChunkAnnotationMetadata.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        chunkMetadata:
            json_.containsKey('chunkMetadata')
                ? GoogleCloudDiscoveryengineV1alphaChunkChunkMetadata.fromJson(
                  json_['chunkMetadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        content: json_['content'] as core.String?,
        dataUrls:
            (json_['dataUrls'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        derivedStructData:
            json_.containsKey('derivedStructData')
                ? json_['derivedStructData']
                    as core.Map<core.String, core.dynamic>
                : null,
        documentMetadata:
            json_.containsKey('documentMetadata')
                ? GoogleCloudDiscoveryengineV1alphaChunkDocumentMetadata.fromJson(
                  json_['documentMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
        pageSpan:
            json_.containsKey('pageSpan')
                ? GoogleCloudDiscoveryengineV1alphaChunkPageSpan.fromJson(
                  json_['pageSpan'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        relevanceScore: (json_['relevanceScore'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (annotationContents != null) 'annotationContents': annotationContents!,
    if (annotationMetadata != null) 'annotationMetadata': annotationMetadata!,
    if (chunkMetadata != null) 'chunkMetadata': chunkMetadata!,
    if (content != null) 'content': content!,
    if (dataUrls != null) 'dataUrls': dataUrls!,
    if (derivedStructData != null) 'derivedStructData': derivedStructData!,
    if (documentMetadata != null) 'documentMetadata': documentMetadata!,
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
    if (pageSpan != null) 'pageSpan': pageSpan!,
    if (relevanceScore != null) 'relevanceScore': relevanceScore!,
  };
}

/// The annotation metadata includes structured content in the current chunk.
class GoogleCloudDiscoveryengineV1alphaChunkAnnotationMetadata {
  /// Image id is provided if the structured content is based on an image.
  ///
  /// Output only.
  core.String? imageId;

  /// The structured content information.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaChunkStructuredContent? structuredContent;

  GoogleCloudDiscoveryengineV1alphaChunkAnnotationMetadata({
    this.imageId,
    this.structuredContent,
  });

  GoogleCloudDiscoveryengineV1alphaChunkAnnotationMetadata.fromJson(
    core.Map json_,
  ) : this(
        imageId: json_['imageId'] as core.String?,
        structuredContent:
            json_.containsKey('structuredContent')
                ? GoogleCloudDiscoveryengineV1alphaChunkStructuredContent.fromJson(
                  json_['structuredContent']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (imageId != null) 'imageId': imageId!,
    if (structuredContent != null) 'structuredContent': structuredContent!,
  };
}

/// Metadata of the current chunk.
///
/// This field is only populated on SearchService.Search API.
class GoogleCloudDiscoveryengineV1alphaChunkChunkMetadata {
  /// The next chunks of the current chunk.
  ///
  /// The number is controlled by
  /// SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks. This field is
  /// only populated on SearchService.Search API.
  core.List<GoogleCloudDiscoveryengineV1alphaChunk>? nextChunks;

  /// The previous chunks of the current chunk.
  ///
  /// The number is controlled by
  /// SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks. This field
  /// is only populated on SearchService.Search API.
  core.List<GoogleCloudDiscoveryengineV1alphaChunk>? previousChunks;

  GoogleCloudDiscoveryengineV1alphaChunkChunkMetadata({
    this.nextChunks,
    this.previousChunks,
  });

  GoogleCloudDiscoveryengineV1alphaChunkChunkMetadata.fromJson(core.Map json_)
    : this(
        nextChunks:
            (json_['nextChunks'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaChunk.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        previousChunks:
            (json_['previousChunks'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaChunk.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextChunks != null) 'nextChunks': nextChunks!,
    if (previousChunks != null) 'previousChunks': previousChunks!,
  };
}

/// Document metadata contains the information of the document of the current
/// chunk.
typedef GoogleCloudDiscoveryengineV1alphaChunkDocumentMetadata =
    $ChunkDocumentMetadata;

/// Page span of the chunk.
typedef GoogleCloudDiscoveryengineV1alphaChunkPageSpan = $ChunkPageSpan;

/// The structured content information.
typedef GoogleCloudDiscoveryengineV1alphaChunkStructuredContent =
    $ChunkStructuredContent;

/// Cloud SQL source import data from.
typedef GoogleCloudDiscoveryengineV1alphaCloudSqlSource = $CloudSqlSource;

/// Configurations used to enable CMEK data encryption with Cloud KMS keys.
class GoogleCloudDiscoveryengineV1alphaCmekConfig {
  /// The default CmekConfig for the Customer.
  ///
  /// Output only.
  core.bool? isDefault;

  /// KMS key resource name which will be used to encrypt resources
  /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
  ///
  /// Required.
  core.String? kmsKey;

  /// KMS key version resource name which will be used to encrypt resources
  /// `/cryptoKeyVersions/{keyVersion}`.
  ///
  /// Output only.
  core.String? kmsKeyVersion;

  /// The timestamp of the last key rotation.
  ///
  /// Output only.
  core.String? lastRotationTimestampMicros;

  /// The name of the CmekConfig of the form
  /// `projects/{project}/locations/{location}/cmekConfig` or
  /// `projects/{project}/locations/{location}/cmekConfigs/{cmek_config}`.
  ///
  /// Required.
  core.String? name;

  /// Whether the NotebookLM Corpus is ready to be used.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "NOTEBOOK_LM_STATE_UNSPECIFIED" : The NotebookLM state is unknown.
  /// - "NOTEBOOK_LM_NOT_READY" : The NotebookLM is not ready.
  /// - "NOTEBOOK_LM_READY" : The NotebookLM is ready to be used.
  /// - "NOTEBOOK_LM_NOT_ENABLED" : The NotebookLM is not enabled.
  core.String? notebooklmState;

  /// Single-regional CMEKs that are required for some VAIS features.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaSingleRegionKey>? singleRegionKeys;

  /// The states of the CmekConfig.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The CmekConfig state is unknown.
  /// - "CREATING" : The CmekConfig is creating.
  /// - "ACTIVE" : The CmekConfig can be used with DataStores.
  /// - "KEY_ISSUE" : The CmekConfig is unavailable, most likely due to the KMS
  /// Key being revoked.
  /// - "DELETING" : The CmekConfig is deleting.
  /// - "DELETE_FAILED" : The CmekConfig deletion process failed.
  /// - "UNUSABLE" : The CmekConfig is not usable, most likely due to some
  /// internal issue.
  /// - "ACTIVE_ROTATING" : The KMS key version is being rotated.
  /// - "DELETED" : The KMS key is soft deleted. Some cleanup policy will
  /// eventually be applied.
  core.String? state;

  GoogleCloudDiscoveryengineV1alphaCmekConfig({
    this.isDefault,
    this.kmsKey,
    this.kmsKeyVersion,
    this.lastRotationTimestampMicros,
    this.name,
    this.notebooklmState,
    this.singleRegionKeys,
    this.state,
  });

  GoogleCloudDiscoveryengineV1alphaCmekConfig.fromJson(core.Map json_)
    : this(
        isDefault: json_['isDefault'] as core.bool?,
        kmsKey: json_['kmsKey'] as core.String?,
        kmsKeyVersion: json_['kmsKeyVersion'] as core.String?,
        lastRotationTimestampMicros:
            json_['lastRotationTimestampMicros'] as core.String?,
        name: json_['name'] as core.String?,
        notebooklmState: json_['notebooklmState'] as core.String?,
        singleRegionKeys:
            (json_['singleRegionKeys'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSingleRegionKey.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (isDefault != null) 'isDefault': isDefault!,
    if (kmsKey != null) 'kmsKey': kmsKey!,
    if (kmsKeyVersion != null) 'kmsKeyVersion': kmsKeyVersion!,
    if (lastRotationTimestampMicros != null)
      'lastRotationTimestampMicros': lastRotationTimestampMicros!,
    if (name != null) 'name': name!,
    if (notebooklmState != null) 'notebooklmState': notebooklmState!,
    if (singleRegionKeys != null) 'singleRegionKeys': singleRegionKeys!,
    if (state != null) 'state': state!,
  };
}

/// Collection is a container for configuring resources and access to a set of
/// DataStores.
class GoogleCloudDiscoveryengineV1alphaCollection {
  /// Timestamp the Collection was created at.
  ///
  /// Output only.
  core.String? createTime;

  /// The data connector, if present, manages the connection for data stores in
  /// the Collection.
  ///
  /// To set up the connector, use DataConnectorService.SetUpDataConnector
  /// method, which creates a new Collection while setting up the DataConnector
  /// singleton resource. Setting up connector on an existing Collection is not
  /// supported. This output only field contains a subset of the DataConnector
  /// fields, including `name`, `data_source`, `entities.entity_name` and
  /// `entities.data_store`. To get more details about a data connector, use the
  /// DataConnectorService.GetDataConnector method.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaDataConnector? dataConnector;

  /// The Collection display name.
  ///
  /// This field must be a UTF-8 encoded string with a length limit of 128
  /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
  ///
  /// Required.
  core.String? displayName;

  /// The full resource name of the Collection.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  GoogleCloudDiscoveryengineV1alphaCollection({
    this.createTime,
    this.dataConnector,
    this.displayName,
    this.name,
  });

  GoogleCloudDiscoveryengineV1alphaCollection.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        dataConnector:
            json_.containsKey('dataConnector')
                ? GoogleCloudDiscoveryengineV1alphaDataConnector.fromJson(
                  json_['dataConnector'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        displayName: json_['displayName'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (dataConnector != null) 'dataConnector': dataConnector!,
    if (displayName != null) 'displayName': displayName!,
    if (name != null) 'name': name!,
  };
}

/// Response message for CompletionService.CompleteQuery method.
class GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse {
  /// Results of the matched query suggestions.
  ///
  /// The result list is ordered and the first result is a top suggestion.
  core.List<
    GoogleCloudDiscoveryengineV1alphaCompleteQueryResponseQuerySuggestion
  >?
  querySuggestions;

  /// True if the returned suggestions are all tail suggestions.
  ///
  /// For tail matching to be triggered, include_tail_suggestions in the request
  /// must be true and there must be no suggestions that match the full query.
  core.bool? tailMatchTriggered;

  GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse({
    this.querySuggestions,
    this.tailMatchTriggered,
  });

  GoogleCloudDiscoveryengineV1alphaCompleteQueryResponse.fromJson(
    core.Map json_,
  ) : this(
        querySuggestions:
            (json_['querySuggestions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCompleteQueryResponseQuerySuggestion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        tailMatchTriggered: json_['tailMatchTriggered'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (querySuggestions != null) 'querySuggestions': querySuggestions!,
    if (tailMatchTriggered != null) 'tailMatchTriggered': tailMatchTriggered!,
  };
}

/// Suggestions as search queries.
typedef GoogleCloudDiscoveryengineV1alphaCompleteQueryResponseQuerySuggestion =
    $CompleteQueryResponseQuerySuggestion;

/// Detailed completion information including completion attribution token and
/// clicked completion info.
typedef GoogleCloudDiscoveryengineV1alphaCompletionInfo = $CompletionInfo;

/// Autocomplete suggestions that are imported from Customer.
typedef GoogleCloudDiscoveryengineV1alphaCompletionSuggestion =
    $CompletionSuggestion;

/// Defines circumstances to be checked before allowing a behavior
class GoogleCloudDiscoveryengineV1alphaCondition {
  /// Range of time(s) specifying when condition is active.
  ///
  /// Maximum of 10 time ranges.
  core.List<GoogleCloudDiscoveryengineV1alphaConditionTimeRange>?
  activeTimeRange;

  /// Query regex to match the whole search query.
  ///
  /// Cannot be set when Condition.query_terms is set. Only supported for Basic
  /// Site Search promotion serving controls.
  ///
  /// Optional.
  core.String? queryRegex;

  /// Search only A list of terms to match the query on.
  ///
  /// Cannot be set when Condition.query_regex is set. Maximum of 10 query
  /// terms.
  core.List<GoogleCloudDiscoveryengineV1alphaConditionQueryTerm>? queryTerms;

  GoogleCloudDiscoveryengineV1alphaCondition({
    this.activeTimeRange,
    this.queryRegex,
    this.queryTerms,
  });

  GoogleCloudDiscoveryengineV1alphaCondition.fromJson(core.Map json_)
    : this(
        activeTimeRange:
            (json_['activeTimeRange'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaConditionTimeRange.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        queryRegex: json_['queryRegex'] as core.String?,
        queryTerms:
            (json_['queryTerms'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaConditionQueryTerm.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (activeTimeRange != null) 'activeTimeRange': activeTimeRange!,
    if (queryRegex != null) 'queryRegex': queryRegex!,
    if (queryTerms != null) 'queryTerms': queryTerms!,
  };
}

/// Matcher for search request query
typedef GoogleCloudDiscoveryengineV1alphaConditionQueryTerm =
    $ConditionQueryTerm00;

/// Used for time-dependent conditions.
typedef GoogleCloudDiscoveryengineV1alphaConditionTimeRange =
    $ConditionTimeRange00;

/// A data sync run of DataConnector.
///
/// After DataConnector is successfully initialized, data syncs are scheduled at
/// DataConnector.refresh_interval. A ConnectorRun represents a data sync either
/// in the past or onging that the moment. //
class GoogleCloudDiscoveryengineV1alphaConnectorRun {
  /// The time when the connector run ended.
  ///
  /// Output only.
  core.String? endTime;

  /// The details of the entities synced at the ConnectorRun.
  ///
  /// Each ConnectorRun consists of syncing one or more entities.
  ///
  /// Output only.
  core.List<GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRun>? entityRuns;

  /// Contains info about errors incurred during the sync.
  ///
  /// Only exist if running into an error state. Contains error code and error
  /// message. Use with the `state` field.
  core.List<GoogleRpcStatus>? errors;

  /// The time when the connector run was most recently paused.
  ///
  /// Output only.
  core.String? latestPauseTime;

  /// The full resource name of the Connector Run.
  ///
  /// Format: `projects / * /locations / * /collections / *
  /// /dataConnector/connectorRuns / * `. The `connector_run_id` is
  /// system-generated.
  ///
  /// Output only.
  core.String? name;

  /// The time when the connector run started.
  ///
  /// Output only.
  core.String? startTime;

  /// The state of the sync run.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value.
  /// - "RUNNING" : The data sync is ongoing.
  /// - "SUCCEEDED" : The data sync is finished.
  /// - "FAILED" : The data sync is failed.
  /// - "OVERRUN" : Data sync has been running longer than expected and is still
  /// running at the time the next run is supposed to start.
  /// - "CANCELLED" : Data sync was scheduled but has been cancelled.
  /// - "PENDING" : Data sync is about to start.
  /// - "WARNING" : The data sync completed with non-fatal errors.
  /// - "SKIPPED" : An ongoing connector run has been running longer than
  /// expected, causing this run to be skipped.
  core.String? state;

  /// Timestamp at which the connector run sync state was last updated.
  core.String? stateUpdateTime;

  /// The trigger for this ConnectorRun.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TRIGGER_UNSPECIFIED" : Default value.
  /// - "SCHEDULER" : ConnectorRun triggered by scheduler if connector has
  /// PERIODIC sync mode.
  /// - "INITIALIZATION" : ConnectorRun auto triggered by connector
  /// initialization.
  /// - "RESUME" : ConnectorRun auto triggered by resuming connector.
  /// - "MANUAL" : ConnectorRun triggered by user manually.
  core.String? trigger;

  GoogleCloudDiscoveryengineV1alphaConnectorRun({
    this.endTime,
    this.entityRuns,
    this.errors,
    this.latestPauseTime,
    this.name,
    this.startTime,
    this.state,
    this.stateUpdateTime,
    this.trigger,
  });

  GoogleCloudDiscoveryengineV1alphaConnectorRun.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        entityRuns:
            (json_['entityRuns'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRun.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        errors:
            (json_['errors'] as core.List?)
                ?.map(
                  (value) => GoogleRpcStatus.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        latestPauseTime: json_['latestPauseTime'] as core.String?,
        name: json_['name'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        stateUpdateTime: json_['stateUpdateTime'] as core.String?,
        trigger: json_['trigger'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (entityRuns != null) 'entityRuns': entityRuns!,
    if (errors != null) 'errors': errors!,
    if (latestPauseTime != null) 'latestPauseTime': latestPauseTime!,
    if (name != null) 'name': name!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (stateUpdateTime != null) 'stateUpdateTime': stateUpdateTime!,
    if (trigger != null) 'trigger': trigger!,
  };
}

/// Represents an entity that was synced in this ConnectorRun.
class GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRun {
  /// The number of documents deleted.
  ///
  /// Optional.
  core.String? deletedRecordCount;

  /// The name of the source entity.
  core.String? entityName;

  /// The total number of documents failed at sync at indexing stage.
  ///
  /// Optional.
  core.String? errorRecordCount;

  /// The errors from the entity's sync run.
  ///
  /// Only exist if running into an error state. Contains error code and error
  /// message.
  core.List<GoogleRpcStatus>? errors;

  /// The number of documents extracted from connector source, ready to be
  /// ingested to VAIS.
  ///
  /// Optional.
  core.String? extractedRecordCount;

  /// The number of documents indexed.
  ///
  /// Optional.
  core.String? indexedRecordCount;

  /// Metadata to generate the progress bar.
  GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRunProgress? progress;

  /// The number of documents scheduled to be crawled/extracted from connector
  /// source.
  ///
  /// This only applies to third party connectors.
  ///
  /// Optional.
  core.String? scheduledRecordCount;

  /// The number of requests sent to 3p API.
  ///
  /// Optional.
  core.String? sourceApiRequestCount;

  /// The state of the entity's sync run.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value.
  /// - "RUNNING" : The data sync is ongoing.
  /// - "SUCCEEDED" : The data sync is finished.
  /// - "FAILED" : The data sync is failed.
  /// - "OVERRUN" : Data sync has been running longer than expected and is still
  /// running at the time the next run is supposed to start.
  /// - "CANCELLED" : Data sync was scheduled but has been cancelled.
  /// - "PENDING" : Data sync is about to start.
  /// - "WARNING" : The data sync completed with non-fatal errors.
  /// - "SKIPPED" : An ongoing connector run has been running longer than
  /// expected, causing this run to be skipped.
  core.String? state;

  /// Timestamp at which the entity sync state was last updated.
  core.String? stateUpdateTime;

  /// The timestamp for either extracted_documents_count,
  /// indexed_documents_count and error_documents_count was last updated.
  core.String? statsUpdateTime;

  /// Sync type of this run.
  /// Possible string values are:
  /// - "SYNC_TYPE_UNSPECIFIED" : Sync type unspecified.
  /// - "FULL" : Sync triggers full sync of all documents.
  /// - "INCREMENTAL" : Incremental sync of updated documents.
  /// - "REALTIME" : Realtime sync.
  /// - "SCALA_SYNC" : Scala sync.
  core.String? syncType;

  GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRun({
    this.deletedRecordCount,
    this.entityName,
    this.errorRecordCount,
    this.errors,
    this.extractedRecordCount,
    this.indexedRecordCount,
    this.progress,
    this.scheduledRecordCount,
    this.sourceApiRequestCount,
    this.state,
    this.stateUpdateTime,
    this.statsUpdateTime,
    this.syncType,
  });

  GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRun.fromJson(
    core.Map json_,
  ) : this(
        deletedRecordCount: json_['deletedRecordCount'] as core.String?,
        entityName: json_['entityName'] as core.String?,
        errorRecordCount: json_['errorRecordCount'] as core.String?,
        errors:
            (json_['errors'] as core.List?)
                ?.map(
                  (value) => GoogleRpcStatus.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        extractedRecordCount: json_['extractedRecordCount'] as core.String?,
        indexedRecordCount: json_['indexedRecordCount'] as core.String?,
        progress:
            json_.containsKey('progress')
                ? GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRunProgress.fromJson(
                  json_['progress'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        scheduledRecordCount: json_['scheduledRecordCount'] as core.String?,
        sourceApiRequestCount: json_['sourceApiRequestCount'] as core.String?,
        state: json_['state'] as core.String?,
        stateUpdateTime: json_['stateUpdateTime'] as core.String?,
        statsUpdateTime: json_['statsUpdateTime'] as core.String?,
        syncType: json_['syncType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deletedRecordCount != null) 'deletedRecordCount': deletedRecordCount!,
    if (entityName != null) 'entityName': entityName!,
    if (errorRecordCount != null) 'errorRecordCount': errorRecordCount!,
    if (errors != null) 'errors': errors!,
    if (extractedRecordCount != null)
      'extractedRecordCount': extractedRecordCount!,
    if (indexedRecordCount != null) 'indexedRecordCount': indexedRecordCount!,
    if (progress != null) 'progress': progress!,
    if (scheduledRecordCount != null)
      'scheduledRecordCount': scheduledRecordCount!,
    if (sourceApiRequestCount != null)
      'sourceApiRequestCount': sourceApiRequestCount!,
    if (state != null) 'state': state!,
    if (stateUpdateTime != null) 'stateUpdateTime': stateUpdateTime!,
    if (statsUpdateTime != null) 'statsUpdateTime': statsUpdateTime!,
    if (syncType != null) 'syncType': syncType!,
  };
}

/// Represents the progress of a sync run.
class GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRunProgress {
  /// The current progress.
  core.String? currentCount;

  /// Derived.
  ///
  /// The percentile of the progress.current_count / total_count. The value is
  /// between \[0, 1.0\] inclusive.
  core.double? percentile;

  /// The total.
  core.String? totalCount;

  GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRunProgress({
    this.currentCount,
    this.percentile,
    this.totalCount,
  });

  GoogleCloudDiscoveryengineV1alphaConnectorRunEntityRunProgress.fromJson(
    core.Map json_,
  ) : this(
        currentCount: json_['currentCount'] as core.String?,
        percentile: (json_['percentile'] as core.num?)?.toDouble(),
        totalCount: json_['totalCount'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (currentCount != null) 'currentCount': currentCount!,
    if (percentile != null) 'percentile': percentile!,
    if (totalCount != null) 'totalCount': totalCount!,
  };
}

/// Defines a conditioned behavior to employ during serving.
///
/// Must be attached to a ServingConfig to be considered at serving time.
/// Permitted actions dependent on `SolutionType`.
class GoogleCloudDiscoveryengineV1alphaControl {
  /// List of all ServingConfig IDs this control is attached to.
  ///
  /// May take up to 10 minutes to update after changes.
  ///
  /// Output only.
  core.List<core.String>? associatedServingConfigIds;

  /// Defines a boost-type control
  GoogleCloudDiscoveryengineV1alphaControlBoostAction? boostAction;

  /// Determines when the associated action will trigger.
  ///
  /// Omit to always apply the action. Currently only a single condition may be
  /// specified. Otherwise an INVALID ARGUMENT error is thrown.
  core.List<GoogleCloudDiscoveryengineV1alphaCondition>? conditions;

  /// Human readable name.
  ///
  /// The identifier used in UI views. Must be UTF-8 encoded string. Length
  /// limit is 128 characters. Otherwise an INVALID ARGUMENT error is thrown.
  ///
  /// Required.
  core.String? displayName;

  /// Defines a filter-type control Currently not supported by Recommendation
  GoogleCloudDiscoveryengineV1alphaControlFilterAction? filterAction;

  /// Fully qualified name `projects / * /locations/global/dataStore / *
  /// /controls / * `
  ///
  /// Immutable.
  core.String? name;

  /// Promote certain links based on predefined trigger queries.
  GoogleCloudDiscoveryengineV1alphaControlPromoteAction? promoteAction;

  /// Defines a redirect-type control.
  GoogleCloudDiscoveryengineV1alphaControlRedirectAction? redirectAction;

  /// What solution the control belongs to.
  ///
  /// Must be compatible with vertical of resource. Otherwise an INVALID
  /// ARGUMENT error is thrown.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "SOLUTION_TYPE_UNSPECIFIED" : Default value.
  /// - "SOLUTION_TYPE_RECOMMENDATION" : Used for Recommendations AI.
  /// - "SOLUTION_TYPE_SEARCH" : Used for Discovery Search.
  /// - "SOLUTION_TYPE_CHAT" : Used for use cases related to the Generative AI
  /// agent.
  /// - "SOLUTION_TYPE_GENERATIVE_CHAT" : Used for use cases related to the
  /// Generative Chat agent. It's used for Generative chat engine only, the
  /// associated data stores must enrolled with `SOLUTION_TYPE_CHAT` solution.
  core.String? solutionType;

  /// Treats a group of terms as synonyms of one another.
  GoogleCloudDiscoveryengineV1alphaControlSynonymsAction? synonymsAction;

  /// Specifies the use case for the control.
  ///
  /// Affects what condition fields can be set. Only applies to
  /// SOLUTION_TYPE_SEARCH. Currently only allow one use case per control. Must
  /// be set when solution_type is SolutionType.SOLUTION_TYPE_SEARCH.
  core.List<core.String>? useCases;

  GoogleCloudDiscoveryengineV1alphaControl({
    this.associatedServingConfigIds,
    this.boostAction,
    this.conditions,
    this.displayName,
    this.filterAction,
    this.name,
    this.promoteAction,
    this.redirectAction,
    this.solutionType,
    this.synonymsAction,
    this.useCases,
  });

  GoogleCloudDiscoveryengineV1alphaControl.fromJson(core.Map json_)
    : this(
        associatedServingConfigIds:
            (json_['associatedServingConfigIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        boostAction:
            json_.containsKey('boostAction')
                ? GoogleCloudDiscoveryengineV1alphaControlBoostAction.fromJson(
                  json_['boostAction'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        conditions:
            (json_['conditions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCondition.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        displayName: json_['displayName'] as core.String?,
        filterAction:
            json_.containsKey('filterAction')
                ? GoogleCloudDiscoveryengineV1alphaControlFilterAction.fromJson(
                  json_['filterAction'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        promoteAction:
            json_.containsKey('promoteAction')
                ? GoogleCloudDiscoveryengineV1alphaControlPromoteAction.fromJson(
                  json_['promoteAction'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        redirectAction:
            json_.containsKey('redirectAction')
                ? GoogleCloudDiscoveryengineV1alphaControlRedirectAction.fromJson(
                  json_['redirectAction']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        solutionType: json_['solutionType'] as core.String?,
        synonymsAction:
            json_.containsKey('synonymsAction')
                ? GoogleCloudDiscoveryengineV1alphaControlSynonymsAction.fromJson(
                  json_['synonymsAction']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        useCases:
            (json_['useCases'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (associatedServingConfigIds != null)
      'associatedServingConfigIds': associatedServingConfigIds!,
    if (boostAction != null) 'boostAction': boostAction!,
    if (conditions != null) 'conditions': conditions!,
    if (displayName != null) 'displayName': displayName!,
    if (filterAction != null) 'filterAction': filterAction!,
    if (name != null) 'name': name!,
    if (promoteAction != null) 'promoteAction': promoteAction!,
    if (redirectAction != null) 'redirectAction': redirectAction!,
    if (solutionType != null) 'solutionType': solutionType!,
    if (synonymsAction != null) 'synonymsAction': synonymsAction!,
    if (useCases != null) 'useCases': useCases!,
  };
}

/// Adjusts order of products in returned list.
class GoogleCloudDiscoveryengineV1alphaControlBoostAction {
  /// Strength of the boost, which should be in \[-1, 1\].
  ///
  /// Negative boost means demotion. Default is 0.0 (No-op).
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.double? boost;

  /// Specifies which data store's documents can be boosted by this control.
  ///
  /// Full data store name e.g.
  /// projects/123/locations/global/collections/default_collection/dataStores/default_data_store
  ///
  /// Required.
  core.String? dataStore;

  /// Specifies which products to apply the boost to.
  ///
  /// If no filter is provided all products will be boosted (No-op). Syntax
  /// documentation: https://cloud.google.com/retail/docs/filter-and-order
  /// Maximum length is 5000 characters. Otherwise an INVALID ARGUMENT error is
  /// thrown.
  ///
  /// Required.
  core.String? filter;

  /// Strength of the boost, which should be in \[-1, 1\].
  ///
  /// Negative boost means demotion. Default is 0.0 (No-op).
  ///
  /// Optional.
  core.double? fixedBoost;

  /// Complex specification for custom ranking based on customer defined
  /// attribute value.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpec?
  interpolationBoostSpec;

  GoogleCloudDiscoveryengineV1alphaControlBoostAction({
    this.boost,
    this.dataStore,
    this.filter,
    this.fixedBoost,
    this.interpolationBoostSpec,
  });

  GoogleCloudDiscoveryengineV1alphaControlBoostAction.fromJson(core.Map json_)
    : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        dataStore: json_['dataStore'] as core.String?,
        filter: json_['filter'] as core.String?,
        fixedBoost: (json_['fixedBoost'] as core.num?)?.toDouble(),
        interpolationBoostSpec:
            json_.containsKey('interpolationBoostSpec')
                ? GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpec.fromJson(
                  json_['interpolationBoostSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (dataStore != null) 'dataStore': dataStore!,
    if (filter != null) 'filter': filter!,
    if (fixedBoost != null) 'fixedBoost': fixedBoost!,
    if (interpolationBoostSpec != null)
      'interpolationBoostSpec': interpolationBoostSpec!,
  };
}

/// Specification for custom ranking based on customer specified attribute
/// value.
///
/// It provides more controls for customized ranking than the simple (condition,
/// boost) combination above.
class GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpec {
  /// The attribute type to be used to determine the boost amount.
  ///
  /// The attribute value can be derived from the field value of the specified
  /// field_name. In the case of numerical it is straightforward i.e.
  /// attribute_value = numerical_field_value. In the case of freshness however,
  /// attribute_value = (time.now() - datetime_field_value).
  ///
  /// Optional.
  /// Possible string values are:
  /// - "ATTRIBUTE_TYPE_UNSPECIFIED" : Unspecified AttributeType.
  /// - "NUMERICAL" : The value of the numerical field will be used to
  /// dynamically update the boost amount. In this case, the attribute_value
  /// (the x value) of the control point will be the actual value of the
  /// numerical field for which the boost_amount is specified.
  /// - "FRESHNESS" : For the freshness use case the attribute value will be the
  /// duration between the current time and the date in the datetime field
  /// specified. The value must be formatted as an XSD `dayTimeDuration` value
  /// (a restricted subset of an ISO 8601 duration value). The pattern for this
  /// is: `nDnM]`. For example, `5D`, `3DT12H30M`, `T24H`.
  core.String? attributeType;

  /// The control points used to define the curve.
  ///
  /// The monotonic function (defined through the interpolation_type above)
  /// passes through the control points listed here.
  ///
  /// Optional.
  core.List<
    GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpecControlPoint
  >?
  controlPoints;

  /// The name of the field whose value will be used to determine the boost
  /// amount.
  ///
  /// Optional.
  core.String? fieldName;

  /// The interpolation type to be applied to connect the control points listed
  /// below.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "INTERPOLATION_TYPE_UNSPECIFIED" : Interpolation type is unspecified. In
  /// this case, it defaults to Linear.
  /// - "LINEAR" : Piecewise linear interpolation will be applied.
  core.String? interpolationType;

  GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpec({
    this.attributeType,
    this.controlPoints,
    this.fieldName,
    this.interpolationType,
  });

  GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpec.fromJson(
    core.Map json_,
  ) : this(
        attributeType: json_['attributeType'] as core.String?,
        controlPoints:
            (json_['controlPoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpecControlPoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        fieldName: json_['fieldName'] as core.String?,
        interpolationType: json_['interpolationType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeType != null) 'attributeType': attributeType!,
    if (controlPoints != null) 'controlPoints': controlPoints!,
    if (fieldName != null) 'fieldName': fieldName!,
    if (interpolationType != null) 'interpolationType': interpolationType!,
  };
}

/// The control points used to define the curve.
///
/// The curve defined through these control points can only be monotonically
/// increasing or decreasing(constant values are acceptable).
typedef GoogleCloudDiscoveryengineV1alphaControlBoostActionInterpolationBoostSpecControlPoint =
    $SpecControlPoint;

/// Specified which products may be included in results.
///
/// Uses same filter as boost.
typedef GoogleCloudDiscoveryengineV1alphaControlFilterAction =
    $ControlFilterAction;

/// Promote certain links based on some trigger queries.
///
/// Example: Promote shoe store link when searching for `shoe` keyword. The link
/// can be outside of associated data store.
class GoogleCloudDiscoveryengineV1alphaControlPromoteAction {
  /// Data store with which this promotion is attached to.
  ///
  /// Required.
  core.String? dataStore;

  /// Promotion attached to this action.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaSearchLinkPromotion? searchLinkPromotion;

  GoogleCloudDiscoveryengineV1alphaControlPromoteAction({
    this.dataStore,
    this.searchLinkPromotion,
  });

  GoogleCloudDiscoveryengineV1alphaControlPromoteAction.fromJson(core.Map json_)
    : this(
        dataStore: json_['dataStore'] as core.String?,
        searchLinkPromotion:
            json_.containsKey('searchLinkPromotion')
                ? GoogleCloudDiscoveryengineV1alphaSearchLinkPromotion.fromJson(
                  json_['searchLinkPromotion']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStore != null) 'dataStore': dataStore!,
    if (searchLinkPromotion != null)
      'searchLinkPromotion': searchLinkPromotion!,
  };
}

/// Redirects a shopper to the provided URI.
typedef GoogleCloudDiscoveryengineV1alphaControlRedirectAction =
    $ControlRedirectAction;

/// Creates a set of terms that will act as synonyms of one another.
///
/// Example: "happy" will also be considered as "glad", "glad" will also be
/// considered as "happy".
typedef GoogleCloudDiscoveryengineV1alphaControlSynonymsAction =
    $ControlSynonymsAction;

/// External conversation proto definition.
class GoogleCloudDiscoveryengineV1alphaConversation {
  /// The time the conversation finished.
  ///
  /// Output only.
  core.String? endTime;

  /// Conversation messages.
  core.List<GoogleCloudDiscoveryengineV1alphaConversationMessage>? messages;

  /// Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/dataStore /
  /// * /conversations / * ` or
  /// `projects/{project}/locations/global/collections/{collection}/engines / *
  /// /conversations / * `.
  ///
  /// Immutable.
  core.String? name;

  /// The time the conversation started.
  ///
  /// Output only.
  core.String? startTime;

  /// The state of the Conversation.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Unknown.
  /// - "IN_PROGRESS" : Conversation is currently open.
  /// - "COMPLETED" : Conversation has been completed.
  core.String? state;

  /// A unique identifier for tracking users.
  core.String? userPseudoId;

  GoogleCloudDiscoveryengineV1alphaConversation({
    this.endTime,
    this.messages,
    this.name,
    this.startTime,
    this.state,
    this.userPseudoId,
  });

  GoogleCloudDiscoveryengineV1alphaConversation.fromJson(core.Map json_)
    : this(
        endTime: json_['endTime'] as core.String?,
        messages:
            (json_['messages'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaConversationMessage.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        name: json_['name'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        userPseudoId: json_['userPseudoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endTime != null) 'endTime': endTime!,
    if (messages != null) 'messages': messages!,
    if (name != null) 'name': name!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (userPseudoId != null) 'userPseudoId': userPseudoId!,
  };
}

/// Defines context of the conversation
typedef GoogleCloudDiscoveryengineV1alphaConversationContext =
    $ConversationContext;

/// Defines a conversation message.
class GoogleCloudDiscoveryengineV1alphaConversationMessage {
  /// Message creation timestamp.
  ///
  /// Output only.
  core.String? createTime;

  /// Search reply.
  GoogleCloudDiscoveryengineV1alphaReply? reply;

  /// User text input.
  GoogleCloudDiscoveryengineV1alphaTextInput? userInput;

  GoogleCloudDiscoveryengineV1alphaConversationMessage({
    this.createTime,
    this.reply,
    this.userInput,
  });

  GoogleCloudDiscoveryengineV1alphaConversationMessage.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        reply:
            json_.containsKey('reply')
                ? GoogleCloudDiscoveryengineV1alphaReply.fromJson(
                  json_['reply'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userInput:
            json_.containsKey('userInput')
                ? GoogleCloudDiscoveryengineV1alphaTextInput.fromJson(
                  json_['userInput'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (reply != null) 'reply': reply!,
    if (userInput != null) 'userInput': userInput!,
  };
}

/// Request message for ConversationalSearchService.ConverseConversation method.
class GoogleCloudDiscoveryengineV1alphaConverseConversationRequest {
  /// Boost specification to boost certain documents in search results which may
  /// affect the converse response.
  ///
  /// For more information on boosting, see
  /// [Boosting](https://cloud.google.com/retail/docs/boosting#boost)
  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec? boostSpec;

  /// The conversation to be used by auto session only.
  ///
  /// The name field will be ignored as we automatically assign new name for the
  /// conversation in auto session.
  GoogleCloudDiscoveryengineV1alphaConversation? conversation;

  /// The filter syntax consists of an expression language for constructing a
  /// predicate from one or more fields of the documents being filtered.
  ///
  /// Filter expression is case-sensitive. This will be used to filter search
  /// results which may affect the summary response. If this field is
  /// unrecognizable, an `INVALID_ARGUMENT` is returned. Filtering in Vertex AI
  /// Search is done by mapping the LHS filter key to a key property defined in
  /// the Vertex AI Search backend -- this mapping is defined by the customer in
  /// their schema. For example a media customer might have a field 'name' in
  /// their schema. In this case the filter would look like this: filter --\>
  /// name:'ANY("king kong")' For more information about filtering including
  /// syntax and filter operators, see
  /// [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  core.String? filter;

  /// Current user input.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaTextInput? query;

  /// Whether to turn on safe search.
  core.bool? safeSearch;

  /// The resource name of the Serving Config to use.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/servingConfigs/{serving_config_id}`
  /// If this is not set, the default serving config will be used.
  core.String? servingConfig;

  /// A specification for configuring the summary returned in the response.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpec?
  summarySpec;

  /// The user labels applied to a resource must meet the following
  /// requirements: * Each resource can have multiple labels, up to a maximum of
  /// 64.
  ///
  /// * Each label must be a key-value pair. * Keys have a minimum length of 1
  /// character and a maximum length of 63 characters and cannot be empty.
  /// Values can be empty and have a maximum length of 63 characters. * Keys and
  /// values can contain only lowercase letters, numeric characters,
  /// underscores, and dashes. All characters must use UTF-8 encoding, and
  /// international characters are allowed. * The key portion of a label must be
  /// unique. However, you can use the same key with multiple resources. * Keys
  /// must start with a lowercase letter or international character. See
  /// [Google Cloud Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
  /// for more details.
  core.Map<core.String, core.String>? userLabels;

  GoogleCloudDiscoveryengineV1alphaConverseConversationRequest({
    this.boostSpec,
    this.conversation,
    this.filter,
    this.query,
    this.safeSearch,
    this.servingConfig,
    this.summarySpec,
    this.userLabels,
  });

  GoogleCloudDiscoveryengineV1alphaConverseConversationRequest.fromJson(
    core.Map json_,
  ) : this(
        boostSpec:
            json_.containsKey('boostSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec.fromJson(
                  json_['boostSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        conversation:
            json_.containsKey('conversation')
                ? GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
                  json_['conversation'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        filter: json_['filter'] as core.String?,
        query:
            json_.containsKey('query')
                ? GoogleCloudDiscoveryengineV1alphaTextInput.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        safeSearch: json_['safeSearch'] as core.bool?,
        servingConfig: json_['servingConfig'] as core.String?,
        summarySpec:
            json_.containsKey('summarySpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpec.fromJson(
                  json_['summarySpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boostSpec != null) 'boostSpec': boostSpec!,
    if (conversation != null) 'conversation': conversation!,
    if (filter != null) 'filter': filter!,
    if (query != null) 'query': query!,
    if (safeSearch != null) 'safeSearch': safeSearch!,
    if (servingConfig != null) 'servingConfig': servingConfig!,
    if (summarySpec != null) 'summarySpec': summarySpec!,
    if (userLabels != null) 'userLabels': userLabels!,
  };
}

/// Response message for ConversationalSearchService.ConverseConversation
/// method.
class GoogleCloudDiscoveryengineV1alphaConverseConversationResponse {
  /// Updated conversation including the answer.
  GoogleCloudDiscoveryengineV1alphaConversation? conversation;

  /// Suggested related questions.
  core.List<core.String>? relatedQuestions;

  /// Answer to the current query.
  GoogleCloudDiscoveryengineV1alphaReply? reply;

  /// Search Results.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult>?
  searchResults;

  GoogleCloudDiscoveryengineV1alphaConverseConversationResponse({
    this.conversation,
    this.relatedQuestions,
    this.reply,
    this.searchResults,
  });

  GoogleCloudDiscoveryengineV1alphaConverseConversationResponse.fromJson(
    core.Map json_,
  ) : this(
        conversation:
            json_.containsKey('conversation')
                ? GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
                  json_['conversation'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        relatedQuestions:
            (json_['relatedQuestions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        reply:
            json_.containsKey('reply')
                ? GoogleCloudDiscoveryengineV1alphaReply.fromJson(
                  json_['reply'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchResults:
            (json_['searchResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (conversation != null) 'conversation': conversation!,
    if (relatedQuestions != null) 'relatedQuestions': relatedQuestions!,
    if (reply != null) 'reply': reply!,
    if (searchResults != null) 'searchResults': searchResults!,
  };
}

/// The historical crawl rate timeseries data, used for monitoring.
class GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries {
  /// The QPS of the crawl rate.
  GoogleMonitoringV3TimeSeries? qpsTimeSeries;

  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries({this.qpsTimeSeries});

  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries.fromJson(core.Map json_)
    : this(
        qpsTimeSeries:
            json_.containsKey('qpsTimeSeries')
                ? GoogleMonitoringV3TimeSeries.fromJson(
                  json_['qpsTimeSeries'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (qpsTimeSeries != null) 'qpsTimeSeries': qpsTimeSeries!,
  };
}

/// Request message for SiteSearchEngineService.CreateTargetSite method.
class GoogleCloudDiscoveryengineV1alphaCreateTargetSiteRequest {
  /// Parent resource name of TargetSite, such as
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
  ///
  /// Required.
  core.String? parent;

  /// The TargetSite to create.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaTargetSite? targetSite;

  GoogleCloudDiscoveryengineV1alphaCreateTargetSiteRequest({
    this.parent,
    this.targetSite,
  });

  GoogleCloudDiscoveryengineV1alphaCreateTargetSiteRequest.fromJson(
    core.Map json_,
  ) : this(
        parent: json_['parent'] as core.String?,
        targetSite:
            json_.containsKey('targetSite')
                ? GoogleCloudDiscoveryengineV1alphaTargetSite.fromJson(
                  json_['targetSite'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (parent != null) 'parent': parent!,
    if (targetSite != null) 'targetSite': targetSite!,
  };
}

/// A custom attribute that is not explicitly modeled in a resource, e.g.
/// UserEvent.
typedef GoogleCloudDiscoveryengineV1alphaCustomAttribute = $CustomAttribute00;

/// Defines custom fine tuning spec.
class GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec {
  /// Whether or not to enable and include custom fine tuned search adaptor
  /// model.
  core.bool? enableSearchAdaptor;

  GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec({
    this.enableSearchAdaptor,
  });

  GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec.fromJson(core.Map json_)
    : this(enableSearchAdaptor: json_['enableSearchAdaptor'] as core.bool?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableSearchAdaptor != null)
      'enableSearchAdaptor': enableSearchAdaptor!,
  };
}

/// Metadata that describes a custom tuned model.
typedef GoogleCloudDiscoveryengineV1alphaCustomTuningModel = $CustomTuningModel;

/// Manages the connection to external data sources for all data stores grouped
/// under a Collection.
///
/// It's a singleton resource of Collection. The initialization is only
/// supported through DataConnectorService.SetUpDataConnector method, which will
/// create a new Collection and initialize its DataConnector.
class GoogleCloudDiscoveryengineV1alphaDataConnector {
  /// Whether the connector will be created with an ACL config.
  ///
  /// Currently this field only affects Cloud Storage and BigQuery connectors.
  ///
  /// Optional.
  core.bool? aclEnabled;

  /// Action configurations to make the connector support actions.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaActionConfig? actionConfig;

  /// State of the action connector.
  ///
  /// This reflects whether the action connector is initializing, active or has
  /// encountered errors.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value.
  /// - "CREATING" : The connector is being set up.
  /// - "ACTIVE" : The connector is successfully set up and awaiting next sync
  /// run.
  /// - "FAILED" : The connector is in error. The error details can be found in
  /// DataConnector.errors. If the error is unfixable, the DataConnector can be
  /// deleted by \[CollectionService.DeleteCollection\] API.
  /// - "RUNNING" : The connector is actively syncing records from the data
  /// source.
  /// - "WARNING" : The connector has completed a sync run, but encountered
  /// non-fatal errors.
  /// - "INITIALIZATION_FAILED" : Connector initialization failed. Potential
  /// causes include runtime errors or issues in the asynchronous pipeline,
  /// preventing the request from reaching downstream services (except for some
  /// connector types).
  /// - "UPDATING" : Connector is in the process of an update.
  core.String? actionState;

  /// The connector level alert config.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaAlertPolicyConfig>?
  alertPolicyConfigs;

  /// Indicates whether the connector is disabled for auto run.
  ///
  /// It can be used to pause periodical and real time sync. Update: with the
  /// introduction of incremental_sync_disabled, auto_run_disabled is used to
  /// pause/disable only full syncs
  ///
  /// Optional.
  core.bool? autoRunDisabled;

  /// The configuration for establishing a BAP connection.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaBAPConfig? bapConfig;

  /// User actions that must be completed before the connector can start syncing
  /// data.
  ///
  /// Output only.
  core.List<core.String>? blockingReasons;

  /// The modes enabled for this connector.
  ///
  /// Default state is CONNECTOR_MODE_UNSPECIFIED.
  ///
  /// Optional.
  core.List<core.String>? connectorModes;

  /// The type of connector.
  ///
  /// Each source can only map to one type. For example, salesforce, confluence
  /// and jira have THIRD_PARTY connector type. It is not mutable once set by
  /// system.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONNECTOR_TYPE_UNSPECIFIED" : Default value.
  /// - "THIRD_PARTY" : Third party connector to connector to third party
  /// application.
  /// - "GCP_FHIR" : Data connector connects between FHIR store and VAIS
  /// datastore.
  /// - "BIG_QUERY" : Big query connector.
  /// - "GCS" : Google Cloud Storage connector.
  /// - "GOOGLE_MAIL" : Gmail connector.
  /// - "GOOGLE_CALENDAR" : Google Calendar connector.
  /// - "GOOGLE_DRIVE" : Google Drive connector.
  /// - "NATIVE_CLOUD_IDENTITY" : Native Cloud Identity connector for people
  /// search powered by People API.
  /// - "THIRD_PARTY_FEDERATED" : Federated connector, it is a third party
  /// connector that doesn't ingestion data, and search is powered by third
  /// party application's API.
  /// - "THIRD_PARTY_EUA" : Connector utilized for End User Authentication
  /// features.
  /// - "GCNV" : Google Cloud NetApp Volumes connector.
  core.String? connectorType;

  /// Whether the END USER AUTHENTICATION connector is created in SaaS.
  ///
  /// Optional.
  core.bool? createEuaSaas;

  /// Timestamp the DataConnector was created at.
  ///
  /// Output only.
  core.String? createTime;

  /// The name of the data source.
  ///
  /// Supported values: `salesforce`, `jira`, `confluence`, `bigquery`.
  ///
  /// Required.
  core.String? dataSource;

  /// Any target destinations used to connect to third-party services.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaDestinationConfig>?
  destinationConfigs;

  /// Any params and credentials used specifically for EUA connectors.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaDataConnectorEndUserConfig? endUserConfig;

  /// List of entities from the connected data source to ingest.
  core.List<GoogleCloudDiscoveryengineV1alphaDataConnectorSourceEntity>?
  entities;

  /// The errors from initialization or from the latest connector run.
  ///
  /// Output only.
  core.List<GoogleRpcStatus>? errors;

  /// The refresh interval to sync the Access Control List information for the
  /// documents ingested by this connector.
  ///
  /// If not set, the access control list will be refreshed at the default
  /// interval of 30 minutes. The identity refresh interval can be at least 30
  /// minutes and at most 7 days.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? identityRefreshInterval;

  /// The configuration for the identity data synchronization runs.
  ///
  /// This contains the refresh interval to sync the Access Control List
  /// information for the documents ingested by this connector.
  GoogleCloudDiscoveryengineV1alphaIdentityScheduleConfig?
  identityScheduleConfig;

  /// The refresh interval specifically for incremental data syncs.
  ///
  /// If unset, incremental syncs will use the default from env, set to 3hrs.
  /// The minimum is 30 minutes and maximum is 7 days. Applicable to only 3P
  /// connectors. When the refresh interval is set to the same value as the
  /// incremental refresh interval, incremental sync will be disabled.
  ///
  /// Optional.
  core.String? incrementalRefreshInterval;

  /// Indicates whether incremental syncs are paused for this connector.
  ///
  /// This is independent of auto_run_disabled. Applicable to only 3P
  /// connectors. When the refresh interval is set to the same value as the
  /// incremental refresh interval, incremental sync will be disabled, i.e. set
  /// to true.
  ///
  /// Optional.
  core.bool? incrementalSyncDisabled;

  /// Input only.
  ///
  /// The KMS key to be used to protect the DataStores managed by this
  /// connector. Must be set for requests that need to comply with CMEK Org
  /// Policy protections. If this field is set and processed successfully, the
  /// DataStores created by this connector will be protected by the KMS key.
  core.String? kmsKeyName;

  /// For periodic connectors only, the last time a data sync was completed.
  ///
  /// Output only.
  core.String? lastSyncTime;

  /// The most recent timestamp when this DataConnector was paused, affecting
  /// all functionalities such as data synchronization.
  ///
  /// Pausing a connector has the following effects: - All functionalities,
  /// including data synchronization, are halted. - Any ongoing data
  /// synchronization job will be canceled. - No future data synchronization
  /// runs will be scheduled nor can be triggered.
  ///
  /// Output only.
  core.String? latestPauseTime;

  /// The full resource name of the Data Connector.
  ///
  /// Format: `projects / * /locations / * /collections / * /dataConnector`.
  ///
  /// Output only.
  core.String? name;

  /// Defines the scheduled time for the next data synchronization.
  ///
  /// This field requires hour , minute, and time_zone from the
  /// [IANA Time Zone Database](https://www.iana.org/time-zones). This is
  /// utilized when the data connector has a refresh interval greater than 1
  /// day. When the hours or minutes are not specified, we will assume a sync
  /// time of 0:00. The user must provide a time zone to avoid ambiguity.
  GoogleTypeDateTime? nextSyncTime;

  /// Params needed to access the source in the format of (Key, Value) pairs.
  ///
  /// Required parameters for all data sources: * Key: `instance_uri` * Value:
  /// type STRING. The uri to access the data source. Required parameters for
  /// sources that support OAUTH, i.e. `salesforce`: * Key: `client_id` * Value:
  /// type STRING. The client ID for the third party service provider to
  /// identify your application. * Key: `client_secret` * Value:type STRING. The
  /// client secret generated by the third party authorization server. * Key:
  /// `access_token` * Value: type STRING. OAuth token for UCS to access to the
  /// protected resource. * Key: `refresh_token` * Value: type STRING. OAuth
  /// refresh token for UCS to obtain a new access token without user
  /// interaction. Required parameters for sources that support basic API token
  /// auth, i.e. `jira`, `confluence`: * Key: `user_account` * Value: type
  /// STRING. The username or email with the source. * Key: `api_token` * Value:
  /// type STRING. The API token generated for the source account, that is used
  /// for authenticating anywhere where you would have used a password. Example:
  /// ```json { "instance_uri": "https://xxx.atlassian.net", "user_account":
  /// "xxxx.xxx@xxx.com", "api_token": "test-token" } ``` Optional parameter to
  /// specify the authorization type to use for multiple authorization types
  /// support: * Key: `auth_type` * Value: type STRING. The authorization type
  /// for the data source. Supported values: `BASIC_AUTH`, `OAUTH`,
  /// `OAUTH_ACCESS_TOKEN`, `OAUTH_TWO_LEGGED`, `OAUTH_JWT_BEARER`,
  /// `OAUTH_PASSWORD_GRANT`, `JWT`, `API_TOKEN`, `FEDERATED_CREDENTIAL`.
  ///
  /// Required.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? params;

  /// The tenant project ID associated with private connectivity connectors.
  ///
  /// This project must be allowlisted by in order for the connector to
  /// function.
  ///
  /// Output only.
  core.String? privateConnectivityProjectId;

  /// real-time sync state
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value.
  /// - "CREATING" : The connector is being set up.
  /// - "ACTIVE" : The connector is successfully set up and awaiting next sync
  /// run.
  /// - "FAILED" : The connector is in error. The error details can be found in
  /// DataConnector.errors. If the error is unfixable, the DataConnector can be
  /// deleted by \[CollectionService.DeleteCollection\] API.
  /// - "RUNNING" : The connector is actively syncing records from the data
  /// source.
  /// - "WARNING" : The connector has completed a sync run, but encountered
  /// non-fatal errors.
  /// - "INITIALIZATION_FAILED" : Connector initialization failed. Potential
  /// causes include runtime errors or issues in the asynchronous pipeline,
  /// preventing the request from reaching downstream services (except for some
  /// connector types).
  /// - "UPDATING" : Connector is in the process of an update.
  core.String? realtimeState;

  /// The configuration for realtime sync.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfig?
  realtimeSyncConfig;

  /// The refresh interval for data sync.
  ///
  /// If duration is set to 0, the data will be synced in real time. The
  /// streaming feature is not supported yet. The minimum is 30 minutes and
  /// maximum is 7 days. When the refresh interval is set to the same value as
  /// the incremental refresh interval, incremental sync will be disabled.
  ///
  /// Required.
  core.String? refreshInterval;

  /// State of the connector.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : Default value.
  /// - "CREATING" : The connector is being set up.
  /// - "ACTIVE" : The connector is successfully set up and awaiting next sync
  /// run.
  /// - "FAILED" : The connector is in error. The error details can be found in
  /// DataConnector.errors. If the error is unfixable, the DataConnector can be
  /// deleted by \[CollectionService.DeleteCollection\] API.
  /// - "RUNNING" : The connector is actively syncing records from the data
  /// source.
  /// - "WARNING" : The connector has completed a sync run, but encountered
  /// non-fatal errors.
  /// - "INITIALIZATION_FAILED" : Connector initialization failed. Potential
  /// causes include runtime errors or issues in the asynchronous pipeline,
  /// preventing the request from reaching downstream services (except for some
  /// connector types).
  /// - "UPDATING" : Connector is in the process of an update.
  core.String? state;

  /// The static IP addresses used by this connector.
  ///
  /// Output only.
  core.List<core.String>? staticIpAddresses;

  /// Whether customer has enabled static IP addresses for this connector.
  ///
  /// Optional.
  core.bool? staticIpEnabled;

  /// The data synchronization mode supported by the data connector.
  /// Possible string values are:
  /// - "PERIODIC" : The connector will sync data periodically based on the
  /// refresh_interval. Use it with auto_run_disabled to pause the periodic
  /// sync, or indicate a one-time sync.
  /// - "STREAMING" : The data will be synced in real time.
  /// - "UNSPECIFIED" : Connector that doesn't ingest data will have this value
  core.String? syncMode;

  /// Timestamp the DataConnector was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudDiscoveryengineV1alphaDataConnector({
    this.aclEnabled,
    this.actionConfig,
    this.actionState,
    this.alertPolicyConfigs,
    this.autoRunDisabled,
    this.bapConfig,
    this.blockingReasons,
    this.connectorModes,
    this.connectorType,
    this.createEuaSaas,
    this.createTime,
    this.dataSource,
    this.destinationConfigs,
    this.endUserConfig,
    this.entities,
    this.errors,
    this.identityRefreshInterval,
    this.identityScheduleConfig,
    this.incrementalRefreshInterval,
    this.incrementalSyncDisabled,
    this.kmsKeyName,
    this.lastSyncTime,
    this.latestPauseTime,
    this.name,
    this.nextSyncTime,
    this.params,
    this.privateConnectivityProjectId,
    this.realtimeState,
    this.realtimeSyncConfig,
    this.refreshInterval,
    this.state,
    this.staticIpAddresses,
    this.staticIpEnabled,
    this.syncMode,
    this.updateTime,
  });

  GoogleCloudDiscoveryengineV1alphaDataConnector.fromJson(core.Map json_)
    : this(
        aclEnabled: json_['aclEnabled'] as core.bool?,
        actionConfig:
            json_.containsKey('actionConfig')
                ? GoogleCloudDiscoveryengineV1alphaActionConfig.fromJson(
                  json_['actionConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        actionState: json_['actionState'] as core.String?,
        alertPolicyConfigs:
            (json_['alertPolicyConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaAlertPolicyConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        autoRunDisabled: json_['autoRunDisabled'] as core.bool?,
        bapConfig:
            json_.containsKey('bapConfig')
                ? GoogleCloudDiscoveryengineV1alphaBAPConfig.fromJson(
                  json_['bapConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        blockingReasons:
            (json_['blockingReasons'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        connectorModes:
            (json_['connectorModes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        connectorType: json_['connectorType'] as core.String?,
        createEuaSaas: json_['createEuaSaas'] as core.bool?,
        createTime: json_['createTime'] as core.String?,
        dataSource: json_['dataSource'] as core.String?,
        destinationConfigs:
            (json_['destinationConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaDestinationConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        endUserConfig:
            json_.containsKey('endUserConfig')
                ? GoogleCloudDiscoveryengineV1alphaDataConnectorEndUserConfig.fromJson(
                  json_['endUserConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        entities:
            (json_['entities'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaDataConnectorSourceEntity.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        errors:
            (json_['errors'] as core.List?)
                ?.map(
                  (value) => GoogleRpcStatus.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        identityRefreshInterval:
            json_['identityRefreshInterval'] as core.String?,
        identityScheduleConfig:
            json_.containsKey('identityScheduleConfig')
                ? GoogleCloudDiscoveryengineV1alphaIdentityScheduleConfig.fromJson(
                  json_['identityScheduleConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        incrementalRefreshInterval:
            json_['incrementalRefreshInterval'] as core.String?,
        incrementalSyncDisabled: json_['incrementalSyncDisabled'] as core.bool?,
        kmsKeyName: json_['kmsKeyName'] as core.String?,
        lastSyncTime: json_['lastSyncTime'] as core.String?,
        latestPauseTime: json_['latestPauseTime'] as core.String?,
        name: json_['name'] as core.String?,
        nextSyncTime:
            json_.containsKey('nextSyncTime')
                ? GoogleTypeDateTime.fromJson(
                  json_['nextSyncTime'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        params:
            json_.containsKey('params')
                ? json_['params'] as core.Map<core.String, core.dynamic>
                : null,
        privateConnectivityProjectId:
            json_['privateConnectivityProjectId'] as core.String?,
        realtimeState: json_['realtimeState'] as core.String?,
        realtimeSyncConfig:
            json_.containsKey('realtimeSyncConfig')
                ? GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfig.fromJson(
                  json_['realtimeSyncConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        refreshInterval: json_['refreshInterval'] as core.String?,
        state: json_['state'] as core.String?,
        staticIpAddresses:
            (json_['staticIpAddresses'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        staticIpEnabled: json_['staticIpEnabled'] as core.bool?,
        syncMode: json_['syncMode'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aclEnabled != null) 'aclEnabled': aclEnabled!,
    if (actionConfig != null) 'actionConfig': actionConfig!,
    if (actionState != null) 'actionState': actionState!,
    if (alertPolicyConfigs != null) 'alertPolicyConfigs': alertPolicyConfigs!,
    if (autoRunDisabled != null) 'autoRunDisabled': autoRunDisabled!,
    if (bapConfig != null) 'bapConfig': bapConfig!,
    if (blockingReasons != null) 'blockingReasons': blockingReasons!,
    if (connectorModes != null) 'connectorModes': connectorModes!,
    if (connectorType != null) 'connectorType': connectorType!,
    if (createEuaSaas != null) 'createEuaSaas': createEuaSaas!,
    if (createTime != null) 'createTime': createTime!,
    if (dataSource != null) 'dataSource': dataSource!,
    if (destinationConfigs != null) 'destinationConfigs': destinationConfigs!,
    if (endUserConfig != null) 'endUserConfig': endUserConfig!,
    if (entities != null) 'entities': entities!,
    if (errors != null) 'errors': errors!,
    if (identityRefreshInterval != null)
      'identityRefreshInterval': identityRefreshInterval!,
    if (identityScheduleConfig != null)
      'identityScheduleConfig': identityScheduleConfig!,
    if (incrementalRefreshInterval != null)
      'incrementalRefreshInterval': incrementalRefreshInterval!,
    if (incrementalSyncDisabled != null)
      'incrementalSyncDisabled': incrementalSyncDisabled!,
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
    if (lastSyncTime != null) 'lastSyncTime': lastSyncTime!,
    if (latestPauseTime != null) 'latestPauseTime': latestPauseTime!,
    if (name != null) 'name': name!,
    if (nextSyncTime != null) 'nextSyncTime': nextSyncTime!,
    if (params != null) 'params': params!,
    if (privateConnectivityProjectId != null)
      'privateConnectivityProjectId': privateConnectivityProjectId!,
    if (realtimeState != null) 'realtimeState': realtimeState!,
    if (realtimeSyncConfig != null) 'realtimeSyncConfig': realtimeSyncConfig!,
    if (refreshInterval != null) 'refreshInterval': refreshInterval!,
    if (state != null) 'state': state!,
    if (staticIpAddresses != null) 'staticIpAddresses': staticIpAddresses!,
    if (staticIpEnabled != null) 'staticIpEnabled': staticIpEnabled!,
    if (syncMode != null) 'syncMode': syncMode!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Any params and credentials used specifically for EUA connectors.
class GoogleCloudDiscoveryengineV1alphaDataConnectorEndUserConfig {
  /// Any additional parameters needed for EUA.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? additionalParams;

  /// Any authentication parameters specific to EUA connectors.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? authParams;

  /// The tenant project the connector is connected to.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaTenant? tenant;

  GoogleCloudDiscoveryengineV1alphaDataConnectorEndUserConfig({
    this.additionalParams,
    this.authParams,
    this.tenant,
  });

  GoogleCloudDiscoveryengineV1alphaDataConnectorEndUserConfig.fromJson(
    core.Map json_,
  ) : this(
        additionalParams:
            json_.containsKey('additionalParams')
                ? json_['additionalParams']
                    as core.Map<core.String, core.dynamic>
                : null,
        authParams:
            json_.containsKey('authParams')
                ? json_['authParams'] as core.Map<core.String, core.dynamic>
                : null,
        tenant:
            json_.containsKey('tenant')
                ? GoogleCloudDiscoveryengineV1alphaTenant.fromJson(
                  json_['tenant'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (additionalParams != null) 'additionalParams': additionalParams!,
    if (authParams != null) 'authParams': authParams!,
    if (tenant != null) 'tenant': tenant!,
  };
}

/// The configuration for realtime sync to store additional params for realtime
/// sync.
class GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfig {
  /// The ID of the Secret Manager secret used for webhook secret.
  ///
  /// Optional.
  core.String? realtimeSyncSecret;

  /// Streaming error details.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfigStreamingError?
  streamingError;

  /// Webhook url for the connector to specify additional params for realtime
  /// sync.
  ///
  /// Optional.
  core.String? webhookUri;

  GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfig({
    this.realtimeSyncSecret,
    this.streamingError,
    this.webhookUri,
  });

  GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfig.fromJson(
    core.Map json_,
  ) : this(
        realtimeSyncSecret: json_['realtimeSyncSecret'] as core.String?,
        streamingError:
            json_.containsKey('streamingError')
                ? GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfigStreamingError.fromJson(
                  json_['streamingError']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        webhookUri: json_['webhookUri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (realtimeSyncSecret != null) 'realtimeSyncSecret': realtimeSyncSecret!,
    if (streamingError != null) 'streamingError': streamingError!,
    if (webhookUri != null) 'webhookUri': webhookUri!,
  };
}

/// Streaming error details.
class GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfigStreamingError {
  /// Error details.
  ///
  /// Optional.
  GoogleRpcStatus? error;

  /// Streaming error.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "STREAMING_ERROR_REASON_UNSPECIFIED" : Streaming error reason
  /// unspecified.
  /// - "STREAMING_SETUP_ERROR" : Some error occurred while setting up resources
  /// for realtime sync.
  /// - "STREAMING_SYNC_ERROR" : Some error was encountered while running
  /// realtime sync for the connector.
  /// - "INGRESS_ENDPOINT_REQUIRED" : Ingress endpoint is required when setting
  /// up realtime sync in private connectivity.
  core.String? streamingErrorReason;

  GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfigStreamingError({
    this.error,
    this.streamingErrorReason,
  });

  GoogleCloudDiscoveryengineV1alphaDataConnectorRealtimeSyncConfigStreamingError.fromJson(
    core.Map json_,
  ) : this(
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        streamingErrorReason: json_['streamingErrorReason'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (error != null) 'error': error!,
    if (streamingErrorReason != null)
      'streamingErrorReason': streamingErrorReason!,
  };
}

/// Represents an entity in the data source.
///
/// For example, the `Account` object in Salesforce.
class GoogleCloudDiscoveryengineV1alphaDataConnectorSourceEntity {
  /// The full resource name of the associated data store for the source entity.
  ///
  /// Format: `projects / * /locations / * /collections / * /dataStores / * `.
  /// When the connector is initialized by the
  /// DataConnectorService.SetUpDataConnector method, a DataStore is
  /// automatically created for each source entity.
  ///
  /// Output only.
  core.String? dataStore;

  /// The name of the entity.
  ///
  /// Supported values by data source: * Salesforce: `Lead`, `Opportunity`,
  /// `Contact`, `Account`, `Case`, `Contract`, `Campaign` * Jira: `Issue` *
  /// Confluence: `Content`, `Space`
  core.String? entityName;

  /// Configuration for `HEALTHCARE_FHIR` vertical.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaHealthcareFhirConfig? healthcareFhirConfig;

  /// Attributes for indexing.
  ///
  /// Key: Field name. Value: The key property to map a field to, such as
  /// `title`, and `description`. Supported key properties: * `title`: The title
  /// for data record. This would be displayed on search results. *
  /// `description`: The description for data record. This would be displayed on
  /// search results.
  core.Map<core.String, core.String>? keyPropertyMappings;

  /// The parameters for the entity to facilitate data ingestion.
  ///
  /// E.g. for BigQuery connectors: * Key: `document_id_column` * Value: type
  /// STRING. The value of the column ID.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? params;

  /// The start schema to use for the DataStore created from this SourceEntity.
  ///
  /// If unset, a default vertical specialized schema will be used. This field
  /// is only used by SetUpDataConnector API, and will be ignored if used in
  /// other APIs. This field will be omitted from all API responses including
  /// GetDataConnector API. To retrieve a schema of a DataStore, use
  /// SchemaService.GetSchema API instead. The provided schema will be validated
  /// against certain rules on schema. Learn more from
  /// [this doc](https://cloud.google.com/generative-ai-app-builder/docs/provide-schema).
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaSchema? startingSchema;

  GoogleCloudDiscoveryengineV1alphaDataConnectorSourceEntity({
    this.dataStore,
    this.entityName,
    this.healthcareFhirConfig,
    this.keyPropertyMappings,
    this.params,
    this.startingSchema,
  });

  GoogleCloudDiscoveryengineV1alphaDataConnectorSourceEntity.fromJson(
    core.Map json_,
  ) : this(
        dataStore: json_['dataStore'] as core.String?,
        entityName: json_['entityName'] as core.String?,
        healthcareFhirConfig:
            json_.containsKey('healthcareFhirConfig')
                ? GoogleCloudDiscoveryengineV1alphaHealthcareFhirConfig.fromJson(
                  json_['healthcareFhirConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        keyPropertyMappings: (json_['keyPropertyMappings']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        params:
            json_.containsKey('params')
                ? json_['params'] as core.Map<core.String, core.dynamic>
                : null,
        startingSchema:
            json_.containsKey('startingSchema')
                ? GoogleCloudDiscoveryengineV1alphaSchema.fromJson(
                  json_['startingSchema']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStore != null) 'dataStore': dataStore!,
    if (entityName != null) 'entityName': entityName!,
    if (healthcareFhirConfig != null)
      'healthcareFhirConfig': healthcareFhirConfig!,
    if (keyPropertyMappings != null)
      'keyPropertyMappings': keyPropertyMappings!,
    if (params != null) 'params': params!,
    if (startingSchema != null) 'startingSchema': startingSchema!,
  };
}

/// DataStore captures global settings and configs at the DataStore level.
class GoogleCloudDiscoveryengineV1alphaDataStore {
  /// Whether data in the DataStore has ACL information.
  ///
  /// If set to `true`, the source data must have ACL. ACL will be ingested when
  /// data is ingested by DocumentService.ImportDocuments methods. When ACL is
  /// enabled for the DataStore, Document can't be accessed by calling
  /// DocumentService.GetDocument or DocumentService.ListDocuments. Currently
  /// ACL is only supported in `GENERIC` industry vertical with
  /// non-`PUBLIC_WEBSITE` content config.
  ///
  /// Immutable.
  core.bool? aclEnabled;

  /// Configuration for advanced site search.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAdvancedSiteSearchConfig?
  advancedSiteSearchConfig;

  /// Data size estimation for billing.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaDataStoreBillingEstimation?
  billingEstimation;

  /// CMEK-related information for the DataStore.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaCmekConfig? cmekConfig;

  /// The content config of the data store.
  ///
  /// If this field is unset, the server behavior defaults to
  /// ContentConfig.NO_CONTENT.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "CONTENT_CONFIG_UNSPECIFIED" : Default value.
  /// - "NO_CONTENT" : Only contains documents without any Document.content.
  /// - "CONTENT_REQUIRED" : Only contains documents with Document.content.
  /// - "PUBLIC_WEBSITE" : The data store is used for public website search.
  /// - "GOOGLE_WORKSPACE" : The data store is used for workspace search.
  /// Details of workspace data store are specified in the WorkspaceConfig.
  core.String? contentConfig;

  /// Timestamp the DataStore was created at.
  ///
  /// Output only.
  core.String? createTime;

  /// The id of the default Schema associated to this data store.
  ///
  /// Output only.
  core.String? defaultSchemaId;

  /// The data store display name.
  ///
  /// This field must be a UTF-8 encoded string with a length limit of 128
  /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
  ///
  /// Required.
  core.String? displayName;

  /// Configuration for Document understanding and enrichment.
  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig?
  documentProcessingConfig;

  /// Configuration for `HEALTHCARE_FHIR` vertical.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaHealthcareFhirConfig? healthcareFhirConfig;

  /// The fully qualified resource name of the associated IdentityMappingStore.
  ///
  /// This field can only be set for acl_enabled DataStores with `THIRD_PARTY`
  /// or `GSUITE` IdP. Format:
  /// `projects/{project}/locations/{location}/identityMappingStores/{identity_mapping_store}`.
  ///
  /// Immutable.
  core.String? identityMappingStore;

  /// Data store level identity provider config.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaIdpConfig? idpConfig;

  /// The industry vertical that the data store registers.
  ///
  /// Immutable.
  /// Possible string values are:
  /// - "INDUSTRY_VERTICAL_UNSPECIFIED" : Value used when unset.
  /// - "GENERIC" : The generic vertical for documents that are not specific to
  /// any industry vertical.
  /// - "MEDIA" : The media industry vertical.
  /// - "HEALTHCARE_FHIR" : The healthcare FHIR vertical.
  core.String? industryVertical;

  /// If set, this DataStore is an Infobot FAQ DataStore.
  ///
  /// Optional.
  core.bool? isInfobotFaqDataStore;

  /// Input only.
  ///
  /// The KMS key to be used to protect this DataStore at creation time. Must be
  /// set for requests that need to comply with CMEK Org Policy protections. If
  /// this field is set and processed successfully, the DataStore will be
  /// protected by the KMS key, as indicated in the cmek_config field.
  core.String? kmsKeyName;

  /// Language info for DataStore.
  GoogleCloudDiscoveryengineV1alphaLanguageInfo? languageInfo;

  /// Identifier.
  ///
  /// The full resource name of the data store. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  /// Configuration for Natural Language Query Understanding.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaNaturalLanguageQueryUnderstandingConfig?
  naturalLanguageQueryUnderstandingConfig;

  /// Stores serving config at DataStore level.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaDataStoreServingConfigDataStore?
  servingConfigDataStore;

  /// The solutions that the data store enrolls.
  ///
  /// Available solutions for each industry_vertical: * `MEDIA`:
  /// `SOLUTION_TYPE_RECOMMENDATION` and `SOLUTION_TYPE_SEARCH`. *
  /// `SITE_SEARCH`: `SOLUTION_TYPE_SEARCH` is automatically enrolled. Other
  /// solutions cannot be enrolled.
  core.List<core.String>? solutionTypes;

  /// The start schema to use for this DataStore when provisioning it.
  ///
  /// If unset, a default vertical specialized schema will be used. This field
  /// is only used by CreateDataStore API, and will be ignored if used in other
  /// APIs. This field will be omitted from all API responses including
  /// CreateDataStore API. To retrieve a schema of a DataStore, use
  /// SchemaService.GetSchema API instead. The provided schema will be validated
  /// against certain rules on schema. Learn more from
  /// [this doc](https://cloud.google.com/generative-ai-app-builder/docs/provide-schema).
  GoogleCloudDiscoveryengineV1alphaSchema? startingSchema;

  /// Config to store data store type configuration for workspace data.
  ///
  /// This must be set when DataStore.content_config is set as
  /// DataStore.ContentConfig.GOOGLE_WORKSPACE.
  GoogleCloudDiscoveryengineV1alphaWorkspaceConfig? workspaceConfig;

  GoogleCloudDiscoveryengineV1alphaDataStore({
    this.aclEnabled,
    this.advancedSiteSearchConfig,
    this.billingEstimation,
    this.cmekConfig,
    this.contentConfig,
    this.createTime,
    this.defaultSchemaId,
    this.displayName,
    this.documentProcessingConfig,
    this.healthcareFhirConfig,
    this.identityMappingStore,
    this.idpConfig,
    this.industryVertical,
    this.isInfobotFaqDataStore,
    this.kmsKeyName,
    this.languageInfo,
    this.name,
    this.naturalLanguageQueryUnderstandingConfig,
    this.servingConfigDataStore,
    this.solutionTypes,
    this.startingSchema,
    this.workspaceConfig,
  });

  GoogleCloudDiscoveryengineV1alphaDataStore.fromJson(core.Map json_)
    : this(
        aclEnabled: json_['aclEnabled'] as core.bool?,
        advancedSiteSearchConfig:
            json_.containsKey('advancedSiteSearchConfig')
                ? GoogleCloudDiscoveryengineV1alphaAdvancedSiteSearchConfig.fromJson(
                  json_['advancedSiteSearchConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        billingEstimation:
            json_.containsKey('billingEstimation')
                ? GoogleCloudDiscoveryengineV1alphaDataStoreBillingEstimation.fromJson(
                  json_['billingEstimation']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        cmekConfig:
            json_.containsKey('cmekConfig')
                ? GoogleCloudDiscoveryengineV1alphaCmekConfig.fromJson(
                  json_['cmekConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        contentConfig: json_['contentConfig'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        defaultSchemaId: json_['defaultSchemaId'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        documentProcessingConfig:
            json_.containsKey('documentProcessingConfig')
                ? GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig.fromJson(
                  json_['documentProcessingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        healthcareFhirConfig:
            json_.containsKey('healthcareFhirConfig')
                ? GoogleCloudDiscoveryengineV1alphaHealthcareFhirConfig.fromJson(
                  json_['healthcareFhirConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        identityMappingStore: json_['identityMappingStore'] as core.String?,
        idpConfig:
            json_.containsKey('idpConfig')
                ? GoogleCloudDiscoveryengineV1alphaIdpConfig.fromJson(
                  json_['idpConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        industryVertical: json_['industryVertical'] as core.String?,
        isInfobotFaqDataStore: json_['isInfobotFaqDataStore'] as core.bool?,
        kmsKeyName: json_['kmsKeyName'] as core.String?,
        languageInfo:
            json_.containsKey('languageInfo')
                ? GoogleCloudDiscoveryengineV1alphaLanguageInfo.fromJson(
                  json_['languageInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        naturalLanguageQueryUnderstandingConfig:
            json_.containsKey('naturalLanguageQueryUnderstandingConfig')
                ? GoogleCloudDiscoveryengineV1alphaNaturalLanguageQueryUnderstandingConfig.fromJson(
                  json_['naturalLanguageQueryUnderstandingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        servingConfigDataStore:
            json_.containsKey('servingConfigDataStore')
                ? GoogleCloudDiscoveryengineV1alphaDataStoreServingConfigDataStore.fromJson(
                  json_['servingConfigDataStore']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        solutionTypes:
            (json_['solutionTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        startingSchema:
            json_.containsKey('startingSchema')
                ? GoogleCloudDiscoveryengineV1alphaSchema.fromJson(
                  json_['startingSchema']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        workspaceConfig:
            json_.containsKey('workspaceConfig')
                ? GoogleCloudDiscoveryengineV1alphaWorkspaceConfig.fromJson(
                  json_['workspaceConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aclEnabled != null) 'aclEnabled': aclEnabled!,
    if (advancedSiteSearchConfig != null)
      'advancedSiteSearchConfig': advancedSiteSearchConfig!,
    if (billingEstimation != null) 'billingEstimation': billingEstimation!,
    if (cmekConfig != null) 'cmekConfig': cmekConfig!,
    if (contentConfig != null) 'contentConfig': contentConfig!,
    if (createTime != null) 'createTime': createTime!,
    if (defaultSchemaId != null) 'defaultSchemaId': defaultSchemaId!,
    if (displayName != null) 'displayName': displayName!,
    if (documentProcessingConfig != null)
      'documentProcessingConfig': documentProcessingConfig!,
    if (healthcareFhirConfig != null)
      'healthcareFhirConfig': healthcareFhirConfig!,
    if (identityMappingStore != null)
      'identityMappingStore': identityMappingStore!,
    if (idpConfig != null) 'idpConfig': idpConfig!,
    if (industryVertical != null) 'industryVertical': industryVertical!,
    if (isInfobotFaqDataStore != null)
      'isInfobotFaqDataStore': isInfobotFaqDataStore!,
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
    if (languageInfo != null) 'languageInfo': languageInfo!,
    if (name != null) 'name': name!,
    if (naturalLanguageQueryUnderstandingConfig != null)
      'naturalLanguageQueryUnderstandingConfig':
          naturalLanguageQueryUnderstandingConfig!,
    if (servingConfigDataStore != null)
      'servingConfigDataStore': servingConfigDataStore!,
    if (solutionTypes != null) 'solutionTypes': solutionTypes!,
    if (startingSchema != null) 'startingSchema': startingSchema!,
    if (workspaceConfig != null) 'workspaceConfig': workspaceConfig!,
  };
}

/// Estimation of data size per data store.
typedef GoogleCloudDiscoveryengineV1alphaDataStoreBillingEstimation =
    $DataStoreBillingEstimation;

/// Stores information regarding the serving configurations at DataStore level.
typedef GoogleCloudDiscoveryengineV1alphaDataStoreServingConfigDataStore =
    $DataStoreServingConfigDataStore;

/// The historical dedicated crawl rate timeseries data, used for monitoring.
///
/// Dedicated crawl is used by Vertex AI to crawl the user's website when
/// dedicate crawl is set.
class GoogleCloudDiscoveryengineV1alphaDedicatedCrawlRateTimeSeries {
  /// Vertex AI's error rate time series of auto-refresh dedicated crawl.
  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries?
  autoRefreshCrawlErrorRate;

  /// Vertex AI's dedicated crawl rate time series of auto-refresh, which is the
  /// crawl rate of Google-CloudVertexBot when dedicate crawl is set, and the
  /// crawl rate is for best effort use cases like refreshing urls periodically.
  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries? autoRefreshCrawlRate;

  /// Vertex AI's error rate time series of user triggered dedicated crawl.
  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries?
  userTriggeredCrawlErrorRate;

  /// Vertex AI's dedicated crawl rate time series of user triggered crawl,
  /// which is the crawl rate of Google-CloudVertexBot when dedicate crawl is
  /// set, and user triggered crawl rate is for deterministic use cases like
  /// crawling urls or sitemaps specified by users.
  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries? userTriggeredCrawlRate;

  GoogleCloudDiscoveryengineV1alphaDedicatedCrawlRateTimeSeries({
    this.autoRefreshCrawlErrorRate,
    this.autoRefreshCrawlRate,
    this.userTriggeredCrawlErrorRate,
    this.userTriggeredCrawlRate,
  });

  GoogleCloudDiscoveryengineV1alphaDedicatedCrawlRateTimeSeries.fromJson(
    core.Map json_,
  ) : this(
        autoRefreshCrawlErrorRate:
            json_.containsKey('autoRefreshCrawlErrorRate')
                ? GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries.fromJson(
                  json_['autoRefreshCrawlErrorRate']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        autoRefreshCrawlRate:
            json_.containsKey('autoRefreshCrawlRate')
                ? GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries.fromJson(
                  json_['autoRefreshCrawlRate']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userTriggeredCrawlErrorRate:
            json_.containsKey('userTriggeredCrawlErrorRate')
                ? GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries.fromJson(
                  json_['userTriggeredCrawlErrorRate']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userTriggeredCrawlRate:
            json_.containsKey('userTriggeredCrawlRate')
                ? GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries.fromJson(
                  json_['userTriggeredCrawlRate']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (autoRefreshCrawlErrorRate != null)
      'autoRefreshCrawlErrorRate': autoRefreshCrawlErrorRate!,
    if (autoRefreshCrawlRate != null)
      'autoRefreshCrawlRate': autoRefreshCrawlRate!,
    if (userTriggeredCrawlErrorRate != null)
      'userTriggeredCrawlErrorRate': userTriggeredCrawlErrorRate!,
    if (userTriggeredCrawlRate != null)
      'userTriggeredCrawlRate': userTriggeredCrawlRate!,
  };
}

/// Defines target endpoints used to connect to third-party sources.
class GoogleCloudDiscoveryengineV1alphaDestinationConfig {
  /// The destinations for the corresponding key.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaDestinationConfigDestination>?
  destinations;

  /// Unique destination identifier that is supported by the connector.
  ///
  /// Optional.
  core.String? key;

  /// Additional parameters for this destination config.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? params;

  GoogleCloudDiscoveryengineV1alphaDestinationConfig({
    this.destinations,
    this.key,
    this.params,
  });

  GoogleCloudDiscoveryengineV1alphaDestinationConfig.fromJson(core.Map json_)
    : this(
        destinations:
            (json_['destinations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaDestinationConfigDestination.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        key: json_['key'] as core.String?,
        params:
            json_.containsKey('params')
                ? json_['params'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinations != null) 'destinations': destinations!,
    if (key != null) 'key': key!,
    if (params != null) 'params': params!,
  };
}

/// Defines a target endpoint
class GoogleCloudDiscoveryengineV1alphaDestinationConfigDestination {
  /// Publicly routable host.
  core.String? host;

  /// Target port number accepted by the destination.
  ///
  /// Optional.
  core.int? port;

  GoogleCloudDiscoveryengineV1alphaDestinationConfigDestination({
    this.host,
    this.port,
  });

  GoogleCloudDiscoveryengineV1alphaDestinationConfigDestination.fromJson(
    core.Map json_,
  ) : this(
        host: json_['host'] as core.String?,
        port: json_['port'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (host != null) 'host': host!,
    if (port != null) 'port': port!,
  };
}

/// Request message for SiteSearchEngineService.DisableAdvancedSiteSearch
/// method.
typedef GoogleCloudDiscoveryengineV1alphaDisableAdvancedSiteSearchRequest =
    $Empty;

/// Document captures all raw metadata information of items to be recommended or
/// searched.
class GoogleCloudDiscoveryengineV1alphaDocument {
  /// Access control information for the document.
  GoogleCloudDiscoveryengineV1alphaDocumentAclInfo? aclInfo;

  /// The unstructured data linked to this document.
  ///
  /// Content can only be set and must be set if this document is under a
  /// `CONTENT_REQUIRED` data store.
  GoogleCloudDiscoveryengineV1alphaDocumentContent? content;

  /// This field is OUTPUT_ONLY.
  ///
  /// It contains derived data that are not in the original input document.
  ///
  /// Output only.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? derivedStructData;

  /// The identifier of the document.
  ///
  /// Id should conform to \[RFC-1034\](https://tools.ietf.org/html/rfc1034)
  /// standard with a length limit of 128 characters.
  ///
  /// Immutable.
  core.String? id;

  /// The index status of the document.
  ///
  /// * If document is indexed successfully, the index_time field is populated.
  /// * Otherwise, if document is not indexed due to errors, the error_samples
  /// field is populated. * Otherwise, if document's index is in progress, the
  /// pending_message field is populated.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaDocumentIndexStatus? indexStatus;

  /// The last time the document was indexed.
  ///
  /// If this field is set, the document could be returned in search results.
  /// This field is OUTPUT_ONLY. If this field is not populated, it means the
  /// document has never been indexed.
  ///
  /// Output only.
  core.String? indexTime;

  /// The JSON string representation of the document.
  ///
  /// It should conform to the registered Schema or an `INVALID_ARGUMENT` error
  /// is thrown.
  core.String? jsonData;

  /// The full resource name of the document.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  /// The identifier of the parent document.
  ///
  /// Currently supports at most two level document hierarchy. Id should conform
  /// to \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a
  /// length limit of 63 characters.
  core.String? parentDocumentId;

  /// The identifier of the schema located in the same data store.
  core.String? schemaId;

  /// The structured JSON data for the document.
  ///
  /// It should conform to the registered Schema or an `INVALID_ARGUMENT` error
  /// is thrown.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structData;

  GoogleCloudDiscoveryengineV1alphaDocument({
    this.aclInfo,
    this.content,
    this.derivedStructData,
    this.id,
    this.indexStatus,
    this.indexTime,
    this.jsonData,
    this.name,
    this.parentDocumentId,
    this.schemaId,
    this.structData,
  });

  GoogleCloudDiscoveryengineV1alphaDocument.fromJson(core.Map json_)
    : this(
        aclInfo:
            json_.containsKey('aclInfo')
                ? GoogleCloudDiscoveryengineV1alphaDocumentAclInfo.fromJson(
                  json_['aclInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        content:
            json_.containsKey('content')
                ? GoogleCloudDiscoveryengineV1alphaDocumentContent.fromJson(
                  json_['content'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        derivedStructData:
            json_.containsKey('derivedStructData')
                ? json_['derivedStructData']
                    as core.Map<core.String, core.dynamic>
                : null,
        id: json_['id'] as core.String?,
        indexStatus:
            json_.containsKey('indexStatus')
                ? GoogleCloudDiscoveryengineV1alphaDocumentIndexStatus.fromJson(
                  json_['indexStatus'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        indexTime: json_['indexTime'] as core.String?,
        jsonData: json_['jsonData'] as core.String?,
        name: json_['name'] as core.String?,
        parentDocumentId: json_['parentDocumentId'] as core.String?,
        schemaId: json_['schemaId'] as core.String?,
        structData:
            json_.containsKey('structData')
                ? json_['structData'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (aclInfo != null) 'aclInfo': aclInfo!,
    if (content != null) 'content': content!,
    if (derivedStructData != null) 'derivedStructData': derivedStructData!,
    if (id != null) 'id': id!,
    if (indexStatus != null) 'indexStatus': indexStatus!,
    if (indexTime != null) 'indexTime': indexTime!,
    if (jsonData != null) 'jsonData': jsonData!,
    if (name != null) 'name': name!,
    if (parentDocumentId != null) 'parentDocumentId': parentDocumentId!,
    if (schemaId != null) 'schemaId': schemaId!,
    if (structData != null) 'structData': structData!,
  };
}

/// ACL Information of the Document.
class GoogleCloudDiscoveryengineV1alphaDocumentAclInfo {
  /// Readers of the document.
  core.List<GoogleCloudDiscoveryengineV1alphaDocumentAclInfoAccessRestriction>?
  readers;

  GoogleCloudDiscoveryengineV1alphaDocumentAclInfo({this.readers});

  GoogleCloudDiscoveryengineV1alphaDocumentAclInfo.fromJson(core.Map json_)
    : this(
        readers:
            (json_['readers'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaDocumentAclInfoAccessRestriction.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (readers != null) 'readers': readers!,
  };
}

/// AclRestriction to model complex inheritance restrictions.
///
/// Example: Modeling a "Both Permit" inheritance, where to access a child
/// document, user needs to have access to parent document. Document Hierarchy -
/// Space_S --\> Page_P. Readers: Space_S: group_1, user_1 Page_P: group_2,
/// group_3, user_2 Space_S ACL Restriction - { "acl_info": { "readers": \[ {
/// "principals": \[ { "group_id": "group_1" }, { "user_id": "user_1" } \] } \]
/// } } Page_P ACL Restriction. { "acl_info": { "readers": \[ { "principals": \[
/// { "group_id": "group_2" }, { "group_id": "group_3" }, { "user_id": "user_2"
/// } \], }, { "principals": \[ { "group_id": "group_1" }, { "user_id": "user_1"
/// } \], } \] } }
class GoogleCloudDiscoveryengineV1alphaDocumentAclInfoAccessRestriction {
  /// All users within the Identity Provider.
  core.bool? idpWide;

  /// List of principals.
  core.List<GoogleCloudDiscoveryengineV1alphaPrincipal>? principals;

  GoogleCloudDiscoveryengineV1alphaDocumentAclInfoAccessRestriction({
    this.idpWide,
    this.principals,
  });

  GoogleCloudDiscoveryengineV1alphaDocumentAclInfoAccessRestriction.fromJson(
    core.Map json_,
  ) : this(
        idpWide: json_['idpWide'] as core.bool?,
        principals:
            (json_['principals'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaPrincipal.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (idpWide != null) 'idpWide': idpWide!,
    if (principals != null) 'principals': principals!,
  };
}

/// Unstructured data linked to this document.
typedef GoogleCloudDiscoveryengineV1alphaDocumentContent = $DocumentContent;

/// Index status of the document.
class GoogleCloudDiscoveryengineV1alphaDocumentIndexStatus {
  /// A sample of errors encountered while indexing the document.
  ///
  /// If this field is populated, the document is not indexed due to errors.
  core.List<GoogleRpcStatus>? errorSamples;

  /// The time when the document was indexed.
  ///
  /// If this field is populated, it means the document has been indexed.
  core.String? indexTime;

  /// The message indicates the document index is in progress.
  ///
  /// If this field is populated, the document index is pending.
  ///
  /// Immutable.
  core.String? pendingMessage;

  GoogleCloudDiscoveryengineV1alphaDocumentIndexStatus({
    this.errorSamples,
    this.indexTime,
    this.pendingMessage,
  });

  GoogleCloudDiscoveryengineV1alphaDocumentIndexStatus.fromJson(core.Map json_)
    : this(
        errorSamples:
            (json_['errorSamples'] as core.List?)
                ?.map(
                  (value) => GoogleRpcStatus.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        indexTime: json_['indexTime'] as core.String?,
        pendingMessage: json_['pendingMessage'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorSamples != null) 'errorSamples': errorSamples!,
    if (indexTime != null) 'indexTime': indexTime!,
    if (pendingMessage != null) 'pendingMessage': pendingMessage!,
  };
}

/// Detailed document information associated with a user event.
typedef GoogleCloudDiscoveryengineV1alphaDocumentInfo = $DocumentInfo;

/// A singleton resource of DataStore.
///
/// If it's empty when DataStore is created and DataStore is set to
/// DataStore.ContentConfig.CONTENT_REQUIRED, the default parser will default to
/// digital parser.
class GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig {
  /// Whether chunking mode is enabled.
  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfig?
  chunkingConfig;

  /// Configurations for default Document parser.
  ///
  /// If not specified, we will configure it as default DigitalParsingConfig,
  /// and the default parsing config will be applied to all file types for
  /// Document parsing.
  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig?
  defaultParsingConfig;

  /// The full resource name of the Document Processing Config.
  ///
  /// Format: `projects / * /locations / * /collections / * /dataStores / *
  /// /documentProcessingConfig`.
  core.String? name;

  /// Map from file type to override the default parsing configuration based on
  /// the file type.
  ///
  /// Supported keys: * `pdf`: Override parsing config for PDF files, either
  /// digital parsing, ocr parsing or layout parsing is supported. * `html`:
  /// Override parsing config for HTML files, only digital parsing and layout
  /// parsing are supported. * `docx`: Override parsing config for DOCX files,
  /// only digital parsing and layout parsing are supported. * `pptx`: Override
  /// parsing config for PPTX files, only digital parsing and layout parsing are
  /// supported. * `xlsm`: Override parsing config for XLSM files, only digital
  /// parsing and layout parsing are supported. * `xlsx`: Override parsing
  /// config for XLSX files, only digital parsing and layout parsing are
  /// supported.
  core.Map<
    core.String,
    GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig
  >?
  parsingConfigOverrides;

  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig({
    this.chunkingConfig,
    this.defaultParsingConfig,
    this.name,
    this.parsingConfigOverrides,
  });

  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfig.fromJson(
    core.Map json_,
  ) : this(
        chunkingConfig:
            json_.containsKey('chunkingConfig')
                ? GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfig.fromJson(
                  json_['chunkingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        defaultParsingConfig:
            json_.containsKey('defaultParsingConfig')
                ? GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig.fromJson(
                  json_['defaultParsingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        parsingConfigOverrides: (json_['parsingConfigOverrides']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkingConfig != null) 'chunkingConfig': chunkingConfig!,
    if (defaultParsingConfig != null)
      'defaultParsingConfig': defaultParsingConfig!,
    if (name != null) 'name': name!,
    if (parsingConfigOverrides != null)
      'parsingConfigOverrides': parsingConfigOverrides!,
  };
}

/// Configuration for chunking config.
class GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfig {
  /// Configuration for the layout based chunking.
  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig?
  layoutBasedChunkingConfig;

  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfig({
    this.layoutBasedChunkingConfig,
  });

  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfig.fromJson(
    core.Map json_,
  ) : this(
        layoutBasedChunkingConfig:
            json_.containsKey('layoutBasedChunkingConfig')
                ? GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig.fromJson(
                  json_['layoutBasedChunkingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (layoutBasedChunkingConfig != null)
      'layoutBasedChunkingConfig': layoutBasedChunkingConfig!,
  };
}

/// Configuration for the layout based chunking.
typedef GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig =
    $DocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig;

/// Related configurations applied to a specific type of document parser.
class GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig {
  /// Configurations applied to digital parser.
  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigDigitalParsingConfig?
  digitalParsingConfig;

  /// Configurations applied to layout parser.
  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigLayoutParsingConfig?
  layoutParsingConfig;

  /// Configurations applied to OCR parser.
  ///
  /// Currently it only applies to PDFs.
  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigOcrParsingConfig?
  ocrParsingConfig;

  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig({
    this.digitalParsingConfig,
    this.layoutParsingConfig,
    this.ocrParsingConfig,
  });

  GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfig.fromJson(
    core.Map json_,
  ) : this(
        digitalParsingConfig:
            json_.containsKey('digitalParsingConfig')
                ? GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigDigitalParsingConfig.fromJson(
                  json_['digitalParsingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        layoutParsingConfig:
            json_.containsKey('layoutParsingConfig')
                ? GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigLayoutParsingConfig.fromJson(
                  json_['layoutParsingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ocrParsingConfig:
            json_.containsKey('ocrParsingConfig')
                ? GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigOcrParsingConfig.fromJson(
                  json_['ocrParsingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (digitalParsingConfig != null)
      'digitalParsingConfig': digitalParsingConfig!,
    if (layoutParsingConfig != null)
      'layoutParsingConfig': layoutParsingConfig!,
    if (ocrParsingConfig != null) 'ocrParsingConfig': ocrParsingConfig!,
  };
}

/// The digital parsing configurations for documents.
typedef GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigDigitalParsingConfig =
    $Empty;

/// The layout parsing configurations for documents.
typedef GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigLayoutParsingConfig =
    $DocumentProcessingConfigParsingConfigLayoutParsingConfig;

/// The OCR parsing configurations for documents.
typedef GoogleCloudDiscoveryengineV1alphaDocumentProcessingConfigParsingConfigOcrParsingConfig =
    $DocumentProcessingConfigParsingConfigOcrParsingConfig;

/// Double list.
typedef GoogleCloudDiscoveryengineV1alphaDoubleList = $DoubleList00;

/// Defines embedding config, used for bring your own embeddings feature.
typedef GoogleCloudDiscoveryengineV1alphaEmbeddingConfig = $EmbeddingConfig;

/// Request message for SiteSearchEngineService.EnableAdvancedSiteSearch method.
typedef GoogleCloudDiscoveryengineV1alphaEnableAdvancedSiteSearchRequest =
    $Empty;

/// Metadata that describes the training and serving parameters of an Engine.
class GoogleCloudDiscoveryengineV1alphaEngine {
  /// Configurations for the Chat Engine.
  ///
  /// Only applicable if solution_type is SOLUTION_TYPE_CHAT.
  GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfig? chatEngineConfig;

  /// Additional information of the Chat Engine.
  ///
  /// Only applicable if solution_type is SOLUTION_TYPE_CHAT.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaEngineChatEngineMetadata? chatEngineMetadata;

  /// Common config spec that specifies the metadata of the engine.
  GoogleCloudDiscoveryengineV1alphaEngineCommonConfig? commonConfig;

  /// Timestamp the Recommendation Engine was created at.
  ///
  /// Output only.
  core.String? createTime;

  /// The data stores associated with this engine.
  ///
  /// For SOLUTION_TYPE_SEARCH and SOLUTION_TYPE_RECOMMENDATION type of engines,
  /// they can only associate with at most one data store. If solution_type is
  /// SOLUTION_TYPE_CHAT, multiple DataStores in the same Collection can be
  /// associated here. Note that when used in CreateEngineRequest, one DataStore
  /// id must be provided as the system will use it for necessary
  /// initializations.
  ///
  /// Optional.
  core.List<core.String>? dataStoreIds;

  /// Whether to disable analytics for searches performed on this engine.
  ///
  /// Optional.
  core.bool? disableAnalytics;

  /// The display name of the engine.
  ///
  /// Should be human readable. UTF-8 encoded string with limit of 1024
  /// characters.
  ///
  /// Required.
  core.String? displayName;

  /// Feature config for the engine to opt in or opt out of features.
  ///
  /// Supported keys: * `*`: all features, if it's present, all other feature
  /// state settings are ignored. * `agent-gallery` * `no-code-agent-builder` *
  /// `prompt-gallery` * `model-selector` * `notebook-lm` * `people-search` *
  /// `people-search-org-chart` * `bi-directional-audio` * `feedback` *
  /// `session-sharing` * `personalization-memory` - Enables personalization
  /// based on user preferences.
  ///
  /// Optional.
  core.Map<core.String, core.String>? features;

  /// The industry vertical that the engine registers.
  ///
  /// The restriction of the Engine industry vertical is based on DataStore:
  /// Vertical on Engine has to match vertical of the DataStore linked to the
  /// engine.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "INDUSTRY_VERTICAL_UNSPECIFIED" : Value used when unset.
  /// - "GENERIC" : The generic vertical for documents that are not specific to
  /// any industry vertical.
  /// - "MEDIA" : The media industry vertical.
  /// - "HEALTHCARE_FHIR" : The healthcare FHIR vertical.
  core.String? industryVertical;

  /// Configurations for the Media Engine.
  ///
  /// Only applicable on the data stores with solution_type
  /// SOLUTION_TYPE_RECOMMENDATION and IndustryVertical.MEDIA vertical.
  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfig?
  mediaRecommendationEngineConfig;

  /// Identifier.
  ///
  /// The fully qualified resource name of the engine. This field must be a
  /// UTF-8 encoded string with a length limit of 1024 characters. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  /// engine should be 1-63 characters, and valid characters are /a-z0-9 * / .
  /// Otherwise, an INVALID_ARGUMENT error is returned.
  ///
  /// Immutable.
  core.String? name;

  /// Additional information of a recommendation engine.
  ///
  /// Only applicable if solution_type is SOLUTION_TYPE_RECOMMENDATION.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaEngineRecommendationMetadata?
  recommendationMetadata;

  /// Configurations for the Search Engine.
  ///
  /// Only applicable if solution_type is SOLUTION_TYPE_SEARCH.
  GoogleCloudDiscoveryengineV1alphaEngineSearchEngineConfig? searchEngineConfig;

  /// Additional config specs for a `similar-items` engine.
  GoogleCloudDiscoveryengineV1alphaEngineSimilarDocumentsEngineConfig?
  similarDocumentsConfig;

  /// The solutions of the engine.
  ///
  /// Required.
  /// Possible string values are:
  /// - "SOLUTION_TYPE_UNSPECIFIED" : Default value.
  /// - "SOLUTION_TYPE_RECOMMENDATION" : Used for Recommendations AI.
  /// - "SOLUTION_TYPE_SEARCH" : Used for Discovery Search.
  /// - "SOLUTION_TYPE_CHAT" : Used for use cases related to the Generative AI
  /// agent.
  /// - "SOLUTION_TYPE_GENERATIVE_CHAT" : Used for use cases related to the
  /// Generative Chat agent. It's used for Generative chat engine only, the
  /// associated data stores must enrolled with `SOLUTION_TYPE_CHAT` solution.
  core.String? solutionType;

  /// Timestamp the Recommendation Engine was last updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudDiscoveryengineV1alphaEngine({
    this.chatEngineConfig,
    this.chatEngineMetadata,
    this.commonConfig,
    this.createTime,
    this.dataStoreIds,
    this.disableAnalytics,
    this.displayName,
    this.features,
    this.industryVertical,
    this.mediaRecommendationEngineConfig,
    this.name,
    this.recommendationMetadata,
    this.searchEngineConfig,
    this.similarDocumentsConfig,
    this.solutionType,
    this.updateTime,
  });

  GoogleCloudDiscoveryengineV1alphaEngine.fromJson(core.Map json_)
    : this(
        chatEngineConfig:
            json_.containsKey('chatEngineConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfig.fromJson(
                  json_['chatEngineConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        chatEngineMetadata:
            json_.containsKey('chatEngineMetadata')
                ? GoogleCloudDiscoveryengineV1alphaEngineChatEngineMetadata.fromJson(
                  json_['chatEngineMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        commonConfig:
            json_.containsKey('commonConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineCommonConfig.fromJson(
                  json_['commonConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        dataStoreIds:
            (json_['dataStoreIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        disableAnalytics: json_['disableAnalytics'] as core.bool?,
        displayName: json_['displayName'] as core.String?,
        features: (json_['features'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        industryVertical: json_['industryVertical'] as core.String?,
        mediaRecommendationEngineConfig:
            json_.containsKey('mediaRecommendationEngineConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfig.fromJson(
                  json_['mediaRecommendationEngineConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        recommendationMetadata:
            json_.containsKey('recommendationMetadata')
                ? GoogleCloudDiscoveryengineV1alphaEngineRecommendationMetadata.fromJson(
                  json_['recommendationMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchEngineConfig:
            json_.containsKey('searchEngineConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineSearchEngineConfig.fromJson(
                  json_['searchEngineConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        similarDocumentsConfig:
            json_.containsKey('similarDocumentsConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineSimilarDocumentsEngineConfig.fromJson(
                  json_['similarDocumentsConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        solutionType: json_['solutionType'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chatEngineConfig != null) 'chatEngineConfig': chatEngineConfig!,
    if (chatEngineMetadata != null) 'chatEngineMetadata': chatEngineMetadata!,
    if (commonConfig != null) 'commonConfig': commonConfig!,
    if (createTime != null) 'createTime': createTime!,
    if (dataStoreIds != null) 'dataStoreIds': dataStoreIds!,
    if (disableAnalytics != null) 'disableAnalytics': disableAnalytics!,
    if (displayName != null) 'displayName': displayName!,
    if (features != null) 'features': features!,
    if (industryVertical != null) 'industryVertical': industryVertical!,
    if (mediaRecommendationEngineConfig != null)
      'mediaRecommendationEngineConfig': mediaRecommendationEngineConfig!,
    if (name != null) 'name': name!,
    if (recommendationMetadata != null)
      'recommendationMetadata': recommendationMetadata!,
    if (searchEngineConfig != null) 'searchEngineConfig': searchEngineConfig!,
    if (similarDocumentsConfig != null)
      'similarDocumentsConfig': similarDocumentsConfig!,
    if (solutionType != null) 'solutionType': solutionType!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Configurations for a Chat Engine.
class GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfig {
  /// The configurationt generate the Dialogflow agent that is associated to
  /// this Engine.
  ///
  /// Note that these configurations are one-time consumed by and passed to
  /// Dialogflow service. It means they cannot be retrieved using
  /// EngineService.GetEngine or EngineService.ListEngines API after engine
  /// creation.
  GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfigAgentCreationConfig?
  agentCreationConfig;

  /// If the flag set to true, we allow the agent and engine are in different
  /// locations, otherwise the agent and engine are required to be in the same
  /// location.
  ///
  /// The flag is set to false by default. Note that the `allow_cross_region`
  /// are one-time consumed by and passed to EngineService.CreateEngine. It
  /// means they cannot be retrieved using EngineService.GetEngine or
  /// EngineService.ListEngines API after engine creation.
  ///
  /// Optional.
  core.bool? allowCrossRegion;

  /// The resource name of an exist Dialogflow agent to link to this Chat
  /// Engine.
  ///
  /// Customers can either provide `agent_creation_config` to create agent or
  /// provide an agent name that links the agent with the Chat engine. Format:
  /// `projects//locations//agents/`. Note that the `dialogflow_agent_to_link`
  /// are one-time consumed by and passed to Dialogflow service. It means they
  /// cannot be retrieved using EngineService.GetEngine or
  /// EngineService.ListEngines API after engine creation. Use
  /// ChatEngineMetadata.dialogflow_agent for actual agent association after
  /// Engine is created.
  core.String? dialogflowAgentToLink;

  GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfig({
    this.agentCreationConfig,
    this.allowCrossRegion,
    this.dialogflowAgentToLink,
  });

  GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfig.fromJson(
    core.Map json_,
  ) : this(
        agentCreationConfig:
            json_.containsKey('agentCreationConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfigAgentCreationConfig.fromJson(
                  json_['agentCreationConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        allowCrossRegion: json_['allowCrossRegion'] as core.bool?,
        dialogflowAgentToLink: json_['dialogflowAgentToLink'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agentCreationConfig != null)
      'agentCreationConfig': agentCreationConfig!,
    if (allowCrossRegion != null) 'allowCrossRegion': allowCrossRegion!,
    if (dialogflowAgentToLink != null)
      'dialogflowAgentToLink': dialogflowAgentToLink!,
  };
}

/// Configurations for generating a Dialogflow agent.
///
/// Note that these configurations are one-time consumed by and passed to
/// Dialogflow service. It means they cannot be retrieved using
/// EngineService.GetEngine or EngineService.ListEngines API after engine
/// creation.
typedef GoogleCloudDiscoveryengineV1alphaEngineChatEngineConfigAgentCreationConfig =
    $EngineChatEngineConfigAgentCreationConfig;

/// Additional information of a Chat Engine.
///
/// Fields in this message are output only.
typedef GoogleCloudDiscoveryengineV1alphaEngineChatEngineMetadata =
    $EngineChatEngineMetadata;

/// Common configurations for an Engine.
typedef GoogleCloudDiscoveryengineV1alphaEngineCommonConfig =
    $EngineCommonConfig;

/// Additional config specs for a Media Recommendation engine.
class GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfig {
  /// Additional engine features config.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigEngineFeaturesConfig?
  engineFeaturesConfig;

  /// The optimization objective.
  ///
  /// e.g., `cvr`. This field together with optimization_objective describe
  /// engine metadata to use to control engine training and serving. Currently
  /// supported values: `ctr`, `cvr`. If not specified, we choose default based
  /// on engine type. Default depends on type of recommendation:
  /// `recommended-for-you` =\> `ctr` `others-you-may-like` =\> `ctr`
  core.String? optimizationObjective;

  /// Name and value of the custom threshold for cvr optimization_objective.
  ///
  /// For target_field `watch-time`, target_field_value must be an integer value
  /// indicating the media progress time in seconds between (0, 86400\]
  /// (excludes 0, includes 86400) (e.g., 90). For target_field
  /// `watch-percentage`, the target_field_value must be a valid float value
  /// between (0, 1.0\] (excludes 0, includes 1.0) (e.g., 0.5).
  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig?
  optimizationObjectiveConfig;

  /// The training state that the engine is in (e.g. `TRAINING` or `PAUSED`).
  ///
  /// Since part of the cost of running the service is frequency of training -
  /// this can be used to determine when to train engine in order to control
  /// cost. If not specified: the default value for `CreateEngine` method is
  /// `TRAINING`. The default value for `UpdateEngine` method is to keep the
  /// state the same as before.
  /// Possible string values are:
  /// - "TRAINING_STATE_UNSPECIFIED" : Unspecified training state.
  /// - "PAUSED" : The engine training is paused.
  /// - "TRAINING" : The engine is training.
  core.String? trainingState;

  /// The type of engine.
  ///
  /// e.g., `recommended-for-you`. This field together with
  /// optimization_objective describe engine metadata to use to control engine
  /// training and serving. Currently supported values: `recommended-for-you`,
  /// `others-you-may-like`, `more-like-this`, `most-popular-items`.
  ///
  /// Required.
  core.String? type;

  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfig({
    this.engineFeaturesConfig,
    this.optimizationObjective,
    this.optimizationObjectiveConfig,
    this.trainingState,
    this.type,
  });

  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfig.fromJson(
    core.Map json_,
  ) : this(
        engineFeaturesConfig:
            json_.containsKey('engineFeaturesConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigEngineFeaturesConfig.fromJson(
                  json_['engineFeaturesConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        optimizationObjective: json_['optimizationObjective'] as core.String?,
        optimizationObjectiveConfig:
            json_.containsKey('optimizationObjectiveConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig.fromJson(
                  json_['optimizationObjectiveConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        trainingState: json_['trainingState'] as core.String?,
        type: json_['type'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (engineFeaturesConfig != null)
      'engineFeaturesConfig': engineFeaturesConfig!,
    if (optimizationObjective != null)
      'optimizationObjective': optimizationObjective!,
    if (optimizationObjectiveConfig != null)
      'optimizationObjectiveConfig': optimizationObjectiveConfig!,
    if (trainingState != null) 'trainingState': trainingState!,
    if (type != null) 'type': type!,
  };
}

/// More feature configs of the selected engine type.
class GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigEngineFeaturesConfig {
  /// Most popular engine feature config.
  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigMostPopularFeatureConfig?
  mostPopularConfig;

  /// Recommended for you engine feature config.
  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig?
  recommendedForYouConfig;

  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigEngineFeaturesConfig({
    this.mostPopularConfig,
    this.recommendedForYouConfig,
  });

  GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigEngineFeaturesConfig.fromJson(
    core.Map json_,
  ) : this(
        mostPopularConfig:
            json_.containsKey('mostPopularConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigMostPopularFeatureConfig.fromJson(
                  json_['mostPopularConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        recommendedForYouConfig:
            json_.containsKey('recommendedForYouConfig')
                ? GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig.fromJson(
                  json_['recommendedForYouConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mostPopularConfig != null) 'mostPopularConfig': mostPopularConfig!,
    if (recommendedForYouConfig != null)
      'recommendedForYouConfig': recommendedForYouConfig!,
  };
}

/// Feature configurations that are required for creating a Most Popular engine.
typedef GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigMostPopularFeatureConfig =
    $EngineMediaRecommendationEngineConfigMostPopularFeatureConfig;

/// Custom threshold for `cvr` optimization_objective.
typedef GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig =
    $EngineMediaRecommendationEngineConfigOptimizationObjectiveConfig;

/// Additional feature configurations for creating a `recommended-for-you`
/// engine.
typedef GoogleCloudDiscoveryengineV1alphaEngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig =
    $EngineMediaRecommendationEngineConfigRecommendedForYouFeatureConfig;

/// Additional information of a recommendation engine.
class GoogleCloudDiscoveryengineV1alphaEngineRecommendationMetadata {
  /// The state of data requirements for this engine: `DATA_OK` and
  /// `DATA_ERROR`.
  ///
  /// Engine cannot be trained if the data is in `DATA_ERROR` state. Engine can
  /// have `DATA_ERROR` state even if serving state is `ACTIVE`: engines were
  /// trained successfully before, but cannot be refreshed because the
  /// underlying engine no longer has sufficient data for training.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DATA_STATE_UNSPECIFIED" : Unspecified default value, should never be
  /// explicitly set.
  /// - "DATA_OK" : The engine has sufficient training data.
  /// - "DATA_ERROR" : The engine does not have sufficient training data. Error
  /// messages can be queried via Stackdriver.
  core.String? dataState;

  /// The timestamp when the latest successful training finished.
  ///
  /// Only applicable on Media Recommendation engines.
  ///
  /// Output only.
  core.String? lastTrainTime;

  /// The timestamp when the latest successful tune finished.
  ///
  /// Only applicable on Media Recommendation engines.
  ///
  /// Output only.
  core.String? lastTuneTime;

  /// The serving state of the engine: `ACTIVE`, `NOT_ACTIVE`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "SERVING_STATE_UNSPECIFIED" : Unspecified serving state.
  /// - "INACTIVE" : The engine is not serving.
  /// - "ACTIVE" : The engine is serving and can be queried.
  /// - "TUNED" : The engine is trained on tuned hyperparameters and can be
  /// queried.
  core.String? servingState;

  /// The latest tune operation id associated with the engine.
  ///
  /// Only applicable on Media Recommendation engines. If present, this
  /// operation id can be used to determine if there is an ongoing tune for this
  /// engine. To check the operation status, send the GetOperation request with
  /// this operation id in the engine resource format. If no tuning has happened
  /// for this engine, the string is empty.
  ///
  /// Output only.
  core.String? tuningOperation;

  GoogleCloudDiscoveryengineV1alphaEngineRecommendationMetadata({
    this.dataState,
    this.lastTrainTime,
    this.lastTuneTime,
    this.servingState,
    this.tuningOperation,
  });

  GoogleCloudDiscoveryengineV1alphaEngineRecommendationMetadata.fromJson(
    core.Map json_,
  ) : this(
        dataState: json_['dataState'] as core.String?,
        lastTrainTime: json_['lastTrainTime'] as core.String?,
        lastTuneTime: json_['lastTuneTime'] as core.String?,
        servingState: json_['servingState'] as core.String?,
        tuningOperation: json_['tuningOperation'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataState != null) 'dataState': dataState!,
    if (lastTrainTime != null) 'lastTrainTime': lastTrainTime!,
    if (lastTuneTime != null) 'lastTuneTime': lastTuneTime!,
    if (servingState != null) 'servingState': servingState!,
    if (tuningOperation != null) 'tuningOperation': tuningOperation!,
  };
}

/// Configurations for a Search Engine.
typedef GoogleCloudDiscoveryengineV1alphaEngineSearchEngineConfig =
    $EngineSearchEngineConfig;

/// Additional config specs for a `similar-items` engine.
typedef GoogleCloudDiscoveryengineV1alphaEngineSimilarDocumentsEngineConfig =
    $Empty;

/// Request message for EstimateBillingService.EstimateDataSize method
class GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequest {
  /// Structured or unstructured data.
  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestFileDataSource?
  fileDataSource;

  /// Website data.
  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSource?
  websiteDataSource;

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequest({
    this.fileDataSource,
    this.websiteDataSource,
  });

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequest.fromJson(
    core.Map json_,
  ) : this(
        fileDataSource:
            json_.containsKey('fileDataSource')
                ? GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestFileDataSource.fromJson(
                  json_['fileDataSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        websiteDataSource:
            json_.containsKey('websiteDataSource')
                ? GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSource.fromJson(
                  json_['websiteDataSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fileDataSource != null) 'fileDataSource': fileDataSource!,
    if (websiteDataSource != null) 'websiteDataSource': websiteDataSource!,
  };
}

/// Data source contains files either in Cloud Storage or BigQuery.
class GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestFileDataSource {
  /// BigQuery input source.
  GoogleCloudDiscoveryengineV1alphaBigQuerySource? bigquerySource;

  /// Cloud Storage location for the input content.
  GoogleCloudDiscoveryengineV1alphaGcsSource? gcsSource;

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestFileDataSource({
    this.bigquerySource,
    this.gcsSource,
  });

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestFileDataSource.fromJson(
    core.Map json_,
  ) : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudDiscoveryengineV1alphaBigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudDiscoveryengineV1alphaGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
  };
}

/// Data source is a set of website patterns that we crawl to get the total
/// number of websites.
class GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSource {
  /// The URI patterns to estimate the data sizes.
  ///
  /// At most 10 patterns are allowed, otherwise an INVALID_ARGUMENT error is
  /// thrown.
  ///
  /// Required.
  core.List<
    GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSourceEstimatorUriPattern
  >?
  estimatorUriPatterns;

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSource({
    this.estimatorUriPatterns,
  });

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSource.fromJson(
    core.Map json_,
  ) : this(
        estimatorUriPatterns:
            (json_['estimatorUriPatterns'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSourceEstimatorUriPattern.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (estimatorUriPatterns != null)
      'estimatorUriPatterns': estimatorUriPatterns!,
  };
}

/// URI patterns that we use to crawl.
class GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSourceEstimatorUriPattern {
  /// Whether we infer the generated URI or use the exact provided one.
  core.bool? exactMatch;

  /// Whether the pattern is exclusive or not.
  ///
  /// If set to true, the pattern is considered exclusive. If unset or set to
  /// false, the pattern is considered inclusive by default.
  core.bool? exclusive;

  /// User provided URI pattern.
  ///
  /// For example, `foo.com/bar / * `.
  core.String? providedUriPattern;

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSourceEstimatorUriPattern({
    this.exactMatch,
    this.exclusive,
    this.providedUriPattern,
  });

  GoogleCloudDiscoveryengineV1alphaEstimateDataSizeRequestWebsiteDataSourceEstimatorUriPattern.fromJson(
    core.Map json_,
  ) : this(
        exactMatch: json_['exactMatch'] as core.bool?,
        exclusive: json_['exclusive'] as core.bool?,
        providedUriPattern: json_['providedUriPattern'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exactMatch != null) 'exactMatch': exactMatch!,
    if (exclusive != null) 'exclusive': exclusive!,
    if (providedUriPattern != null) 'providedUriPattern': providedUriPattern!,
  };
}

/// An evaluation is a single execution (or run) of an evaluation process.
///
/// It encapsulates the state of the evaluation and the resulting data.
class GoogleCloudDiscoveryengineV1alphaEvaluation {
  /// Timestamp the Evaluation was created at.
  ///
  /// Output only.
  core.String? createTime;

  /// Timestamp the Evaluation was completed at.
  ///
  /// Output only.
  core.String? endTime;

  /// The error that occurred during evaluation.
  ///
  /// Only populated when the evaluation's state is FAILED.
  ///
  /// Output only.
  GoogleRpcStatus? error;

  /// A sample of errors encountered while processing the request.
  ///
  /// Output only.
  core.List<GoogleRpcStatus>? errorSamples;

  /// The specification of the evaluation.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpec? evaluationSpec;

  /// Identifier.
  ///
  /// The full resource name of the Evaluation, in the format of
  /// `projects/{project}/locations/{location}/evaluations/{evaluation}`. This
  /// field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  core.String? name;

  /// The metrics produced by the evaluation, averaged across all SampleQuerys
  /// in the SampleQuerySet.
  ///
  /// Only populated when the evaluation's state is SUCCEEDED.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaQualityMetrics? qualityMetrics;

  /// The state of the evaluation.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The evaluation is unspecified.
  /// - "PENDING" : The service is preparing to run the evaluation.
  /// - "RUNNING" : The evaluation is in progress.
  /// - "SUCCEEDED" : The evaluation completed successfully.
  /// - "FAILED" : The evaluation failed.
  core.String? state;

  GoogleCloudDiscoveryengineV1alphaEvaluation({
    this.createTime,
    this.endTime,
    this.error,
    this.errorSamples,
    this.evaluationSpec,
    this.name,
    this.qualityMetrics,
    this.state,
  });

  GoogleCloudDiscoveryengineV1alphaEvaluation.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        errorSamples:
            (json_['errorSamples'] as core.List?)
                ?.map(
                  (value) => GoogleRpcStatus.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        evaluationSpec:
            json_.containsKey('evaluationSpec')
                ? GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpec.fromJson(
                  json_['evaluationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        qualityMetrics:
            json_.containsKey('qualityMetrics')
                ? GoogleCloudDiscoveryengineV1alphaQualityMetrics.fromJson(
                  json_['qualityMetrics']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (endTime != null) 'endTime': endTime!,
    if (error != null) 'error': error!,
    if (errorSamples != null) 'errorSamples': errorSamples!,
    if (evaluationSpec != null) 'evaluationSpec': evaluationSpec!,
    if (name != null) 'name': name!,
    if (qualityMetrics != null) 'qualityMetrics': qualityMetrics!,
    if (state != null) 'state': state!,
  };
}

/// Describes the specification of the evaluation.
class GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpec {
  /// The specification of the query set.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpecQuerySetSpec?
  querySetSpec;

  /// The search request that is used to perform the evaluation.
  ///
  /// Only the following fields within SearchRequest are supported; if any other
  /// fields are provided, an UNSUPPORTED error will be returned: *
  /// SearchRequest.serving_config * SearchRequest.branch *
  /// SearchRequest.canonical_filter * SearchRequest.query_expansion_spec *
  /// SearchRequest.spell_correction_spec * SearchRequest.content_search_spec *
  /// SearchRequest.user_pseudo_id
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaSearchRequest? searchRequest;

  GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpec({
    this.querySetSpec,
    this.searchRequest,
  });

  GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpec.fromJson(
    core.Map json_,
  ) : this(
        querySetSpec:
            json_.containsKey('querySetSpec')
                ? GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpecQuerySetSpec.fromJson(
                  json_['querySetSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchRequest:
            json_.containsKey('searchRequest')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequest.fromJson(
                  json_['searchRequest'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (querySetSpec != null) 'querySetSpec': querySetSpec!,
    if (searchRequest != null) 'searchRequest': searchRequest!,
  };
}

/// Describes the specification of the query set.
typedef GoogleCloudDiscoveryengineV1alphaEvaluationEvaluationSpecQuerySetSpec =
    $EvaluationEvaluationSpecQuerySetSpec;

/// Request message for the `ExportMetrics` method.
class GoogleCloudDiscoveryengineV1alphaExportMetricsRequest {
  /// The output location of the data.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaOutputConfig? outputConfig;

  GoogleCloudDiscoveryengineV1alphaExportMetricsRequest({this.outputConfig});

  GoogleCloudDiscoveryengineV1alphaExportMetricsRequest.fromJson(core.Map json_)
    : this(
        outputConfig:
            json_.containsKey('outputConfig')
                ? GoogleCloudDiscoveryengineV1alphaOutputConfig.fromJson(
                  json_['outputConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (outputConfig != null) 'outputConfig': outputConfig!,
  };
}

/// Fact Chunk.
typedef GoogleCloudDiscoveryengineV1alphaFactChunk = $FactChunk;

/// Response message for SiteSearchEngineService.FetchDomainVerificationStatus
/// method.
class GoogleCloudDiscoveryengineV1alphaFetchDomainVerificationStatusResponse {
  /// A token that can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// List of TargetSites containing the site verification status.
  core.List<GoogleCloudDiscoveryengineV1alphaTargetSite>? targetSites;

  /// The total number of items matching the request.
  ///
  /// This will always be populated in the response.
  core.int? totalSize;

  GoogleCloudDiscoveryengineV1alphaFetchDomainVerificationStatusResponse({
    this.nextPageToken,
    this.targetSites,
    this.totalSize,
  });

  GoogleCloudDiscoveryengineV1alphaFetchDomainVerificationStatusResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        targetSites:
            (json_['targetSites'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaTargetSite.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        totalSize: json_['totalSize'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (targetSites != null) 'targetSites': targetSites!,
    if (totalSize != null) 'totalSize': totalSize!,
  };
}

/// Response message for SiteSearchEngineService.FetchSitemaps method.
class GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse {
  /// List of Sitemaps fetched.
  core.List<
    GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponseSitemapMetadata
  >?
  sitemapsMetadata;

  GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse({
    this.sitemapsMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponse.fromJson(
    core.Map json_,
  ) : this(
        sitemapsMetadata:
            (json_['sitemapsMetadata'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponseSitemapMetadata.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sitemapsMetadata != null) 'sitemapsMetadata': sitemapsMetadata!,
  };
}

/// Contains a Sitemap and its metadata.
class GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponseSitemapMetadata {
  /// The Sitemap.
  GoogleCloudDiscoveryengineV1alphaSitemap? sitemap;

  GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponseSitemapMetadata({
    this.sitemap,
  });

  GoogleCloudDiscoveryengineV1alphaFetchSitemapsResponseSitemapMetadata.fromJson(
    core.Map json_,
  ) : this(
        sitemap:
            json_.containsKey('sitemap')
                ? GoogleCloudDiscoveryengineV1alphaSitemap.fromJson(
                  json_['sitemap'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sitemap != null) 'sitemap': sitemap!,
  };
}

/// Cloud FhirStore source import data from.
typedef GoogleCloudDiscoveryengineV1alphaFhirStoreSource = $FhirStoreSource;

/// Configurations for fields of a schema.
///
/// For example, configuring a field is indexable, or searchable.
class GoogleCloudDiscoveryengineV1alphaFieldConfig {
  /// If this field is set, only the corresponding source will be indexed for
  /// this field.
  ///
  /// Otherwise, the values from different sources are merged. Assuming a page
  /// with `` in meta tag, and `` in page map: if this enum is set to METATAGS,
  /// we will only index ``; if this enum is not set, we will merge them and
  /// index ``.
  core.List<core.String>? advancedSiteSearchDataSources;

  /// If completable_option is COMPLETABLE_ENABLED, field values are directly
  /// used and returned as suggestions for Autocomplete in
  /// CompletionService.CompleteQuery.
  ///
  /// If completable_option is unset, the server behavior defaults to
  /// COMPLETABLE_DISABLED for fields that support setting completable options,
  /// which are just `string` fields. For those fields that do not support
  /// setting completable options, the server will skip completable option
  /// setting, and setting completable_option for those fields will throw
  /// `INVALID_ARGUMENT` error.
  /// Possible string values are:
  /// - "COMPLETABLE_OPTION_UNSPECIFIED" : Value used when unset.
  /// - "COMPLETABLE_ENABLED" : Completable option enabled for a schema field.
  /// - "COMPLETABLE_DISABLED" : Completable option disabled for a schema field.
  core.String? completableOption;

  /// If dynamic_facetable_option is DYNAMIC_FACETABLE_ENABLED, field values are
  /// available for dynamic facet.
  ///
  /// Could only be DYNAMIC_FACETABLE_DISABLED if FieldConfig.indexable_option
  /// is INDEXABLE_DISABLED. Otherwise, an `INVALID_ARGUMENT` error will be
  /// returned. If dynamic_facetable_option is unset, the server behavior
  /// defaults to DYNAMIC_FACETABLE_DISABLED for fields that support setting
  /// dynamic facetable options. For those fields that do not support setting
  /// dynamic facetable options, such as `object` and `boolean`, the server will
  /// skip dynamic facetable option setting, and setting
  /// dynamic_facetable_option for those fields will throw `INVALID_ARGUMENT`
  /// error.
  /// Possible string values are:
  /// - "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED" : Value used when unset.
  /// - "DYNAMIC_FACETABLE_ENABLED" : Dynamic facetable option enabled for a
  /// schema field.
  /// - "DYNAMIC_FACETABLE_DISABLED" : Dynamic facetable option disabled for a
  /// schema field.
  core.String? dynamicFacetableOption;

  /// Field path of the schema field.
  ///
  /// For example: `title`, `description`, `release_info.release_year`.
  ///
  /// Required.
  core.String? fieldPath;

  /// Raw type of the field.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "FIELD_TYPE_UNSPECIFIED" : Field type is unspecified.
  /// - "OBJECT" : Field value type is Object.
  /// - "STRING" : Field value type is String.
  /// - "NUMBER" : Field value type is Number.
  /// - "INTEGER" : Field value type is Integer.
  /// - "BOOLEAN" : Field value type is Boolean.
  /// - "GEOLOCATION" : Field value type is Geolocation. Geolocation is
  /// expressed as an object with the following keys: * `id`: a string
  /// representing the location id * `longitude`: a number representing the
  /// longitude coordinate of the location * `latitude`: a number repesenting
  /// the latitude coordinate of the location * `address`: a string representing
  /// the full address of the location `latitude` and `longitude` must always be
  /// provided together. At least one of a) `address` or b)
  /// `latitude`-`longitude` pair must be provided.
  /// - "DATETIME" : Field value type is Datetime. Datetime can be expressed as
  /// either: * a number representing milliseconds-since-the-epoch * a string
  /// representing milliseconds-since-the-epoch. e.g. `"1420070400001"` * a
  /// string representing the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)
  /// date or date and time. e.g. `"2015-01-01"` or `"2015-01-01T12:10:30Z"`
  core.String? fieldType;

  /// If indexable_option is INDEXABLE_ENABLED, field values are indexed so that
  /// it can be filtered or faceted in SearchService.Search.
  ///
  /// If indexable_option is unset, the server behavior defaults to
  /// INDEXABLE_DISABLED for fields that support setting indexable options. For
  /// those fields that do not support setting indexable options, such as
  /// `object` and `boolean` and key properties, the server will skip
  /// indexable_option setting, and setting indexable_option for those fields
  /// will throw `INVALID_ARGUMENT` error.
  /// Possible string values are:
  /// - "INDEXABLE_OPTION_UNSPECIFIED" : Value used when unset.
  /// - "INDEXABLE_ENABLED" : Indexable option enabled for a schema field.
  /// - "INDEXABLE_DISABLED" : Indexable option disabled for a schema field.
  core.String? indexableOption;

  /// Type of the key property that this field is mapped to.
  ///
  /// Empty string if this is not annotated as mapped to a key property. Example
  /// types are `title`, `description`. Full list is defined by
  /// `keyPropertyMapping` in the schema field annotation. If the schema field
  /// has a `KeyPropertyMapping` annotation, `indexable_option` and
  /// `searchable_option` of this field cannot be modified.
  ///
  /// Output only.
  core.String? keyPropertyType;

  /// The metatag name found in the HTML page.
  ///
  /// If user defines this field, the value of this metatag name will be used to
  /// extract metatag. If the user does not define this field, the
  /// FieldConfig.field_path will be used to extract metatag.
  ///
  /// Optional.
  core.String? metatagName;

  /// If recs_filterable_option is FILTERABLE_ENABLED, field values are
  /// filterable by filter expression in RecommendationService.Recommend.
  ///
  /// If FILTERABLE_ENABLED but the field type is numerical, field values are
  /// not filterable by text queries in RecommendationService.Recommend. Only
  /// textual fields are supported. If recs_filterable_option is unset, the
  /// default setting is FILTERABLE_DISABLED for fields that support setting
  /// filterable options. When a field set to \[FILTERABLE_DISABLED\] is
  /// filtered, a warning is generated and an empty result is returned.
  /// Possible string values are:
  /// - "FILTERABLE_OPTION_UNSPECIFIED" : Value used when unset.
  /// - "FILTERABLE_ENABLED" : Filterable option enabled for a schema field.
  /// - "FILTERABLE_DISABLED" : Filterable option disabled for a schema field.
  core.String? recsFilterableOption;

  /// If retrievable_option is RETRIEVABLE_ENABLED, field values are included in
  /// the search results.
  ///
  /// If retrievable_option is unset, the server behavior defaults to
  /// RETRIEVABLE_DISABLED for fields that support setting retrievable options.
  /// For those fields that do not support setting retrievable options, such as
  /// `object` and `boolean`, the server will skip retrievable option setting,
  /// and setting retrievable_option for those fields will throw
  /// `INVALID_ARGUMENT` error.
  /// Possible string values are:
  /// - "RETRIEVABLE_OPTION_UNSPECIFIED" : Value used when unset.
  /// - "RETRIEVABLE_ENABLED" : Retrievable option enabled for a schema field.
  /// - "RETRIEVABLE_DISABLED" : Retrievable option disabled for a schema field.
  core.String? retrievableOption;

  /// Field paths for indexing custom attribute from schema.org data.
  ///
  /// More details of schema.org and its defined types can be found at
  /// [schema.org](https://schema.org). It is only used on advanced site search
  /// schema. Currently only support full path from root. The full path to a
  /// field is constructed by concatenating field names, starting from `_root`,
  /// with a period `.` as the delimiter. Examples: * Publish date of the root:
  /// _root.datePublished * Publish date of the reviews:
  /// _root.review.datePublished
  core.List<core.String>? schemaOrgPaths;

  /// If searchable_option is SEARCHABLE_ENABLED, field values are searchable by
  /// text queries in SearchService.Search.
  ///
  /// If SEARCHABLE_ENABLED but field type is numerical, field values will not
  /// be searchable by text queries in SearchService.Search, as there are no
  /// text values associated to numerical fields. If searchable_option is unset,
  /// the server behavior defaults to SEARCHABLE_DISABLED for fields that
  /// support setting searchable options. Only `string` fields that have no key
  /// property mapping support setting searchable_option. For those fields that
  /// do not support setting searchable options, the server will skip searchable
  /// option setting, and setting searchable_option for those fields will throw
  /// `INVALID_ARGUMENT` error.
  /// Possible string values are:
  /// - "SEARCHABLE_OPTION_UNSPECIFIED" : Value used when unset.
  /// - "SEARCHABLE_ENABLED" : Searchable option enabled for a schema field.
  /// - "SEARCHABLE_DISABLED" : Searchable option disabled for a schema field.
  core.String? searchableOption;

  GoogleCloudDiscoveryengineV1alphaFieldConfig({
    this.advancedSiteSearchDataSources,
    this.completableOption,
    this.dynamicFacetableOption,
    this.fieldPath,
    this.fieldType,
    this.indexableOption,
    this.keyPropertyType,
    this.metatagName,
    this.recsFilterableOption,
    this.retrievableOption,
    this.schemaOrgPaths,
    this.searchableOption,
  });

  GoogleCloudDiscoveryengineV1alphaFieldConfig.fromJson(core.Map json_)
    : this(
        advancedSiteSearchDataSources:
            (json_['advancedSiteSearchDataSources'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        completableOption: json_['completableOption'] as core.String?,
        dynamicFacetableOption: json_['dynamicFacetableOption'] as core.String?,
        fieldPath: json_['fieldPath'] as core.String?,
        fieldType: json_['fieldType'] as core.String?,
        indexableOption: json_['indexableOption'] as core.String?,
        keyPropertyType: json_['keyPropertyType'] as core.String?,
        metatagName: json_['metatagName'] as core.String?,
        recsFilterableOption: json_['recsFilterableOption'] as core.String?,
        retrievableOption: json_['retrievableOption'] as core.String?,
        schemaOrgPaths:
            (json_['schemaOrgPaths'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        searchableOption: json_['searchableOption'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (advancedSiteSearchDataSources != null)
      'advancedSiteSearchDataSources': advancedSiteSearchDataSources!,
    if (completableOption != null) 'completableOption': completableOption!,
    if (dynamicFacetableOption != null)
      'dynamicFacetableOption': dynamicFacetableOption!,
    if (fieldPath != null) 'fieldPath': fieldPath!,
    if (fieldType != null) 'fieldType': fieldType!,
    if (indexableOption != null) 'indexableOption': indexableOption!,
    if (keyPropertyType != null) 'keyPropertyType': keyPropertyType!,
    if (metatagName != null) 'metatagName': metatagName!,
    if (recsFilterableOption != null)
      'recsFilterableOption': recsFilterableOption!,
    if (retrievableOption != null) 'retrievableOption': retrievableOption!,
    if (schemaOrgPaths != null) 'schemaOrgPaths': schemaOrgPaths!,
    if (searchableOption != null) 'searchableOption': searchableOption!,
  };
}

/// Caracteristics of other file types.
class GoogleCloudDiscoveryengineV1alphaFileCharacteristics {
  /// Generic map of characteristics.
  ///
  /// Output only.
  core.Map<core.String, core.String>? characteristics;

  GoogleCloudDiscoveryengineV1alphaFileCharacteristics({this.characteristics});

  GoogleCloudDiscoveryengineV1alphaFileCharacteristics.fromJson(core.Map json_)
    : this(
        characteristics: (json_['characteristics']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (characteristics != null) 'characteristics': characteristics!,
  };
}

/// Represents a file attached to a session (context file)
class GoogleCloudDiscoveryengineV1alphaFileMetadata {
  /// The size of the context file in bytes.
  ///
  /// Output only.
  core.String? byteSize;

  /// The AssistantService.DownloadSessionFile URL to download the file.
  ///
  /// This URL will need the same credentials as
  /// AssistantService.ListSessionFileMetadata method and will provide the
  /// resource.
  ///
  /// Output only.
  core.String? downloadUri;

  /// The ID of the file.
  ///
  /// Output only.
  core.String? fileId;

  /// The origin of the file.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "FILE_ORIGIN_TYPE_UNSPECIFIED" : Default value.
  /// - "USER_PROVIDED" : The file was provided by the user.
  /// - "AI_GENERATED" : The file was generated by an AI model.
  /// - "INTERNALLY_GENERATED" : The file was generated from other files by an
  /// internal process.
  core.String? fileOriginType;

  /// The time the file was added to the session.
  ///
  /// Note that if a file was added, then modified externally, then added again,
  /// the add time will be updated.
  ///
  /// Output only.
  core.String? lastAddTime;

  /// Represents metadata related to the file that can suit particular use
  /// cases.
  ///
  /// The prefix "google." is reserved for the key for use by Google, but other
  /// prefixes can be freely used.
  ///
  /// Optional.
  core.Map<core.String, core.String>? metadata;

  /// The content type of the file, see
  /// https://www.iana.org/assignments/media-types/media-types.xhtml.
  core.String? mimeType;

  /// The name of the file uploaded.
  ///
  /// Output only.
  core.String? name;

  /// The type of the original source of the file.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "FILE_SOURCE_UNSPECIFIED" : Default value. Unknown source.
  /// - "FILE_SOURCE_INLINE" : The data of the file was provided inline (e.g.
  /// pasted from the clipboard).
  /// - "FILE_SOURCE_LOCAL" : The file was uploaded from a local file.
  /// - "FILE_SOURCE_CLOUD_STORAGE" : The file was uploaded from Cloud Storage.
  /// - "FILE_SOURCE_CLOUD_DRIVE" : The file was uploaded from Drive.
  /// - "FILE_SOURCE_URL" : The file was retrieved from a URL (e.g. public web).
  core.String? originalSourceType;

  /// The original location of the file.
  ///
  /// It may be a local file path, or any other URI that allows accessing the
  /// file in an external system. There are two scenarios in which this url may
  /// be empty: 1. If the file was sent as inline data (e.g. pasted from the
  /// clipboard). 2. If the original location is not available. Note that
  /// there's no guarantee that the URI will be pointing to a valid or actually
  /// existing file. For example, a file might have been uploaded to the
  /// session, and then deleted from the original source.
  ///
  /// Optional.
  core.String? originalUri;

  /// The time the file was uploaded (If this is a file generated by an internal
  /// process and then made available to the session, this indicates the moment
  /// it happened).
  ///
  /// Output only.
  core.String? uploadTime;

  /// Alternate views of this file object.
  ///
  /// Each file view is attached to a specific role. Possible example keys: -
  /// "thumbnail" - "mobile_thumbnail" - "clip" - "summary" - "translation"
  ///
  /// Output only.
  core.Map<core.String, GoogleCloudDiscoveryengineV1alphaFileView>? views;

  GoogleCloudDiscoveryengineV1alphaFileMetadata({
    this.byteSize,
    this.downloadUri,
    this.fileId,
    this.fileOriginType,
    this.lastAddTime,
    this.metadata,
    this.mimeType,
    this.name,
    this.originalSourceType,
    this.originalUri,
    this.uploadTime,
    this.views,
  });

  GoogleCloudDiscoveryengineV1alphaFileMetadata.fromJson(core.Map json_)
    : this(
        byteSize: json_['byteSize'] as core.String?,
        downloadUri: json_['downloadUri'] as core.String?,
        fileId: json_['fileId'] as core.String?,
        fileOriginType: json_['fileOriginType'] as core.String?,
        lastAddTime: json_['lastAddTime'] as core.String?,
        metadata: (json_['metadata'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        mimeType: json_['mimeType'] as core.String?,
        name: json_['name'] as core.String?,
        originalSourceType: json_['originalSourceType'] as core.String?,
        originalUri: json_['originalUri'] as core.String?,
        uploadTime: json_['uploadTime'] as core.String?,
        views: (json_['views'] as core.Map<core.String, core.dynamic>?)?.map(
          (key, value) => core.MapEntry(
            key,
            GoogleCloudDiscoveryengineV1alphaFileView.fromJson(
              value as core.Map<core.String, core.dynamic>,
            ),
          ),
        ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (byteSize != null) 'byteSize': byteSize!,
    if (downloadUri != null) 'downloadUri': downloadUri!,
    if (fileId != null) 'fileId': fileId!,
    if (fileOriginType != null) 'fileOriginType': fileOriginType!,
    if (lastAddTime != null) 'lastAddTime': lastAddTime!,
    if (metadata != null) 'metadata': metadata!,
    if (mimeType != null) 'mimeType': mimeType!,
    if (name != null) 'name': name!,
    if (originalSourceType != null) 'originalSourceType': originalSourceType!,
    if (originalUri != null) 'originalUri': originalUri!,
    if (uploadTime != null) 'uploadTime': uploadTime!,
    if (views != null) 'views': views!,
  };
}

/// Represents a specific alternate version or "view" of a file object, such as
/// a summary, a thumbnail, a translated version, etc.
class GoogleCloudDiscoveryengineV1alphaFileView {
  /// The size of the view in bytes.
  ///
  /// Output only.
  core.String? byteSize;

  /// The time the view was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Characteristics of other file types.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaFileCharacteristics? fileCharacteristics;

  /// Characteristics of an image media view.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaImageCharacteristics? imageCharacteristics;

  /// MIME type (e.g., "image/jpeg", "image/png", "text/plain", "video/mp4")
  ///
  /// Output only.
  core.String? mimeType;

  /// The URI to access this media view.
  ///
  /// Output only.
  core.String? uri;

  /// Characteristics of a video media view.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaVideoCharacteristics? videoCharacteristics;

  /// Globally Unique id for this specific view.
  ///
  /// Output only.
  core.String? viewId;

  GoogleCloudDiscoveryengineV1alphaFileView({
    this.byteSize,
    this.createTime,
    this.fileCharacteristics,
    this.imageCharacteristics,
    this.mimeType,
    this.uri,
    this.videoCharacteristics,
    this.viewId,
  });

  GoogleCloudDiscoveryengineV1alphaFileView.fromJson(core.Map json_)
    : this(
        byteSize: json_['byteSize'] as core.String?,
        createTime: json_['createTime'] as core.String?,
        fileCharacteristics:
            json_.containsKey('fileCharacteristics')
                ? GoogleCloudDiscoveryengineV1alphaFileCharacteristics.fromJson(
                  json_['fileCharacteristics']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        imageCharacteristics:
            json_.containsKey('imageCharacteristics')
                ? GoogleCloudDiscoveryengineV1alphaImageCharacteristics.fromJson(
                  json_['imageCharacteristics']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        mimeType: json_['mimeType'] as core.String?,
        uri: json_['uri'] as core.String?,
        videoCharacteristics:
            json_.containsKey('videoCharacteristics')
                ? GoogleCloudDiscoveryengineV1alphaVideoCharacteristics.fromJson(
                  json_['videoCharacteristics']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        viewId: json_['viewId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (byteSize != null) 'byteSize': byteSize!,
    if (createTime != null) 'createTime': createTime!,
    if (fileCharacteristics != null)
      'fileCharacteristics': fileCharacteristics!,
    if (imageCharacteristics != null)
      'imageCharacteristics': imageCharacteristics!,
    if (mimeType != null) 'mimeType': mimeType!,
    if (uri != null) 'uri': uri!,
    if (videoCharacteristics != null)
      'videoCharacteristics': videoCharacteristics!,
    if (viewId != null) 'viewId': viewId!,
  };
}

/// Firestore source import data from.
typedef GoogleCloudDiscoveryengineV1alphaFirestoreSource = $FirestoreSource;

/// Cloud Storage location for input content.
typedef GoogleCloudDiscoveryengineV1alphaGcsSource = $GcsSource01;

/// Response message for DataConnectorService.GetConnectorSecret.
class GoogleCloudDiscoveryengineV1alphaGetConnectorSecretResponse {
  /// The app name of the associated Connector.
  core.String? app;

  /// The authorization uri for the data connector.
  core.String? authorizationUri;

  /// The client id of the associated Connector.
  core.String? clientId;

  /// The instance name of the associated Connector.
  core.String? instance;

  /// The redirect url of the associated Connector.
  core.String? redirectUri;

  /// The tenant id of the associated Connector.
  core.String? tenantId;

  GoogleCloudDiscoveryengineV1alphaGetConnectorSecretResponse({
    this.app,
    this.authorizationUri,
    this.clientId,
    this.instance,
    this.redirectUri,
    this.tenantId,
  });

  GoogleCloudDiscoveryengineV1alphaGetConnectorSecretResponse.fromJson(
    core.Map json_,
  ) : this(
        app: json_['app'] as core.String?,
        authorizationUri: json_['authorizationUri'] as core.String?,
        clientId: json_['clientId'] as core.String?,
        instance: json_['instance'] as core.String?,
        redirectUri: json_['redirectUri'] as core.String?,
        tenantId: json_['tenantId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (app != null) 'app': app!,
    if (authorizationUri != null) 'authorizationUri': authorizationUri!,
    if (clientId != null) 'clientId': clientId!,
    if (instance != null) 'instance': instance!,
    if (redirectUri != null) 'redirectUri': redirectUri!,
    if (tenantId != null) 'tenantId': tenantId!,
  };
}

/// Response message for SiteSearchEngineService.GetUriPatternDocumentData
/// method.
class GoogleCloudDiscoveryengineV1alphaGetUriPatternDocumentDataResponse {
  /// Document data keyed by URI pattern.
  ///
  /// For example: document_data_map = { "www.url1.com / * ": { "Categories":
  /// \["category1", "category2"\] }, "www.url2.com / * ": { "Categories":
  /// \["category3"\] } }
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Map<core.String, core.Object?>>? documentDataMap;

  GoogleCloudDiscoveryengineV1alphaGetUriPatternDocumentDataResponse({
    this.documentDataMap,
  });

  GoogleCloudDiscoveryengineV1alphaGetUriPatternDocumentDataResponse.fromJson(
    core.Map json_,
  ) : this(
        documentDataMap: (json_['documentDataMap']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                value as core.Map<core.String, core.dynamic>,
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentDataMap != null) 'documentDataMap': documentDataMap!,
  };
}

/// Grounding Fact.
typedef GoogleCloudDiscoveryengineV1alphaGroundingFact = $GroundingFact;

/// Defines guided search spec.
class GoogleCloudDiscoveryengineV1alphaGuidedSearchSpec {
  /// Whether or not to enable and include refinement attributes in gudied
  /// search result.
  core.bool? enableRefinementAttributes;

  /// Whether or not to enable and include related questions in search response.
  core.bool? enableRelatedQuestions;

  /// Max number of related questions to be returned.
  ///
  /// The valid range is \[1, 5\]. If enable_related_questions is true, the
  /// default value is 3.
  core.int? maxRelatedQuestions;

  GoogleCloudDiscoveryengineV1alphaGuidedSearchSpec({
    this.enableRefinementAttributes,
    this.enableRelatedQuestions,
    this.maxRelatedQuestions,
  });

  GoogleCloudDiscoveryengineV1alphaGuidedSearchSpec.fromJson(core.Map json_)
    : this(
        enableRefinementAttributes:
            json_['enableRefinementAttributes'] as core.bool?,
        enableRelatedQuestions: json_['enableRelatedQuestions'] as core.bool?,
        maxRelatedQuestions: json_['maxRelatedQuestions'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableRefinementAttributes != null)
      'enableRefinementAttributes': enableRefinementAttributes!,
    if (enableRelatedQuestions != null)
      'enableRelatedQuestions': enableRelatedQuestions!,
    if (maxRelatedQuestions != null)
      'maxRelatedQuestions': maxRelatedQuestions!,
  };
}

/// Config to data store for `HEALTHCARE_FHIR` vertical.
typedef GoogleCloudDiscoveryengineV1alphaHealthcareFhirConfig =
    $HealthcareFhirConfig;

/// Identity Mapping Entry that maps an external identity to an internal
/// identity.
typedef GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry =
    $IdentityMappingEntry;

/// Identity Mapping Store which contains Identity Mapping Entries.
class GoogleCloudDiscoveryengineV1alphaIdentityMappingStore {
  /// CMEK-related information for the Identity Mapping Store.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaCmekConfig? cmekConfig;

  /// The identity provider configuration this is bound to translate the
  /// identity mapping entries within.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaIdpConfig? idpConfig;

  /// Input only.
  ///
  /// The KMS key to be used to protect this Identity Mapping Store at creation
  /// time. Must be set for requests that need to comply with CMEK Org Policy
  /// protections. If this field is set and processed successfully, the Identity
  /// Mapping Store will be protected by the KMS key, as indicated in the
  /// cmek_config field.
  core.String? kmsKeyName;

  /// The full resource name of the identity mapping store.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/identityMappingStores/{identity_mapping_store}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  GoogleCloudDiscoveryengineV1alphaIdentityMappingStore({
    this.cmekConfig,
    this.idpConfig,
    this.kmsKeyName,
    this.name,
  });

  GoogleCloudDiscoveryengineV1alphaIdentityMappingStore.fromJson(core.Map json_)
    : this(
        cmekConfig:
            json_.containsKey('cmekConfig')
                ? GoogleCloudDiscoveryengineV1alphaCmekConfig.fromJson(
                  json_['cmekConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        idpConfig:
            json_.containsKey('idpConfig')
                ? GoogleCloudDiscoveryengineV1alphaIdpConfig.fromJson(
                  json_['idpConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        kmsKeyName: json_['kmsKeyName'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cmekConfig != null) 'cmekConfig': cmekConfig!,
    if (idpConfig != null) 'idpConfig': idpConfig!,
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName!,
    if (name != null) 'name': name!,
  };
}

/// The configuration for the identity data synchronization runs.
class GoogleCloudDiscoveryengineV1alphaIdentityScheduleConfig {
  /// The UTC time when the next data sync is expected to start for the Data
  /// Connector.
  ///
  /// Customers are only able to specify the hour and minute to schedule the
  /// data sync. This is utilized when the data connector has a refresh interval
  /// greater than 1 day.
  ///
  /// Optional.
  GoogleTypeDateTime? nextSyncTime;

  /// The refresh interval to sync the Access Control List information for the
  /// documents ingested by this connector.
  ///
  /// If not set, the access control list will be refreshed at the default
  /// interval of 30 minutes. The identity refresh interval can be at least 30
  /// minutes and at most 7 days.
  ///
  /// Optional.
  core.String? refreshInterval;

  GoogleCloudDiscoveryengineV1alphaIdentityScheduleConfig({
    this.nextSyncTime,
    this.refreshInterval,
  });

  GoogleCloudDiscoveryengineV1alphaIdentityScheduleConfig.fromJson(
    core.Map json_,
  ) : this(
        nextSyncTime:
            json_.containsKey('nextSyncTime')
                ? GoogleTypeDateTime.fromJson(
                  json_['nextSyncTime'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        refreshInterval: json_['refreshInterval'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextSyncTime != null) 'nextSyncTime': nextSyncTime!,
    if (refreshInterval != null) 'refreshInterval': refreshInterval!,
  };
}

/// Identity Provider Config.
class GoogleCloudDiscoveryengineV1alphaIdpConfig {
  /// External Identity provider config.
  GoogleCloudDiscoveryengineV1alphaIdpConfigExternalIdpConfig?
  externalIdpConfig;

  /// Identity provider type configured.
  /// Possible string values are:
  /// - "IDP_TYPE_UNSPECIFIED" : Default value. ACL search not enabled.
  /// - "GSUITE" : Google 1P provider.
  /// - "THIRD_PARTY" : Third party provider.
  core.String? idpType;

  GoogleCloudDiscoveryengineV1alphaIdpConfig({
    this.externalIdpConfig,
    this.idpType,
  });

  GoogleCloudDiscoveryengineV1alphaIdpConfig.fromJson(core.Map json_)
    : this(
        externalIdpConfig:
            json_.containsKey('externalIdpConfig')
                ? GoogleCloudDiscoveryengineV1alphaIdpConfigExternalIdpConfig.fromJson(
                  json_['externalIdpConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        idpType: json_['idpType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (externalIdpConfig != null) 'externalIdpConfig': externalIdpConfig!,
    if (idpType != null) 'idpType': idpType!,
  };
}

/// Third party IDP Config.
class GoogleCloudDiscoveryengineV1alphaIdpConfigExternalIdpConfig {
  /// Workforce pool name.
  ///
  /// Example: "locations/global/workforcePools/pool_id"
  core.String? workforcePoolName;

  GoogleCloudDiscoveryengineV1alphaIdpConfigExternalIdpConfig({
    this.workforcePoolName,
  });

  GoogleCloudDiscoveryengineV1alphaIdpConfigExternalIdpConfig.fromJson(
    core.Map json_,
  ) : this(workforcePoolName: json_['workforcePoolName'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (workforcePoolName != null) 'workforcePoolName': workforcePoolName!,
  };
}

/// Standard characteristics of an image media view.
class GoogleCloudDiscoveryengineV1alphaImageCharacteristics {
  /// Bit depth of the image (e.g., 8-bit, 16-bit).
  ///
  /// Output only.
  core.int? bitDepth;

  /// Color space of the image (e.g., "RGB", "CMYK", "Grayscale").
  ///
  /// Output only.
  /// Possible string values are:
  /// - "COLOR_SPACE_UNSPECIFIED" : Default value. Unknown color space.
  /// - "RGB" : Red, green, blue colorspace.
  /// - "CMYK" : Cyan, magenta, yellow, and black colorspace.
  /// - "GRAYSCALE" : Grayscale colorspace.
  /// - "YUV" : YUV colorspace.
  /// - "OTHER_COLOR_SPACE" : Other colorspace.
  core.String? colorSpace;

  /// Image height in pixels.
  ///
  /// Output only.
  core.int? height;

  /// Image width in pixels.
  ///
  /// Output only.
  core.int? width;

  GoogleCloudDiscoveryengineV1alphaImageCharacteristics({
    this.bitDepth,
    this.colorSpace,
    this.height,
    this.width,
  });

  GoogleCloudDiscoveryengineV1alphaImageCharacteristics.fromJson(core.Map json_)
    : this(
        bitDepth: json_['bitDepth'] as core.int?,
        colorSpace: json_['colorSpace'] as core.String?,
        height: json_['height'] as core.int?,
        width: json_['width'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bitDepth != null) 'bitDepth': bitDepth!,
    if (colorSpace != null) 'colorSpace': colorSpace!,
    if (height != null) 'height': height!,
    if (width != null) 'width': width!,
  };
}

/// Request message for CompletionService.ImportCompletionSuggestions method.
class GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequest {
  /// BigQuery input source.
  GoogleCloudDiscoveryengineV1alphaBigQuerySource? bigquerySource;

  /// The desired location of errors incurred during the Import.
  GoogleCloudDiscoveryengineV1alphaImportErrorConfig? errorConfig;

  /// Cloud Storage location for the input content.
  GoogleCloudDiscoveryengineV1alphaGcsSource? gcsSource;

  /// The Inline source for suggestion entries.
  GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequest({
    this.bigquerySource,
    this.errorConfig,
    this.gcsSource,
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequest.fromJson(
    core.Map json_,
  ) : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudDiscoveryengineV1alphaBigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        errorConfig:
            json_.containsKey('errorConfig')
                ? GoogleCloudDiscoveryengineV1alphaImportErrorConfig.fromJson(
                  json_['errorConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudDiscoveryengineV1alphaGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (errorConfig != null) 'errorConfig': errorConfig!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source for CompletionSuggestions.
class GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequestInlineSource {
  /// A list of all denylist entries to import.
  ///
  /// Max of 1000 items.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaCompletionSuggestion>? suggestions;

  GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequestInlineSource({
    this.suggestions,
  });

  GoogleCloudDiscoveryengineV1alphaImportCompletionSuggestionsRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        suggestions:
            (json_['suggestions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCompletionSuggestion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (suggestions != null) 'suggestions': suggestions!,
  };
}

/// Request message for Import methods.
class GoogleCloudDiscoveryengineV1alphaImportDocumentsRequest {
  /// AlloyDB input source.
  GoogleCloudDiscoveryengineV1alphaAlloyDbSource? alloyDbSource;

  /// Whether to automatically generate IDs for the documents if absent.
  ///
  /// If set to `true`, Document.ids are automatically generated based on the
  /// hash of the payload, where IDs may not be consistent during multiple
  /// imports. In which case ReconciliationMode.FULL is highly recommended to
  /// avoid duplicate contents. If unset or set to `false`, Document.ids have to
  /// be specified using id_field, otherwise, documents without IDs fail to be
  /// imported. Supported data sources: * GcsSource. GcsSource.data_schema must
  /// be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown. *
  /// BigQuerySource. BigQuerySource.data_schema must be `custom` or `csv`.
  /// Otherwise, an INVALID_ARGUMENT error is thrown. * SpannerSource. *
  /// CloudSqlSource. * FirestoreSource. * BigtableSource.
  core.bool? autoGenerateIds;

  /// BigQuery input source.
  GoogleCloudDiscoveryengineV1alphaBigQuerySource? bigquerySource;

  /// Cloud Bigtable input source.
  GoogleCloudDiscoveryengineV1alphaBigtableSource? bigtableSource;

  /// Cloud SQL input source.
  GoogleCloudDiscoveryengineV1alphaCloudSqlSource? cloudSqlSource;

  /// The desired location of errors incurred during the Import.
  GoogleCloudDiscoveryengineV1alphaImportErrorConfig? errorConfig;

  /// FhirStore input source.
  GoogleCloudDiscoveryengineV1alphaFhirStoreSource? fhirStoreSource;

  /// Firestore input source.
  GoogleCloudDiscoveryengineV1alphaFirestoreSource? firestoreSource;

  /// Whether to force refresh the unstructured content of the documents.
  ///
  /// If set to `true`, the content part of the documents will be refreshed
  /// regardless of the update status of the referencing content.
  ///
  /// Optional.
  core.bool? forceRefreshContent;

  /// Cloud Storage location for the input content.
  GoogleCloudDiscoveryengineV1alphaGcsSource? gcsSource;

  /// The field indicates the ID field or column to be used as unique IDs of the
  /// documents.
  ///
  /// For GcsSource it is the key of the JSON field. For instance, `my_id` for
  /// JSON `{"my_id": "some_uuid"}`. For others, it may be the column name of
  /// the table where the unique ids are stored. The values of the JSON field or
  /// the table column are used as the Document.ids. The JSON field or the table
  /// column must be of string type, and the values must be set as valid strings
  /// conform to \[RFC-1034\](https://tools.ietf.org/html/rfc1034) with 1-63
  /// characters. Otherwise, documents without valid IDs fail to be imported.
  /// Only set this field when auto_generate_ids is unset or set as `false`.
  /// Otherwise, an INVALID_ARGUMENT error is thrown. If it is unset, a default
  /// value `_id` is used when importing from the allowed data sources.
  /// Supported data sources: * GcsSource. GcsSource.data_schema must be
  /// `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown. *
  /// BigQuerySource. BigQuerySource.data_schema must be `custom` or `csv`.
  /// Otherwise, an INVALID_ARGUMENT error is thrown. * SpannerSource. *
  /// CloudSqlSource. * BigtableSource.
  core.String? idField;

  /// The Inline source for the input content for documents.
  GoogleCloudDiscoveryengineV1alphaImportDocumentsRequestInlineSource?
  inlineSource;

  /// The mode of reconciliation between existing documents and the documents to
  /// be imported.
  ///
  /// Defaults to ReconciliationMode.INCREMENTAL.
  /// Possible string values are:
  /// - "RECONCILIATION_MODE_UNSPECIFIED" : Defaults to `INCREMENTAL`.
  /// - "INCREMENTAL" : Inserts new documents or updates existing documents.
  /// - "FULL" : Calculates diff and replaces the entire document dataset.
  /// Existing documents may be deleted if they are not present in the source
  /// location. When using this mode, there won't be any downtime on the dataset
  /// targeted. Any document that should remain unchanged or that should be
  /// updated will continue serving while the operation is running.
  core.String? reconciliationMode;

  /// Spanner input source.
  GoogleCloudDiscoveryengineV1alphaSpannerSource? spannerSource;

  /// Indicates which fields in the provided imported documents to update.
  ///
  /// If not set, the default is to update all fields.
  core.String? updateMask;

  GoogleCloudDiscoveryengineV1alphaImportDocumentsRequest({
    this.alloyDbSource,
    this.autoGenerateIds,
    this.bigquerySource,
    this.bigtableSource,
    this.cloudSqlSource,
    this.errorConfig,
    this.fhirStoreSource,
    this.firestoreSource,
    this.forceRefreshContent,
    this.gcsSource,
    this.idField,
    this.inlineSource,
    this.reconciliationMode,
    this.spannerSource,
    this.updateMask,
  });

  GoogleCloudDiscoveryengineV1alphaImportDocumentsRequest.fromJson(
    core.Map json_,
  ) : this(
        alloyDbSource:
            json_.containsKey('alloyDbSource')
                ? GoogleCloudDiscoveryengineV1alphaAlloyDbSource.fromJson(
                  json_['alloyDbSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        autoGenerateIds: json_['autoGenerateIds'] as core.bool?,
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudDiscoveryengineV1alphaBigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        bigtableSource:
            json_.containsKey('bigtableSource')
                ? GoogleCloudDiscoveryengineV1alphaBigtableSource.fromJson(
                  json_['bigtableSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        cloudSqlSource:
            json_.containsKey('cloudSqlSource')
                ? GoogleCloudDiscoveryengineV1alphaCloudSqlSource.fromJson(
                  json_['cloudSqlSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        errorConfig:
            json_.containsKey('errorConfig')
                ? GoogleCloudDiscoveryengineV1alphaImportErrorConfig.fromJson(
                  json_['errorConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        fhirStoreSource:
            json_.containsKey('fhirStoreSource')
                ? GoogleCloudDiscoveryengineV1alphaFhirStoreSource.fromJson(
                  json_['fhirStoreSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        firestoreSource:
            json_.containsKey('firestoreSource')
                ? GoogleCloudDiscoveryengineV1alphaFirestoreSource.fromJson(
                  json_['firestoreSource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        forceRefreshContent: json_['forceRefreshContent'] as core.bool?,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudDiscoveryengineV1alphaGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        idField: json_['idField'] as core.String?,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaImportDocumentsRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        reconciliationMode: json_['reconciliationMode'] as core.String?,
        spannerSource:
            json_.containsKey('spannerSource')
                ? GoogleCloudDiscoveryengineV1alphaSpannerSource.fromJson(
                  json_['spannerSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateMask: json_['updateMask'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (alloyDbSource != null) 'alloyDbSource': alloyDbSource!,
    if (autoGenerateIds != null) 'autoGenerateIds': autoGenerateIds!,
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (bigtableSource != null) 'bigtableSource': bigtableSource!,
    if (cloudSqlSource != null) 'cloudSqlSource': cloudSqlSource!,
    if (errorConfig != null) 'errorConfig': errorConfig!,
    if (fhirStoreSource != null) 'fhirStoreSource': fhirStoreSource!,
    if (firestoreSource != null) 'firestoreSource': firestoreSource!,
    if (forceRefreshContent != null)
      'forceRefreshContent': forceRefreshContent!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (idField != null) 'idField': idField!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
    if (reconciliationMode != null) 'reconciliationMode': reconciliationMode!,
    if (spannerSource != null) 'spannerSource': spannerSource!,
    if (updateMask != null) 'updateMask': updateMask!,
  };
}

/// The inline source for the input config for ImportDocuments method.
class GoogleCloudDiscoveryengineV1alphaImportDocumentsRequestInlineSource {
  /// A list of documents to update/create.
  ///
  /// Each document must have a valid Document.id. Recommended max of 100 items.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaDocument>? documents;

  GoogleCloudDiscoveryengineV1alphaImportDocumentsRequestInlineSource({
    this.documents,
  });

  GoogleCloudDiscoveryengineV1alphaImportDocumentsRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        documents:
            (json_['documents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documents != null) 'documents': documents!,
  };
}

/// Configuration of destination for Import related errors.
typedef GoogleCloudDiscoveryengineV1alphaImportErrorConfig = $ImportErrorConfig;

/// Request message for IdentityMappingStoreService.ImportIdentityMappings
class GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequest {
  /// The inline source to import identity mapping entries from.
  GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequest({
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequest.fromJson(
    core.Map json_,
  ) : this(
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source to import identity mapping entries from.
class GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequestInlineSource {
  /// A maximum of 10000 entries can be imported at one time
  core.List<GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry>?
  identityMappingEntries;

  GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequestInlineSource({
    this.identityMappingEntries,
  });

  GoogleCloudDiscoveryengineV1alphaImportIdentityMappingsRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        identityMappingEntries:
            (json_['identityMappingEntries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (identityMappingEntries != null)
      'identityMappingEntries': identityMappingEntries!,
  };
}

/// Request message for SampleQueryService.ImportSampleQueries method.
class GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequest {
  /// BigQuery input source.
  GoogleCloudDiscoveryengineV1alphaBigQuerySource? bigquerySource;

  /// The desired location of errors incurred during the Import.
  GoogleCloudDiscoveryengineV1alphaImportErrorConfig? errorConfig;

  /// Cloud Storage location for the input content.
  GoogleCloudDiscoveryengineV1alphaGcsSource? gcsSource;

  /// The Inline source for sample query entries.
  GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequest({
    this.bigquerySource,
    this.errorConfig,
    this.gcsSource,
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequest.fromJson(
    core.Map json_,
  ) : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudDiscoveryengineV1alphaBigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        errorConfig:
            json_.containsKey('errorConfig')
                ? GoogleCloudDiscoveryengineV1alphaImportErrorConfig.fromJson(
                  json_['errorConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudDiscoveryengineV1alphaGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (errorConfig != null) 'errorConfig': errorConfig!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source for SampleQuerys.
class GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequestInlineSource {
  /// A list of SampleQuerys to import.
  ///
  /// Max of 1000 items.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaSampleQuery>? sampleQueries;

  GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequestInlineSource({
    this.sampleQueries,
  });

  GoogleCloudDiscoveryengineV1alphaImportSampleQueriesRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        sampleQueries:
            (json_['sampleQueries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSampleQuery.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sampleQueries != null) 'sampleQueries': sampleQueries!,
  };
}

/// Request message for CompletionService.ImportSuggestionDenyListEntries
/// method.
class GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequest {
  /// Cloud Storage location for the input content.
  ///
  /// Only 1 file can be specified that contains all entries to import.
  /// Supported values `gcs_source.schema` for autocomplete suggestion deny list
  /// entry imports: * `suggestion_deny_list` (default): One JSON
  /// \[SuggestionDenyListEntry\] per line.
  GoogleCloudDiscoveryengineV1alphaGcsSource? gcsSource;

  /// The Inline source for the input content for suggestion deny list entries.
  GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequest({
    this.gcsSource,
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequest.fromJson(
    core.Map json_,
  ) : this(
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudDiscoveryengineV1alphaGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source for SuggestionDenyListEntry.
class GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequestInlineSource {
  /// A list of all denylist entries to import.
  ///
  /// Max of 1000 items.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaSuggestionDenyListEntry>? entries;

  GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequestInlineSource({
    this.entries,
  });

  GoogleCloudDiscoveryengineV1alphaImportSuggestionDenyListEntriesRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        entries:
            (json_['entries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSuggestionDenyListEntry.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entries != null) 'entries': entries!,
  };
}

/// Request message for the ImportUserEvents request.
class GoogleCloudDiscoveryengineV1alphaImportUserEventsRequest {
  /// BigQuery input source.
  GoogleCloudDiscoveryengineV1alphaBigQuerySource? bigquerySource;

  /// The desired location of errors incurred during the Import.
  ///
  /// Cannot be set for inline user event imports.
  GoogleCloudDiscoveryengineV1alphaImportErrorConfig? errorConfig;

  /// Cloud Storage location for the input content.
  GoogleCloudDiscoveryengineV1alphaGcsSource? gcsSource;

  /// The Inline source for the input content for UserEvents.
  GoogleCloudDiscoveryengineV1alphaImportUserEventsRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaImportUserEventsRequest({
    this.bigquerySource,
    this.errorConfig,
    this.gcsSource,
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaImportUserEventsRequest.fromJson(
    core.Map json_,
  ) : this(
        bigquerySource:
            json_.containsKey('bigquerySource')
                ? GoogleCloudDiscoveryengineV1alphaBigQuerySource.fromJson(
                  json_['bigquerySource']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        errorConfig:
            json_.containsKey('errorConfig')
                ? GoogleCloudDiscoveryengineV1alphaImportErrorConfig.fromJson(
                  json_['errorConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudDiscoveryengineV1alphaGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaImportUserEventsRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigquerySource != null) 'bigquerySource': bigquerySource!,
    if (errorConfig != null) 'errorConfig': errorConfig!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source for the input config for ImportUserEvents method.
class GoogleCloudDiscoveryengineV1alphaImportUserEventsRequestInlineSource {
  /// A list of user events to import.
  ///
  /// Recommended max of 10k items.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaUserEvent>? userEvents;

  GoogleCloudDiscoveryengineV1alphaImportUserEventsRequestInlineSource({
    this.userEvents,
  });

  GoogleCloudDiscoveryengineV1alphaImportUserEventsRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        userEvents:
            (json_['userEvents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaUserEvent.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (userEvents != null) 'userEvents': userEvents!,
  };
}

/// A floating point interval.
typedef GoogleCloudDiscoveryengineV1alphaInterval = $Interval01;

/// Language info for DataStore.
typedef GoogleCloudDiscoveryengineV1alphaLanguageInfo = $LanguageInfo;

/// Response message for ChunkService.ListChunks method.
class GoogleCloudDiscoveryengineV1alphaListChunksResponse {
  /// The Chunks.
  core.List<GoogleCloudDiscoveryengineV1alphaChunk>? chunks;

  /// A token that can be sent as ListChunksRequest.page_token to retrieve the
  /// next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListChunksResponse({
    this.chunks,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListChunksResponse.fromJson(core.Map json_)
    : this(
        chunks:
            (json_['chunks'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaChunk.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunks != null) 'chunks': chunks!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for CmekConfigService.ListCmekConfigs method.
class GoogleCloudDiscoveryengineV1alphaListCmekConfigsResponse {
  /// All the customer's CmekConfigs.
  core.List<GoogleCloudDiscoveryengineV1alphaCmekConfig>? cmekConfigs;

  GoogleCloudDiscoveryengineV1alphaListCmekConfigsResponse({this.cmekConfigs});

  GoogleCloudDiscoveryengineV1alphaListCmekConfigsResponse.fromJson(
    core.Map json_,
  ) : this(
        cmekConfigs:
            (json_['cmekConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCmekConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (cmekConfigs != null) 'cmekConfigs': cmekConfigs!,
  };
}

/// Response message for CollectionService.ListCollections method.
class GoogleCloudDiscoveryengineV1alphaListCollectionsResponse {
  /// The Collections.
  core.List<GoogleCloudDiscoveryengineV1alphaCollection>? collections;

  /// A token that can be sent as ListCollectionsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListCollectionsResponse({
    this.collections,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListCollectionsResponse.fromJson(
    core.Map json_,
  ) : this(
        collections:
            (json_['collections'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCollection.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (collections != null) 'collections': collections!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response for DataConnectorService.ListConnectorRuns method.
class GoogleCloudDiscoveryengineV1alphaListConnectorRunsResponse {
  /// List of ConnectorRuns.
  core.List<GoogleCloudDiscoveryengineV1alphaConnectorRun>? connectorRuns;

  /// A token that can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListConnectorRunsResponse({
    this.connectorRuns,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListConnectorRunsResponse.fromJson(
    core.Map json_,
  ) : this(
        connectorRuns:
            (json_['connectorRuns'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaConnectorRun.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectorRuns != null) 'connectorRuns': connectorRuns!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response for ListControls method.
class GoogleCloudDiscoveryengineV1alphaListControlsResponse {
  /// All the Controls for a given data store.
  core.List<GoogleCloudDiscoveryengineV1alphaControl>? controls;

  /// Pagination token, if not returned indicates the last page.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListControlsResponse({
    this.controls,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListControlsResponse.fromJson(core.Map json_)
    : this(
        controls:
            (json_['controls'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaControl.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (controls != null) 'controls': controls!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response for ListConversations method.
class GoogleCloudDiscoveryengineV1alphaListConversationsResponse {
  /// All the Conversations for a given data store.
  core.List<GoogleCloudDiscoveryengineV1alphaConversation>? conversations;

  /// Pagination token, if not returned indicates the last page.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListConversationsResponse({
    this.conversations,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListConversationsResponse.fromJson(
    core.Map json_,
  ) : this(
        conversations:
            (json_['conversations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaConversation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (conversations != null) 'conversations': conversations!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for SearchTuningService.ListCustomModels method.
class GoogleCloudDiscoveryengineV1alphaListCustomModelsResponse {
  /// List of custom tuning models.
  core.List<GoogleCloudDiscoveryengineV1alphaCustomTuningModel>? models;

  GoogleCloudDiscoveryengineV1alphaListCustomModelsResponse({this.models});

  GoogleCloudDiscoveryengineV1alphaListCustomModelsResponse.fromJson(
    core.Map json_,
  ) : this(
        models:
            (json_['models'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaCustomTuningModel.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (models != null) 'models': models!,
  };
}

/// Response message for DataStoreService.ListDataStores method.
class GoogleCloudDiscoveryengineV1alphaListDataStoresResponse {
  /// All the customer's DataStores.
  core.List<GoogleCloudDiscoveryengineV1alphaDataStore>? dataStores;

  /// A token that can be sent as ListDataStoresRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListDataStoresResponse({
    this.dataStores,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListDataStoresResponse.fromJson(
    core.Map json_,
  ) : this(
        dataStores:
            (json_['dataStores'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaDataStore.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStores != null) 'dataStores': dataStores!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for DocumentService.ListDocuments method.
class GoogleCloudDiscoveryengineV1alphaListDocumentsResponse {
  /// The Documents.
  core.List<GoogleCloudDiscoveryengineV1alphaDocument>? documents;

  /// A token that can be sent as ListDocumentsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListDocumentsResponse({
    this.documents,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListDocumentsResponse.fromJson(
    core.Map json_,
  ) : this(
        documents:
            (json_['documents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documents != null) 'documents': documents!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for EngineService.ListEngines method.
class GoogleCloudDiscoveryengineV1alphaListEnginesResponse {
  /// All the customer's Engines.
  core.List<GoogleCloudDiscoveryengineV1alphaEngine>? engines;

  /// Not supported.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListEnginesResponse({
    this.engines,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListEnginesResponse.fromJson(core.Map json_)
    : this(
        engines:
            (json_['engines'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaEngine.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (engines != null) 'engines': engines!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for EvaluationService.ListEvaluationResults method.
class GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponse {
  /// The evaluation results for the SampleQuerys.
  core.List<
    GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponseEvaluationResult
  >?
  evaluationResults;

  /// A token that can be sent as ListEvaluationResultsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponse({
    this.evaluationResults,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponse.fromJson(
    core.Map json_,
  ) : this(
        evaluationResults:
            (json_['evaluationResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponseEvaluationResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (evaluationResults != null) 'evaluationResults': evaluationResults!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Represents the results of an evaluation for a single SampleQuery.
class GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponseEvaluationResult {
  /// The metrics produced by the evaluation, for a given SampleQuery.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaQualityMetrics? qualityMetrics;

  /// The SampleQuery that was evaluated.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaSampleQuery? sampleQuery;

  GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponseEvaluationResult({
    this.qualityMetrics,
    this.sampleQuery,
  });

  GoogleCloudDiscoveryengineV1alphaListEvaluationResultsResponseEvaluationResult.fromJson(
    core.Map json_,
  ) : this(
        qualityMetrics:
            json_.containsKey('qualityMetrics')
                ? GoogleCloudDiscoveryengineV1alphaQualityMetrics.fromJson(
                  json_['qualityMetrics']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        sampleQuery:
            json_.containsKey('sampleQuery')
                ? GoogleCloudDiscoveryengineV1alphaSampleQuery.fromJson(
                  json_['sampleQuery'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (qualityMetrics != null) 'qualityMetrics': qualityMetrics!,
    if (sampleQuery != null) 'sampleQuery': sampleQuery!,
  };
}

/// Response message for EvaluationService.ListEvaluations method.
class GoogleCloudDiscoveryengineV1alphaListEvaluationsResponse {
  /// The Evaluations.
  core.List<GoogleCloudDiscoveryengineV1alphaEvaluation>? evaluations;

  /// A token that can be sent as ListEvaluationsRequest.page_token to retrieve
  /// the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListEvaluationsResponse({
    this.evaluations,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListEvaluationsResponse.fromJson(
    core.Map json_,
  ) : this(
        evaluations:
            (json_['evaluations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaEvaluation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (evaluations != null) 'evaluations': evaluations!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for SessionService.ListFiles method.
class GoogleCloudDiscoveryengineV1alphaListFilesResponse {
  /// The FileMetadatas.
  core.List<GoogleCloudDiscoveryengineV1alphaFileMetadata>? files;

  /// A token to retrieve next page of results.
  ///
  /// Pass this value in the ListFilesRequest.page_token field in the subsequent
  /// call to `ListFiles` method to retrieve the next page of results.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListFilesResponse({
    this.files,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListFilesResponse.fromJson(core.Map json_)
    : this(
        files:
            (json_['files'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaFileMetadata.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (files != null) 'files': files!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for IdentityMappingStoreService.ListIdentityMappingStores
class GoogleCloudDiscoveryengineV1alphaListIdentityMappingStoresResponse {
  /// The Identity Mapping Stores.
  core.List<GoogleCloudDiscoveryengineV1alphaIdentityMappingStore>?
  identityMappingStores;

  /// A token that can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListIdentityMappingStoresResponse({
    this.identityMappingStores,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListIdentityMappingStoresResponse.fromJson(
    core.Map json_,
  ) : this(
        identityMappingStores:
            (json_['identityMappingStores'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaIdentityMappingStore.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (identityMappingStores != null)
      'identityMappingStores': identityMappingStores!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for IdentityMappingStoreService.ListIdentityMappings
class GoogleCloudDiscoveryengineV1alphaListIdentityMappingsResponse {
  /// The Identity Mapping Entries.
  core.List<GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry>?
  identityMappingEntries;

  /// A token that can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  GoogleCloudDiscoveryengineV1alphaListIdentityMappingsResponse({
    this.identityMappingEntries,
    this.nextPageToken,
  });

  GoogleCloudDiscoveryengineV1alphaListIdentityMappingsResponse.fromJson(
    core.Map json_,
  ) : this(
        identityMappingEntries:
            (json_['identityMappingEntries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        nextPageToken: json_['nextPageToken'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (identityMappingEntries != null)
      'identityMappingEntries': identityMappingEntries!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
  };
}

/// Response message for SampleQueryService.ListSampleQueries method.
class GoogleCloudDiscoveryengineV1alphaListSampleQueriesResponse {
  /// A token that can be sent as ListSampleQueriesRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The SampleQuerys.
  core.List<GoogleCloudDiscoveryengineV1alphaSampleQuery>? sampleQueries;

  GoogleCloudDiscoveryengineV1alphaListSampleQueriesResponse({
    this.nextPageToken,
    this.sampleQueries,
  });

  GoogleCloudDiscoveryengineV1alphaListSampleQueriesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        sampleQueries:
            (json_['sampleQueries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSampleQuery.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (sampleQueries != null) 'sampleQueries': sampleQueries!,
  };
}

/// Response message for SampleQuerySetService.ListSampleQuerySets method.
class GoogleCloudDiscoveryengineV1alphaListSampleQuerySetsResponse {
  /// A token that can be sent as ListSampleQuerySetsRequest.page_token to
  /// retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The SampleQuerySets.
  core.List<GoogleCloudDiscoveryengineV1alphaSampleQuerySet>? sampleQuerySets;

  GoogleCloudDiscoveryengineV1alphaListSampleQuerySetsResponse({
    this.nextPageToken,
    this.sampleQuerySets,
  });

  GoogleCloudDiscoveryengineV1alphaListSampleQuerySetsResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        sampleQuerySets:
            (json_['sampleQuerySets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSampleQuerySet.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (sampleQuerySets != null) 'sampleQuerySets': sampleQuerySets!,
  };
}

/// Response message for SchemaService.ListSchemas method.
class GoogleCloudDiscoveryengineV1alphaListSchemasResponse {
  /// A token that can be sent as ListSchemasRequest.page_token to retrieve the
  /// next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// The Schemas.
  core.List<GoogleCloudDiscoveryengineV1alphaSchema>? schemas;

  GoogleCloudDiscoveryengineV1alphaListSchemasResponse({
    this.nextPageToken,
    this.schemas,
  });

  GoogleCloudDiscoveryengineV1alphaListSchemasResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        schemas:
            (json_['schemas'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaSchema.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (schemas != null) 'schemas': schemas!,
  };
}

/// Response for ListServingConfigs method.
class GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse {
  /// Pagination token, if not returned indicates the last page.
  core.String? nextPageToken;

  /// All the ServingConfigs for a given dataStore.
  core.List<GoogleCloudDiscoveryengineV1alphaServingConfig>? servingConfigs;

  GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse({
    this.nextPageToken,
    this.servingConfigs,
  });

  GoogleCloudDiscoveryengineV1alphaListServingConfigsResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        servingConfigs:
            (json_['servingConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (servingConfigs != null) 'servingConfigs': servingConfigs!,
  };
}

/// Response for ListSessions method.
class GoogleCloudDiscoveryengineV1alphaListSessionsResponse {
  /// Pagination token, if not returned indicates the last page.
  core.String? nextPageToken;

  /// All the Sessions for a given data store.
  core.List<GoogleCloudDiscoveryengineV1alphaSession>? sessions;

  GoogleCloudDiscoveryengineV1alphaListSessionsResponse({
    this.nextPageToken,
    this.sessions,
  });

  GoogleCloudDiscoveryengineV1alphaListSessionsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        sessions:
            (json_['sessions'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaSession.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (sessions != null) 'sessions': sessions!,
  };
}

/// Response message for SiteSearchEngineService.ListTargetSites method.
class GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse {
  /// A token that can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// List of TargetSites.
  core.List<GoogleCloudDiscoveryengineV1alphaTargetSite>? targetSites;

  /// The total number of items matching the request.
  ///
  /// This will always be populated in the response.
  core.int? totalSize;

  GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse({
    this.nextPageToken,
    this.targetSites,
    this.totalSize,
  });

  GoogleCloudDiscoveryengineV1alphaListTargetSitesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        targetSites:
            (json_['targetSites'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaTargetSite.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        totalSize: json_['totalSize'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (targetSites != null) 'targetSites': targetSites!,
    if (totalSize != null) 'totalSize': totalSize!,
  };
}

/// Response message for UserLicenseService.ListUserLicenses.
class GoogleCloudDiscoveryengineV1alphaListUserLicensesResponse {
  /// A token, which can be sent as `page_token` to retrieve the next page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// All the customer's UserLicenses.
  core.List<GoogleCloudDiscoveryengineV1alphaUserLicense>? userLicenses;

  GoogleCloudDiscoveryengineV1alphaListUserLicensesResponse({
    this.nextPageToken,
    this.userLicenses,
  });

  GoogleCloudDiscoveryengineV1alphaListUserLicensesResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        userLicenses:
            (json_['userLicenses'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaUserLicense.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (userLicenses != null) 'userLicenses': userLicenses!,
  };
}

/// Media-specific user event information.
typedef GoogleCloudDiscoveryengineV1alphaMediaInfo = $MediaInfo;

/// Configuration for Natural Language Query Understanding.
typedef GoogleCloudDiscoveryengineV1alphaNaturalLanguageQueryUnderstandingConfig =
    $NaturalLanguageQueryUnderstandingConfig;

/// Request message for CrawlRateManagementService.ObtainCrawlRate method.
typedef GoogleCloudDiscoveryengineV1alphaObtainCrawlRateRequest =
    $ObtainCrawlRateRequest;

/// Response message for CrawlRateManagementService.ObtainCrawlRate method.
///
/// The response contains organcic or dedicated crawl rate time series data for
/// monitoring, depending on whether dedicated crawl rate is set.
class GoogleCloudDiscoveryengineV1alphaObtainCrawlRateResponse {
  /// The historical dedicated crawl rate timeseries data, used for monitoring.
  GoogleCloudDiscoveryengineV1alphaDedicatedCrawlRateTimeSeries?
  dedicatedCrawlRateTimeSeries;

  /// Errors from service when handling the request.
  GoogleRpcStatus? error;

  /// The historical organic crawl rate timeseries data, used for monitoring.
  GoogleCloudDiscoveryengineV1alphaOrganicCrawlRateTimeSeries?
  organicCrawlRateTimeSeries;

  /// The state of the response.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The state is unspecified.
  /// - "SUCCEEDED" : The state is successful.
  /// - "FAILED" : The state is failed.
  core.String? state;

  GoogleCloudDiscoveryengineV1alphaObtainCrawlRateResponse({
    this.dedicatedCrawlRateTimeSeries,
    this.error,
    this.organicCrawlRateTimeSeries,
    this.state,
  });

  GoogleCloudDiscoveryengineV1alphaObtainCrawlRateResponse.fromJson(
    core.Map json_,
  ) : this(
        dedicatedCrawlRateTimeSeries:
            json_.containsKey('dedicatedCrawlRateTimeSeries')
                ? GoogleCloudDiscoveryengineV1alphaDedicatedCrawlRateTimeSeries.fromJson(
                  json_['dedicatedCrawlRateTimeSeries']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        organicCrawlRateTimeSeries:
            json_.containsKey('organicCrawlRateTimeSeries')
                ? GoogleCloudDiscoveryengineV1alphaOrganicCrawlRateTimeSeries.fromJson(
                  json_['organicCrawlRateTimeSeries']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        state: json_['state'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dedicatedCrawlRateTimeSeries != null)
      'dedicatedCrawlRateTimeSeries': dedicatedCrawlRateTimeSeries!,
    if (error != null) 'error': error!,
    if (organicCrawlRateTimeSeries != null)
      'organicCrawlRateTimeSeries': organicCrawlRateTimeSeries!,
    if (state != null) 'state': state!,
  };
}

/// The historical organic crawl rate timeseries data, used for monitoring.
///
/// Organic crawl is auto-determined by Google to crawl the user's website when
/// dedicate crawl is not set. Crawl rate is the QPS of crawl request Google
/// sends to the user's website.
class GoogleCloudDiscoveryengineV1alphaOrganicCrawlRateTimeSeries {
  /// Google's organic crawl rate time series, which is the sum of all
  /// googlebots' crawl rate.
  ///
  /// Please refer to
  /// https://developers.google.com/search/docs/crawling-indexing/overview-google-crawlers
  /// for more details about googlebots.
  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries? googleOrganicCrawlRate;

  /// Vertex AI's organic crawl rate time series, which is the crawl rate of
  /// Google-CloudVertexBot when dedicate crawl is not set.
  ///
  /// Please refer to
  /// https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers#google-cloudvertexbot
  /// for more details about Google-CloudVertexBot.
  GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries?
  vertexAiOrganicCrawlRate;

  GoogleCloudDiscoveryengineV1alphaOrganicCrawlRateTimeSeries({
    this.googleOrganicCrawlRate,
    this.vertexAiOrganicCrawlRate,
  });

  GoogleCloudDiscoveryengineV1alphaOrganicCrawlRateTimeSeries.fromJson(
    core.Map json_,
  ) : this(
        googleOrganicCrawlRate:
            json_.containsKey('googleOrganicCrawlRate')
                ? GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries.fromJson(
                  json_['googleOrganicCrawlRate']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexAiOrganicCrawlRate:
            json_.containsKey('vertexAiOrganicCrawlRate')
                ? GoogleCloudDiscoveryengineV1alphaCrawlRateTimeSeries.fromJson(
                  json_['vertexAiOrganicCrawlRate']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (googleOrganicCrawlRate != null)
      'googleOrganicCrawlRate': googleOrganicCrawlRate!,
    if (vertexAiOrganicCrawlRate != null)
      'vertexAiOrganicCrawlRate': vertexAiOrganicCrawlRate!,
  };
}

/// The output configuration setting.
class GoogleCloudDiscoveryengineV1alphaOutputConfig {
  /// The BigQuery location where the output is to be written to.
  GoogleCloudDiscoveryengineV1alphaBigQueryDestination? bigqueryDestination;

  GoogleCloudDiscoveryengineV1alphaOutputConfig({this.bigqueryDestination});

  GoogleCloudDiscoveryengineV1alphaOutputConfig.fromJson(core.Map json_)
    : this(
        bigqueryDestination:
            json_.containsKey('bigqueryDestination')
                ? GoogleCloudDiscoveryengineV1alphaBigQueryDestination.fromJson(
                  json_['bigqueryDestination']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!,
  };
}

/// Detailed page information.
typedef GoogleCloudDiscoveryengineV1alphaPageInfo = $PageInfo00;

/// Detailed panel information associated with a user event.
class GoogleCloudDiscoveryengineV1alphaPanelInfo {
  /// The display name of the panel.
  core.String? displayName;

  /// The document IDs associated with this panel.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaDocumentInfo>? documents;

  /// The panel ID.
  ///
  /// Required.
  core.String? panelId;

  /// The ordered position of the panel, if shown to the user with other panels.
  ///
  /// If set, then total_panels must also be set.
  core.int? panelPosition;

  /// The total number of panels, including this one, shown to the user.
  ///
  /// Must be set if panel_position is set.
  core.int? totalPanels;

  GoogleCloudDiscoveryengineV1alphaPanelInfo({
    this.displayName,
    this.documents,
    this.panelId,
    this.panelPosition,
    this.totalPanels,
  });

  GoogleCloudDiscoveryengineV1alphaPanelInfo.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        documents:
            (json_['documents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaDocumentInfo.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        panelId: json_['panelId'] as core.String?,
        panelPosition: json_['panelPosition'] as core.int?,
        totalPanels: json_['totalPanels'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (documents != null) 'documents': documents!,
    if (panelId != null) 'panelId': panelId!,
    if (panelPosition != null) 'panelPosition': panelPosition!,
    if (totalPanels != null) 'totalPanels': totalPanels!,
  };
}

/// Request for pausing training of an engine.
typedef GoogleCloudDiscoveryengineV1alphaPauseEngineRequest = $Empty;

/// Principal identifier of a user or a group.
typedef GoogleCloudDiscoveryengineV1alphaPrincipal = $Principal;

/// Document captures all raw metadata information of items to be recommended or
/// searched.
class GoogleCloudDiscoveryengineV1alphaProcessedDocument {
  /// Full resource name of the referenced document, in the format `projects / *
  /// /locations / * /collections / * /dataStores / * /branches / * /documents /
  /// * `.
  ///
  /// Required.
  core.String? document;

  /// The JSON string representation of the processed document.
  core.String? jsonData;

  GoogleCloudDiscoveryengineV1alphaProcessedDocument({
    this.document,
    this.jsonData,
  });

  GoogleCloudDiscoveryengineV1alphaProcessedDocument.fromJson(core.Map json_)
    : this(
        document: json_['document'] as core.String?,
        jsonData: json_['jsonData'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (jsonData != null) 'jsonData': jsonData!,
  };
}

/// Metadata and configurations for a Google Cloud project in the service.
class GoogleCloudDiscoveryengineV1alphaProject {
  /// The timestamp when this project is created.
  ///
  /// Output only.
  core.String? createTime;

  /// Full resource name of the project, for example `projects/{project}`.
  ///
  /// Note that when making requests, project number and project id are both
  /// acceptable, but the server will always respond in project number.
  ///
  /// Output only.
  core.String? name;

  /// The timestamp when this project is successfully provisioned.
  ///
  /// Empty value means this project is still provisioning and is not ready for
  /// use.
  ///
  /// Output only.
  core.String? provisionCompletionTime;

  /// A map of terms of services.
  ///
  /// The key is the `id` of ServiceTerms.
  ///
  /// Output only.
  core.Map<core.String, GoogleCloudDiscoveryengineV1alphaProjectServiceTerms>?
  serviceTermsMap;

  GoogleCloudDiscoveryengineV1alphaProject({
    this.createTime,
    this.name,
    this.provisionCompletionTime,
    this.serviceTermsMap,
  });

  GoogleCloudDiscoveryengineV1alphaProject.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        name: json_['name'] as core.String?,
        provisionCompletionTime:
            json_['provisionCompletionTime'] as core.String?,
        serviceTermsMap: (json_['serviceTermsMap']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudDiscoveryengineV1alphaProjectServiceTerms.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (name != null) 'name': name!,
    if (provisionCompletionTime != null)
      'provisionCompletionTime': provisionCompletionTime!,
    if (serviceTermsMap != null) 'serviceTermsMap': serviceTermsMap!,
  };
}

/// Metadata about the terms of service.
class GoogleCloudDiscoveryengineV1alphaProjectServiceTerms {
  /// The last time when the project agreed to the terms of service.
  core.String? acceptTime;

  /// The last time when the project declined or revoked the agreement to terms
  /// of service.
  core.String? declineTime;

  /// The unique identifier of this terms of service.
  ///
  /// Available terms: * `GA_DATA_USE_TERMS`:
  /// [Terms for data use](https://cloud.google.com/retail/data-use-terms). When
  /// using this as `id`, the acceptable version to provide is `2022-11-23`.
  core.String? id;

  /// Whether the project has accepted/rejected the service terms or it is still
  /// pending.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : The default value of the enum. This value is not
  /// actually used.
  /// - "TERMS_ACCEPTED" : The project has given consent to the terms of
  /// service.
  /// - "TERMS_PENDING" : The project is pending to review and accept the terms
  /// of service.
  /// - "TERMS_DECLINED" : The project has declined or revoked the agreement to
  /// terms of service.
  core.String? state;

  /// The version string of the terms of service.
  ///
  /// For acceptable values, see the comments for id above.
  core.String? version;

  GoogleCloudDiscoveryengineV1alphaProjectServiceTerms({
    this.acceptTime,
    this.declineTime,
    this.id,
    this.state,
    this.version,
  });

  GoogleCloudDiscoveryengineV1alphaProjectServiceTerms.fromJson(core.Map json_)
    : this(
        acceptTime: json_['acceptTime'] as core.String?,
        declineTime: json_['declineTime'] as core.String?,
        id: json_['id'] as core.String?,
        state: json_['state'] as core.String?,
        version: json_['version'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceptTime != null) 'acceptTime': acceptTime!,
    if (declineTime != null) 'declineTime': declineTime!,
    if (id != null) 'id': id!,
    if (state != null) 'state': state!,
    if (version != null) 'version': version!,
  };
}

/// Request for ProjectService.ProvisionProject method.
class GoogleCloudDiscoveryengineV1alphaProvisionProjectRequest {
  /// Set to `true` to specify that caller has read and would like to give
  /// consent to the
  /// [Terms for data use](https://cloud.google.com/retail/data-use-terms).
  ///
  /// Required.
  core.bool? acceptDataUseTerms;

  /// The version of the
  /// [Terms for data use](https://cloud.google.com/retail/data-use-terms) that
  /// caller has read and would like to give consent to.
  ///
  /// Acceptable version is `2022-11-23`, and this may change over time.
  ///
  /// Required.
  core.String? dataUseTermsVersion;

  /// Parameters for Agentspace.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaProvisionProjectRequestSaasParams?
  saasParams;

  GoogleCloudDiscoveryengineV1alphaProvisionProjectRequest({
    this.acceptDataUseTerms,
    this.dataUseTermsVersion,
    this.saasParams,
  });

  GoogleCloudDiscoveryengineV1alphaProvisionProjectRequest.fromJson(
    core.Map json_,
  ) : this(
        acceptDataUseTerms: json_['acceptDataUseTerms'] as core.bool?,
        dataUseTermsVersion: json_['dataUseTermsVersion'] as core.String?,
        saasParams:
            json_.containsKey('saasParams')
                ? GoogleCloudDiscoveryengineV1alphaProvisionProjectRequestSaasParams.fromJson(
                  json_['saasParams'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (acceptDataUseTerms != null) 'acceptDataUseTerms': acceptDataUseTerms!,
    if (dataUseTermsVersion != null)
      'dataUseTermsVersion': dataUseTermsVersion!,
    if (saasParams != null) 'saasParams': saasParams!,
  };
}

/// Parameters for Agentspace.
typedef GoogleCloudDiscoveryengineV1alphaProvisionProjectRequestSaasParams =
    $ProvisionProjectRequestSaasParams;

/// Request message for CompletionService.PurgeCompletionSuggestions method.
typedef GoogleCloudDiscoveryengineV1alphaPurgeCompletionSuggestionsRequest =
    $Empty;

/// Request message for DocumentService.PurgeDocuments method.
class GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequest {
  /// The desired location of errors incurred during the purge.
  GoogleCloudDiscoveryengineV1alphaPurgeErrorConfig? errorConfig;

  /// Filter matching documents to purge.
  ///
  /// Only currently supported value is `*` (all items).
  ///
  /// Required.
  core.String? filter;

  /// Actually performs the purge.
  ///
  /// If `force` is set to false, return the expected purge count without
  /// deleting any documents.
  core.bool? force;

  /// Cloud Storage location for the input content.
  ///
  /// Supported `data_schema`: * `document_id`: One valid Document.id per line.
  GoogleCloudDiscoveryengineV1alphaGcsSource? gcsSource;

  /// Inline source for the input content for purge.
  GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequest({
    this.errorConfig,
    this.filter,
    this.force,
    this.gcsSource,
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequest.fromJson(
    core.Map json_,
  ) : this(
        errorConfig:
            json_.containsKey('errorConfig')
                ? GoogleCloudDiscoveryengineV1alphaPurgeErrorConfig.fromJson(
                  json_['errorConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
        gcsSource:
            json_.containsKey('gcsSource')
                ? GoogleCloudDiscoveryengineV1alphaGcsSource.fromJson(
                  json_['gcsSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorConfig != null) 'errorConfig': errorConfig!,
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
    if (gcsSource != null) 'gcsSource': gcsSource!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source for the input config for DocumentService.PurgeDocuments
/// method.
typedef GoogleCloudDiscoveryengineV1alphaPurgeDocumentsRequestInlineSource =
    $PurgeDocumentsRequestInlineSource;

/// Configuration of destination for Purge related errors.
typedef GoogleCloudDiscoveryengineV1alphaPurgeErrorConfig = $PurgeErrorConfig;

/// Request message for IdentityMappingStoreService.PurgeIdentityMappings
class GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequest {
  /// Filter matching identity mappings to purge.
  ///
  /// The eligible field for filtering is: * `update_time`: in ISO 8601 "zulu"
  /// format. * `external_id` Examples: * Deleting all identity mappings updated
  /// in a time range: `update_time > "2012-04-23T18:25:43.511Z" AND update_time
  /// < "2012-04-23T18:30:43.511Z"` * Deleting all identity mappings for a given
  /// external_id: `external_id = "id1"` * Deleting all identity mappings inside
  /// an identity mapping store: `*` The filtering fields are assumed to have an
  /// implicit AND. Should not be used with source. An error will be thrown, if
  /// both are provided.
  core.String? filter;

  /// Actually performs the purge.
  ///
  /// If `force` is set to false, return the expected purge count without
  /// deleting any identity mappings. This field is only supported for purge
  /// with filter. For input source this field is ignored and data will be
  /// purged regardless of the value of this field.
  core.bool? force;

  /// The inline source to purge identity mapping entries from.
  GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequestInlineSource?
  inlineSource;

  GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequest({
    this.filter,
    this.force,
    this.inlineSource,
  });

  GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequest.fromJson(
    core.Map json_,
  ) : this(
        filter: json_['filter'] as core.String?,
        force: json_['force'] as core.bool?,
        inlineSource:
            json_.containsKey('inlineSource')
                ? GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequestInlineSource.fromJson(
                  json_['inlineSource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (force != null) 'force': force!,
    if (inlineSource != null) 'inlineSource': inlineSource!,
  };
}

/// The inline source to purge identity mapping entries from.
class GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequestInlineSource {
  /// A maximum of 10000 entries can be purged at one time
  core.List<GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry>?
  identityMappingEntries;

  GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequestInlineSource({
    this.identityMappingEntries,
  });

  GoogleCloudDiscoveryengineV1alphaPurgeIdentityMappingsRequestInlineSource.fromJson(
    core.Map json_,
  ) : this(
        identityMappingEntries:
            (json_['identityMappingEntries'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaIdentityMappingEntry.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (identityMappingEntries != null)
      'identityMappingEntries': identityMappingEntries!,
  };
}

/// Request message for CompletionService.PurgeSuggestionDenyListEntries method.
typedef GoogleCloudDiscoveryengineV1alphaPurgeSuggestionDenyListEntriesRequest =
    $Empty;

/// Request message for PurgeUserEvents method.
typedef GoogleCloudDiscoveryengineV1alphaPurgeUserEventsRequest =
    $PurgeUserEventsRequest00;

/// Describes the metrics produced by the evaluation.
class GoogleCloudDiscoveryengineV1alphaQualityMetrics {
  /// Normalized discounted cumulative gain (NDCG) per document, at various
  /// top-k cutoff levels.
  ///
  /// NDCG measures the ranking quality, giving higher relevance to top results.
  /// Example (top-3): Suppose SampleQuery with three retrieved documents (D1,
  /// D2, D3) and binary relevance judgements (1 for relevant, 0 for not
  /// relevant): Retrieved: \[D3 (0), D1 (1), D2 (1)\] Ideal: \[D1 (1), D2 (1),
  /// D3 (0)\] Calculate NDCG@3 for each SampleQuery: * DCG@3: 0/log2(1+1) +
  /// 1/log2(2+1) + 1/log2(3+1) = 1.13 * Ideal DCG@3: 1/log2(1+1) + 1/log2(2+1)
  /// + 0/log2(3+1) = 1.63 * NDCG@3: 1.13/1.63 = 0.693
  GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics? docNdcg;

  /// Precision per document, at various top-k cutoff levels.
  ///
  /// Precision is the fraction of retrieved documents that are relevant.
  /// Example (top-5): * For a single SampleQuery, If 4 out of 5 retrieved
  /// documents in the top-5 are relevant, precision@5 = 4/5 = 0.8
  GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics? docPrecision;

  /// Recall per document, at various top-k cutoff levels.
  ///
  /// Recall is the fraction of relevant documents retrieved out of all relevant
  /// documents. Example (top-5): * For a single SampleQuery, If 3 out of 5
  /// relevant documents are retrieved in the top-5, recall@5 = 3/5 = 0.6
  GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics? docRecall;

  /// Normalized discounted cumulative gain (NDCG) per page, at various top-k
  /// cutoff levels.
  ///
  /// NDCG measures the ranking quality, giving higher relevance to top results.
  /// Example (top-3): Suppose SampleQuery with three retrieved pages (P1, P2,
  /// P3) and binary relevance judgements (1 for relevant, 0 for not relevant):
  /// Retrieved: \[P3 (0), P1 (1), P2 (1)\] Ideal: \[P1 (1), P2 (1), P3 (0)\]
  /// Calculate NDCG@3 for SampleQuery: * DCG@3: 0/log2(1+1) + 1/log2(2+1) +
  /// 1/log2(3+1) = 1.13 * Ideal DCG@3: 1/log2(1+1) + 1/log2(2+1) + 0/log2(3+1)
  /// = 1.63 * NDCG@3: 1.13/1.63 = 0.693
  GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics? pageNdcg;

  /// Recall per page, at various top-k cutoff levels.
  ///
  /// Recall is the fraction of relevant pages retrieved out of all relevant
  /// pages. Example (top-5): * For a single SampleQuery, if 3 out of 5 relevant
  /// pages are retrieved in the top-5, recall@5 = 3/5 = 0.6
  GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics? pageRecall;

  GoogleCloudDiscoveryengineV1alphaQualityMetrics({
    this.docNdcg,
    this.docPrecision,
    this.docRecall,
    this.pageNdcg,
    this.pageRecall,
  });

  GoogleCloudDiscoveryengineV1alphaQualityMetrics.fromJson(core.Map json_)
    : this(
        docNdcg:
            json_.containsKey('docNdcg')
                ? GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics.fromJson(
                  json_['docNdcg'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        docPrecision:
            json_.containsKey('docPrecision')
                ? GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics.fromJson(
                  json_['docPrecision'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        docRecall:
            json_.containsKey('docRecall')
                ? GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics.fromJson(
                  json_['docRecall'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        pageNdcg:
            json_.containsKey('pageNdcg')
                ? GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics.fromJson(
                  json_['pageNdcg'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        pageRecall:
            json_.containsKey('pageRecall')
                ? GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics.fromJson(
                  json_['pageRecall'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (docNdcg != null) 'docNdcg': docNdcg!,
    if (docPrecision != null) 'docPrecision': docPrecision!,
    if (docRecall != null) 'docRecall': docRecall!,
    if (pageNdcg != null) 'pageNdcg': pageNdcg!,
    if (pageRecall != null) 'pageRecall': pageRecall!,
  };
}

/// Stores the metric values at specific top-k levels.
typedef GoogleCloudDiscoveryengineV1alphaQualityMetricsTopkMetrics =
    $QualityMetricsTopkMetrics;

/// Defines a user inputed query.
typedef GoogleCloudDiscoveryengineV1alphaQuery = $Query00;

/// Request message for RankService.Rank method.
class GoogleCloudDiscoveryengineV1alphaRankRequest {
  /// If true, the response will contain only record ID and score.
  ///
  /// By default, it is false, the response will contain record details.
  core.bool? ignoreRecordDetailsInResponse;

  /// The identifier of the model to use.
  ///
  /// It is one of: * `semantic-ranker-512@latest`: Semantic ranking model with
  /// maximum input token size 512. It is set to `semantic-ranker-512@latest` by
  /// default if unspecified.
  core.String? model;

  /// The query to use.
  core.String? query;

  /// A list of records to rank.
  ///
  /// Required.
  core.List<GoogleCloudDiscoveryengineV1alphaRankingRecord>? records;

  /// The number of results to return.
  ///
  /// If this is unset or no bigger than zero, returns all results.
  core.int? topN;

  /// The user labels applied to a resource must meet the following
  /// requirements: * Each resource can have multiple labels, up to a maximum of
  /// 64.
  ///
  /// * Each label must be a key-value pair. * Keys have a minimum length of 1
  /// character and a maximum length of 63 characters and cannot be empty.
  /// Values can be empty and have a maximum length of 63 characters. * Keys and
  /// values can contain only lowercase letters, numeric characters,
  /// underscores, and dashes. All characters must use UTF-8 encoding, and
  /// international characters are allowed. * The key portion of a label must be
  /// unique. However, you can use the same key with multiple resources. * Keys
  /// must start with a lowercase letter or international character. See
  /// [Google Cloud Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
  /// for more details.
  core.Map<core.String, core.String>? userLabels;

  GoogleCloudDiscoveryengineV1alphaRankRequest({
    this.ignoreRecordDetailsInResponse,
    this.model,
    this.query,
    this.records,
    this.topN,
    this.userLabels,
  });

  GoogleCloudDiscoveryengineV1alphaRankRequest.fromJson(core.Map json_)
    : this(
        ignoreRecordDetailsInResponse:
            json_['ignoreRecordDetailsInResponse'] as core.bool?,
        model: json_['model'] as core.String?,
        query: json_['query'] as core.String?,
        records:
            (json_['records'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaRankingRecord.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        topN: json_['topN'] as core.int?,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ignoreRecordDetailsInResponse != null)
      'ignoreRecordDetailsInResponse': ignoreRecordDetailsInResponse!,
    if (model != null) 'model': model!,
    if (query != null) 'query': query!,
    if (records != null) 'records': records!,
    if (topN != null) 'topN': topN!,
    if (userLabels != null) 'userLabels': userLabels!,
  };
}

/// Response message for RankService.Rank method.
class GoogleCloudDiscoveryengineV1alphaRankResponse {
  /// A list of records sorted by descending score.
  core.List<GoogleCloudDiscoveryengineV1alphaRankingRecord>? records;

  GoogleCloudDiscoveryengineV1alphaRankResponse({this.records});

  GoogleCloudDiscoveryengineV1alphaRankResponse.fromJson(core.Map json_)
    : this(
        records:
            (json_['records'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaRankingRecord.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (records != null) 'records': records!,
  };
}

/// Record message for RankService.Rank method.
typedef GoogleCloudDiscoveryengineV1alphaRankingRecord = $RankingRecord;

/// Request message for Recommend method.
class GoogleCloudDiscoveryengineV1alphaRecommendRequest {
  /// Filter for restricting recommendation results with a length limit of 5,000
  /// characters.
  ///
  /// Currently, only filter expressions on the `filter_tags` attribute is
  /// supported. Examples: * `(filter_tags: ANY("Red", "Blue") OR filter_tags:
  /// ANY("Hot", "Cold"))` * `(filter_tags: ANY("Red", "Blue")) AND NOT
  /// (filter_tags: ANY("Green"))` If `attributeFilteringSyntax` is set to true
  /// under the `params` field, then attribute-based expressions are expected
  /// instead of the above described tag-based syntax. Examples: * (language:
  /// ANY("en", "es")) AND NOT (categories: ANY("Movie")) * (available: true)
  /// AND (language: ANY("en", "es")) OR (categories: ANY("Movie")) If your
  /// filter blocks all results, the API returns generic (unfiltered) popular
  /// Documents. If you only want results strictly matching the filters, set
  /// `strictFiltering` to `true` in RecommendRequest.params to receive empty
  /// results instead. Note that the API never returns Documents with
  /// `storageStatus` as `EXPIRED` or `DELETED` regardless of filter choices.
  core.String? filter;

  /// Maximum number of results to return.
  ///
  /// Set this property to the number of recommendation results needed. If zero,
  /// the service chooses a reasonable default. The maximum allowed value is
  /// 100. Values above 100 are set to 100.
  core.int? pageSize;

  /// Additional domain specific parameters for the recommendations.
  ///
  /// Allowed values: * `returnDocument`: Boolean. If set to `true`, the
  /// associated Document object is returned in
  /// RecommendResponse.RecommendationResult.document. * `returnScore`: Boolean.
  /// If set to true, the recommendation score corresponding to each returned
  /// Document is set in RecommendResponse.RecommendationResult.metadata. The
  /// given score indicates the probability of a Document conversion given the
  /// user's context and history. * `strictFiltering`: Boolean. True by default.
  /// If set to `false`, the service returns generic (unfiltered) popular
  /// Documents instead of empty if your filter blocks all recommendation
  /// results. * `diversityLevel`: String. Default empty. If set to be
  /// non-empty, then it needs to be one of: * `no-diversity` * `low-diversity`
  /// * `medium-diversity` * `high-diversity` * `auto-diversity` This gives
  /// request-level control and adjusts recommendation results based on Document
  /// category. * `attributeFilteringSyntax`: Boolean. False by default. If set
  /// to true, the `filter` field is interpreted according to the new,
  /// attribute-based syntax.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? params;

  /// Context about the user, what they are looking at and what action they took
  /// to trigger the Recommend request.
  ///
  /// Note that this user event detail won't be ingested to userEvent logs.
  /// Thus, a separate userEvent write request is required for event logging.
  /// Don't set UserEvent.user_pseudo_id or UserEvent.user_info.user_id to the
  /// same fixed ID for different users. If you are trying to receive
  /// non-personalized recommendations (not recommended; this can negatively
  /// impact model performance), instead set UserEvent.user_pseudo_id to a
  /// random unique ID and leave UserEvent.user_info.user_id unset.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaUserEvent? userEvent;

  /// The user labels applied to a resource must meet the following
  /// requirements: * Each resource can have multiple labels, up to a maximum of
  /// 64.
  ///
  /// * Each label must be a key-value pair. * Keys have a minimum length of 1
  /// character and a maximum length of 63 characters and cannot be empty.
  /// Values can be empty and have a maximum length of 63 characters. * Keys and
  /// values can contain only lowercase letters, numeric characters,
  /// underscores, and dashes. All characters must use UTF-8 encoding, and
  /// international characters are allowed. * The key portion of a label must be
  /// unique. However, you can use the same key with multiple resources. * Keys
  /// must start with a lowercase letter or international character. See
  /// [Requirements for labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
  /// for more details.
  core.Map<core.String, core.String>? userLabels;

  /// Use validate only mode for this recommendation query.
  ///
  /// If set to `true`, a fake model is used that returns arbitrary Document
  /// IDs. Note that the validate only mode should only be used for testing the
  /// API, or if the model is not ready.
  core.bool? validateOnly;

  GoogleCloudDiscoveryengineV1alphaRecommendRequest({
    this.filter,
    this.pageSize,
    this.params,
    this.userEvent,
    this.userLabels,
    this.validateOnly,
  });

  GoogleCloudDiscoveryengineV1alphaRecommendRequest.fromJson(core.Map json_)
    : this(
        filter: json_['filter'] as core.String?,
        pageSize: json_['pageSize'] as core.int?,
        params:
            json_.containsKey('params')
                ? json_['params'] as core.Map<core.String, core.dynamic>
                : null,
        userEvent:
            json_.containsKey('userEvent')
                ? GoogleCloudDiscoveryengineV1alphaUserEvent.fromJson(
                  json_['userEvent'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (filter != null) 'filter': filter!,
    if (pageSize != null) 'pageSize': pageSize!,
    if (params != null) 'params': params!,
    if (userEvent != null) 'userEvent': userEvent!,
    if (userLabels != null) 'userLabels': userLabels!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// Response message for Recommend method.
class GoogleCloudDiscoveryengineV1alphaRecommendResponse {
  /// A unique attribution token.
  ///
  /// This should be included in the UserEvent logs resulting from this
  /// recommendation, which enables accurate attribution of recommendation model
  /// performance.
  core.String? attributionToken;

  /// IDs of documents in the request that were missing from the default Branch
  /// associated with the requested ServingConfig.
  core.List<core.String>? missingIds;

  /// A list of recommended Documents.
  ///
  /// The order represents the ranking (from the most relevant Document to the
  /// least).
  core.List<
    GoogleCloudDiscoveryengineV1alphaRecommendResponseRecommendationResult
  >?
  results;

  /// True if RecommendRequest.validate_only was set.
  core.bool? validateOnly;

  GoogleCloudDiscoveryengineV1alphaRecommendResponse({
    this.attributionToken,
    this.missingIds,
    this.results,
    this.validateOnly,
  });

  GoogleCloudDiscoveryengineV1alphaRecommendResponse.fromJson(core.Map json_)
    : this(
        attributionToken: json_['attributionToken'] as core.String?,
        missingIds:
            (json_['missingIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        results:
            (json_['results'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaRecommendResponseRecommendationResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        validateOnly: json_['validateOnly'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributionToken != null) 'attributionToken': attributionToken!,
    if (missingIds != null) 'missingIds': missingIds!,
    if (results != null) 'results': results!,
    if (validateOnly != null) 'validateOnly': validateOnly!,
  };
}

/// RecommendationResult represents a generic recommendation result with
/// associated metadata.
class GoogleCloudDiscoveryengineV1alphaRecommendResponseRecommendationResult {
  /// Set if `returnDocument` is set to true in RecommendRequest.params.
  GoogleCloudDiscoveryengineV1alphaDocument? document;

  /// Resource ID of the recommended Document.
  core.String? id;

  /// Additional Document metadata or annotations.
  ///
  /// Possible values: * `score`: Recommendation score in double value. Is set
  /// if `returnScore` is set to true in RecommendRequest.params.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  GoogleCloudDiscoveryengineV1alphaRecommendResponseRecommendationResult({
    this.document,
    this.id,
    this.metadata,
  });

  GoogleCloudDiscoveryengineV1alphaRecommendResponseRecommendationResult.fromJson(
    core.Map json_,
  ) : this(
        document:
            json_.containsKey('document')
                ? GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
                  json_['document'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        id: json_['id'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (document != null) 'document': document!,
    if (id != null) 'id': id!,
    if (metadata != null) 'metadata': metadata!,
  };
}

/// Request message for SiteSearchEngineService.RecrawlUris method.
typedef GoogleCloudDiscoveryengineV1alphaRecrawlUrisRequest =
    $RecrawlUrisRequest;

/// Describes a refresh token.
class GoogleCloudDiscoveryengineV1alphaRefreshTokenInfo {
  /// The connection for which this token applies.
  ///
  /// Required.
  core.String? name;

  /// The list of scopes for this token.
  core.List<core.String>? scopes;

  GoogleCloudDiscoveryengineV1alphaRefreshTokenInfo({this.name, this.scopes});

  GoogleCloudDiscoveryengineV1alphaRefreshTokenInfo.fromJson(core.Map json_)
    : this(
        name: json_['name'] as core.String?,
        scopes:
            (json_['scopes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (name != null) 'name': name!,
    if (scopes != null) 'scopes': scopes!,
  };
}

/// Request message for CrawlRateManagementService.RemoveDedicatedCrawlRate
/// method.
///
/// The user can remove the dedicated crawl rate for a crawl_rate_scope they
/// own, and Google will fall back to organic crawl, and the crawl rate will be
/// determined by Google.
typedef GoogleCloudDiscoveryengineV1alphaRemoveDedicatedCrawlRateRequest =
    $RemoveDedicatedCrawlRateRequest;

/// Request message for CompletionService.RemoveSuggestion method.
class GoogleCloudDiscoveryengineV1alphaRemoveSuggestionRequest {
  /// Remove all search history suggestions for the user.
  core.bool? removeAllSearchHistorySuggestions;

  /// Time at which the suggestion was removed.
  ///
  /// If not set, the current time will be used.
  ///
  /// Required.
  core.String? removeTime;

  /// The search history suggestion to be removed.
  core.String? searchHistorySuggestion;

  /// Information about the end user.
  ///
  /// This should be the same identifier information as UserEvent.user_info and
  /// SearchRequest.user_info.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaUserInfo? userInfo;

  /// A unique identifier for tracking visitors.
  ///
  /// For example, this could be implemented with an HTTP cookie, which should
  /// be able to uniquely identify a visitor on a single device. This unique
  /// identifier should not change if the visitor logs in or out of the website.
  /// This field should NOT have a fixed value such as `unknown_visitor`. This
  /// should be the same identifier as UserEvent.user_pseudo_id and
  /// SearchRequest.user_pseudo_id. The field must be a UTF-8 encoded string
  /// with a length limit of 128.
  ///
  /// Required.
  core.String? userPseudoId;

  GoogleCloudDiscoveryengineV1alphaRemoveSuggestionRequest({
    this.removeAllSearchHistorySuggestions,
    this.removeTime,
    this.searchHistorySuggestion,
    this.userInfo,
    this.userPseudoId,
  });

  GoogleCloudDiscoveryengineV1alphaRemoveSuggestionRequest.fromJson(
    core.Map json_,
  ) : this(
        removeAllSearchHistorySuggestions:
            json_['removeAllSearchHistorySuggestions'] as core.bool?,
        removeTime: json_['removeTime'] as core.String?,
        searchHistorySuggestion:
            json_['searchHistorySuggestion'] as core.String?,
        userInfo:
            json_.containsKey('userInfo')
                ? GoogleCloudDiscoveryengineV1alphaUserInfo.fromJson(
                  json_['userInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userPseudoId: json_['userPseudoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (removeAllSearchHistorySuggestions != null)
      'removeAllSearchHistorySuggestions': removeAllSearchHistorySuggestions!,
    if (removeTime != null) 'removeTime': removeTime!,
    if (searchHistorySuggestion != null)
      'searchHistorySuggestion': searchHistorySuggestion!,
    if (userInfo != null) 'userInfo': userInfo!,
    if (userPseudoId != null) 'userPseudoId': userPseudoId!,
  };
}

/// Response message for CompletionService.RemoveSuggestion method.
typedef GoogleCloudDiscoveryengineV1alphaRemoveSuggestionResponse = $Empty;

/// Defines a reply message to user.
class GoogleCloudDiscoveryengineV1alphaReply {
  /// References in the reply.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<GoogleCloudDiscoveryengineV1alphaReplyReference>? references;

  /// DEPRECATED: use `summary` instead.
  ///
  /// Text reply.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? reply;

  /// Summary based on search results.
  GoogleCloudDiscoveryengineV1alphaSearchResponseSummary? summary;

  GoogleCloudDiscoveryengineV1alphaReply({
    this.references,
    this.reply,
    this.summary,
  });

  GoogleCloudDiscoveryengineV1alphaReply.fromJson(core.Map json_)
    : this(
        references:
            (json_['references'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaReplyReference.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        reply: json_['reply'] as core.String?,
        summary:
            json_.containsKey('summary')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseSummary.fromJson(
                  json_['summary'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (references != null) 'references': references!,
    if (reply != null) 'reply': reply!,
    if (summary != null) 'summary': summary!,
  };
}

/// Defines reference in reply.
typedef GoogleCloudDiscoveryengineV1alphaReplyReference = $ReplyReference;

/// Request for ReportConsentChange method.
class GoogleCloudDiscoveryengineV1alphaReportConsentChangeRequest {
  /// Whether customer decides to accept or decline service term.
  ///
  /// At this moment, only accept action is supported.
  ///
  /// Required.
  /// Possible string values are:
  /// - "CONSENT_CHANGE_ACTION_UNSPECIFIED" : Invalid action, user must specify
  /// accept/decline
  /// - "ACCEPT" : User accepts service terms.
  core.String? consentChangeAction;

  /// The unique identifier of the terms of service to update.
  ///
  /// Available term ids: * `GA_DATA_USE_TERMS`:
  /// [Terms for data use](https://cloud.google.com/retail/data-use-terms). When
  /// using this service term id, the acceptable service_term_version to provide
  /// is `2022-11-23`.
  ///
  /// Required.
  core.String? serviceTermId;

  /// The version string of the terms of service to update.
  ///
  /// Required.
  core.String? serviceTermVersion;

  GoogleCloudDiscoveryengineV1alphaReportConsentChangeRequest({
    this.consentChangeAction,
    this.serviceTermId,
    this.serviceTermVersion,
  });

  GoogleCloudDiscoveryengineV1alphaReportConsentChangeRequest.fromJson(
    core.Map json_,
  ) : this(
        consentChangeAction: json_['consentChangeAction'] as core.String?,
        serviceTermId: json_['serviceTermId'] as core.String?,
        serviceTermVersion: json_['serviceTermVersion'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (consentChangeAction != null)
      'consentChangeAction': consentChangeAction!,
    if (serviceTermId != null) 'serviceTermId': serviceTermId!,
    if (serviceTermVersion != null) 'serviceTermVersion': serviceTermVersion!,
  };
}

/// A data requirement.
class GoogleCloudDiscoveryengineV1alphaRequirement {
  /// The condition for evaluating the requirement result.
  ///
  /// Variables in the expression should be provided by `metrics_bindings` or
  /// `threshold_bindings`. Where `metrics_bindings` are used for computed
  /// metrics and `threshold_bindings` are used to define thresholds for
  /// corresponding `metric_bindings`.
  GoogleTypeExpr? condition;

  /// The description of the requirement.
  core.String? description;

  /// The name of the requirement.
  core.String? displayName;

  /// A list of the metric bindings to be used in `condition`.
  core.List<GoogleCloudDiscoveryengineV1alphaRequirementMetricBinding>?
  metricBindings;

  /// The severity of errors if the requirement is not met.
  ///
  /// It must be ordered from the most strict to the least strict. Examples: *
  /// `BLOCKING` * `CRITICAL` * `WARNING` All thresholds in the requirement must
  /// have all the severity here.
  core.List<core.String>? severity;

  /// A list of threshold bindings to be used in `condition`.
  core.List<GoogleCloudDiscoveryengineV1alphaRequirementThresholdBinding>?
  thresholdBindings;

  /// The requirement type, used as an identifier.
  ///
  /// Must be unique. The type should prefix with service name to avoid possible
  /// collision. It's encouraged to use natural hierarchical grouping for
  /// similar requirements. Examples: *
  /// `library.googleapis.com/books/min_available_books` *
  /// `discoveryengine.googleapis.com/media_rec/recommended_for_you/conversion_rate`
  core.String? type;

  /// A list of the metric bindings to be used in `condition`.
  core.List<
    GoogleCloudDiscoveryengineV1alphaRequirementViolationSamplesBinding
  >?
  violationSamplesBindings;

  GoogleCloudDiscoveryengineV1alphaRequirement({
    this.condition,
    this.description,
    this.displayName,
    this.metricBindings,
    this.severity,
    this.thresholdBindings,
    this.type,
    this.violationSamplesBindings,
  });

  GoogleCloudDiscoveryengineV1alphaRequirement.fromJson(core.Map json_)
    : this(
        condition:
            json_.containsKey('condition')
                ? GoogleTypeExpr.fromJson(
                  json_['condition'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        description: json_['description'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        metricBindings:
            (json_['metricBindings'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaRequirementMetricBinding.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        severity:
            (json_['severity'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        thresholdBindings:
            (json_['thresholdBindings'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaRequirementThresholdBinding.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        type: json_['type'] as core.String?,
        violationSamplesBindings:
            (json_['violationSamplesBindings'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaRequirementViolationSamplesBinding.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (condition != null) 'condition': condition!,
    if (description != null) 'description': description!,
    if (displayName != null) 'displayName': displayName!,
    if (metricBindings != null) 'metricBindings': metricBindings!,
    if (severity != null) 'severity': severity!,
    if (thresholdBindings != null) 'thresholdBindings': thresholdBindings!,
    if (type != null) 'type': type!,
    if (violationSamplesBindings != null)
      'violationSamplesBindings': violationSamplesBindings!,
  };
}

/// Specifies a metrics query and bind its result to a variable which will be
/// used in the `condition`.
class GoogleCloudDiscoveryengineV1alphaRequirementMetricBinding {
  /// The category of the metric's target resource.
  ///
  /// Example: "Events"
  core.String? category;

  /// Human readable description of the corresponding metric filter.
  core.String? description;

  /// The filter string used for metrics query.
  ///
  /// Example: "metric.type =
  /// \"discoveryengine.googleapis.com/events/day_count\" AND "
  /// "metric.conditions.time_range = \"NINETY_DAYS\""
  core.String? metricFilter;

  /// The resource being monitored for the metric.
  core.String? resourceType;

  /// The variable id to be referenced in `condition`.
  core.String? variableId;

  GoogleCloudDiscoveryengineV1alphaRequirementMetricBinding({
    this.category,
    this.description,
    this.metricFilter,
    this.resourceType,
    this.variableId,
  });

  GoogleCloudDiscoveryengineV1alphaRequirementMetricBinding.fromJson(
    core.Map json_,
  ) : this(
        category: json_['category'] as core.String?,
        description: json_['description'] as core.String?,
        metricFilter: json_['metricFilter'] as core.String?,
        resourceType: json_['resourceType'] as core.String?,
        variableId: json_['variableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (category != null) 'category': category!,
    if (description != null) 'description': description!,
    if (metricFilter != null) 'metricFilter': metricFilter!,
    if (resourceType != null) 'resourceType': resourceType!,
    if (variableId != null) 'variableId': variableId!,
  };
}

/// Specifies a multi-level threshold to apply to apply to a `metric_bindings`
/// in the `condition` CEL expression.
class GoogleCloudDiscoveryengineV1alphaRequirementThresholdBinding {
  /// Human readable description of the corresponding threshold and
  /// sub-requirement.
  core.String? description;

  /// The values of the threshold.
  ///
  /// The values should be ordered from the most strict to the least strict.
  core.List<
    GoogleCloudDiscoveryengineV1alphaRequirementThresholdBindingThresholdValue
  >?
  thresholdValues;

  /// The variable id to be referenced in `condition`.
  ///
  /// Must be unique across all `metric_bindings` and `threshold_bindings`.
  core.String? variableId;

  GoogleCloudDiscoveryengineV1alphaRequirementThresholdBinding({
    this.description,
    this.thresholdValues,
    this.variableId,
  });

  GoogleCloudDiscoveryengineV1alphaRequirementThresholdBinding.fromJson(
    core.Map json_,
  ) : this(
        description: json_['description'] as core.String?,
        thresholdValues:
            (json_['thresholdValues'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaRequirementThresholdBindingThresholdValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        variableId: json_['variableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (thresholdValues != null) 'thresholdValues': thresholdValues!,
    if (variableId != null) 'variableId': variableId!,
  };
}

/// Specifies a threshold value for a given severity.
class GoogleCloudDiscoveryengineV1alphaRequirementThresholdBindingThresholdValue {
  /// The severity of errors if the threshold is not met.
  ///
  /// It should be one of the `severity` fields in the requirement.
  core.String? severity;

  /// The value of the threshold.
  core.double? value;

  GoogleCloudDiscoveryengineV1alphaRequirementThresholdBindingThresholdValue({
    this.severity,
    this.value,
  });

  GoogleCloudDiscoveryengineV1alphaRequirementThresholdBindingThresholdValue.fromJson(
    core.Map json_,
  ) : this(
        severity: json_['severity'] as core.String?,
        value: (json_['value'] as core.num?)?.toDouble(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (severity != null) 'severity': severity!,
    if (value != null) 'value': value!,
  };
}

/// Specifies a samples query and bind its result to a variable which will be
/// used in the `condition`.
class GoogleCloudDiscoveryengineV1alphaRequirementViolationSamplesBinding {
  /// Description of this sample binding.
  ///
  /// Used by the UI to render user friendly descriptions for each requirement
  /// condition. Should be less than 128 characters long.
  core.String? description;

  /// The filter string used for samples query.
  ///
  /// Example: "sample.type = \"retail.googleapis.com/user_event\" AND "
  /// "sample.labels.event_type = \"PURCHASE\" "
  core.String? sampleFilter;

  /// The variable id to be referenced in `condition`.
  core.String? variableId;

  GoogleCloudDiscoveryengineV1alphaRequirementViolationSamplesBinding({
    this.description,
    this.sampleFilter,
    this.variableId,
  });

  GoogleCloudDiscoveryengineV1alphaRequirementViolationSamplesBinding.fromJson(
    core.Map json_,
  ) : this(
        description: json_['description'] as core.String?,
        sampleFilter: json_['sampleFilter'] as core.String?,
        variableId: json_['variableId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (sampleFilter != null) 'sampleFilter': sampleFilter!,
    if (variableId != null) 'variableId': variableId!,
  };
}

/// Request for resuming training of an engine.
typedef GoogleCloudDiscoveryengineV1alphaResumeEngineRequest = $Empty;

/// Safety rating corresponding to the generated content.
typedef GoogleCloudDiscoveryengineV1alphaSafetyRating = $SafetyRating01;

/// Sample Query captures metadata to be used for evaluation.
class GoogleCloudDiscoveryengineV1alphaSampleQuery {
  /// Timestamp the SampleQuery was created at.
  ///
  /// Output only.
  core.String? createTime;

  /// Identifier.
  ///
  /// The full resource name of the sample query, in the format of
  /// `projects/{project}/locations/{location}/sampleQuerySets/{sample_query_set}/sampleQueries/{sample_query}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  core.String? name;

  /// The query entry.
  GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntry? queryEntry;

  GoogleCloudDiscoveryengineV1alphaSampleQuery({
    this.createTime,
    this.name,
    this.queryEntry,
  });

  GoogleCloudDiscoveryengineV1alphaSampleQuery.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        name: json_['name'] as core.String?,
        queryEntry:
            json_.containsKey('queryEntry')
                ? GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntry.fromJson(
                  json_['queryEntry'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (name != null) 'name': name!,
    if (queryEntry != null) 'queryEntry': queryEntry!,
  };
}

/// Query Entry captures metadata to be used for search evaluation.
class GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntry {
  /// The query.
  ///
  /// Required.
  core.String? query;

  /// List of targets for the query.
  core.List<GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntryTarget>?
  targets;

  GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntry({
    this.query,
    this.targets,
  });

  GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntry.fromJson(
    core.Map json_,
  ) : this(
        query: json_['query'] as core.String?,
        targets:
            (json_['targets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntryTarget.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (query != null) 'query': query!,
    if (targets != null) 'targets': targets!,
  };
}

/// Defines the parameters of the query's expected outcome.
typedef GoogleCloudDiscoveryengineV1alphaSampleQueryQueryEntryTarget =
    $SampleQueryQueryEntryTarget;

/// A SampleQuerySet is the parent resource of SampleQuery, and contains the
/// configurations shared by all SampleQuery under it.
typedef GoogleCloudDiscoveryengineV1alphaSampleQuerySet = $SampleQuerySet;

/// Defines the structure and layout of a type of document data.
class GoogleCloudDiscoveryengineV1alphaSchema {
  /// Configurations for fields of the schema.
  ///
  /// Output only.
  core.List<GoogleCloudDiscoveryengineV1alphaFieldConfig>? fieldConfigs;

  /// The JSON representation of the schema.
  core.String? jsonSchema;

  /// The full resource name of the schema, in the format of
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
  ///
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  /// The structured representation of the schema.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? structSchema;

  GoogleCloudDiscoveryengineV1alphaSchema({
    this.fieldConfigs,
    this.jsonSchema,
    this.name,
    this.structSchema,
  });

  GoogleCloudDiscoveryengineV1alphaSchema.fromJson(core.Map json_)
    : this(
        fieldConfigs:
            (json_['fieldConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaFieldConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        jsonSchema: json_['jsonSchema'] as core.String?,
        name: json_['name'] as core.String?,
        structSchema:
            json_.containsKey('structSchema')
                ? json_['structSchema'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (fieldConfigs != null) 'fieldConfigs': fieldConfigs!,
    if (jsonSchema != null) 'jsonSchema': jsonSchema!,
    if (name != null) 'name': name!,
    if (structSchema != null) 'structSchema': structSchema!,
  };
}

/// Detailed search information.
typedef GoogleCloudDiscoveryengineV1alphaSearchInfo = $SearchInfo;

/// Promotion proto includes uri and other helping information to display the
/// promotion.
typedef GoogleCloudDiscoveryengineV1alphaSearchLinkPromotion =
    $SearchLinkPromotion;

/// Request message for SearchService.Search method.
class GoogleCloudDiscoveryengineV1alphaSearchRequest {
  /// Boost specification to boost certain documents.
  ///
  /// For more information on boosting, see
  /// [Boosting](https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results)
  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec? boostSpec;

  /// The branch resource name, such as `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/branches/0`.
  ///
  /// Use `default_branch` as the branch ID or leave this field empty, to search
  /// documents under the default branch.
  core.String? branch;

  /// The default filter that is applied when a user performs a search without
  /// checking any filters on the search page.
  ///
  /// The filter applied to every search request when quality improvement such
  /// as query expansion is needed. In the case a query does not have a
  /// sufficient amount of results this filter will be used to determine whether
  /// or not to enable the query expansion flow. The original filter will still
  /// be used for the query expanded search. This field is strongly recommended
  /// to achieve high search quality. For more information about filter syntax,
  /// see SearchRequest.filter.
  core.String? canonicalFilter;

  /// A specification for configuring the behavior of content search.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec?
  contentSearchSpec;

  /// Custom fine tuning configs.
  ///
  /// If set, it has higher priority than the configs set in
  /// ServingConfig.custom_fine_tuning_spec.
  GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec? customFineTuningSpec;

  /// Specifications that define the specific DataStores to be searched, along
  /// with configurations for those data stores.
  ///
  /// This is only considered for Engines with multiple data stores. For engines
  /// with a single data store, the specs directly under SearchRequest should be
  /// used.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec>?
  dataStoreSpecs;

  /// Config for display feature, like match highlighting on search results.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaSearchRequestDisplaySpec? displaySpec;

  /// Uses the provided embedding to do additional semantic document retrieval.
  ///
  /// The retrieval is based on the dot product of
  /// SearchRequest.EmbeddingSpec.EmbeddingVector.vector and the document
  /// embedding that is provided in
  /// SearchRequest.EmbeddingSpec.EmbeddingVector.field_path. If
  /// SearchRequest.EmbeddingSpec.EmbeddingVector.field_path is not provided, it
  /// will use ServingConfig.EmbeddingConfig.field_path.
  GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpec? embeddingSpec;

  /// Facet specifications for faceted search.
  ///
  /// If empty, no facets are returned. A maximum of 100 values are allowed.
  /// Otherwise, an `INVALID_ARGUMENT` error is returned.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec>?
  facetSpecs;

  /// The filter syntax consists of an expression language for constructing a
  /// predicate from one or more fields of the documents being filtered.
  ///
  /// Filter expression is case-sensitive. If this field is unrecognizable, an
  /// `INVALID_ARGUMENT` is returned. Filtering in Vertex AI Search is done by
  /// mapping the LHS filter key to a key property defined in the Vertex AI
  /// Search backend -- this mapping is defined by the customer in their schema.
  /// For example a media customer might have a field 'name' in their schema. In
  /// this case the filter would look like this: filter --\> name:'ANY("king
  /// kong")' For more information about filtering including syntax and filter
  /// operators, see
  /// [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  core.String? filter;

  /// Raw image query.
  GoogleCloudDiscoveryengineV1alphaSearchRequestImageQuery? imageQuery;

  /// The BCP-47 language code, such as "en-US" or "sr-Latn".
  ///
  /// For more information, see
  /// [Standard fields](https://cloud.google.com/apis/design/standard_fields).
  /// This field helps to better interpret the query. If a value isn't
  /// specified, the query language code is automatically detected, which may
  /// not be accurate.
  core.String? languageCode;

  /// Config for natural language query understanding capabilities, such as
  /// extracting structured field filters from the query.
  ///
  /// Refer to
  /// [this documentation](https://cloud.google.com/generative-ai-app-builder/docs/natural-language-queries)
  /// for more information. If `naturalLanguageQueryUnderstandingSpec` is not
  /// specified, no additional natural language query understanding will be
  /// done.
  GoogleCloudDiscoveryengineV1alphaSearchRequestNaturalLanguageQueryUnderstandingSpec?
  naturalLanguageQueryUnderstandingSpec;

  /// A 0-indexed integer that specifies the current offset (that is, starting
  /// result location, amongst the Documents deemed by the API as relevant) in
  /// search results.
  ///
  /// This field is only considered if page_token is unset. If this field is
  /// negative, an `INVALID_ARGUMENT` is returned.
  core.int? offset;

  /// The maximum number of results to return for OneBox.
  ///
  /// This applies to each OneBox type individually. Default number is 10.
  core.int? oneBoxPageSize;

  /// The order in which documents are returned.
  ///
  /// Documents can be ordered by a field in an Document object. Leave it unset
  /// if ordered by relevance. `order_by` expression is case-sensitive. For more
  /// information on ordering the website search results, see
  /// [Order web search results](https://cloud.google.com/generative-ai-app-builder/docs/order-web-search-results).
  /// For more information on ordering the healthcare search results, see
  /// [Order healthcare search results](https://cloud.google.com/generative-ai-app-builder/docs/order-hc-results).
  /// If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
  core.String? orderBy;

  /// Maximum number of Documents to return.
  ///
  /// The maximum allowed value depends on the data type. Values above the
  /// maximum value are coerced to the maximum value. * Websites with basic
  /// indexing: Default `10`, Maximum `25`. * Websites with advanced indexing:
  /// Default `25`, Maximum `50`. * Other: Default `50`, Maximum `100`. If this
  /// field is negative, an `INVALID_ARGUMENT` is returned.
  core.int? pageSize;

  /// A page token received from a previous SearchService.Search call.
  ///
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters provided to SearchService.Search must match the call that
  /// provided the page token. Otherwise, an `INVALID_ARGUMENT` error is
  /// returned.
  core.String? pageToken;

  /// Additional search parameters.
  ///
  /// For public website search only, supported values are: *
  /// `user_country_code`: string. Default empty. If set to non-empty, results
  /// are restricted or boosted based on the location provided. For example,
  /// `user_country_code: "au"` For available codes see
  /// [Country Codes](https://developers.google.com/custom-search/docs/json_api_reference#countryCodes)
  /// * `search_type`: double. Default empty. Enables non-webpage searching
  /// depending on the value. The only valid non-default value is 1, which
  /// enables image searching. For example, `search_type: 1`
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? params;

  /// The specification for personalization.
  ///
  /// Notice that if both ServingConfig.personalization_spec and
  /// SearchRequest.personalization_spec are set,
  /// SearchRequest.personalization_spec overrides
  /// ServingConfig.personalization_spec.
  GoogleCloudDiscoveryengineV1alphaSearchRequestPersonalizationSpec?
  personalizationSpec;

  /// Raw search query.
  core.String? query;

  /// The query expansion specification that specifies the conditions under
  /// which query expansion occurs.
  GoogleCloudDiscoveryengineV1alphaSearchRequestQueryExpansionSpec?
  queryExpansionSpec;

  /// The ranking expression controls the customized ranking on retrieval
  /// documents.
  ///
  /// This overrides ServingConfig.ranking_expression. The syntax and supported
  /// features depend on the `ranking_expression_backend` value. If
  /// `ranking_expression_backend` is not provided, it defaults to
  /// `RANK_BY_EMBEDDING`. If ranking_expression_backend is not provided or set
  /// to `RANK_BY_EMBEDDING`, it should be a single function or multiple
  /// functions that are joined by "+". * ranking_expression = function, { " +
  /// ", function }; Supported functions: * double * relevance_score * double *
  /// dotProduct(embedding_field_path) Function variables: * `relevance_score`:
  /// pre-defined keywords, used for measure relevance between query and
  /// document. * `embedding_field_path`: the document embedding field used with
  /// query embedding vector. * `dotProduct`: embedding function between
  /// `embedding_field_path` and query embedding vector. Example ranking
  /// expression: If document has an embedding field doc_embedding, the ranking
  /// expression could be `0.5 * relevance_score + 0.3 *
  /// dotProduct(doc_embedding)`. If ranking_expression_backend is set to
  /// `RANK_BY_FORMULA`, the following expression types (and combinations of
  /// those chained using + or * operators) are supported: * `double` * `signal`
  /// * `log(signal)` * `exp(signal)` * `rr(signal, double > 0)` -- reciprocal
  /// rank transformation with second argument being a denominator constant. *
  /// `is_nan(signal)` -- returns 0 if signal is NaN, 1 otherwise. *
  /// `fill_nan(signal1, signal2 | double)` -- if signal1 is NaN, returns
  /// signal2 | double, else returns signal1. Here are a few examples of ranking
  /// formulas that use the supported ranking expression types: - `0.2 *
  /// semantic_similarity_score + 0.8 * log(keyword_similarity_score)` -- mostly
  /// rank by the logarithm of `keyword_similarity_score` with slight
  /// `semantic_smilarity_score` adjustment. - `0.2 *
  /// exp(fill_nan(semantic_similarity_score, 0)) + 0.3 *
  /// is_nan(keyword_similarity_score)` -- rank by the exponent of
  /// `semantic_similarity_score` filling the value with 0 if it's NaN, also add
  /// constant 0.3 adjustment to the final score if `semantic_similarity_score`
  /// is NaN. - `0.2 * rr(semantic_similarity_score, 16) + 0.8 *
  /// rr(keyword_similarity_score, 16)` -- mostly rank by the reciprocal rank of
  /// `keyword_similarity_score` with slight adjustment of reciprocal rank of
  /// `semantic_smilarity_score`. The following signals are supported: *
  /// `semantic_similarity_score`: semantic similarity adjustment that is
  /// calculated using the embeddings generated by a proprietary Google model.
  /// This score determines how semantically similar a search query is to a
  /// document. * `keyword_similarity_score`: keyword match adjustment uses the
  /// Best Match 25 (BM25) ranking function. This score is calculated using a
  /// probabilistic model to estimate the probability that a document is
  /// relevant to a given query. * `relevance_score`: semantic relevance
  /// adjustment that uses a proprietary Google model to determine the meaning
  /// and intent behind a user's query in context with the content in the
  /// documents. * `pctr_rank`: predicted conversion rate adjustment as a rank
  /// use predicted Click-through rate (pCTR) to gauge the relevance and
  /// attractiveness of a search result from a user's perspective. A higher pCTR
  /// suggests that the result is more likely to satisfy the user's query and
  /// intent, making it a valuable signal for ranking. * `freshness_rank`:
  /// freshness adjustment as a rank * `document_age`: The time in hours elapsed
  /// since the document was last updated, a floating-point number (e.g., 0.25
  /// means 15 minutes). * `topicality_rank`: topicality adjustment as a rank.
  /// Uses proprietary Google model to determine the keyword-based overlap
  /// between the query and the document. * `base_rank`: the default rank of the
  /// result
  ///
  /// Optional.
  core.String? rankingExpression;

  /// The backend to use for the ranking expression evaluation.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "RANKING_EXPRESSION_BACKEND_UNSPECIFIED" : Default option for
  /// unspecified/unknown values.
  /// - "BYOE" : Deprecated: Use `RANK_BY_EMBEDDING` instead. Ranking by custom
  /// embedding model, the default way to evaluate the ranking expression.
  /// Legacy enum option, `RANK_BY_EMBEDDING` should be used instead.
  /// - "CLEARBOX" : Deprecated: Use `RANK_BY_FORMULA` instead. Ranking by
  /// custom formula. Legacy enum option, `RANK_BY_FORMULA` should be used
  /// instead.
  /// - "RANK_BY_EMBEDDING" : Ranking by custom embedding model, the default way
  /// to evaluate the ranking expression.
  /// - "RANK_BY_FORMULA" : Ranking by custom formula.
  core.String? rankingExpressionBackend;

  /// The Unicode country/region code (CLDR) of a location, such as "US" and
  /// "419".
  ///
  /// For more information, see
  /// [Standard fields](https://cloud.google.com/apis/design/standard_fields).
  /// If set, then results will be boosted based on the region_code provided.
  core.String? regionCode;

  /// The specification for returning the relevance score.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaSearchRequestRelevanceScoreSpec?
  relevanceScoreSpec;

  /// The relevance threshold of the search results.
  ///
  /// Default to Google defined threshold, leveraging a balance of precision and
  /// recall to deliver both highly accurate results and comprehensive coverage
  /// of relevant information. This feature is not supported for healthcare
  /// search.
  /// Possible string values are:
  /// - "RELEVANCE_THRESHOLD_UNSPECIFIED" : Default value. In this case, server
  /// behavior defaults to Google defined threshold.
  /// - "LOWEST" : Lowest relevance threshold.
  /// - "LOW" : Low relevance threshold.
  /// - "MEDIUM" : Medium relevance threshold.
  /// - "HIGH" : High relevance threshold.
  core.String? relevanceThreshold;

  /// Whether to turn on safe search.
  ///
  /// This is only supported for website search.
  core.bool? safeSearch;

  /// Search as you type configuration.
  ///
  /// Only supported for the IndustryVertical.MEDIA vertical.
  GoogleCloudDiscoveryengineV1alphaSearchRequestSearchAsYouTypeSpec?
  searchAsYouTypeSpec;

  /// The resource name of the Search serving config, such as `projects / *
  /// /locations/global/collections/default_collection/engines / *
  /// /servingConfigs/default_serving_config`, or `projects / *
  /// /locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
  ///
  /// This field is used to identify the serving configuration name, set of
  /// models used to make the search.
  ///
  /// Required.
  core.String? servingConfig;

  /// The session resource name.
  ///
  /// Optional. Session allows users to do multi-turn /search API calls or
  /// coordination between /search API calls and /answer API calls. Example #1
  /// (multi-turn /search API calls): Call /search API with the session ID
  /// generated in the first call. Here, the previous search query gets
  /// considered in query standing. I.e., if the first query is "How did
  /// Alphabet do in 2022?" and the current query is "How about 2023?", the
  /// current query will be interpreted as "How did Alphabet do in 2023?".
  /// Example #2 (coordination between /search API calls and /answer API calls):
  /// Call /answer API with the session ID generated in the first call. Here,
  /// the answer generation happens in the context of the search results from
  /// the first search call. Multi-turn Search feature is currently at private
  /// GA stage. Please use v1alpha or v1beta version instead before we launch
  /// this feature to public GA. Or ask for allowlisting through Google Support
  /// team.
  core.String? session;

  /// Session specification.
  ///
  /// Can be used only when `session` is set.
  GoogleCloudDiscoveryengineV1alphaSearchRequestSessionSpec? sessionSpec;

  /// The spell correction specification that specifies the mode under which
  /// spell correction takes effect.
  GoogleCloudDiscoveryengineV1alphaSearchRequestSpellCorrectionSpec?
  spellCorrectionSpec;

  /// Uses the Engine, ServingConfig and Control freshly read from the database.
  ///
  /// Note: this skips config cache and introduces dependency on databases,
  /// which could significantly increase the API latency. It should only be used
  /// for testing, but not serving end users.
  core.bool? useLatestData;

  /// Information about the end user.
  ///
  /// Highly recommended for analytics and personalization. UserInfo.user_agent
  /// is used to deduce `device_type` for analytics.
  GoogleCloudDiscoveryengineV1alphaUserInfo? userInfo;

  /// The user labels applied to a resource must meet the following
  /// requirements: * Each resource can have multiple labels, up to a maximum of
  /// 64.
  ///
  /// * Each label must be a key-value pair. * Keys have a minimum length of 1
  /// character and a maximum length of 63 characters and cannot be empty.
  /// Values can be empty and have a maximum length of 63 characters. * Keys and
  /// values can contain only lowercase letters, numeric characters,
  /// underscores, and dashes. All characters must use UTF-8 encoding, and
  /// international characters are allowed. * The key portion of a label must be
  /// unique. However, you can use the same key with multiple resources. * Keys
  /// must start with a lowercase letter or international character. See
  /// [Google Cloud Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
  /// for more details.
  core.Map<core.String, core.String>? userLabels;

  /// A unique identifier for tracking visitors.
  ///
  /// For example, this could be implemented with an HTTP cookie, which should
  /// be able to uniquely identify a visitor on a single device. This unique
  /// identifier should not change if the visitor logs in or out of the website.
  /// This field should NOT have a fixed value such as `unknown_visitor`. This
  /// should be the same identifier as UserEvent.user_pseudo_id and
  /// CompleteQueryRequest.user_pseudo_id The field must be a UTF-8 encoded
  /// string with a length limit of 128 characters. Otherwise, an
  /// `INVALID_ARGUMENT` error is returned.
  core.String? userPseudoId;

  GoogleCloudDiscoveryengineV1alphaSearchRequest({
    this.boostSpec,
    this.branch,
    this.canonicalFilter,
    this.contentSearchSpec,
    this.customFineTuningSpec,
    this.dataStoreSpecs,
    this.displaySpec,
    this.embeddingSpec,
    this.facetSpecs,
    this.filter,
    this.imageQuery,
    this.languageCode,
    this.naturalLanguageQueryUnderstandingSpec,
    this.offset,
    this.oneBoxPageSize,
    this.orderBy,
    this.pageSize,
    this.pageToken,
    this.params,
    this.personalizationSpec,
    this.query,
    this.queryExpansionSpec,
    this.rankingExpression,
    this.rankingExpressionBackend,
    this.regionCode,
    this.relevanceScoreSpec,
    this.relevanceThreshold,
    this.safeSearch,
    this.searchAsYouTypeSpec,
    this.servingConfig,
    this.session,
    this.sessionSpec,
    this.spellCorrectionSpec,
    this.useLatestData,
    this.userInfo,
    this.userLabels,
    this.userPseudoId,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequest.fromJson(core.Map json_)
    : this(
        boostSpec:
            json_.containsKey('boostSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec.fromJson(
                  json_['boostSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        branch: json_['branch'] as core.String?,
        canonicalFilter: json_['canonicalFilter'] as core.String?,
        contentSearchSpec:
            json_.containsKey('contentSearchSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec.fromJson(
                  json_['contentSearchSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        customFineTuningSpec:
            json_.containsKey('customFineTuningSpec')
                ? GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec.fromJson(
                  json_['customFineTuningSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        dataStoreSpecs:
            (json_['dataStoreSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        displaySpec:
            json_.containsKey('displaySpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestDisplaySpec.fromJson(
                  json_['displaySpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        embeddingSpec:
            json_.containsKey('embeddingSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpec.fromJson(
                  json_['embeddingSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        facetSpecs:
            (json_['facetSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        filter: json_['filter'] as core.String?,
        imageQuery:
            json_.containsKey('imageQuery')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestImageQuery.fromJson(
                  json_['imageQuery'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        languageCode: json_['languageCode'] as core.String?,
        naturalLanguageQueryUnderstandingSpec:
            json_.containsKey('naturalLanguageQueryUnderstandingSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestNaturalLanguageQueryUnderstandingSpec.fromJson(
                  json_['naturalLanguageQueryUnderstandingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        offset: json_['offset'] as core.int?,
        oneBoxPageSize: json_['oneBoxPageSize'] as core.int?,
        orderBy: json_['orderBy'] as core.String?,
        pageSize: json_['pageSize'] as core.int?,
        pageToken: json_['pageToken'] as core.String?,
        params:
            json_.containsKey('params')
                ? json_['params'] as core.Map<core.String, core.dynamic>
                : null,
        personalizationSpec:
            json_.containsKey('personalizationSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestPersonalizationSpec.fromJson(
                  json_['personalizationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        query: json_['query'] as core.String?,
        queryExpansionSpec:
            json_.containsKey('queryExpansionSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestQueryExpansionSpec.fromJson(
                  json_['queryExpansionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        rankingExpression: json_['rankingExpression'] as core.String?,
        rankingExpressionBackend:
            json_['rankingExpressionBackend'] as core.String?,
        regionCode: json_['regionCode'] as core.String?,
        relevanceScoreSpec:
            json_.containsKey('relevanceScoreSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestRelevanceScoreSpec.fromJson(
                  json_['relevanceScoreSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        relevanceThreshold: json_['relevanceThreshold'] as core.String?,
        safeSearch: json_['safeSearch'] as core.bool?,
        searchAsYouTypeSpec:
            json_.containsKey('searchAsYouTypeSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestSearchAsYouTypeSpec.fromJson(
                  json_['searchAsYouTypeSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        servingConfig: json_['servingConfig'] as core.String?,
        session: json_['session'] as core.String?,
        sessionSpec:
            json_.containsKey('sessionSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestSessionSpec.fromJson(
                  json_['sessionSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        spellCorrectionSpec:
            json_.containsKey('spellCorrectionSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestSpellCorrectionSpec.fromJson(
                  json_['spellCorrectionSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        useLatestData: json_['useLatestData'] as core.bool?,
        userInfo:
            json_.containsKey('userInfo')
                ? GoogleCloudDiscoveryengineV1alphaUserInfo.fromJson(
                  json_['userInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userLabels: (json_['userLabels']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        userPseudoId: json_['userPseudoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boostSpec != null) 'boostSpec': boostSpec!,
    if (branch != null) 'branch': branch!,
    if (canonicalFilter != null) 'canonicalFilter': canonicalFilter!,
    if (contentSearchSpec != null) 'contentSearchSpec': contentSearchSpec!,
    if (customFineTuningSpec != null)
      'customFineTuningSpec': customFineTuningSpec!,
    if (dataStoreSpecs != null) 'dataStoreSpecs': dataStoreSpecs!,
    if (displaySpec != null) 'displaySpec': displaySpec!,
    if (embeddingSpec != null) 'embeddingSpec': embeddingSpec!,
    if (facetSpecs != null) 'facetSpecs': facetSpecs!,
    if (filter != null) 'filter': filter!,
    if (imageQuery != null) 'imageQuery': imageQuery!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (naturalLanguageQueryUnderstandingSpec != null)
      'naturalLanguageQueryUnderstandingSpec':
          naturalLanguageQueryUnderstandingSpec!,
    if (offset != null) 'offset': offset!,
    if (oneBoxPageSize != null) 'oneBoxPageSize': oneBoxPageSize!,
    if (orderBy != null) 'orderBy': orderBy!,
    if (pageSize != null) 'pageSize': pageSize!,
    if (pageToken != null) 'pageToken': pageToken!,
    if (params != null) 'params': params!,
    if (personalizationSpec != null)
      'personalizationSpec': personalizationSpec!,
    if (query != null) 'query': query!,
    if (queryExpansionSpec != null) 'queryExpansionSpec': queryExpansionSpec!,
    if (rankingExpression != null) 'rankingExpression': rankingExpression!,
    if (rankingExpressionBackend != null)
      'rankingExpressionBackend': rankingExpressionBackend!,
    if (regionCode != null) 'regionCode': regionCode!,
    if (relevanceScoreSpec != null) 'relevanceScoreSpec': relevanceScoreSpec!,
    if (relevanceThreshold != null) 'relevanceThreshold': relevanceThreshold!,
    if (safeSearch != null) 'safeSearch': safeSearch!,
    if (searchAsYouTypeSpec != null)
      'searchAsYouTypeSpec': searchAsYouTypeSpec!,
    if (servingConfig != null) 'servingConfig': servingConfig!,
    if (session != null) 'session': session!,
    if (sessionSpec != null) 'sessionSpec': sessionSpec!,
    if (spellCorrectionSpec != null)
      'spellCorrectionSpec': spellCorrectionSpec!,
    if (useLatestData != null) 'useLatestData': useLatestData!,
    if (userInfo != null) 'userInfo': userInfo!,
    if (userLabels != null) 'userLabels': userLabels!,
    if (userPseudoId != null) 'userPseudoId': userPseudoId!,
  };
}

/// Boost specification to boost certain documents.
class GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec {
  /// Condition boost specifications.
  ///
  /// If a document matches multiple conditions in the specifications, boost
  /// scores from these specifications are all applied and combined in a
  /// non-linear way. Maximum number of specifications is 20.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpec
  >?
  conditionBoostSpecs;

  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec({
    this.conditionBoostSpecs,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec.fromJson(
    core.Map json_,
  ) : this(
        conditionBoostSpecs:
            (json_['conditionBoostSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (conditionBoostSpecs != null)
      'conditionBoostSpecs': conditionBoostSpecs!,
  };
}

/// Boost applies to documents which match a condition.
class GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpec {
  /// Strength of the condition boost, which should be in \[-1, 1\].
  ///
  /// Negative boost means demotion. Default is 0.0. Setting to 1.0 gives the
  /// document a big promotion. However, it does not necessarily mean that the
  /// boosted document will be the top result at all times, nor that other
  /// documents will be excluded. Results could still be shown even when none of
  /// them matches the condition. And results that are significantly more
  /// relevant to the search query can still trump your heavily favored but
  /// irrelevant documents. Setting to -1.0 gives the document a big demotion.
  /// However, results that are deeply relevant might still be shown. The
  /// document will have an upstream battle to get a fairly high ranking, but it
  /// is not blocked out completely. Setting to 0.0 means no boost applied. The
  /// boosting condition is ignored. Only one of the (condition, boost)
  /// combination or the boost_control_spec below are set. If both are set then
  /// the global boost is ignored and the more fine-grained boost_control_spec
  /// is applied.
  core.double? boost;

  /// Complex specification for custom ranking based on customer defined
  /// attribute value.
  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpec?
  boostControlSpec;

  /// An expression which specifies a boost condition.
  ///
  /// The syntax and supported fields are the same as a filter expression. See
  /// SearchRequest.filter for detail syntax and limitations. Examples: * To
  /// boost documents with document ID "doc_1" or "doc_2", and color "Red" or
  /// "Blue": `(document_id: ANY("doc_1", "doc_2")) AND (color: ANY("Red",
  /// "Blue"))`
  core.String? condition;

  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpec({
    this.boost,
    this.boostControlSpec,
    this.condition,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpec.fromJson(
    core.Map json_,
  ) : this(
        boost: (json_['boost'] as core.num?)?.toDouble(),
        boostControlSpec:
            json_.containsKey('boostControlSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpec.fromJson(
                  json_['boostControlSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        condition: json_['condition'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boost != null) 'boost': boost!,
    if (boostControlSpec != null) 'boostControlSpec': boostControlSpec!,
    if (condition != null) 'condition': condition!,
  };
}

/// Specification for custom ranking based on customer specified attribute
/// value.
///
/// It provides more controls for customized ranking than the simple (condition,
/// boost) combination above.
class GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpec {
  /// The attribute type to be used to determine the boost amount.
  ///
  /// The attribute value can be derived from the field value of the specified
  /// field_name. In the case of numerical it is straightforward i.e.
  /// attribute_value = numerical_field_value. In the case of freshness however,
  /// attribute_value = (time.now() - datetime_field_value).
  /// Possible string values are:
  /// - "ATTRIBUTE_TYPE_UNSPECIFIED" : Unspecified AttributeType.
  /// - "NUMERICAL" : The value of the numerical field will be used to
  /// dynamically update the boost amount. In this case, the attribute_value
  /// (the x value) of the control point will be the actual value of the
  /// numerical field for which the boost_amount is specified.
  /// - "FRESHNESS" : For the freshness use case the attribute value will be the
  /// duration between the current time and the date in the datetime field
  /// specified. The value must be formatted as an XSD `dayTimeDuration` value
  /// (a restricted subset of an ISO 8601 duration value). The pattern for this
  /// is: `nDnM]`. For example, `5D`, `3DT12H30M`, `T24H`.
  core.String? attributeType;

  /// The control points used to define the curve.
  ///
  /// The monotonic function (defined through the interpolation_type above)
  /// passes through the control points listed here.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint
  >?
  controlPoints;

  /// The name of the field whose value will be used to determine the boost
  /// amount.
  core.String? fieldName;

  /// The interpolation type to be applied to connect the control points listed
  /// below.
  /// Possible string values are:
  /// - "INTERPOLATION_TYPE_UNSPECIFIED" : Interpolation type is unspecified. In
  /// this case, it defaults to Linear.
  /// - "LINEAR" : Piecewise linear interpolation will be applied.
  core.String? interpolationType;

  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpec({
    this.attributeType,
    this.controlPoints,
    this.fieldName,
    this.interpolationType,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpec.fromJson(
    core.Map json_,
  ) : this(
        attributeType: json_['attributeType'] as core.String?,
        controlPoints:
            (json_['controlPoints'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        fieldName: json_['fieldName'] as core.String?,
        interpolationType: json_['interpolationType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributeType != null) 'attributeType': attributeType!,
    if (controlPoints != null) 'controlPoints': controlPoints!,
    if (fieldName != null) 'fieldName': fieldName!,
    if (interpolationType != null) 'interpolationType': interpolationType!,
  };
}

/// The control points used to define the curve.
///
/// The curve defined through these control points can only be monotonically
/// increasing or decreasing(constant values are acceptable).
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint =
    $SearchRequestBoostSpecConditionBoostSpecBoostControlSpecControlPoint;

/// A specification for configuring the behavior of content search.
class GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec {
  /// Specifies the chunk spec to be returned from the search response.
  ///
  /// Only available if the SearchRequest.ContentSearchSpec.search_result_mode
  /// is set to CHUNKS
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecChunkSpec?
  chunkSpec;

  /// If there is no extractive_content_spec provided, there will be no
  /// extractive answer in the search response.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecExtractiveContentSpec?
  extractiveContentSpec;

  /// Specifies the search result mode.
  ///
  /// If unspecified, the search result mode defaults to `DOCUMENTS`.
  /// Possible string values are:
  /// - "SEARCH_RESULT_MODE_UNSPECIFIED" : Default value.
  /// - "DOCUMENTS" : Returns documents in the search result.
  /// - "CHUNKS" : Returns chunks in the search result. Only available if the
  /// DocumentProcessingConfig.chunking_config is specified.
  core.String? searchResultMode;

  /// If `snippetSpec` is not specified, snippets are not included in the search
  /// response.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSnippetSpec?
  snippetSpec;

  /// If `summarySpec` is not specified, summaries are not included in the
  /// search response.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpec?
  summarySpec;

  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec({
    this.chunkSpec,
    this.extractiveContentSpec,
    this.searchResultMode,
    this.snippetSpec,
    this.summarySpec,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec.fromJson(
    core.Map json_,
  ) : this(
        chunkSpec:
            json_.containsKey('chunkSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecChunkSpec.fromJson(
                  json_['chunkSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        extractiveContentSpec:
            json_.containsKey('extractiveContentSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecExtractiveContentSpec.fromJson(
                  json_['extractiveContentSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        searchResultMode: json_['searchResultMode'] as core.String?,
        snippetSpec:
            json_.containsKey('snippetSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSnippetSpec.fromJson(
                  json_['snippetSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarySpec:
            json_.containsKey('summarySpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpec.fromJson(
                  json_['summarySpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkSpec != null) 'chunkSpec': chunkSpec!,
    if (extractiveContentSpec != null)
      'extractiveContentSpec': extractiveContentSpec!,
    if (searchResultMode != null) 'searchResultMode': searchResultMode!,
    if (snippetSpec != null) 'snippetSpec': snippetSpec!,
    if (summarySpec != null) 'summarySpec': summarySpec!,
  };
}

/// Specifies the chunk spec to be returned from the search response.
///
/// Only available if the SearchRequest.ContentSearchSpec.search_result_mode is
/// set to CHUNKS
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecChunkSpec =
    $SearchRequestContentSearchSpecChunkSpec;

/// A specification for configuring the extractive content in a search response.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecExtractiveContentSpec =
    $SearchRequestContentSearchSpecExtractiveContentSpec;

/// A specification for configuring snippets in a search response.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSnippetSpec =
    $SearchRequestContentSearchSpecSnippetSpec;

/// A specification for configuring a summary returned in a search response.
class GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpec {
  /// Specifies whether to filter out adversarial queries.
  ///
  /// The default value is `false`. Google employs search-query classification
  /// to detect adversarial queries. No summary is returned if the search query
  /// is classified as an adversarial query. For example, a user might ask a
  /// question regarding negative comments about the company or submit a query
  /// designed to generate unsafe, policy-violating output. If this field is set
  /// to `true`, we skip generating summaries for adversarial queries and return
  /// fallback messages instead.
  core.bool? ignoreAdversarialQuery;

  /// Specifies whether to filter out jail-breaking queries.
  ///
  /// The default value is `false`. Google employs search-query classification
  /// to detect jail-breaking queries. No summary is returned if the search
  /// query is classified as a jail-breaking query. A user might add
  /// instructions to the query to change the tone, style, language, content of
  /// the answer, or ask the model to act as a different entity, e.g. "Reply in
  /// the tone of a competing company's CEO". If this field is set to `true`, we
  /// skip generating summaries for jail-breaking queries and return fallback
  /// messages instead.
  ///
  /// Optional.
  core.bool? ignoreJailBreakingQuery;

  /// Specifies whether to filter out queries that have low relevance.
  ///
  /// The default value is `false`. If this field is set to `false`, all search
  /// results are used regardless of relevance to generate answers. If set to
  /// `true`, only queries with high relevance search results will generate
  /// answers.
  core.bool? ignoreLowRelevantContent;

  /// Specifies whether to filter out queries that are not summary-seeking.
  ///
  /// The default value is `false`. Google employs search-query classification
  /// to detect summary-seeking queries. No summary is returned if the search
  /// query is classified as a non-summary seeking query. For example, `why is
  /// the sky blue` and `Who is the best soccer player in the world?` are
  /// summary-seeking queries, but `SFO airport` and `world cup 2026` are not.
  /// They are most likely navigational queries. If this field is set to `true`,
  /// we skip generating summaries for non-summary seeking queries and return
  /// fallback messages instead.
  core.bool? ignoreNonSummarySeekingQuery;

  /// Specifies whether to include citations in the summary.
  ///
  /// The default value is `false`. When this field is set to `true`, summaries
  /// include in-line citation numbers. Example summary including citations:
  /// BigQuery is Google Cloud's fully managed and completely serverless
  /// enterprise data warehouse \[1\]. BigQuery supports all data types, works
  /// across clouds, and has built-in machine learning and business
  /// intelligence, all within a unified platform \[2, 3\]. The citation numbers
  /// refer to the returned search results and are 1-indexed. For example, \[1\]
  /// means that the sentence is attributed to the first search result. \[2, 3\]
  /// means that the sentence is attributed to both the second and third search
  /// results.
  core.bool? includeCitations;

  /// Language code for Summary.
  ///
  /// Use language tags defined by
  /// [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This is an
  /// experimental feature.
  core.String? languageCode;

  /// If specified, the spec will be used to modify the prompt provided to the
  /// LLM.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelPromptSpec?
  modelPromptSpec;

  /// If specified, the spec will be used to modify the model specification
  /// provided to the LLM.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelSpec?
  modelSpec;

  /// Multimodal specification.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecMultiModalSpec?
  multimodalSpec;

  /// The number of top results to generate the summary from.
  ///
  /// If the number of results returned is less than `summaryResultCount`, the
  /// summary is generated from all of the results. At most 10 results for
  /// documents mode, or 50 for chunks mode, can be used to generate a summary.
  /// The chunks mode is used when
  /// SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS.
  core.int? summaryResultCount;

  /// If true, answer will be generated from most relevant chunks from top
  /// search results.
  ///
  /// This feature will improve summary quality. Note that with this feature
  /// enabled, not all top search results will be referenced and included in the
  /// reference list, so the citation source index only points to the search
  /// results listed in the reference list.
  core.bool? useSemanticChunks;

  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpec({
    this.ignoreAdversarialQuery,
    this.ignoreJailBreakingQuery,
    this.ignoreLowRelevantContent,
    this.ignoreNonSummarySeekingQuery,
    this.includeCitations,
    this.languageCode,
    this.modelPromptSpec,
    this.modelSpec,
    this.multimodalSpec,
    this.summaryResultCount,
    this.useSemanticChunks,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpec.fromJson(
    core.Map json_,
  ) : this(
        ignoreAdversarialQuery: json_['ignoreAdversarialQuery'] as core.bool?,
        ignoreJailBreakingQuery: json_['ignoreJailBreakingQuery'] as core.bool?,
        ignoreLowRelevantContent:
            json_['ignoreLowRelevantContent'] as core.bool?,
        ignoreNonSummarySeekingQuery:
            json_['ignoreNonSummarySeekingQuery'] as core.bool?,
        includeCitations: json_['includeCitations'] as core.bool?,
        languageCode: json_['languageCode'] as core.String?,
        modelPromptSpec:
            json_.containsKey('modelPromptSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelPromptSpec.fromJson(
                  json_['modelPromptSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelSpec:
            json_.containsKey('modelSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelSpec.fromJson(
                  json_['modelSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        multimodalSpec:
            json_.containsKey('multimodalSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecMultiModalSpec.fromJson(
                  json_['multimodalSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        summaryResultCount: json_['summaryResultCount'] as core.int?,
        useSemanticChunks: json_['useSemanticChunks'] as core.bool?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (ignoreAdversarialQuery != null)
      'ignoreAdversarialQuery': ignoreAdversarialQuery!,
    if (ignoreJailBreakingQuery != null)
      'ignoreJailBreakingQuery': ignoreJailBreakingQuery!,
    if (ignoreLowRelevantContent != null)
      'ignoreLowRelevantContent': ignoreLowRelevantContent!,
    if (ignoreNonSummarySeekingQuery != null)
      'ignoreNonSummarySeekingQuery': ignoreNonSummarySeekingQuery!,
    if (includeCitations != null) 'includeCitations': includeCitations!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (modelPromptSpec != null) 'modelPromptSpec': modelPromptSpec!,
    if (modelSpec != null) 'modelSpec': modelSpec!,
    if (multimodalSpec != null) 'multimodalSpec': multimodalSpec!,
    if (summaryResultCount != null) 'summaryResultCount': summaryResultCount!,
    if (useSemanticChunks != null) 'useSemanticChunks': useSemanticChunks!,
  };
}

/// Specification of the prompt to use with the model.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelPromptSpec =
    $SearchRequestContentSearchSpecSummarySpecModelPromptSpec;

/// Specification of the model.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecModelSpec =
    $SearchRequestContentSearchSpecSummarySpecModelSpec;

/// Multimodal specification: Will return an image from specified source.
///
/// If multiple sources are specified, the pick is a quality based decision.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpecSummarySpecMultiModalSpec =
    $Spec02;

/// A struct to define data stores to filter on in a search call and
/// configurations for those data stores.
///
/// Otherwise, an `INVALID_ARGUMENT` error is returned.
class GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec {
  /// Boost specification to boost certain documents.
  ///
  /// For more information on boosting, see
  /// [Boosting](https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results)
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec? boostSpec;

  /// Custom search operators which if specified will be used to filter results
  /// from workspace data stores.
  ///
  /// For more information on custom search operators, see
  /// [SearchOperators](https://support.google.com/cloudsearch/answer/6172299).
  ///
  /// Optional.
  core.String? customSearchOperators;

  /// Full resource name of DataStore, such as
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  ///
  /// Required.
  core.String? dataStore;

  /// Filter specification to filter documents in the data store specified by
  /// data_store field.
  ///
  /// For more information on filtering, see
  /// [Filtering](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  ///
  /// Optional.
  core.String? filter;

  GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec({
    this.boostSpec,
    this.customSearchOperators,
    this.dataStore,
    this.filter,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec.fromJson(
    core.Map json_,
  ) : this(
        boostSpec:
            json_.containsKey('boostSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestBoostSpec.fromJson(
                  json_['boostSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        customSearchOperators: json_['customSearchOperators'] as core.String?,
        dataStore: json_['dataStore'] as core.String?,
        filter: json_['filter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boostSpec != null) 'boostSpec': boostSpec!,
    if (customSearchOperators != null)
      'customSearchOperators': customSearchOperators!,
    if (dataStore != null) 'dataStore': dataStore!,
    if (filter != null) 'filter': filter!,
  };
}

/// Specifies features for display, like match highlighting.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestDisplaySpec =
    $SearchRequestDisplaySpec;

/// The specification that uses customized query embedding vector to do semantic
/// document retrieval.
class GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpec {
  /// The embedding vector used for retrieval.
  ///
  /// Limit to 1.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpecEmbeddingVector
  >?
  embeddingVectors;

  GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpec({
    this.embeddingVectors,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpec.fromJson(
    core.Map json_,
  ) : this(
        embeddingVectors:
            (json_['embeddingVectors'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpecEmbeddingVector.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (embeddingVectors != null) 'embeddingVectors': embeddingVectors!,
  };
}

/// Embedding vector.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestEmbeddingSpecEmbeddingVector =
    $SearchRequestEmbeddingSpecEmbeddingVector;

/// A facet specification to perform faceted search.
class GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec {
  /// Enables dynamic position for this facet.
  ///
  /// If set to true, the position of this facet among all facets in the
  /// response is determined automatically. If dynamic facets are enabled, it is
  /// ordered together. If set to false, the position of this facet in the
  /// response is the same as in the request, and it is ranked before the facets
  /// with dynamic position enable and all dynamic facets. For example, you may
  /// always want to have rating facet returned in the response, but it's not
  /// necessarily to always display the rating facet at the top. In that case,
  /// you can set enable_dynamic_position to true so that the position of rating
  /// facet in response is determined automatically. Another example, assuming
  /// you have the following facets in the request: * "rating",
  /// enable_dynamic_position = true * "price", enable_dynamic_position = false
  /// * "brands", enable_dynamic_position = false And also you have a dynamic
  /// facets enabled, which generates a facet `gender`. Then the final order of
  /// the facets in the response can be ("price", "brands", "rating", "gender")
  /// or ("price", "brands", "gender", "rating") depends on how API orders
  /// "gender" and "rating" facets. However, notice that "price" and "brands"
  /// are always ranked at first and second position because their
  /// enable_dynamic_position is false.
  core.bool? enableDynamicPosition;

  /// List of keys to exclude when faceting.
  ///
  /// By default, FacetKey.key is not excluded from the filter unless it is
  /// listed in this field. Listing a facet key in this field allows its values
  /// to appear as facet results, even when they are filtered out of search
  /// results. Using this field does not affect what search results are
  /// returned. For example, suppose there are 100 documents with the color
  /// facet "Red" and 200 documents with the color facet "Blue". A query
  /// containing the filter "color:ANY("Red")" and having "color" as
  /// FacetKey.key would by default return only "Red" documents in the search
  /// results, and also return "Red" with count 100 as the only color facet.
  /// Although there are also blue documents available, "Blue" would not be
  /// shown as an available facet value. If "color" is listed in
  /// "excludedFilterKeys", then the query returns the facet values "Red" with
  /// count 100 and "Blue" with count 200, because the "color" key is now
  /// excluded from the filter. Because this field doesn't affect search
  /// results, the search results are still correctly filtered to return only
  /// "Red" documents. A maximum of 100 values are allowed. Otherwise, an
  /// `INVALID_ARGUMENT` error is returned.
  core.List<core.String>? excludedFilterKeys;

  /// The facet key specification.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey? facetKey;

  /// Maximum facet values that are returned for this facet.
  ///
  /// If unspecified, defaults to 20. The maximum allowed value is 300. Values
  /// above 300 are coerced to 300. For aggregation in healthcare search, when
  /// the \[FacetKey.key\] is "healthcare_aggregation_key", the limit will be
  /// overridden to 10,000 internally, regardless of the value set here. If this
  /// field is negative, an `INVALID_ARGUMENT` is returned.
  core.int? limit;

  GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec({
    this.enableDynamicPosition,
    this.excludedFilterKeys,
    this.facetKey,
    this.limit,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpec.fromJson(
    core.Map json_,
  ) : this(
        enableDynamicPosition: json_['enableDynamicPosition'] as core.bool?,
        excludedFilterKeys:
            (json_['excludedFilterKeys'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        facetKey:
            json_.containsKey('facetKey')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.fromJson(
                  json_['facetKey'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        limit: json_['limit'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (enableDynamicPosition != null)
      'enableDynamicPosition': enableDynamicPosition!,
    if (excludedFilterKeys != null) 'excludedFilterKeys': excludedFilterKeys!,
    if (facetKey != null) 'facetKey': facetKey!,
    if (limit != null) 'limit': limit!,
  };
}

/// Specifies how a facet is computed.
class GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey {
  /// True to make facet keys case insensitive when getting faceting values with
  /// prefixes or contains; false otherwise.
  core.bool? caseInsensitive;

  /// Only get facet values that contain the given strings.
  ///
  /// For example, suppose "category" has three values "Action \> 2022", "Action
  /// \> 2021" and "Sci-Fi \> 2022". If set "contains" to "2022", the "category"
  /// facet only contains "Action \> 2022" and "Sci-Fi \> 2022". Only supported
  /// on textual fields. Maximum is 10.
  core.List<core.String>? contains;

  /// Set only if values should be bucketed into intervals.
  ///
  /// Must be set for facets with numerical values. Must not be set for facet
  /// with text values. Maximum number of intervals is 30.
  core.List<GoogleCloudDiscoveryengineV1alphaInterval>? intervals;

  /// Supported textual and numerical facet keys in Document object, over which
  /// the facet values are computed.
  ///
  /// Facet key is case-sensitive.
  ///
  /// Required.
  core.String? key;

  /// The order in which documents are returned.
  ///
  /// Allowed values are: * "count desc", which means order by
  /// SearchResponse.Facet.values.count descending. * "value desc", which means
  /// order by SearchResponse.Facet.values.value descending. Only applies to
  /// textual facets. If not set, textual values are sorted in
  /// [natural order](https://en.wikipedia.org/wiki/Natural_sort_order);
  /// numerical intervals are sorted in the order given by
  /// FacetSpec.FacetKey.intervals.
  core.String? orderBy;

  /// Only get facet values that start with the given string prefix.
  ///
  /// For example, suppose "category" has three values "Action \> 2022", "Action
  /// \> 2021" and "Sci-Fi \> 2022". If set "prefixes" to "Action", the
  /// "category" facet only contains "Action \> 2022" and "Action \> 2021". Only
  /// supported on textual fields. Maximum is 10.
  core.List<core.String>? prefixes;

  /// Only get facet for the given restricted values.
  ///
  /// Only supported on textual fields. For example, suppose "category" has
  /// three values "Action \> 2022", "Action \> 2021" and "Sci-Fi \> 2022". If
  /// set "restricted_values" to "Action \> 2022", the "category" facet only
  /// contains "Action \> 2022". Only supported on textual fields. Maximum is
  /// 10.
  core.List<core.String>? restrictedValues;

  GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey({
    this.caseInsensitive,
    this.contains,
    this.intervals,
    this.key,
    this.orderBy,
    this.prefixes,
    this.restrictedValues,
  });

  GoogleCloudDiscoveryengineV1alphaSearchRequestFacetSpecFacetKey.fromJson(
    core.Map json_,
  ) : this(
        caseInsensitive: json_['caseInsensitive'] as core.bool?,
        contains:
            (json_['contains'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        intervals:
            (json_['intervals'] as core.List?)
                ?.map(
                  (value) => GoogleCloudDiscoveryengineV1alphaInterval.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        key: json_['key'] as core.String?,
        orderBy: json_['orderBy'] as core.String?,
        prefixes:
            (json_['prefixes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        restrictedValues:
            (json_['restrictedValues'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (caseInsensitive != null) 'caseInsensitive': caseInsensitive!,
    if (contains != null) 'contains': contains!,
    if (intervals != null) 'intervals': intervals!,
    if (key != null) 'key': key!,
    if (orderBy != null) 'orderBy': orderBy!,
    if (prefixes != null) 'prefixes': prefixes!,
    if (restrictedValues != null) 'restrictedValues': restrictedValues!,
  };
}

/// Specifies the image query input.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestImageQuery =
    $SearchRequestImageQuery;

/// Specification to enable natural language understanding capabilities for
/// search requests.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestNaturalLanguageQueryUnderstandingSpec =
    $SearchRequestNaturalLanguageQueryUnderstandingSpec;

/// The specification for personalization.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestPersonalizationSpec =
    $SearchRequestPersonalizationSpec01;

/// Specification to determine under which conditions query expansion should
/// occur.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestQueryExpansionSpec =
    $SearchRequestQueryExpansionSpec00;

/// The specification for returning the document relevance score.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestRelevanceScoreSpec =
    $SearchRequestRelevanceScoreSpec;

/// Specification for search as you type in search requests.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestSearchAsYouTypeSpec =
    $SearchRequestSearchAsYouTypeSpec;

/// Session specification.
///
/// Multi-turn Search feature is currently at private GA stage. Please use
/// v1alpha or v1beta version instead before we launch this feature to public
/// GA. Or ask for allowlisting through Google Support team.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestSessionSpec =
    $SearchRequestSessionSpec;

/// The specification for query spell correction.
typedef GoogleCloudDiscoveryengineV1alphaSearchRequestSpellCorrectionSpec =
    $SearchRequestSpellCorrectionSpec00;

/// Response message for SearchService.Search method.
class GoogleCloudDiscoveryengineV1alphaSearchResponse {
  /// Controls applied as part of the Control service.
  core.List<core.String>? appliedControls;

  /// A unique search token.
  ///
  /// This should be included in the UserEvent logs resulting from this search,
  /// which enables accurate attribution of search model performance. This also
  /// helps to identify a request during the customer support scenarios.
  core.String? attributionToken;

  /// Contains the spell corrected query, if found.
  ///
  /// If the spell correction type is AUTOMATIC, then the search results are
  /// based on corrected_query. Otherwise the original query is used for search.
  core.String? correctedQuery;

  /// Results of facets requested by user.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseFacet>? facets;
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseGeoSearchDebugInfo>?
  geoSearchDebugInfo;

  /// Guided search result.
  GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResult?
  guidedSearchResult;

  /// Natural language query understanding information for the returned results.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfo?
  naturalLanguageQueryUnderstandingInfo;

  /// A token that can be sent as SearchRequest.page_token to retrieve the next
  /// page.
  ///
  /// If this field is omitted, there are no subsequent pages.
  core.String? nextPageToken;

  /// A list of One Box results.
  ///
  /// There can be multiple One Box results of different types.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseOneBoxResult>?
  oneBoxResults;

  /// Query expansion information for the returned results.
  GoogleCloudDiscoveryengineV1alphaSearchResponseQueryExpansionInfo?
  queryExpansionInfo;

  /// The URI of a customer-defined redirect page.
  ///
  /// If redirect action is triggered, no search is performed, and only
  /// redirect_uri and attribution_token are set in the response.
  core.String? redirectUri;

  /// A list of matched documents.
  ///
  /// The order represents the ranking.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult>?
  results;

  /// Promotions for site search.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchLinkPromotion>?
  searchLinkPromotions;

  /// Session information.
  ///
  /// Only set if SearchRequest.session is provided. See its description for
  /// more details.
  GoogleCloudDiscoveryengineV1alphaSearchResponseSessionInfo? sessionInfo;

  /// Corrected query with low confidence, AKA did you mean query.
  ///
  /// Compared with corrected_query, this field is set when SpellCorrector
  /// returned a response, but FPR(full page replacement) is not triggered
  /// because the corrction is of low confidence(eg, reversed because there are
  /// matches of the original query in document corpus).
  core.String? suggestedQuery;

  /// A summary as part of the search results.
  ///
  /// This field is only returned if
  /// SearchRequest.ContentSearchSpec.summary_spec is set.
  GoogleCloudDiscoveryengineV1alphaSearchResponseSummary? summary;

  /// The estimated total count of matched items irrespective of pagination.
  ///
  /// The count of results returned by pagination may be less than the
  /// total_size that matches.
  core.int? totalSize;

  GoogleCloudDiscoveryengineV1alphaSearchResponse({
    this.appliedControls,
    this.attributionToken,
    this.correctedQuery,
    this.facets,
    this.geoSearchDebugInfo,
    this.guidedSearchResult,
    this.naturalLanguageQueryUnderstandingInfo,
    this.nextPageToken,
    this.oneBoxResults,
    this.queryExpansionInfo,
    this.redirectUri,
    this.results,
    this.searchLinkPromotions,
    this.sessionInfo,
    this.suggestedQuery,
    this.summary,
    this.totalSize,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponse.fromJson(core.Map json_)
    : this(
        appliedControls:
            (json_['appliedControls'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        attributionToken: json_['attributionToken'] as core.String?,
        correctedQuery: json_['correctedQuery'] as core.String?,
        facets:
            (json_['facets'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseFacet.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        geoSearchDebugInfo:
            (json_['geoSearchDebugInfo'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseGeoSearchDebugInfo.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        guidedSearchResult:
            json_.containsKey('guidedSearchResult')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResult.fromJson(
                  json_['guidedSearchResult']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        naturalLanguageQueryUnderstandingInfo:
            json_.containsKey('naturalLanguageQueryUnderstandingInfo')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfo.fromJson(
                  json_['naturalLanguageQueryUnderstandingInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        nextPageToken: json_['nextPageToken'] as core.String?,
        oneBoxResults:
            (json_['oneBoxResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseOneBoxResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        queryExpansionInfo:
            json_.containsKey('queryExpansionInfo')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseQueryExpansionInfo.fromJson(
                  json_['queryExpansionInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        redirectUri: json_['redirectUri'] as core.String?,
        results:
            (json_['results'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        searchLinkPromotions:
            (json_['searchLinkPromotions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchLinkPromotion.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        sessionInfo:
            json_.containsKey('sessionInfo')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseSessionInfo.fromJson(
                  json_['sessionInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        suggestedQuery: json_['suggestedQuery'] as core.String?,
        summary:
            json_.containsKey('summary')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseSummary.fromJson(
                  json_['summary'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        totalSize: json_['totalSize'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (appliedControls != null) 'appliedControls': appliedControls!,
    if (attributionToken != null) 'attributionToken': attributionToken!,
    if (correctedQuery != null) 'correctedQuery': correctedQuery!,
    if (facets != null) 'facets': facets!,
    if (geoSearchDebugInfo != null) 'geoSearchDebugInfo': geoSearchDebugInfo!,
    if (guidedSearchResult != null) 'guidedSearchResult': guidedSearchResult!,
    if (naturalLanguageQueryUnderstandingInfo != null)
      'naturalLanguageQueryUnderstandingInfo':
          naturalLanguageQueryUnderstandingInfo!,
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (oneBoxResults != null) 'oneBoxResults': oneBoxResults!,
    if (queryExpansionInfo != null) 'queryExpansionInfo': queryExpansionInfo!,
    if (redirectUri != null) 'redirectUri': redirectUri!,
    if (results != null) 'results': results!,
    if (searchLinkPromotions != null)
      'searchLinkPromotions': searchLinkPromotions!,
    if (sessionInfo != null) 'sessionInfo': sessionInfo!,
    if (suggestedQuery != null) 'suggestedQuery': suggestedQuery!,
    if (summary != null) 'summary': summary!,
    if (totalSize != null) 'totalSize': totalSize!,
  };
}

/// A facet result.
class GoogleCloudDiscoveryengineV1alphaSearchResponseFacet {
  /// Whether the facet is dynamically generated.
  core.bool? dynamicFacet;

  /// The key for this facet.
  ///
  /// For example, `"colors"` or `"price"`. It matches
  /// SearchRequest.FacetSpec.FacetKey.key.
  core.String? key;

  /// The facet values for this field.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseFacetFacetValue>?
  values;

  GoogleCloudDiscoveryengineV1alphaSearchResponseFacet({
    this.dynamicFacet,
    this.key,
    this.values,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseFacet.fromJson(core.Map json_)
    : this(
        dynamicFacet: json_['dynamicFacet'] as core.bool?,
        key: json_['key'] as core.String?,
        values:
            (json_['values'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseFacetFacetValue.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dynamicFacet != null) 'dynamicFacet': dynamicFacet!,
    if (key != null) 'key': key!,
    if (values != null) 'values': values!,
  };
}

/// A facet value which contains value names and their count.
class GoogleCloudDiscoveryengineV1alphaSearchResponseFacetFacetValue {
  /// Number of items that have this facet value.
  core.String? count;

  /// Interval value for a facet, such as 10, 20) for facet "price".
  ///
  /// It matches \[SearchRequest.FacetSpec.FacetKey.intervals.
  GoogleCloudDiscoveryengineV1alphaInterval? interval;

  /// Text value of a facet, such as "Black" for facet "colors".
  core.String? value;

  GoogleCloudDiscoveryengineV1alphaSearchResponseFacetFacetValue({
    this.count,
    this.interval,
    this.value,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseFacetFacetValue.fromJson(
    core.Map json_,
  ) : this(
        count: json_['count'] as core.String?,
        interval:
            json_.containsKey('interval')
                ? GoogleCloudDiscoveryengineV1alphaInterval.fromJson(
                  json_['interval'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        value: json_['value'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (count != null) 'count': count!,
    if (interval != null) 'interval': interval!,
    if (value != null) 'value': value!,
  };
}

/// Debug information specifically related to forward geocoding issues arising
/// from Geolocation Search.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseGeoSearchDebugInfo =
    $SearchResponseGeoSearchDebugInfo;

/// Guided search result.
///
/// The guided search helps user to refine the search results and narrow down to
/// the real needs from a broaded search results.
class GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResult {
  /// Suggested follow-up questions.
  core.List<core.String>? followUpQuestions;

  /// A list of ranked refinement attributes.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResultRefinementAttribute
  >?
  refinementAttributes;

  GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResult({
    this.followUpQuestions,
    this.refinementAttributes,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResult.fromJson(
    core.Map json_,
  ) : this(
        followUpQuestions:
            (json_['followUpQuestions'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        refinementAttributes:
            (json_['refinementAttributes'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResultRefinementAttribute.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (followUpQuestions != null) 'followUpQuestions': followUpQuestions!,
    if (refinementAttributes != null)
      'refinementAttributes': refinementAttributes!,
  };
}

/// Useful attribute for search result refinements.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseGuidedSearchResultRefinementAttribute =
    $SearchResponseGuidedSearchResultRefinementAttribute;

/// Information describing what natural language understanding was done on the
/// input query.
class GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfo {
  /// The classified intents from the input query.
  core.List<core.String>? classifiedIntents;

  /// The filters that were extracted from the input query.
  core.String? extractedFilters;

  /// Rewritten input query minus the extracted filters.
  core.String? rewrittenQuery;

  /// The filters that were extracted from the input query represented in a
  /// structured form.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilter?
  structuredExtractedFilter;

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfo({
    this.classifiedIntents,
    this.extractedFilters,
    this.rewrittenQuery,
    this.structuredExtractedFilter,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfo.fromJson(
    core.Map json_,
  ) : this(
        classifiedIntents:
            (json_['classifiedIntents'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        extractedFilters: json_['extractedFilters'] as core.String?,
        rewrittenQuery: json_['rewrittenQuery'] as core.String?,
        structuredExtractedFilter:
            json_.containsKey('structuredExtractedFilter')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilter.fromJson(
                  json_['structuredExtractedFilter']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (classifiedIntents != null) 'classifiedIntents': classifiedIntents!,
    if (extractedFilters != null) 'extractedFilters': extractedFilters!,
    if (rewrittenQuery != null) 'rewrittenQuery': rewrittenQuery!,
    if (structuredExtractedFilter != null)
      'structuredExtractedFilter': structuredExtractedFilter!,
  };
}

/// The filters that were extracted from the input query represented in a
/// structured form.
class GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilter {
  /// The expression denoting the filter that was extracted from the input query
  /// in a structured form.
  ///
  /// It can be a simple expression denoting a single string, numerical or
  /// geolocation constraint or a compound expression which is a combination of
  /// multiple expressions connected using logical (OR and AND) operators.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression?
  expression;

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilter({
    this.expression,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilter.fromJson(
    core.Map json_,
  ) : this(
        expression:
            json_.containsKey('expression')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression.fromJson(
                  json_['expression'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expression != null) 'expression': expression!,
  };
}

/// Logical `And` operator.
class GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterAndExpression {
  /// The expressions that were ANDed together.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression
  >?
  expressions;

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterAndExpression({
    this.expressions,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterAndExpression.fromJson(
    core.Map json_,
  ) : this(
        expressions:
            (json_['expressions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expressions != null) 'expressions': expressions!,
  };
}

/// The expression denoting the filter that was extracted from the input query.
class GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression {
  /// Logical "And" compound operator connecting multiple expressions.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterAndExpression?
  andExpr;

  /// Geolocation constraint expression.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint?
  geolocationConstraint;

  /// Numerical constraint expression.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint?
  numberConstraint;

  /// Logical "Or" compound operator connecting multiple expressions.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterOrExpression?
  orExpr;

  /// String constraint expression.
  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint?
  stringConstraint;

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression({
    this.andExpr,
    this.geolocationConstraint,
    this.numberConstraint,
    this.orExpr,
    this.stringConstraint,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression.fromJson(
    core.Map json_,
  ) : this(
        andExpr:
            json_.containsKey('andExpr')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterAndExpression.fromJson(
                  json_['andExpr'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        geolocationConstraint:
            json_.containsKey('geolocationConstraint')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint.fromJson(
                  json_['geolocationConstraint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        numberConstraint:
            json_.containsKey('numberConstraint')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint.fromJson(
                  json_['numberConstraint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        orExpr:
            json_.containsKey('orExpr')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterOrExpression.fromJson(
                  json_['orExpr'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        stringConstraint:
            json_.containsKey('stringConstraint')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint.fromJson(
                  json_['stringConstraint']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (andExpr != null) 'andExpr': andExpr!,
    if (geolocationConstraint != null)
      'geolocationConstraint': geolocationConstraint!,
    if (numberConstraint != null) 'numberConstraint': numberConstraint!,
    if (orExpr != null) 'orExpr': orExpr!,
    if (stringConstraint != null) 'stringConstraint': stringConstraint!,
  };
}

/// Constraint of a geolocation field.
///
/// Name of the geolocation field as defined in the schema.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint =
    $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterGeolocationConstraint;

/// Constraint expression of a number field.
///
/// Example: price \< 100.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint =
    $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterNumberConstraint;

/// Logical `Or` operator.
class GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterOrExpression {
  /// The expressions that were ORed together.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression
  >?
  expressions;

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterOrExpression({
    this.expressions,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterOrExpression.fromJson(
    core.Map json_,
  ) : this(
        expressions:
            (json_['expressions'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterExpression.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (expressions != null) 'expressions': expressions!,
  };
}

/// Constraint expression of a string field.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint =
    $SearchResponseNaturalLanguageQueryUnderstandingInfoStructuredExtractedFilterStringConstraint;

/// OneBoxResult is a holder for all results of specific type that we want to
/// display in UI differently.
class GoogleCloudDiscoveryengineV1alphaSearchResponseOneBoxResult {
  /// The type of One Box result.
  /// Possible string values are:
  /// - "ONE_BOX_TYPE_UNSPECIFIED" : Default value. Should not be used.
  /// - "PEOPLE" : One Box result contains people results.
  /// - "ORGANIZATION" : One Box result contains organization results.
  /// - "SLACK" : One Box result contains slack results.
  /// - "KNOWLEDGE_GRAPH" : One Box result contains Knowledge Graph search
  /// responses.
  core.String? oneBoxType;

  /// The search results for this One Box.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult>?
  searchResults;

  GoogleCloudDiscoveryengineV1alphaSearchResponseOneBoxResult({
    this.oneBoxType,
    this.searchResults,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseOneBoxResult.fromJson(
    core.Map json_,
  ) : this(
        oneBoxType: json_['oneBoxType'] as core.String?,
        searchResults:
            (json_['searchResults'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (oneBoxType != null) 'oneBoxType': oneBoxType!,
    if (searchResults != null) 'searchResults': searchResults!,
  };
}

/// Information describing query expansion including whether expansion has
/// occurred.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseQueryExpansionInfo =
    $SearchResponseQueryExpansionInfo;

/// Represents the search results.
class GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult {
  /// The chunk data in the search response if the
  /// SearchRequest.ContentSearchSpec.search_result_mode is set to CHUNKS.
  GoogleCloudDiscoveryengineV1alphaChunk? chunk;

  /// The document data snippet in the search response.
  ///
  /// Only fields that are marked as `retrievable` are populated.
  GoogleCloudDiscoveryengineV1alphaDocument? document;

  /// Document.id of the searched Document.
  core.String? id;

  /// Google provided available scores.
  ///
  /// Output only.
  core.Map<core.String, GoogleCloudDiscoveryengineV1alphaDoubleList>?
  modelScores;

  GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult({
    this.chunk,
    this.document,
    this.id,
    this.modelScores,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseSearchResult.fromJson(
    core.Map json_,
  ) : this(
        chunk:
            json_.containsKey('chunk')
                ? GoogleCloudDiscoveryengineV1alphaChunk.fromJson(
                  json_['chunk'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        document:
            json_.containsKey('document')
                ? GoogleCloudDiscoveryengineV1alphaDocument.fromJson(
                  json_['document'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        id: json_['id'] as core.String?,
        modelScores:
            (json_['modelScores'] as core.Map<core.String, core.dynamic>?)?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudDiscoveryengineV1alphaDoubleList.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunk != null) 'chunk': chunk!,
    if (document != null) 'document': document!,
    if (id != null) 'id': id!,
    if (modelScores != null) 'modelScores': modelScores!,
  };
}

/// Information about the session.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseSessionInfo =
    $SearchResponseSessionInfo;

/// Summary of the top N search results specified by the summary spec.
class GoogleCloudDiscoveryengineV1alphaSearchResponseSummary {
  /// A collection of Safety Attribute categories and their associated
  /// confidence scores.
  GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySafetyAttributes?
  safetyAttributes;

  /// Additional summary-skipped reasons.
  ///
  /// This provides the reason for ignored cases. If nothing is skipped, this
  /// field is not set.
  core.List<core.String>? summarySkippedReasons;

  /// The summary content.
  core.String? summaryText;

  /// Summary with metadata information.
  GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySummaryWithMetadata?
  summaryWithMetadata;

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummary({
    this.safetyAttributes,
    this.summarySkippedReasons,
    this.summaryText,
    this.summaryWithMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummary.fromJson(
    core.Map json_,
  ) : this(
        safetyAttributes:
            json_.containsKey('safetyAttributes')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySafetyAttributes.fromJson(
                  json_['safetyAttributes']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        summarySkippedReasons:
            (json_['summarySkippedReasons'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        summaryText: json_['summaryText'] as core.String?,
        summaryWithMetadata:
            json_.containsKey('summaryWithMetadata')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySummaryWithMetadata.fromJson(
                  json_['summaryWithMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (safetyAttributes != null) 'safetyAttributes': safetyAttributes!,
    if (summarySkippedReasons != null)
      'summarySkippedReasons': summarySkippedReasons!,
    if (summaryText != null) 'summaryText': summaryText!,
    if (summaryWithMetadata != null)
      'summaryWithMetadata': summaryWithMetadata!,
  };
}

/// Stores binarydata attached to text answer, e.g. image, video, audio, etc.
class GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachment {
  /// The attribution type of the blob.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "ATTRIBUTION_TYPE_UNSPECIFIED" : Unspecified attribution type.
  /// - "CORPUS" : The attachment data is from the corpus.
  /// - "GENERATED" : The attachment data is generated by the model through code
  /// generation.
  core.String? attributionType;

  /// The blob data.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachmentBlob?
  data;

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachment({
    this.attributionType,
    this.data,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachment.fromJson(
    core.Map json_,
  ) : this(
        attributionType: json_['attributionType'] as core.String?,
        data:
            json_.containsKey('data')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachmentBlob.fromJson(
                  json_['data'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributionType != null) 'attributionType': attributionType!,
    if (data != null) 'data': data!,
  };
}

/// Stores type and data of the blob.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachmentBlob =
    $SearchResponseSummaryBlobAttachmentBlob;

/// Citation info for a segment.
class GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitation {
  /// End of the attributed segment, exclusive.
  core.String? endIndex;

  /// Citation sources for the attributed segment.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationSource
  >?
  sources;

  /// Index indicates the start of the segment, measured in bytes/unicode.
  core.String? startIndex;

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitation({
    this.endIndex,
    this.sources,
    this.startIndex,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitation.fromJson(
    core.Map json_,
  ) : this(
        endIndex: json_['endIndex'] as core.String?,
        sources:
            (json_['sources'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationSource.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        startIndex: json_['startIndex'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (endIndex != null) 'endIndex': endIndex!,
    if (sources != null) 'sources': sources!,
    if (startIndex != null) 'startIndex': startIndex!,
  };
}

/// Citation metadata.
class GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationMetadata {
  /// Citations for segments.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitation>?
  citations;

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationMetadata({
    this.citations,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationMetadata.fromJson(
    core.Map json_,
  ) : this(
        citations:
            (json_['citations'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitation.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (citations != null) 'citations': citations!,
  };
}

/// Citation source.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationSource =
    $SearchResponseSummaryCitationSource;

/// Document reference.
class GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReference {
  /// List of cited chunk contents derived from document content.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReferenceChunkContent
  >?
  chunkContents;

  /// Document.name of the document.
  ///
  /// Full resource name of the referenced document, in the format `projects / *
  /// /locations / * /collections / * /dataStores / * /branches / * /documents /
  /// * `.
  ///
  /// Required.
  core.String? document;

  /// Title of the document.
  core.String? title;

  /// Cloud Storage or HTTP uri for the document.
  core.String? uri;

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReference({
    this.chunkContents,
    this.document,
    this.title,
    this.uri,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReference.fromJson(
    core.Map json_,
  ) : this(
        chunkContents:
            (json_['chunkContents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReferenceChunkContent.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        document: json_['document'] as core.String?,
        title: json_['title'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (chunkContents != null) 'chunkContents': chunkContents!,
    if (document != null) 'document': document!,
    if (title != null) 'title': title!,
    if (uri != null) 'uri': uri!,
  };
}

/// Chunk content.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReferenceChunkContent =
    $SearchResponseSummaryReferenceChunkContent;

/// Safety Attribute categories and their associated confidence scores.
typedef GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySafetyAttributes =
    $SearchResponseSummarySafetyAttributes;

/// Summary with metadata information.
class GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySummaryWithMetadata {
  /// Store multimodal data for answer enhancement.
  ///
  /// Output only.
  core.List<
    GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachment
  >?
  blobAttachments;

  /// Citation metadata for given summary.
  GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationMetadata?
  citationMetadata;

  /// Document References.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReference>?
  references;

  /// Summary text with no citation information.
  core.String? summary;

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySummaryWithMetadata({
    this.blobAttachments,
    this.citationMetadata,
    this.references,
    this.summary,
  });

  GoogleCloudDiscoveryengineV1alphaSearchResponseSummarySummaryWithMetadata.fromJson(
    core.Map json_,
  ) : this(
        blobAttachments:
            (json_['blobAttachments'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryBlobAttachment.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        citationMetadata:
            json_.containsKey('citationMetadata')
                ? GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryCitationMetadata.fromJson(
                  json_['citationMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        references:
            (json_['references'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchResponseSummaryReference.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        summary: json_['summary'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blobAttachments != null) 'blobAttachments': blobAttachments!,
    if (citationMetadata != null) 'citationMetadata': citationMetadata!,
    if (references != null) 'references': references!,
    if (summary != null) 'summary': summary!,
  };
}

/// Configures metadata that is used to generate serving time results (e.g.
/// search results or recommendation predictions).
///
/// The ServingConfig is passed in the search and predict request and generates
/// results.
class GoogleCloudDiscoveryengineV1alphaServingConfig {
  /// The specification for answer generation.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpec? answerGenerationSpec;

  /// Boost controls to use in serving path.
  ///
  /// All triggered boost controls will be applied. Boost controls must be in
  /// the same data store as the serving config. Maximum of 20 boost controls.
  core.List<core.String>? boostControlIds;

  /// ServingConfig created timestamp.
  ///
  /// Output only.
  core.String? createTime;

  /// Custom fine tuning configs.
  ///
  /// If SearchRequest.custom_fine_tuning_spec is set, it has higher priority
  /// than the configs set here.
  GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec? customFineTuningSpec;

  /// The human readable serving config display name.
  ///
  /// Used in Discovery UI. This field must be a UTF-8 encoded string with a
  /// length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  ///
  /// Required.
  core.String? displayName;

  /// Condition do not associate specifications.
  ///
  /// If multiple do not associate conditions match, all matching do not
  /// associate controls in the list will execute. Order does not matter.
  /// Maximum number of specifications is 100. Can only be set if SolutionType
  /// is SOLUTION_TYPE_SEARCH.
  core.List<core.String>? dissociateControlIds;

  /// How much diversity to use in recommendation model results e.g.
  /// `medium-diversity` or `high-diversity`.
  ///
  /// Currently supported values: * `no-diversity` * `low-diversity` *
  /// `medium-diversity` * `high-diversity` * `auto-diversity` If not specified,
  /// we choose default based on recommendation model type. Default value:
  /// `no-diversity`. Can only be set if SolutionType is
  /// SOLUTION_TYPE_RECOMMENDATION.
  core.String? diversityLevel;

  /// Bring your own embedding config.
  ///
  /// The config is used for search semantic retrieval. The retrieval is based
  /// on the dot product of SearchRequest.EmbeddingSpec.EmbeddingVector.vector
  /// and the document embeddings that are provided by this EmbeddingConfig. If
  /// SearchRequest.EmbeddingSpec.EmbeddingVector.vector is provided, it
  /// overrides this ServingConfig.embedding_config.
  GoogleCloudDiscoveryengineV1alphaEmbeddingConfig? embeddingConfig;

  /// Filter controls to use in serving path.
  ///
  /// All triggered filter controls will be applied. Filter controls must be in
  /// the same data store as the serving config. Maximum of 20 filter controls.
  core.List<core.String>? filterControlIds;

  /// The GenericConfig of the serving configuration.
  GoogleCloudDiscoveryengineV1alphaServingConfigGenericConfig? genericConfig;

  /// Guided search configs.
  GoogleCloudDiscoveryengineV1alphaGuidedSearchSpec? guidedSearchSpec;

  /// Condition ignore specifications.
  ///
  /// If multiple ignore conditions match, all matching ignore controls in the
  /// list will execute. Order does not matter. Maximum number of specifications
  /// is 100.
  core.List<core.String>? ignoreControlIds;

  /// The MediaConfig of the serving configuration.
  GoogleCloudDiscoveryengineV1alphaServingConfigMediaConfig? mediaConfig;

  /// The id of the model to use at serving time.
  ///
  /// Currently only RecommendationModels are supported. Can be changed but only
  /// to a compatible model (e.g. others-you-may-like CTR to others-you-may-like
  /// CVR). Required when SolutionType is SOLUTION_TYPE_RECOMMENDATION.
  core.String? modelId;

  /// Fully qualified name
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
  ///
  /// Immutable.
  core.String? name;

  /// Condition oneway synonyms specifications.
  ///
  /// If multiple oneway synonyms conditions match, all matching oneway synonyms
  /// controls in the list will execute. Maximum number of specifications is
  /// 100. Can only be set if SolutionType is SOLUTION_TYPE_SEARCH.
  core.List<core.String>? onewaySynonymsControlIds;

  /// The specification for personalization spec.
  ///
  /// Notice that if both ServingConfig.personalization_spec and
  /// SearchRequest.personalization_spec are set,
  /// SearchRequest.personalization_spec overrides
  /// ServingConfig.personalization_spec.
  GoogleCloudDiscoveryengineV1alphaSearchRequestPersonalizationSpec?
  personalizationSpec;

  /// Condition promote specifications.
  ///
  /// Maximum number of specifications is 100.
  core.List<core.String>? promoteControlIds;

  /// The ranking expression controls the customized ranking on retrieval
  /// documents.
  ///
  /// To leverage this, document embedding is required. The ranking expression
  /// setting in ServingConfig applies to all search requests served by the
  /// serving config. However, if `SearchRequest.ranking_expression` is
  /// specified, it overrides the ServingConfig ranking expression. The ranking
  /// expression is a single function or multiple functions that are joined by
  /// "+". * ranking_expression = function, { " + ", function }; Supported
  /// functions: * double * relevance_score * double *
  /// dotProduct(embedding_field_path) Function variables: * `relevance_score`:
  /// pre-defined keywords, used for measure relevance between query and
  /// document. * `embedding_field_path`: the document embedding field used with
  /// query embedding vector. * `dotProduct`: embedding function between
  /// embedding_field_path and query embedding vector. Example ranking
  /// expression: If document has an embedding field doc_embedding, the ranking
  /// expression could be `0.5 * relevance_score + 0.3 *
  /// dotProduct(doc_embedding)`.
  core.String? rankingExpression;

  /// IDs of the redirect controls.
  ///
  /// Only the first triggered redirect action is applied, even if multiple
  /// apply. Maximum number of specifications is 100. Can only be set if
  /// SolutionType is SOLUTION_TYPE_SEARCH.
  core.List<core.String>? redirectControlIds;

  /// Condition replacement specifications.
  ///
  /// Applied according to the order in the list. A previously replaced term can
  /// not be re-replaced. Maximum number of specifications is 100. Can only be
  /// set if SolutionType is SOLUTION_TYPE_SEARCH.
  core.List<core.String>? replacementControlIds;

  /// Specifies the solution type that a serving config can be associated with.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "SOLUTION_TYPE_UNSPECIFIED" : Default value.
  /// - "SOLUTION_TYPE_RECOMMENDATION" : Used for Recommendations AI.
  /// - "SOLUTION_TYPE_SEARCH" : Used for Discovery Search.
  /// - "SOLUTION_TYPE_CHAT" : Used for use cases related to the Generative AI
  /// agent.
  /// - "SOLUTION_TYPE_GENERATIVE_CHAT" : Used for use cases related to the
  /// Generative Chat agent. It's used for Generative chat engine only, the
  /// associated data stores must enrolled with `SOLUTION_TYPE_CHAT` solution.
  core.String? solutionType;

  /// Condition synonyms specifications.
  ///
  /// If multiple synonyms conditions match, all matching synonyms controls in
  /// the list will execute. Maximum number of specifications is 100. Can only
  /// be set if SolutionType is SOLUTION_TYPE_SEARCH.
  core.List<core.String>? synonymsControlIds;

  /// ServingConfig updated timestamp.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudDiscoveryengineV1alphaServingConfig({
    this.answerGenerationSpec,
    this.boostControlIds,
    this.createTime,
    this.customFineTuningSpec,
    this.displayName,
    this.dissociateControlIds,
    this.diversityLevel,
    this.embeddingConfig,
    this.filterControlIds,
    this.genericConfig,
    this.guidedSearchSpec,
    this.ignoreControlIds,
    this.mediaConfig,
    this.modelId,
    this.name,
    this.onewaySynonymsControlIds,
    this.personalizationSpec,
    this.promoteControlIds,
    this.rankingExpression,
    this.redirectControlIds,
    this.replacementControlIds,
    this.solutionType,
    this.synonymsControlIds,
    this.updateTime,
  });

  GoogleCloudDiscoveryengineV1alphaServingConfig.fromJson(core.Map json_)
    : this(
        answerGenerationSpec:
            json_.containsKey('answerGenerationSpec')
                ? GoogleCloudDiscoveryengineV1alphaAnswerGenerationSpec.fromJson(
                  json_['answerGenerationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        boostControlIds:
            (json_['boostControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        createTime: json_['createTime'] as core.String?,
        customFineTuningSpec:
            json_.containsKey('customFineTuningSpec')
                ? GoogleCloudDiscoveryengineV1alphaCustomFineTuningSpec.fromJson(
                  json_['customFineTuningSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        displayName: json_['displayName'] as core.String?,
        dissociateControlIds:
            (json_['dissociateControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        diversityLevel: json_['diversityLevel'] as core.String?,
        embeddingConfig:
            json_.containsKey('embeddingConfig')
                ? GoogleCloudDiscoveryengineV1alphaEmbeddingConfig.fromJson(
                  json_['embeddingConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        filterControlIds:
            (json_['filterControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        genericConfig:
            json_.containsKey('genericConfig')
                ? GoogleCloudDiscoveryengineV1alphaServingConfigGenericConfig.fromJson(
                  json_['genericConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        guidedSearchSpec:
            json_.containsKey('guidedSearchSpec')
                ? GoogleCloudDiscoveryengineV1alphaGuidedSearchSpec.fromJson(
                  json_['guidedSearchSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        ignoreControlIds:
            (json_['ignoreControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        mediaConfig:
            json_.containsKey('mediaConfig')
                ? GoogleCloudDiscoveryengineV1alphaServingConfigMediaConfig.fromJson(
                  json_['mediaConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelId: json_['modelId'] as core.String?,
        name: json_['name'] as core.String?,
        onewaySynonymsControlIds:
            (json_['onewaySynonymsControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        personalizationSpec:
            json_.containsKey('personalizationSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestPersonalizationSpec.fromJson(
                  json_['personalizationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        promoteControlIds:
            (json_['promoteControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        rankingExpression: json_['rankingExpression'] as core.String?,
        redirectControlIds:
            (json_['redirectControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        replacementControlIds:
            (json_['replacementControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        solutionType: json_['solutionType'] as core.String?,
        synonymsControlIds:
            (json_['synonymsControlIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answerGenerationSpec != null)
      'answerGenerationSpec': answerGenerationSpec!,
    if (boostControlIds != null) 'boostControlIds': boostControlIds!,
    if (createTime != null) 'createTime': createTime!,
    if (customFineTuningSpec != null)
      'customFineTuningSpec': customFineTuningSpec!,
    if (displayName != null) 'displayName': displayName!,
    if (dissociateControlIds != null)
      'dissociateControlIds': dissociateControlIds!,
    if (diversityLevel != null) 'diversityLevel': diversityLevel!,
    if (embeddingConfig != null) 'embeddingConfig': embeddingConfig!,
    if (filterControlIds != null) 'filterControlIds': filterControlIds!,
    if (genericConfig != null) 'genericConfig': genericConfig!,
    if (guidedSearchSpec != null) 'guidedSearchSpec': guidedSearchSpec!,
    if (ignoreControlIds != null) 'ignoreControlIds': ignoreControlIds!,
    if (mediaConfig != null) 'mediaConfig': mediaConfig!,
    if (modelId != null) 'modelId': modelId!,
    if (name != null) 'name': name!,
    if (onewaySynonymsControlIds != null)
      'onewaySynonymsControlIds': onewaySynonymsControlIds!,
    if (personalizationSpec != null)
      'personalizationSpec': personalizationSpec!,
    if (promoteControlIds != null) 'promoteControlIds': promoteControlIds!,
    if (rankingExpression != null) 'rankingExpression': rankingExpression!,
    if (redirectControlIds != null) 'redirectControlIds': redirectControlIds!,
    if (replacementControlIds != null)
      'replacementControlIds': replacementControlIds!,
    if (solutionType != null) 'solutionType': solutionType!,
    if (synonymsControlIds != null) 'synonymsControlIds': synonymsControlIds!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Specifies the configurations needed for Generic Discovery.Currently we
/// support: * `content_search_spec`: configuration for generic content search.
class GoogleCloudDiscoveryengineV1alphaServingConfigGenericConfig {
  /// Specifies the expected behavior of content search.
  ///
  /// Only valid for content-search enabled data store.
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec?
  contentSearchSpec;

  GoogleCloudDiscoveryengineV1alphaServingConfigGenericConfig({
    this.contentSearchSpec,
  });

  GoogleCloudDiscoveryengineV1alphaServingConfigGenericConfig.fromJson(
    core.Map json_,
  ) : this(
        contentSearchSpec:
            json_.containsKey('contentSearchSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec.fromJson(
                  json_['contentSearchSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentSearchSpec != null) 'contentSearchSpec': contentSearchSpec!,
  };
}

/// Specifies the configurations needed for Media Discovery.
///
/// Currently we support: * `demote_content_watched`: Threshold for watched
/// content demotion. Customers can specify if using watched content demotion or
/// use viewed detail page. Using the content watched demotion, customers need
/// to specify the watched minutes or percentage exceeds the threshold, the
/// content will be demoted in the recommendation result. *
/// `promote_fresh_content`: cutoff days for fresh content promotion. Customers
/// can specify if using content freshness promotion. If the content was
/// published within the cutoff days, the content will be promoted in the
/// recommendation result. Can only be set if SolutionType is
/// SOLUTION_TYPE_RECOMMENDATION.
typedef GoogleCloudDiscoveryengineV1alphaServingConfigMediaConfig =
    $ServingConfigMediaConfig;

/// External session proto definition.
class GoogleCloudDiscoveryengineV1alphaSession {
  /// The display name of the session.
  ///
  /// This field is used to identify the session in the UI. By default, the
  /// display name is the first turn query text in the session.
  ///
  /// Optional.
  core.String? displayName;

  /// The time the session finished.
  ///
  /// Output only.
  core.String? endTime;

  /// Whether the session is pinned, pinned session will be displayed on the top
  /// of the session list.
  ///
  /// Optional.
  core.bool? isPinned;

  /// Fully qualified name
  /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions
  /// / * `
  ///
  /// Immutable.
  core.String? name;

  /// The time the session started.
  ///
  /// Output only.
  core.String? startTime;

  /// The state of the session.
  /// Possible string values are:
  /// - "STATE_UNSPECIFIED" : State is unspecified.
  /// - "IN_PROGRESS" : The session is currently open.
  core.String? state;

  /// Turns.
  core.List<GoogleCloudDiscoveryengineV1alphaSessionTurn>? turns;

  /// A unique identifier for tracking users.
  core.String? userPseudoId;

  GoogleCloudDiscoveryengineV1alphaSession({
    this.displayName,
    this.endTime,
    this.isPinned,
    this.name,
    this.startTime,
    this.state,
    this.turns,
    this.userPseudoId,
  });

  GoogleCloudDiscoveryengineV1alphaSession.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        endTime: json_['endTime'] as core.String?,
        isPinned: json_['isPinned'] as core.bool?,
        name: json_['name'] as core.String?,
        startTime: json_['startTime'] as core.String?,
        state: json_['state'] as core.String?,
        turns:
            (json_['turns'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSessionTurn.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        userPseudoId: json_['userPseudoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (endTime != null) 'endTime': endTime!,
    if (isPinned != null) 'isPinned': isPinned!,
    if (name != null) 'name': name!,
    if (startTime != null) 'startTime': startTime!,
    if (state != null) 'state': state!,
    if (turns != null) 'turns': turns!,
    if (userPseudoId != null) 'userPseudoId': userPseudoId!,
  };
}

/// Represents a turn, including a query from the user and a answer from
/// service.
class GoogleCloudDiscoveryengineV1alphaSessionTurn {
  /// The resource name of the answer to the user query.
  ///
  /// Only set if the answer generation (/answer API call) happened in this
  /// turn.
  ///
  /// Optional.
  core.String? answer;

  /// In ConversationalSearchService.GetSession API, if
  /// GetSessionRequest.include_answer_details is set to true, this field will
  /// be populated when getting answer query session.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaAnswer? detailedAnswer;

  /// The user query.
  ///
  /// May not be set if this turn is merely regenerating an answer to a
  /// different turn
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaQuery? query;

  /// Represents metadata related to the query config, for example LLM model and
  /// version used, model parameters (temperature, grounding parameters, etc.).
  ///
  /// The prefix "google." is reserved for Google-developed functionality.
  ///
  /// Optional.
  core.Map<core.String, core.String>? queryConfig;

  GoogleCloudDiscoveryengineV1alphaSessionTurn({
    this.answer,
    this.detailedAnswer,
    this.query,
    this.queryConfig,
  });

  GoogleCloudDiscoveryengineV1alphaSessionTurn.fromJson(core.Map json_)
    : this(
        answer: json_['answer'] as core.String?,
        detailedAnswer:
            json_.containsKey('detailedAnswer')
                ? GoogleCloudDiscoveryengineV1alphaAnswer.fromJson(
                  json_['detailedAnswer']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        query:
            json_.containsKey('query')
                ? GoogleCloudDiscoveryengineV1alphaQuery.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        queryConfig: (json_['queryConfig']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answer != null) 'answer': answer!,
    if (detailedAnswer != null) 'detailedAnswer': detailedAnswer!,
    if (query != null) 'query': query!,
    if (queryConfig != null) 'queryConfig': queryConfig!,
  };
}

/// Request message for CrawlRateManagementService.SetDedicatedCrawlRate method.
///
/// The user can set the crawl rate for a crawl_rate_scope they own. They can
/// set up an overall crawl rate, or set up a user-triggered crawl rate and a
/// auto-refresh crawl rate separately. If an overall crawl rate is set, Vertex
/// AI will automatically splits crawl_rate into user-triggered and
/// auto-refresh.
typedef GoogleCloudDiscoveryengineV1alphaSetDedicatedCrawlRateRequest =
    $SetDedicatedCrawlRateRequest;

/// Request for DataConnectorService.SetUpDataConnector method.
class GoogleCloudDiscoveryengineV1alphaSetUpDataConnectorRequest {
  /// The display name of the Collection.
  ///
  /// Should be human readable, used to display collections in the Console
  /// Dashboard. UTF-8 encoded string with limit of 1024 characters.
  ///
  /// Required.
  core.String? collectionDisplayName;

  /// The ID to use for the Collection, which will become the final component of
  /// the Collection's resource name.
  ///
  /// A new Collection is created as part of the DataConnector setup.
  /// DataConnector is a singleton resource under Collection, managing all
  /// DataStores of the Collection. This field must conform to
  /// \[RFC-1034\](https://tools.ietf.org/html/rfc1034) standard with a length
  /// limit of 63 characters. Otherwise, an INVALID_ARGUMENT error is returned.
  ///
  /// Required.
  core.String? collectionId;

  /// The DataConnector to initialize in the newly created Collection.
  ///
  /// Required.
  GoogleCloudDiscoveryengineV1alphaDataConnector? dataConnector;

  GoogleCloudDiscoveryengineV1alphaSetUpDataConnectorRequest({
    this.collectionDisplayName,
    this.collectionId,
    this.dataConnector,
  });

  GoogleCloudDiscoveryengineV1alphaSetUpDataConnectorRequest.fromJson(
    core.Map json_,
  ) : this(
        collectionDisplayName: json_['collectionDisplayName'] as core.String?,
        collectionId: json_['collectionId'] as core.String?,
        dataConnector:
            json_.containsKey('dataConnector')
                ? GoogleCloudDiscoveryengineV1alphaDataConnector.fromJson(
                  json_['dataConnector'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (collectionDisplayName != null)
      'collectionDisplayName': collectionDisplayName!,
    if (collectionId != null) 'collectionId': collectionId!,
    if (dataConnector != null) 'dataConnector': dataConnector!,
  };
}

/// Request message for SiteSearchEngineService.SetUriPatternDocumentData
/// method.
class GoogleCloudDiscoveryengineV1alphaSetUriPatternDocumentDataRequest {
  /// Document data keyed by URI pattern.
  ///
  /// Each entry must be consistent with the Schema. For example: Schema = {
  /// "type": "object", "properties": { "Categories": { "type": "array",
  /// "items": { "retrievable": true, "type": "string" } } } document_data_map =
  /// { "www.url1.com / * ": { "Categories": \["category1", "category2"\] },
  /// "www.url2.com / * ": { "Categories": \["category3"\] } }
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Map<core.String, core.Object?>>? documentDataMap;

  /// If true, clears the document data map.
  ///
  /// If true, SetUriPatternDocumentDataRequest.document_data_map must be empty.
  core.bool? emptyDocumentDataMap;

  /// If not provided, the current Schema is used.
  ///
  /// If provided, validates and updates the Schema. If validation fails, an
  /// error is returned.
  ///
  /// Optional.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? schema;

  GoogleCloudDiscoveryengineV1alphaSetUriPatternDocumentDataRequest({
    this.documentDataMap,
    this.emptyDocumentDataMap,
    this.schema,
  });

  GoogleCloudDiscoveryengineV1alphaSetUriPatternDocumentDataRequest.fromJson(
    core.Map json_,
  ) : this(
        documentDataMap: (json_['documentDataMap']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                value as core.Map<core.String, core.dynamic>,
              ),
            ),
        emptyDocumentDataMap: json_['emptyDocumentDataMap'] as core.bool?,
        schema:
            json_.containsKey('schema')
                ? json_['schema'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentDataMap != null) 'documentDataMap': documentDataMap!,
    if (emptyDocumentDataMap != null)
      'emptyDocumentDataMap': emptyDocumentDataMap!,
    if (schema != null) 'schema': schema!,
  };
}

/// Metadata for single-regional CMEKs.
typedef GoogleCloudDiscoveryengineV1alphaSingleRegionKey = $SingleRegionKey;

/// SiteSearchEngine captures DataStore level site search persisting
/// configurations.
///
/// It is a singleton value per data store.
typedef GoogleCloudDiscoveryengineV1alphaSiteSearchEngine = $SiteSearchEngine;

/// Verification information for target sites in advanced site search.
typedef GoogleCloudDiscoveryengineV1alphaSiteVerificationInfo =
    $SiteVerificationInfo;

/// A sitemap for the SiteSearchEngine.
typedef GoogleCloudDiscoveryengineV1alphaSitemap = $Sitemap;

/// The Spanner source for importing data
typedef GoogleCloudDiscoveryengineV1alphaSpannerSource = $SpannerSource;

/// Request message for DataConnectorService.StartConnectorRun method.
class GoogleCloudDiscoveryengineV1alphaStartConnectorRunRequest {
  /// Specifies which Third Party Connector entities should be synced.
  ///
  /// If not specified, all entities will be synced.
  core.List<core.String>? entities;

  /// Whether to force refresh the unstructured content of the documents.
  ///
  /// If set to `true`, the content part of the documents will be refreshed
  /// regardless of the update status of the referencing content.
  ///
  /// Optional.
  core.bool? forceRefreshContent;

  /// The FHIR resource types to import.
  ///
  /// The resource types should be a subset of all
  /// [supported FHIR resource types](https://cloud.google.com/generative-ai-app-builder/docs/fhir-schema-reference#resource-level-specification).
  /// Default to all supported FHIR resource types if empty.
  core.List<core.String>? healthcareFhirResourceTypes;

  /// If true, trigger Identity sync.
  core.bool? syncIdentity;

  /// Timestamp to indicate the point in time from which data should be synced
  /// for Streaming/Batch Data Connectors.
  ///
  /// This field is only utilized for Healthcare Connectors.
  core.String? syncSinceTimestamp;

  GoogleCloudDiscoveryengineV1alphaStartConnectorRunRequest({
    this.entities,
    this.forceRefreshContent,
    this.healthcareFhirResourceTypes,
    this.syncIdentity,
    this.syncSinceTimestamp,
  });

  GoogleCloudDiscoveryengineV1alphaStartConnectorRunRequest.fromJson(
    core.Map json_,
  ) : this(
        entities:
            (json_['entities'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        forceRefreshContent: json_['forceRefreshContent'] as core.bool?,
        healthcareFhirResourceTypes:
            (json_['healthcareFhirResourceTypes'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        syncIdentity: json_['syncIdentity'] as core.bool?,
        syncSinceTimestamp: json_['syncSinceTimestamp'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (entities != null) 'entities': entities!,
    if (forceRefreshContent != null)
      'forceRefreshContent': forceRefreshContent!,
    if (healthcareFhirResourceTypes != null)
      'healthcareFhirResourceTypes': healthcareFhirResourceTypes!,
    if (syncIdentity != null) 'syncIdentity': syncIdentity!,
    if (syncSinceTimestamp != null) 'syncSinceTimestamp': syncSinceTimestamp!,
  };
}

/// Request for the AssistantService.StreamAssist method.
class GoogleCloudDiscoveryengineV1alphaStreamAssistRequest {
  /// Specification of the generation configuration for the request.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestGenerationSpec?
  generationSpec;

  /// Current user query.
  ///
  /// Empty query is only supported if `file_ids` are provided. In this case,
  /// the answer will be generated based on those context files.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaQuery? query;

  /// The session to use for the request.
  ///
  /// If specified, the assistant has access to the session history, and the
  /// query and the answer are stored there. If `-` is specified as the session
  /// ID, or it is left empty, then a new session is created with an
  /// automatically generated ID. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}`
  ///
  /// Optional.
  core.String? session;

  /// Specification of tools that are used to serve the request.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpec? toolsSpec;

  /// Information about the user initiating the query.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaAssistUserMetadata? userMetadata;

  GoogleCloudDiscoveryengineV1alphaStreamAssistRequest({
    this.generationSpec,
    this.query,
    this.session,
    this.toolsSpec,
    this.userMetadata,
  });

  GoogleCloudDiscoveryengineV1alphaStreamAssistRequest.fromJson(core.Map json_)
    : this(
        generationSpec:
            json_.containsKey('generationSpec')
                ? GoogleCloudDiscoveryengineV1alphaStreamAssistRequestGenerationSpec.fromJson(
                  json_['generationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        query:
            json_.containsKey('query')
                ? GoogleCloudDiscoveryengineV1alphaQuery.fromJson(
                  json_['query'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        session: json_['session'] as core.String?,
        toolsSpec:
            json_.containsKey('toolsSpec')
                ? GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpec.fromJson(
                  json_['toolsSpec'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userMetadata:
            json_.containsKey('userMetadata')
                ? GoogleCloudDiscoveryengineV1alphaAssistUserMetadata.fromJson(
                  json_['userMetadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (generationSpec != null) 'generationSpec': generationSpec!,
    if (query != null) 'query': query!,
    if (session != null) 'session': session!,
    if (toolsSpec != null) 'toolsSpec': toolsSpec!,
    if (userMetadata != null) 'userMetadata': userMetadata!,
  };
}

/// Assistant generation specification for the request.
///
/// This allows to override the default generation configuration at the engine
/// level.
typedef GoogleCloudDiscoveryengineV1alphaStreamAssistRequestGenerationSpec =
    $StreamAssistRequestGenerationSpec;

/// Specification of tools that are used to serve the request.
class GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpec {
  /// Specification of the image generation tool.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecImageGenerationSpec?
  imageGenerationSpec;

  /// Specification of the Vertex AI Search tool.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVertexAiSearchSpec?
  vertexAiSearchSpec;

  /// Specification of the video generation tool.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVideoGenerationSpec?
  videoGenerationSpec;

  /// Specification of the web grounding tool.
  ///
  /// If field is present, enables grounding with web search. Works only if
  /// Assistant.web_grounding_type is WEB_GROUNDING_TYPE_GOOGLE_SEARCH or
  /// WEB_GROUNDING_TYPE_ENTERPRISE_WEB_SEARCH.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecWebGroundingSpec?
  webGroundingSpec;

  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpec({
    this.imageGenerationSpec,
    this.vertexAiSearchSpec,
    this.videoGenerationSpec,
    this.webGroundingSpec,
  });

  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpec.fromJson(
    core.Map json_,
  ) : this(
        imageGenerationSpec:
            json_.containsKey('imageGenerationSpec')
                ? GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecImageGenerationSpec.fromJson(
                  json_['imageGenerationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        vertexAiSearchSpec:
            json_.containsKey('vertexAiSearchSpec')
                ? GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVertexAiSearchSpec.fromJson(
                  json_['vertexAiSearchSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        videoGenerationSpec:
            json_.containsKey('videoGenerationSpec')
                ? GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVideoGenerationSpec.fromJson(
                  json_['videoGenerationSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        webGroundingSpec:
            json_.containsKey('webGroundingSpec')
                ? GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecWebGroundingSpec.fromJson(
                  json_['webGroundingSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (imageGenerationSpec != null)
      'imageGenerationSpec': imageGenerationSpec!,
    if (vertexAiSearchSpec != null) 'vertexAiSearchSpec': vertexAiSearchSpec!,
    if (videoGenerationSpec != null)
      'videoGenerationSpec': videoGenerationSpec!,
    if (webGroundingSpec != null) 'webGroundingSpec': webGroundingSpec!,
  };
}

/// Specification of the image generation tool.
typedef GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecImageGenerationSpec =
    $Empty;

/// Specification of the Vertex AI Search tool.
class GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVertexAiSearchSpec {
  /// Specs defining DataStores to filter on in a search call and configurations
  /// for those data stores.
  ///
  /// This is only considered for Engines with multiple data stores.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec>?
  dataStoreSpecs;

  /// The filter syntax consists of an expression language for constructing a
  /// predicate from one or more fields of the documents being filtered.
  ///
  /// Filter expression is case-sensitive. If this field is unrecognizable, an
  /// `INVALID_ARGUMENT` is returned. Filtering in Vertex AI Search is done by
  /// mapping the LHS filter key to a key property defined in the Vertex AI
  /// Search backend -- this mapping is defined by the customer in their schema.
  /// For example a media customer might have a field 'name' in their schema. In
  /// this case the filter would look like this: filter --\> name:'ANY("king
  /// kong")' For more information about filtering including syntax and filter
  /// operators, see
  /// [Filter](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  ///
  /// Optional.
  core.String? filter;

  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVertexAiSearchSpec({
    this.dataStoreSpecs,
    this.filter,
  });

  GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVertexAiSearchSpec.fromJson(
    core.Map json_,
  ) : this(
        dataStoreSpecs:
            (json_['dataStoreSpecs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaSearchRequestDataStoreSpec.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        filter: json_['filter'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStoreSpecs != null) 'dataStoreSpecs': dataStoreSpecs!,
    if (filter != null) 'filter': filter!,
  };
}

/// Specification of the video generation tool.
typedef GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecVideoGenerationSpec =
    $Empty;

/// Specification of the web grounding tool.
typedef GoogleCloudDiscoveryengineV1alphaStreamAssistRequestToolsSpecWebGroundingSpec =
    $Empty;

/// Response for the AssistantService.StreamAssist method.
class GoogleCloudDiscoveryengineV1alphaStreamAssistResponse {
  /// Assist answer resource object containing parts of the assistant's final
  /// answer for the user's query.
  ///
  /// Not present if the current response doesn't add anything to previously
  /// sent AssistAnswer.replies. Observe AssistAnswer.state to see if more parts
  /// are to be expected. While the state is `IN_PROGRESS`, the
  /// AssistAnswer.replies field in each response will contain replies (reply
  /// fragments) to be appended to the ones received in previous responses.
  /// AssistAnswer.name won't be filled. If the state is `SUCCEEDED`, `FAILED`
  /// or `SKIPPED`, the response is the last response and AssistAnswer.name will
  /// have a value.
  GoogleCloudDiscoveryengineV1alphaAssistAnswer? answer;

  /// A global unique ID that identifies the current pair of request and stream
  /// of responses.
  ///
  /// Used for feedback and support.
  core.String? assistToken;

  /// Session information.
  GoogleCloudDiscoveryengineV1alphaStreamAssistResponseSessionInfo? sessionInfo;

  GoogleCloudDiscoveryengineV1alphaStreamAssistResponse({
    this.answer,
    this.assistToken,
    this.sessionInfo,
  });

  GoogleCloudDiscoveryengineV1alphaStreamAssistResponse.fromJson(core.Map json_)
    : this(
        answer:
            json_.containsKey('answer')
                ? GoogleCloudDiscoveryengineV1alphaAssistAnswer.fromJson(
                  json_['answer'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        assistToken: json_['assistToken'] as core.String?,
        sessionInfo:
            json_.containsKey('sessionInfo')
                ? GoogleCloudDiscoveryengineV1alphaStreamAssistResponseSessionInfo.fromJson(
                  json_['sessionInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (answer != null) 'answer': answer!,
    if (assistToken != null) 'assistToken': assistToken!,
    if (sessionInfo != null) 'sessionInfo': sessionInfo!,
  };
}

/// Information about the session.
typedef GoogleCloudDiscoveryengineV1alphaStreamAssistResponseSessionInfo =
    $StreamAssistResponseSessionInfo;

/// Suggestion deny list entry identifying the phrase to block from suggestions
/// and the applied operation for the phrase.
typedef GoogleCloudDiscoveryengineV1alphaSuggestionDenyListEntry =
    $SuggestionDenyListEntry;

/// A target site for the SiteSearchEngine.
class GoogleCloudDiscoveryengineV1alphaTargetSite {
  /// If set to false, a uri_pattern is generated to include all pages whose
  /// address contains the provided_uri_pattern.
  ///
  /// If set to true, an uri_pattern is generated to try to be an exact match of
  /// the provided_uri_pattern or just the specific page if the
  /// provided_uri_pattern is a specific one. provided_uri_pattern is always
  /// normalized to generate the URI pattern to be used by the search engine.
  ///
  /// Immutable.
  core.bool? exactMatch;

  /// Failure reason.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReason? failureReason;

  /// This is system-generated based on the provided_uri_pattern.
  ///
  /// Output only.
  core.String? generatedUriPattern;

  /// Indexing status.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "INDEXING_STATUS_UNSPECIFIED" : Defaults to SUCCEEDED.
  /// - "PENDING" : The target site is in the update queue and will be picked up
  /// by indexing pipeline.
  /// - "FAILED" : The target site fails to be indexed.
  /// - "SUCCEEDED" : The target site has been indexed.
  /// - "DELETING" : The previously indexed target site has been marked to be
  /// deleted. This is a transitioning state which will resulted in either: 1.
  /// target site deleted if unindexing is successful; 2. state reverts to
  /// SUCCEEDED if the unindexing fails.
  /// - "CANCELLABLE" : The target site change is pending but cancellable.
  /// - "CANCELLED" : The target site change is cancelled.
  core.String? indexingStatus;

  /// The fully qualified resource name of the target site.
  ///
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`
  /// The `target_site_id` is system-generated.
  ///
  /// Output only.
  core.String? name;

  /// Input only.
  ///
  /// The user provided URI pattern from which the `generated_uri_pattern` is
  /// generated.
  ///
  /// Required.
  core.String? providedUriPattern;

  /// Root domain of the provided_uri_pattern.
  ///
  /// Output only.
  core.String? rootDomainUri;

  /// Site ownership and validity verification status.
  ///
  /// Output only.
  GoogleCloudDiscoveryengineV1alphaSiteVerificationInfo? siteVerificationInfo;

  /// The type of the target site, e.g., whether the site is to be included or
  /// excluded.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : This value is unused. In this case, server behavior
  /// defaults to Type.INCLUDE.
  /// - "INCLUDE" : Include the target site.
  /// - "EXCLUDE" : Exclude the target site.
  core.String? type;

  /// The target site's last updated time.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudDiscoveryengineV1alphaTargetSite({
    this.exactMatch,
    this.failureReason,
    this.generatedUriPattern,
    this.indexingStatus,
    this.name,
    this.providedUriPattern,
    this.rootDomainUri,
    this.siteVerificationInfo,
    this.type,
    this.updateTime,
  });

  GoogleCloudDiscoveryengineV1alphaTargetSite.fromJson(core.Map json_)
    : this(
        exactMatch: json_['exactMatch'] as core.bool?,
        failureReason:
            json_.containsKey('failureReason')
                ? GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReason.fromJson(
                  json_['failureReason'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        generatedUriPattern: json_['generatedUriPattern'] as core.String?,
        indexingStatus: json_['indexingStatus'] as core.String?,
        name: json_['name'] as core.String?,
        providedUriPattern: json_['providedUriPattern'] as core.String?,
        rootDomainUri: json_['rootDomainUri'] as core.String?,
        siteVerificationInfo:
            json_.containsKey('siteVerificationInfo')
                ? GoogleCloudDiscoveryengineV1alphaSiteVerificationInfo.fromJson(
                  json_['siteVerificationInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        type: json_['type'] as core.String?,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (exactMatch != null) 'exactMatch': exactMatch!,
    if (failureReason != null) 'failureReason': failureReason!,
    if (generatedUriPattern != null)
      'generatedUriPattern': generatedUriPattern!,
    if (indexingStatus != null) 'indexingStatus': indexingStatus!,
    if (name != null) 'name': name!,
    if (providedUriPattern != null) 'providedUriPattern': providedUriPattern!,
    if (rootDomainUri != null) 'rootDomainUri': rootDomainUri!,
    if (siteVerificationInfo != null)
      'siteVerificationInfo': siteVerificationInfo!,
    if (type != null) 'type': type!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Site search indexing failure reasons.
class GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReason {
  /// Failed due to insufficient quota.
  GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReasonQuotaFailure?
  quotaFailure;

  GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReason({this.quotaFailure});

  GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReason.fromJson(
    core.Map json_,
  ) : this(
        quotaFailure:
            json_.containsKey('quotaFailure')
                ? GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReasonQuotaFailure.fromJson(
                  json_['quotaFailure'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (quotaFailure != null) 'quotaFailure': quotaFailure!,
  };
}

/// Failed due to insufficient quota.
typedef GoogleCloudDiscoveryengineV1alphaTargetSiteFailureReasonQuotaFailure =
    $TargetSiteFailureReasonQuotaFailure;

/// Tenant information for a connector source.
///
/// This includes some of the same information stored in the Credential message,
/// but is limited to only what is needed to provide a list of accessible
/// tenants to the user.
class GoogleCloudDiscoveryengineV1alphaTenant {
  /// Optional display name for the tenant, e.g. "My Slack Team".
  core.String? displayName;

  /// The tenant's instance ID.
  ///
  /// Examples: Jira ("8594f221-9797-5f78-1fa4-485e198d7cd0"), Slack
  /// ("T123456").
  core.String? id;

  /// The URI of the tenant, if applicable.
  ///
  /// For example, the URI of a Jira instance is
  /// https://my-jira-instance.atlassian.net, and a Slack tenant does not have a
  /// URI.
  core.String? uri;

  GoogleCloudDiscoveryengineV1alphaTenant({
    this.displayName,
    this.id,
    this.uri,
  });

  GoogleCloudDiscoveryengineV1alphaTenant.fromJson(core.Map json_)
    : this(
        displayName: json_['displayName'] as core.String?,
        id: json_['id'] as core.String?,
        uri: json_['uri'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (id != null) 'id': id!,
    if (uri != null) 'uri': uri!,
  };
}

/// Defines text input.
class GoogleCloudDiscoveryengineV1alphaTextInput {
  /// Conversation context of the input.
  GoogleCloudDiscoveryengineV1alphaConversationContext? context;

  /// Text input.
  core.String? input;

  GoogleCloudDiscoveryengineV1alphaTextInput({this.context, this.input});

  GoogleCloudDiscoveryengineV1alphaTextInput.fromJson(core.Map json_)
    : this(
        context:
            json_.containsKey('context')
                ? GoogleCloudDiscoveryengineV1alphaConversationContext.fromJson(
                  json_['context'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        input: json_['input'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (context != null) 'context': context!,
    if (input != null) 'input': input!,
  };
}

/// Request message for SearchTuningService.TrainCustomModel method.
class GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequest {
  /// The desired location of errors incurred during the data ingestion and
  /// training.
  GoogleCloudDiscoveryengineV1alphaImportErrorConfig? errorConfig;

  /// Cloud Storage training input.
  GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequestGcsTrainingInput?
  gcsTrainingInput;

  /// If not provided, a UUID will be generated.
  core.String? modelId;

  /// Model to be trained.
  ///
  /// Supported values are: * **search-tuning**: Fine tuning the search system
  /// based on data provided.
  core.String? modelType;

  GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequest({
    this.errorConfig,
    this.gcsTrainingInput,
    this.modelId,
    this.modelType,
  });

  GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequest.fromJson(
    core.Map json_,
  ) : this(
        errorConfig:
            json_.containsKey('errorConfig')
                ? GoogleCloudDiscoveryengineV1alphaImportErrorConfig.fromJson(
                  json_['errorConfig'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        gcsTrainingInput:
            json_.containsKey('gcsTrainingInput')
                ? GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequestGcsTrainingInput.fromJson(
                  json_['gcsTrainingInput']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        modelId: json_['modelId'] as core.String?,
        modelType: json_['modelType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (errorConfig != null) 'errorConfig': errorConfig!,
    if (gcsTrainingInput != null) 'gcsTrainingInput': gcsTrainingInput!,
    if (modelId != null) 'modelId': modelId!,
    if (modelType != null) 'modelType': modelType!,
  };
}

/// Cloud Storage training data input.
typedef GoogleCloudDiscoveryengineV1alphaTrainCustomModelRequestGcsTrainingInput =
    $TrainCustomModelRequestGcsTrainingInput;

/// A transaction represents the entire purchase transaction.
typedef GoogleCloudDiscoveryengineV1alphaTransactionInfo = $TransactionInfo;

/// Request to manually start a tuning process now (instead of waiting for the
/// periodically scheduled tuning to happen).
typedef GoogleCloudDiscoveryengineV1alphaTuneEngineRequest = $Empty;

/// UserEvent captures all metadata information Discovery Engine API needs to
/// know about how end users interact with your website.
class GoogleCloudDiscoveryengineV1alphaUserEvent {
  /// Extra user event features to include in the recommendation model.
  ///
  /// These attributes must NOT contain data that needs to be parsed or
  /// processed further, e.g. JSON or other encodings. If you provide custom
  /// attributes for ingested user events, also include them in the user events
  /// that you associate with prediction requests. Custom attribute formatting
  /// must be consistent between imported events and events provided with
  /// prediction requests. This lets the Discovery Engine API use those custom
  /// attributes when training models and serving predictions, which helps
  /// improve recommendation quality. This field needs to pass all below
  /// criteria, otherwise an `INVALID_ARGUMENT` error is returned: * The key
  /// must be a UTF-8 encoded string with a length limit of 5,000 characters. *
  /// For text attributes, at most 400 values are allowed. Empty values are not
  /// allowed. Each value must be a UTF-8 encoded string with a length limit of
  /// 256 characters. * For number attributes, at most 400 values are allowed.
  /// For product recommendations, an example of extra user information is
  /// `traffic_channel`, which is how a user arrives at the site. Users can
  /// arrive at the site by coming to the site directly, coming through Google
  /// search, or in other ways.
  core.Map<core.String, GoogleCloudDiscoveryengineV1alphaCustomAttribute>?
  attributes;

  /// Token to attribute an API response to user action(s) to trigger the event.
  ///
  /// Highly recommended for user events that are the result of
  /// RecommendationService.Recommend. This field enables accurate attribution
  /// of recommendation model performance. The value must be one of: *
  /// RecommendResponse.attribution_token for events that are the result of
  /// RecommendationService.Recommend. * SearchResponse.attribution_token for
  /// events that are the result of SearchService.Search. This token enables us
  /// to accurately attribute page view or conversion completion back to the
  /// event and the particular predict response containing this
  /// clicked/purchased product. If user clicks on product K in the
  /// recommendation results, pass RecommendResponse.attribution_token as a URL
  /// parameter to product K's page. When recording events on product K's page,
  /// log the RecommendResponse.attribution_token to this field.
  core.String? attributionToken;

  /// CompletionService.CompleteQuery details related to the event.
  ///
  /// This field should be set for `search` event when autocomplete function is
  /// enabled and the user clicks a suggestion for search.
  GoogleCloudDiscoveryengineV1alphaCompletionInfo? completionInfo;

  /// Conversion type.
  ///
  /// Required if UserEvent.event_type is `conversion`. This is a
  /// customer-defined conversion name in lowercase letters or numbers separated
  /// by "-", such as "watch", "good-visit" etc. Do not set the field if
  /// UserEvent.event_type is not `conversion`. This mixes the custom conversion
  /// event with predefined events like `search`, `view-item` etc.
  ///
  /// Optional.
  core.String? conversionType;

  /// The DataStore resource full name, of the form
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  ///
  /// Optional. Only required for user events whose data store can't by
  /// determined by UserEvent.engine or UserEvent.documents. If data store is
  /// set in the parent of write/import/collect user event requests, this field
  /// can be omitted.
  core.String? dataStore;

  /// Should set to true if the request is made directly from the end user, in
  /// which case the UserEvent.user_info.user_agent can be populated from the
  /// HTTP request.
  ///
  /// This flag should be set only if the API request is made directly from the
  /// end user such as a mobile app (and not if a gateway or a server is
  /// processing and pushing the user events). This should not be set when using
  /// the JavaScript tag in UserEventService.CollectUserEvent.
  core.bool? directUserRequest;

  /// List of Documents associated with this user event.
  ///
  /// This field is optional except for the following event types: * `view-item`
  /// * `add-to-cart` * `purchase` * `media-play` * `media-complete` In a
  /// `search` event, this field represents the documents returned to the end
  /// user on the current page (the end user may have not finished browsing the
  /// whole page yet). When a new page is returned to the end user, after
  /// pagination/filtering/ordering even for the same query, a new `search`
  /// event with different UserEvent.documents is desired.
  core.List<GoogleCloudDiscoveryengineV1alphaDocumentInfo>? documents;

  /// The Engine resource name, in the form of
  /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
  ///
  /// Optional. Only required for Engine produced user events. For example, user
  /// events from blended search.
  core.String? engine;

  /// Only required for UserEventService.ImportUserEvents method.
  ///
  /// Timestamp of when the user event happened.
  core.String? eventTime;

  /// User event type.
  ///
  /// Allowed values are: Generic values: * `search`: Search for Documents. *
  /// `view-item`: Detailed page view of a Document. * `view-item-list`: View of
  /// a panel or ordered list of Documents. * `view-home-page`: View of the home
  /// page. * `view-category-page`: View of a category page, e.g. Home \> Men \>
  /// Jeans * `add-feedback`: Add a user feedback. Retail-related values: *
  /// `add-to-cart`: Add an item(s) to cart, e.g. in Retail online shopping *
  /// `purchase`: Purchase an item(s) Media-related values: * `media-play`:
  /// Start/resume watching a video, playing a song, etc. * `media-complete`:
  /// Finished or stopped midway through a video, song, etc. Custom conversion
  /// value: * `conversion`: Customer defined conversion event.
  ///
  /// Required.
  core.String? eventType;

  /// The filter syntax consists of an expression language for constructing a
  /// predicate from one or more fields of the documents being filtered.
  ///
  /// One example is for `search` events, the associated SearchRequest may
  /// contain a filter expression in SearchRequest.filter conforming to
  /// https://google.aip.dev/160#filtering. Similarly, for `view-item-list`
  /// events that are generated from a RecommendRequest, this field may be
  /// populated directly from RecommendRequest.filter conforming to
  /// https://google.aip.dev/160#filtering. The value must be a UTF-8 encoded
  /// string with a length limit of 1,000 characters. Otherwise, an
  /// `INVALID_ARGUMENT` error is returned.
  core.String? filter;

  /// Media-specific info.
  GoogleCloudDiscoveryengineV1alphaMediaInfo? mediaInfo;

  /// Page metadata such as categories and other critical information for
  /// certain event types such as `view-category-page`.
  GoogleCloudDiscoveryengineV1alphaPageInfo? pageInfo;

  /// Panel metadata associated with this user event.
  GoogleCloudDiscoveryengineV1alphaPanelInfo? panel;

  /// List of panels associated with this event.
  ///
  /// Used for page-level impression data.
  ///
  /// Optional.
  core.List<GoogleCloudDiscoveryengineV1alphaPanelInfo>? panels;

  /// The promotion IDs if this is an event associated with promotions.
  ///
  /// Currently, this field is restricted to at most one ID.
  core.List<core.String>? promotionIds;

  /// SearchService.Search details related to the event.
  ///
  /// This field should be set for `search` event.
  GoogleCloudDiscoveryengineV1alphaSearchInfo? searchInfo;

  /// A unique identifier for tracking a visitor session with a length limit of
  /// 128 bytes.
  ///
  /// A session is an aggregation of an end user behavior in a time span. A
  /// general guideline to populate the session_id: 1. If user has no activity
  /// for 30 min, a new session_id should be assigned. 2. The session_id should
  /// be unique across users, suggest use uuid or add UserEvent.user_pseudo_id
  /// as prefix.
  core.String? sessionId;

  /// A list of identifiers for the independent experiment groups this user
  /// event belongs to.
  ///
  /// This is used to distinguish between user events associated with different
  /// experiment setups.
  core.List<core.String>? tagIds;

  /// The transaction metadata (if any) associated with this user event.
  GoogleCloudDiscoveryengineV1alphaTransactionInfo? transactionInfo;

  /// Information about the end user.
  GoogleCloudDiscoveryengineV1alphaUserInfo? userInfo;

  /// A unique identifier for tracking visitors.
  ///
  /// For example, this could be implemented with an HTTP cookie, which should
  /// be able to uniquely identify a visitor on a single device. This unique
  /// identifier should not change if the visitor log in/out of the website. Do
  /// not set the field to the same fixed ID for different users. This mixes the
  /// event history of those users together, which results in degraded model
  /// quality. The field must be a UTF-8 encoded string with a length limit of
  /// 128 characters. Otherwise, an `INVALID_ARGUMENT` error is returned. The
  /// field should not contain PII or user-data. We recommend to use Google
  /// Analytics
  /// [Client ID](https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#clientId)
  /// for this field.
  ///
  /// Required.
  core.String? userPseudoId;

  GoogleCloudDiscoveryengineV1alphaUserEvent({
    this.attributes,
    this.attributionToken,
    this.completionInfo,
    this.conversionType,
    this.dataStore,
    this.directUserRequest,
    this.documents,
    this.engine,
    this.eventTime,
    this.eventType,
    this.filter,
    this.mediaInfo,
    this.pageInfo,
    this.panel,
    this.panels,
    this.promotionIds,
    this.searchInfo,
    this.sessionId,
    this.tagIds,
    this.transactionInfo,
    this.userInfo,
    this.userPseudoId,
  });

  GoogleCloudDiscoveryengineV1alphaUserEvent.fromJson(core.Map json_)
    : this(
        attributes:
            (json_['attributes'] as core.Map<core.String, core.dynamic>?)?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudDiscoveryengineV1alphaCustomAttribute.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        attributionToken: json_['attributionToken'] as core.String?,
        completionInfo:
            json_.containsKey('completionInfo')
                ? GoogleCloudDiscoveryengineV1alphaCompletionInfo.fromJson(
                  json_['completionInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        conversionType: json_['conversionType'] as core.String?,
        dataStore: json_['dataStore'] as core.String?,
        directUserRequest: json_['directUserRequest'] as core.bool?,
        documents:
            (json_['documents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaDocumentInfo.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        engine: json_['engine'] as core.String?,
        eventTime: json_['eventTime'] as core.String?,
        eventType: json_['eventType'] as core.String?,
        filter: json_['filter'] as core.String?,
        mediaInfo:
            json_.containsKey('mediaInfo')
                ? GoogleCloudDiscoveryengineV1alphaMediaInfo.fromJson(
                  json_['mediaInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        pageInfo:
            json_.containsKey('pageInfo')
                ? GoogleCloudDiscoveryengineV1alphaPageInfo.fromJson(
                  json_['pageInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        panel:
            json_.containsKey('panel')
                ? GoogleCloudDiscoveryengineV1alphaPanelInfo.fromJson(
                  json_['panel'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        panels:
            (json_['panels'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaPanelInfo.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        promotionIds:
            (json_['promotionIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        searchInfo:
            json_.containsKey('searchInfo')
                ? GoogleCloudDiscoveryengineV1alphaSearchInfo.fromJson(
                  json_['searchInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        sessionId: json_['sessionId'] as core.String?,
        tagIds:
            (json_['tagIds'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        transactionInfo:
            json_.containsKey('transactionInfo')
                ? GoogleCloudDiscoveryengineV1alphaTransactionInfo.fromJson(
                  json_['transactionInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        userInfo:
            json_.containsKey('userInfo')
                ? GoogleCloudDiscoveryengineV1alphaUserInfo.fromJson(
                  json_['userInfo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        userPseudoId: json_['userPseudoId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (attributes != null) 'attributes': attributes!,
    if (attributionToken != null) 'attributionToken': attributionToken!,
    if (completionInfo != null) 'completionInfo': completionInfo!,
    if (conversionType != null) 'conversionType': conversionType!,
    if (dataStore != null) 'dataStore': dataStore!,
    if (directUserRequest != null) 'directUserRequest': directUserRequest!,
    if (documents != null) 'documents': documents!,
    if (engine != null) 'engine': engine!,
    if (eventTime != null) 'eventTime': eventTime!,
    if (eventType != null) 'eventType': eventType!,
    if (filter != null) 'filter': filter!,
    if (mediaInfo != null) 'mediaInfo': mediaInfo!,
    if (pageInfo != null) 'pageInfo': pageInfo!,
    if (panel != null) 'panel': panel!,
    if (panels != null) 'panels': panels!,
    if (promotionIds != null) 'promotionIds': promotionIds!,
    if (searchInfo != null) 'searchInfo': searchInfo!,
    if (sessionId != null) 'sessionId': sessionId!,
    if (tagIds != null) 'tagIds': tagIds!,
    if (transactionInfo != null) 'transactionInfo': transactionInfo!,
    if (userInfo != null) 'userInfo': userInfo!,
    if (userPseudoId != null) 'userPseudoId': userPseudoId!,
  };
}

/// Information of an end user.
typedef GoogleCloudDiscoveryengineV1alphaUserInfo = $UserInfo00;

/// User License information assigned by the admin.
typedef GoogleCloudDiscoveryengineV1alphaUserLicense = $UserLicense;

/// Standard characteristics of a video media view.
class GoogleCloudDiscoveryengineV1alphaVideoCharacteristics {
  /// Bitrate of the audio in kbps.
  ///
  /// Output only.
  core.int? audioBitrateKbps;

  /// Audio codecs used in the video.
  ///
  /// Output only.
  core.List<core.String>? audioCodecs;

  /// Video duration.
  ///
  /// Output only.
  core.String? duration;

  /// Frame rate (frames per second).
  ///
  /// Output only.
  core.double? frameRate;

  /// Video height in pixels.
  ///
  /// Output only.
  core.int? height;

  /// Bitrate of the video in kbps.
  ///
  /// Output only.
  core.int? videoBitrateKbps;

  /// Video codecs used in the video.
  ///
  /// Output only.
  core.List<core.String>? videoCodecs;

  /// Video width in pixels.
  ///
  /// Output only.
  core.int? width;

  GoogleCloudDiscoveryengineV1alphaVideoCharacteristics({
    this.audioBitrateKbps,
    this.audioCodecs,
    this.duration,
    this.frameRate,
    this.height,
    this.videoBitrateKbps,
    this.videoCodecs,
    this.width,
  });

  GoogleCloudDiscoveryengineV1alphaVideoCharacteristics.fromJson(core.Map json_)
    : this(
        audioBitrateKbps: json_['audioBitrateKbps'] as core.int?,
        audioCodecs:
            (json_['audioCodecs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        duration: json_['duration'] as core.String?,
        frameRate: (json_['frameRate'] as core.num?)?.toDouble(),
        height: json_['height'] as core.int?,
        videoBitrateKbps: json_['videoBitrateKbps'] as core.int?,
        videoCodecs:
            (json_['videoCodecs'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        width: json_['width'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (audioBitrateKbps != null) 'audioBitrateKbps': audioBitrateKbps!,
    if (audioCodecs != null) 'audioCodecs': audioCodecs!,
    if (duration != null) 'duration': duration!,
    if (frameRate != null) 'frameRate': frameRate!,
    if (height != null) 'height': height!,
    if (videoBitrateKbps != null) 'videoBitrateKbps': videoBitrateKbps!,
    if (videoCodecs != null) 'videoCodecs': videoCodecs!,
    if (width != null) 'width': width!,
  };
}

/// WidgetConfig captures configs at the Widget level.
class GoogleCloudDiscoveryengineV1alphaWidgetConfig {
  /// Will be used for all widget access settings seen in cloud console
  /// integration page.
  ///
  /// Replaces top deprecated top level properties.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigAccessSettings? accessSettings;

  /// Whether allow no-auth integration with widget.
  ///
  /// If set true, public access to search or other solutions from widget is
  /// allowed without authenication token provided by customer hosted backend
  /// server.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? allowPublicAccess;

  /// Allowlisted domains that can load this widget.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<core.String>? allowlistedDomains;

  /// Describes the assistant settings of the widget.
  ///
  /// Optional. Output only.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigAssistantSettings?
  assistantSettings;

  /// Collection components that lists all collections and child data stores
  /// associated with the widget config, those data sources can be used for
  /// filtering in widget service APIs, users can return results that from
  /// selected data sources.
  ///
  /// Output only.
  core.List<GoogleCloudDiscoveryengineV1alphaWidgetConfigCollectionComponent>?
  collectionComponents;

  /// Unique obfuscated identifier of a WidgetConfig.
  ///
  /// Output only.
  core.String? configId;

  /// The content search spec that configs the desired behavior of content
  /// search.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec?
  contentSearchSpec;

  /// Timestamp the WidgetConfig was created.
  ///
  /// Output only.
  core.String? createTime;

  /// Describes the customer related configurations, currently only used for
  /// government customers.
  ///
  /// This field cannot be modified after project onboarding.
  ///
  /// Optional. Output only.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigCustomerProvidedConfig?
  customerProvidedConfig;

  /// The type of the parent data store.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "DATA_STORE_TYPE_UNSPECIFIED" : Unspecified data store type.
  /// - "SITE_SEARCH" : The parent data store contains a site search engine.
  /// - "STRUCTURED" : The parent data store contains a search engine for
  /// structured data.
  /// - "UNSTRUCTURED" : The parent data store contains a search engine for
  /// unstructured data.
  /// - "BLENDED" : The parent data store is served for blended search with
  /// multiple data stores.
  core.String? dataStoreType;

  /// Configurable UI configurations per data store.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreUiConfig>?
  dataStoreUiConfigs;

  /// The default ordering for search results if specified.
  ///
  /// Used to set SearchRequest#order_by on applicable requests.
  /// https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/projects.locations.dataStores.servingConfigs/search#request-body
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? defaultSearchRequestOrderBy;

  /// The human readable widget config display name.
  ///
  /// Used in Discovery UI. This field must be a UTF-8 encoded string with a
  /// length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error is
  /// returned.
  ///
  /// Required.
  core.String? displayName;

  /// Whether or not to enable autocomplete.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableAutocomplete;

  /// Whether to allow conversational search (LLM, multi-turn) or not (non-LLM,
  /// single-turn).
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableConversationalSearch;

  /// Whether to enable private knowledge graph.
  ///
  /// Optional. Output only.
  core.bool? enablePrivateKnowledgeGraph;

  /// Turn on or off collecting the search result quality feedback from end
  /// users.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableQualityFeedback;

  /// Whether to show the result score.
  core.bool? enableResultScore;

  /// Whether to enable safe search.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableSafeSearch;

  /// Whether to enable search-as-you-type behavior for the search widget
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableSearchAsYouType;

  /// Turn on or off summary for each snippets result.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableSnippetResultSummary;

  /// Turn on or off summarization for the search response.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableSummarization;

  /// Whether to enable standalone web app.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? enableWebApp;

  /// Allows to toggle unstable/experimental features in the widget (or web app)
  core.Map<core.String, core.String>? experimentalFeatures;

  /// The configuration and appearance of facets in the end user view.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.List<GoogleCloudDiscoveryengineV1alphaWidgetConfigFacetField>?
  facetField;

  /// The key is the UI component.
  ///
  /// Mock. Currently supported `title`, `thumbnail`, `url`, `custom1`,
  /// `custom2`, `custom3`. The value is the name of the field along with its
  /// device visibility. The 3 custom fields are optional and can be added or
  /// removed. `title`, `thumbnail`, `url` are required UI components that
  /// cannot be removed.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.Map<
    core.String,
    GoogleCloudDiscoveryengineV1alphaWidgetConfigUIComponentField
  >?
  fieldsUiComponentsMap;

  /// Describes the homepage settings of the widget.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSetting? homepageSetting;

  /// The industry vertical that the WidgetConfig registers.
  ///
  /// The WidgetConfig industry vertical is based on the associated Engine.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "INDUSTRY_VERTICAL_UNSPECIFIED" : Value used when unset.
  /// - "GENERIC" : The generic vertical for documents that are not specific to
  /// any industry vertical.
  /// - "MEDIA" : The media industry vertical.
  /// - "HEALTHCARE_FHIR" : The healthcare FHIR vertical.
  core.String? industryVertical;

  /// Whether LLM is enabled in the corresponding data store.
  ///
  /// Output only.
  core.bool? llmEnabled;

  /// Whether the customer accepted data use terms.
  ///
  /// Output only.
  core.bool? minimumDataTermAccepted;

  /// The full resource name of the widget config.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/widgetConfigs/{widget_config_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  ///
  /// Immutable.
  core.String? name;

  /// The type of snippet to display in UCS widget.
  ///
  /// - RESULT_DISPLAY_TYPE_UNSPECIFIED for existing users. - SNIPPET for new
  /// non-enterprise search users. - EXTRACTIVE_ANSWER for new enterprise search
  /// users.
  /// Possible string values are:
  /// - "RESULT_DISPLAY_TYPE_UNSPECIFIED" : Unspecified display type (default to
  /// showing snippet).
  /// - "SNIPPET" : Display results from the snippet field.
  /// - "EXTRACTIVE_ANSWER" : Display results from extractive answers field.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.String? resultDisplayType;

  /// Specifies the solution type that this WidgetConfig can be used for.
  ///
  /// Required. Immutable.
  /// Possible string values are:
  /// - "SOLUTION_TYPE_UNSPECIFIED" : Default value.
  /// - "SOLUTION_TYPE_RECOMMENDATION" : Used for Recommendations AI.
  /// - "SOLUTION_TYPE_SEARCH" : Used for Discovery Search.
  /// - "SOLUTION_TYPE_CHAT" : Used for use cases related to the Generative AI
  /// agent.
  /// - "SOLUTION_TYPE_GENERATIVE_CHAT" : Used for use cases related to the
  /// Generative Chat agent. It's used for Generative chat engine only, the
  /// associated data stores must enrolled with `SOLUTION_TYPE_CHAT` solution.
  core.String? solutionType;

  /// Describes search widget UI branding settings, such as the widget title,
  /// logo, favicons, and colors.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiBrandingSettings? uiBranding;

  /// Describes general widget search settings as seen in cloud console widget
  /// configuration page.
  ///
  /// Replaces top deprecated top level properties.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettings? uiSettings;

  /// Timestamp the WidgetConfig was updated.
  ///
  /// Output only.
  core.String? updateTime;

  GoogleCloudDiscoveryengineV1alphaWidgetConfig({
    this.accessSettings,
    this.allowPublicAccess,
    this.allowlistedDomains,
    this.assistantSettings,
    this.collectionComponents,
    this.configId,
    this.contentSearchSpec,
    this.createTime,
    this.customerProvidedConfig,
    this.dataStoreType,
    this.dataStoreUiConfigs,
    this.defaultSearchRequestOrderBy,
    this.displayName,
    this.enableAutocomplete,
    this.enableConversationalSearch,
    this.enablePrivateKnowledgeGraph,
    this.enableQualityFeedback,
    this.enableResultScore,
    this.enableSafeSearch,
    this.enableSearchAsYouType,
    this.enableSnippetResultSummary,
    this.enableSummarization,
    this.enableWebApp,
    this.experimentalFeatures,
    this.facetField,
    this.fieldsUiComponentsMap,
    this.homepageSetting,
    this.industryVertical,
    this.llmEnabled,
    this.minimumDataTermAccepted,
    this.name,
    this.resultDisplayType,
    this.solutionType,
    this.uiBranding,
    this.uiSettings,
    this.updateTime,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfig.fromJson(core.Map json_)
    : this(
        accessSettings:
            json_.containsKey('accessSettings')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigAccessSettings.fromJson(
                  json_['accessSettings']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        allowPublicAccess: json_['allowPublicAccess'] as core.bool?,
        allowlistedDomains:
            (json_['allowlistedDomains'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        assistantSettings:
            json_.containsKey('assistantSettings')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigAssistantSettings.fromJson(
                  json_['assistantSettings']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        collectionComponents:
            (json_['collectionComponents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaWidgetConfigCollectionComponent.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        configId: json_['configId'] as core.String?,
        contentSearchSpec:
            json_.containsKey('contentSearchSpec')
                ? GoogleCloudDiscoveryengineV1alphaSearchRequestContentSearchSpec.fromJson(
                  json_['contentSearchSpec']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        createTime: json_['createTime'] as core.String?,
        customerProvidedConfig:
            json_.containsKey('customerProvidedConfig')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigCustomerProvidedConfig.fromJson(
                  json_['customerProvidedConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        dataStoreType: json_['dataStoreType'] as core.String?,
        dataStoreUiConfigs:
            (json_['dataStoreUiConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreUiConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        defaultSearchRequestOrderBy:
            json_['defaultSearchRequestOrderBy'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        enableAutocomplete: json_['enableAutocomplete'] as core.bool?,
        enableConversationalSearch:
            json_['enableConversationalSearch'] as core.bool?,
        enablePrivateKnowledgeGraph:
            json_['enablePrivateKnowledgeGraph'] as core.bool?,
        enableQualityFeedback: json_['enableQualityFeedback'] as core.bool?,
        enableResultScore: json_['enableResultScore'] as core.bool?,
        enableSafeSearch: json_['enableSafeSearch'] as core.bool?,
        enableSearchAsYouType: json_['enableSearchAsYouType'] as core.bool?,
        enableSnippetResultSummary:
            json_['enableSnippetResultSummary'] as core.bool?,
        enableSummarization: json_['enableSummarization'] as core.bool?,
        enableWebApp: json_['enableWebApp'] as core.bool?,
        experimentalFeatures: (json_['experimentalFeatures']
                as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        facetField:
            (json_['facetField'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaWidgetConfigFacetField.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        fieldsUiComponentsMap: (json_['fieldsUiComponentsMap']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudDiscoveryengineV1alphaWidgetConfigUIComponentField.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        homepageSetting:
            json_.containsKey('homepageSetting')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSetting.fromJson(
                  json_['homepageSetting']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        industryVertical: json_['industryVertical'] as core.String?,
        llmEnabled: json_['llmEnabled'] as core.bool?,
        minimumDataTermAccepted: json_['minimumDataTermAccepted'] as core.bool?,
        name: json_['name'] as core.String?,
        resultDisplayType: json_['resultDisplayType'] as core.String?,
        solutionType: json_['solutionType'] as core.String?,
        uiBranding:
            json_.containsKey('uiBranding')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigUiBrandingSettings.fromJson(
                  json_['uiBranding'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        uiSettings:
            json_.containsKey('uiSettings')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettings.fromJson(
                  json_['uiSettings'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        updateTime: json_['updateTime'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (accessSettings != null) 'accessSettings': accessSettings!,
    if (allowPublicAccess != null) 'allowPublicAccess': allowPublicAccess!,
    if (allowlistedDomains != null) 'allowlistedDomains': allowlistedDomains!,
    if (assistantSettings != null) 'assistantSettings': assistantSettings!,
    if (collectionComponents != null)
      'collectionComponents': collectionComponents!,
    if (configId != null) 'configId': configId!,
    if (contentSearchSpec != null) 'contentSearchSpec': contentSearchSpec!,
    if (createTime != null) 'createTime': createTime!,
    if (customerProvidedConfig != null)
      'customerProvidedConfig': customerProvidedConfig!,
    if (dataStoreType != null) 'dataStoreType': dataStoreType!,
    if (dataStoreUiConfigs != null) 'dataStoreUiConfigs': dataStoreUiConfigs!,
    if (defaultSearchRequestOrderBy != null)
      'defaultSearchRequestOrderBy': defaultSearchRequestOrderBy!,
    if (displayName != null) 'displayName': displayName!,
    if (enableAutocomplete != null) 'enableAutocomplete': enableAutocomplete!,
    if (enableConversationalSearch != null)
      'enableConversationalSearch': enableConversationalSearch!,
    if (enablePrivateKnowledgeGraph != null)
      'enablePrivateKnowledgeGraph': enablePrivateKnowledgeGraph!,
    if (enableQualityFeedback != null)
      'enableQualityFeedback': enableQualityFeedback!,
    if (enableResultScore != null) 'enableResultScore': enableResultScore!,
    if (enableSafeSearch != null) 'enableSafeSearch': enableSafeSearch!,
    if (enableSearchAsYouType != null)
      'enableSearchAsYouType': enableSearchAsYouType!,
    if (enableSnippetResultSummary != null)
      'enableSnippetResultSummary': enableSnippetResultSummary!,
    if (enableSummarization != null)
      'enableSummarization': enableSummarization!,
    if (enableWebApp != null) 'enableWebApp': enableWebApp!,
    if (experimentalFeatures != null)
      'experimentalFeatures': experimentalFeatures!,
    if (facetField != null) 'facetField': facetField!,
    if (fieldsUiComponentsMap != null)
      'fieldsUiComponentsMap': fieldsUiComponentsMap!,
    if (homepageSetting != null) 'homepageSetting': homepageSetting!,
    if (industryVertical != null) 'industryVertical': industryVertical!,
    if (llmEnabled != null) 'llmEnabled': llmEnabled!,
    if (minimumDataTermAccepted != null)
      'minimumDataTermAccepted': minimumDataTermAccepted!,
    if (name != null) 'name': name!,
    if (resultDisplayType != null) 'resultDisplayType': resultDisplayType!,
    if (solutionType != null) 'solutionType': solutionType!,
    if (uiBranding != null) 'uiBranding': uiBranding!,
    if (uiSettings != null) 'uiSettings': uiSettings!,
    if (updateTime != null) 'updateTime': updateTime!,
  };
}

/// Describes widget access settings.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigAccessSettings {
  /// Whether public unauthenticated access is allowed.
  core.bool? allowPublicAccess;

  /// List of domains that are allowed to integrate the search widget.
  core.List<core.String>? allowlistedDomains;

  /// Whether web app access is enabled.
  core.bool? enableWebApp;

  /// Language code for user interface.
  ///
  /// Use language tags defined by
  /// [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). If unset, the
  /// default language code is "en-US".
  ///
  /// Optional.
  core.String? languageCode;

  /// The workforce identity pool provider used to access the widget.
  ///
  /// Optional.
  core.String? workforceIdentityPoolProvider;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigAccessSettings({
    this.allowPublicAccess,
    this.allowlistedDomains,
    this.enableWebApp,
    this.languageCode,
    this.workforceIdentityPoolProvider,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigAccessSettings.fromJson(
    core.Map json_,
  ) : this(
        allowPublicAccess: json_['allowPublicAccess'] as core.bool?,
        allowlistedDomains:
            (json_['allowlistedDomains'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        enableWebApp: json_['enableWebApp'] as core.bool?,
        languageCode: json_['languageCode'] as core.String?,
        workforceIdentityPoolProvider:
            json_['workforceIdentityPoolProvider'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (allowPublicAccess != null) 'allowPublicAccess': allowPublicAccess!,
    if (allowlistedDomains != null) 'allowlistedDomains': allowlistedDomains!,
    if (enableWebApp != null) 'enableWebApp': enableWebApp!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (workforceIdentityPoolProvider != null)
      'workforceIdentityPoolProvider': workforceIdentityPoolProvider!,
  };
}

/// Describes the assistant settings of the widget.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigAssistantSettings {
  /// Whether or not the Google search grounding toggle is shown.
  ///
  /// Deprecated. Use web_grounding_type instead.
  @core.Deprecated(
    'Not supported. Member documentation may have more information.',
  )
  core.bool? googleSearchGroundingEnabled;

  /// The type of web grounding to use.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "WEB_GROUNDING_TYPE_UNSPECIFIED" : Default, unspecified setting. This is
  /// the same as disabled.
  /// - "WEB_GROUNDING_TYPE_DISABLED" : Web grounding is disabled.
  /// - "WEB_GROUNDING_TYPE_GOOGLE_SEARCH" : Grounding with Google Search is
  /// enabled.
  /// - "WEB_GROUNDING_TYPE_ENTERPRISE_WEB_SEARCH" : Grounding with Enterprise
  /// Web Search is enabled.
  core.String? webGroundingType;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigAssistantSettings({
    this.googleSearchGroundingEnabled,
    this.webGroundingType,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigAssistantSettings.fromJson(
    core.Map json_,
  ) : this(
        googleSearchGroundingEnabled:
            json_['googleSearchGroundingEnabled'] as core.bool?,
        webGroundingType: json_['webGroundingType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (googleSearchGroundingEnabled != null)
      'googleSearchGroundingEnabled': googleSearchGroundingEnabled!,
    if (webGroundingType != null) 'webGroundingType': webGroundingType!,
  };
}

/// Read-only collection component that contains data store collections fields
/// that may be used for filtering
class GoogleCloudDiscoveryengineV1alphaWidgetConfigCollectionComponent {
  /// The icon link of the connector source.
  ///
  /// Output only.
  core.String? connectorIconLink;

  /// The name of the data source, retrieved from
  /// `Collection.data_connector.data_source`.
  core.String? dataSource;

  /// The display name of the data source.
  ///
  /// Output only.
  core.String? dataSourceDisplayName;

  /// For the data store collection, list of the children data stores.
  core.List<GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreComponent>?
  dataStoreComponents;

  /// The display name of the collection.
  core.String? displayName;

  /// the identifier of the collection, used for widget service.
  ///
  /// For now it refers to collection_id, in the future we will migrate the
  /// field to encrypted collection name UUID.
  ///
  /// Output only.
  core.String? id;

  /// The name of the collection.
  ///
  /// It should be collection resource name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}`. For
  /// APIs under WidgetService, such as WidgetService.LookUpWidgetConfig, the
  /// project number and location part is erased in this field.
  core.String? name;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigCollectionComponent({
    this.connectorIconLink,
    this.dataSource,
    this.dataSourceDisplayName,
    this.dataStoreComponents,
    this.displayName,
    this.id,
    this.name,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigCollectionComponent.fromJson(
    core.Map json_,
  ) : this(
        connectorIconLink: json_['connectorIconLink'] as core.String?,
        dataSource: json_['dataSource'] as core.String?,
        dataSourceDisplayName: json_['dataSourceDisplayName'] as core.String?,
        dataStoreComponents:
            (json_['dataStoreComponents'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreComponent.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        displayName: json_['displayName'] as core.String?,
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (connectorIconLink != null) 'connectorIconLink': connectorIconLink!,
    if (dataSource != null) 'dataSource': dataSource!,
    if (dataSourceDisplayName != null)
      'dataSourceDisplayName': dataSourceDisplayName!,
    if (dataStoreComponents != null)
      'dataStoreComponents': dataStoreComponents!,
    if (displayName != null) 'displayName': displayName!,
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Customer provided configurations.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigCustomerProvidedConfig {
  /// Customer type.
  /// Possible string values are:
  /// - "DEFAULT_CUSTOMER" : Default customer type.
  /// - "GOVERNMENT_CUSTOMER" : Government customer type. Some features are
  /// disabled for government customers due to legal requirements.
  core.String? customerType;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigCustomerProvidedConfig({
    this.customerType,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigCustomerProvidedConfig.fromJson(
    core.Map json_,
  ) : this(customerType: json_['customerType'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (customerType != null) 'customerType': customerType!,
  };
}

/// Read-only data store component that contains data stores fields that may be
/// used for filtering, it's the child of `CollectionComponent`.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreComponent {
  /// The content config of the data store.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "CONTENT_CONFIG_UNSPECIFIED" : Default value.
  /// - "NO_CONTENT" : Only contains documents without any Document.content.
  /// - "CONTENT_REQUIRED" : Only contains documents with Document.content.
  /// - "PUBLIC_WEBSITE" : The data store is used for public website search.
  /// - "GOOGLE_WORKSPACE" : The data store is used for workspace search.
  /// Details of workspace data store are specified in the WorkspaceConfig.
  core.String? contentConfig;

  /// The display name of the data store.
  core.String? displayName;

  /// The name of the entity, retrieved from
  /// `Collection.data_connector.entities.entityName`.
  core.String? entityName;

  /// the identifier of the data store, used for widget service.
  ///
  /// For now it refers to data_store_id, in the future we will migrate the
  /// field to encrypted data store name UUID.
  ///
  /// Output only.
  core.String? id;

  /// The name of the data store.
  ///
  /// It should be data store resource name Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// For APIs under WidgetService, such as WidgetService.LookUpWidgetConfig,
  /// the project number and location part is erased in this field.
  core.String? name;

  /// Workspace Source Types for workspace data, retrieved from
  /// `DataStore.workspace_config.type`.
  ///
  /// Output only.
  /// Possible string values are:
  /// - "TYPE_UNSPECIFIED" : Defaults to an unspecified Workspace type.
  /// - "GOOGLE_DRIVE" : Workspace Data Store contains Drive data
  /// - "GOOGLE_MAIL" : Workspace Data Store contains Mail data
  /// - "GOOGLE_SITES" : Workspace Data Store contains Sites data
  /// - "GOOGLE_CALENDAR" : Workspace Data Store contains Calendar data
  /// - "GOOGLE_CHAT" : Workspace Data Store contains Chat data
  /// - "GOOGLE_GROUPS" : Workspace Data Store contains Groups data
  /// - "GOOGLE_KEEP" : Workspace Data Store contains Keep data
  /// - "GOOGLE_PEOPLE" : Workspace Data Store contains People data
  core.String? workspaceType;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreComponent({
    this.contentConfig,
    this.displayName,
    this.entityName,
    this.id,
    this.name,
    this.workspaceType,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreComponent.fromJson(
    core.Map json_,
  ) : this(
        contentConfig: json_['contentConfig'] as core.String?,
        displayName: json_['displayName'] as core.String?,
        entityName: json_['entityName'] as core.String?,
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
        workspaceType: json_['workspaceType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (contentConfig != null) 'contentConfig': contentConfig!,
    if (displayName != null) 'displayName': displayName!,
    if (entityName != null) 'entityName': entityName!,
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
    if (workspaceType != null) 'workspaceType': workspaceType!,
  };
}

/// UI component configuration for data store.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreUiConfig {
  /// Facet fields that store the mapping of fields to end user widget
  /// appearance.
  core.List<GoogleCloudDiscoveryengineV1alphaWidgetConfigFacetField>?
  facetField;

  /// The key is the UI component.
  ///
  /// Mock. Currently supported `title`, `thumbnail`, `url`, `custom1`,
  /// `custom2`, `custom3`. The value is the name of the field along with its
  /// device visibility. The 3 custom fields are optional and can be added or
  /// removed. `title`, `thumbnail`, `url` are required UI components that
  /// cannot be removed.
  core.Map<
    core.String,
    GoogleCloudDiscoveryengineV1alphaWidgetConfigUIComponentField
  >?
  fieldsUiComponentsMap;

  /// the identifier of the data store, used for widget service.
  ///
  /// For now it refers to data_store_id, in the future we will migrate the
  /// field to encrypted data store name UUID.
  ///
  /// Output only.
  core.String? id;

  /// The name of the data store.
  ///
  /// It should be data store resource name Format:
  /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
  /// For APIs under WidgetService, such as WidgetService.LookUpWidgetConfig,
  /// the project number and location part is erased in this field.
  core.String? name;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreUiConfig({
    this.facetField,
    this.fieldsUiComponentsMap,
    this.id,
    this.name,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreUiConfig.fromJson(
    core.Map json_,
  ) : this(
        facetField:
            (json_['facetField'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaWidgetConfigFacetField.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        fieldsUiComponentsMap: (json_['fieldsUiComponentsMap']
                as core.Map<core.String, core.dynamic>?)
            ?.map(
              (key, value) => core.MapEntry(
                key,
                GoogleCloudDiscoveryengineV1alphaWidgetConfigUIComponentField.fromJson(
                  value as core.Map<core.String, core.dynamic>,
                ),
              ),
            ),
        id: json_['id'] as core.String?,
        name: json_['name'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (facetField != null) 'facetField': facetField!,
    if (fieldsUiComponentsMap != null)
      'fieldsUiComponentsMap': fieldsUiComponentsMap!,
    if (id != null) 'id': id!,
    if (name != null) 'name': name!,
  };
}

/// Facet fields that store the mapping of fields to end user widget appearance.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigFacetField {
  /// The field name that end users will see.
  ///
  /// Optional.
  core.String? displayName;

  /// Registered field name.
  ///
  /// The format is `field.abc`.
  ///
  /// Required.
  core.String? field;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigFacetField({
    this.displayName,
    this.field,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigFacetField.fromJson(
    core.Map json_,
  ) : this(
        displayName: json_['displayName'] as core.String?,
        field: json_['field'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (displayName != null) 'displayName': displayName!,
    if (field != null) 'field': field!,
  };
}

/// Describes the homepage setting of the widget.
///
/// It includes all homepage related settings and configurations, such as
/// shortcuts.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSetting {
  /// The shortcuts to display on the homepage.
  ///
  /// LINT.IfChange(max_shortcuts_number)
  /// LINT.ThenChange(//depot/google3/cloud/console/web/ai/unified_cloud_search/components/widget_preview/widget_homepage_shortcut_config_form.ts:max_shortcuts_number)
  ///
  /// Optional.
  core.List<
    GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSettingShortcut
  >?
  shortcuts;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSetting({
    this.shortcuts,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSetting.fromJson(
    core.Map json_,
  ) : this(
        shortcuts:
            (json_['shortcuts'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSettingShortcut.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (shortcuts != null) 'shortcuts': shortcuts!,
  };
}

/// Describes an entity of shortcut (aka pinned content) on the homepage.
///
/// The home page will render these shortcuts in the same order as what the API
/// returns. If a customer wants to reorder or remove a shortcut, the UI should
/// always provide the new full list of shortcuts.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSettingShortcut {
  /// Destination URL of shortcut.
  ///
  /// Optional.
  core.String? destinationUri;

  /// Icon URL of shortcut.
  ///
  /// Optional.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigImage? icon;

  /// Title of the shortcut.
  ///
  /// Optional.
  core.String? title;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSettingShortcut({
    this.destinationUri,
    this.icon,
    this.title,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigHomepageSettingShortcut.fromJson(
    core.Map json_,
  ) : this(
        destinationUri: json_['destinationUri'] as core.String?,
        icon:
            json_.containsKey('icon')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigImage.fromJson(
                  json_['icon'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (destinationUri != null) 'destinationUri': destinationUri!,
    if (icon != null) 'icon': icon!,
    if (title != null) 'title': title!,
  };
}

/// Options to store an image.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigImage {
  /// Image URL.
  core.String? url;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigImage({this.url});

  GoogleCloudDiscoveryengineV1alphaWidgetConfigImage.fromJson(core.Map json_)
    : this(url: json_['url'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {
    if (url != null) 'url': url!,
  };
}

/// Facet field that maps to a UI Component.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigUIComponentField {
  /// The field visibility on different types of devices.
  core.List<core.String>? deviceVisibility;

  /// The template to customize how the field is displayed.
  ///
  /// An example value would be a string that looks like: "Price: {value}".
  core.String? displayTemplate;

  /// Registered field name.
  ///
  /// The format is `field.abc`.
  ///
  /// Required.
  core.String? field;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUIComponentField({
    this.deviceVisibility,
    this.displayTemplate,
    this.field,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUIComponentField.fromJson(
    core.Map json_,
  ) : this(
        deviceVisibility:
            (json_['deviceVisibility'] as core.List?)
                ?.map((value) => value as core.String)
                .toList(),
        displayTemplate: json_['displayTemplate'] as core.String?,
        field: json_['field'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (deviceVisibility != null) 'deviceVisibility': deviceVisibility!,
    if (displayTemplate != null) 'displayTemplate': displayTemplate!,
    if (field != null) 'field': field!,
  };
}

/// Describes widget UI branding settings.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigUiBrandingSettings {
  /// Logo image.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigImage? logo;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiBrandingSettings({this.logo});

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiBrandingSettings.fromJson(
    core.Map json_,
  ) : this(
        logo:
            json_.containsKey('logo')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigImage.fromJson(
                  json_['logo'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (logo != null) 'logo': logo!,
  };
}

/// Describes general widget (or web app) UI settings as seen in the cloud
/// console UI configuration page.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettings {
  /// Per data store configuration.
  core.List<GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreUiConfig>?
  dataStoreUiConfigs;

  /// The default ordering for search results if specified.
  ///
  /// Used to set SearchRequest#order_by on applicable requests.
  /// https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/projects.locations.dataStores.servingConfigs/search#request-body
  core.String? defaultSearchRequestOrderBy;

  /// If set to true, the widget will not collect user events.
  core.bool? disableUserEventsCollection;

  /// Whether or not to enable autocomplete.
  core.bool? enableAutocomplete;

  /// If set to true, the widget will enable people search.
  ///
  /// Optional.
  core.bool? enablePeopleSearch;

  /// Turn on or off collecting the search result quality feedback from end
  /// users.
  core.bool? enableQualityFeedback;

  /// Whether to enable safe search.
  core.bool? enableSafeSearch;

  /// Whether to enable search-as-you-type behavior for the search widget.
  core.bool? enableSearchAsYouType;

  /// If set to true, the widget will enable visual content summary on
  /// applicable search requests.
  ///
  /// Only used by healthcare search.
  core.bool? enableVisualContentSummary;

  /// Feature config for the engine to opt in or opt out of features.
  ///
  /// Supported keys: * `agent-gallery` * `no-code-agent-builder` *
  /// `prompt-gallery` * `model-selector` * `notebook-lm` * `people-search` *
  /// `people-search-org-chart` * `bi-directional-audio` * `feedback` *
  /// `session-sharing` * `personalization-memory` - Enables personalization
  /// based on user preferences.
  ///
  /// Output only.
  core.Map<core.String, core.String>? features;

  /// Describes generative answer configuration.
  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettingsGenerativeAnswerConfig?
  generativeAnswerConfig;

  /// Describes widget (or web app) interaction type
  /// Possible string values are:
  /// - "INTERACTION_TYPE_UNSPECIFIED" : Not specified. Defaults to SEARCH_ONLY.
  /// - "SEARCH_ONLY" : Search without a generative answer.
  /// - "SEARCH_WITH_ANSWER" : Search with the generative answer.
  /// - "SEARCH_WITH_FOLLOW_UPS" : Search with the generative answer that
  /// supports follow up questions. Also known as multi-turn search.
  core.String? interactionType;

  /// Controls whether result extract is display and how (snippet or extractive
  /// answer).
  ///
  /// Default to no result if unspecified.
  /// Possible string values are:
  /// - "RESULT_DISPLAY_TYPE_UNSPECIFIED" : Unspecified display type (default to
  /// showing snippet).
  /// - "SNIPPET" : Display results from the snippet field.
  /// - "EXTRACTIVE_ANSWER" : Display results from extractive answers field.
  core.String? resultDescriptionType;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettings({
    this.dataStoreUiConfigs,
    this.defaultSearchRequestOrderBy,
    this.disableUserEventsCollection,
    this.enableAutocomplete,
    this.enablePeopleSearch,
    this.enableQualityFeedback,
    this.enableSafeSearch,
    this.enableSearchAsYouType,
    this.enableVisualContentSummary,
    this.features,
    this.generativeAnswerConfig,
    this.interactionType,
    this.resultDescriptionType,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettings.fromJson(
    core.Map json_,
  ) : this(
        dataStoreUiConfigs:
            (json_['dataStoreUiConfigs'] as core.List?)
                ?.map(
                  (value) =>
                      GoogleCloudDiscoveryengineV1alphaWidgetConfigDataStoreUiConfig.fromJson(
                        value as core.Map<core.String, core.dynamic>,
                      ),
                )
                .toList(),
        defaultSearchRequestOrderBy:
            json_['defaultSearchRequestOrderBy'] as core.String?,
        disableUserEventsCollection:
            json_['disableUserEventsCollection'] as core.bool?,
        enableAutocomplete: json_['enableAutocomplete'] as core.bool?,
        enablePeopleSearch: json_['enablePeopleSearch'] as core.bool?,
        enableQualityFeedback: json_['enableQualityFeedback'] as core.bool?,
        enableSafeSearch: json_['enableSafeSearch'] as core.bool?,
        enableSearchAsYouType: json_['enableSearchAsYouType'] as core.bool?,
        enableVisualContentSummary:
            json_['enableVisualContentSummary'] as core.bool?,
        features: (json_['features'] as core.Map<core.String, core.dynamic>?)
            ?.map((key, value) => core.MapEntry(key, value as core.String)),
        generativeAnswerConfig:
            json_.containsKey('generativeAnswerConfig')
                ? GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettingsGenerativeAnswerConfig.fromJson(
                  json_['generativeAnswerConfig']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        interactionType: json_['interactionType'] as core.String?,
        resultDescriptionType: json_['resultDescriptionType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (dataStoreUiConfigs != null) 'dataStoreUiConfigs': dataStoreUiConfigs!,
    if (defaultSearchRequestOrderBy != null)
      'defaultSearchRequestOrderBy': defaultSearchRequestOrderBy!,
    if (disableUserEventsCollection != null)
      'disableUserEventsCollection': disableUserEventsCollection!,
    if (enableAutocomplete != null) 'enableAutocomplete': enableAutocomplete!,
    if (enablePeopleSearch != null) 'enablePeopleSearch': enablePeopleSearch!,
    if (enableQualityFeedback != null)
      'enableQualityFeedback': enableQualityFeedback!,
    if (enableSafeSearch != null) 'enableSafeSearch': enableSafeSearch!,
    if (enableSearchAsYouType != null)
      'enableSearchAsYouType': enableSearchAsYouType!,
    if (enableVisualContentSummary != null)
      'enableVisualContentSummary': enableVisualContentSummary!,
    if (features != null) 'features': features!,
    if (generativeAnswerConfig != null)
      'generativeAnswerConfig': generativeAnswerConfig!,
    if (interactionType != null) 'interactionType': interactionType!,
    if (resultDescriptionType != null)
      'resultDescriptionType': resultDescriptionType!,
  };
}

/// Describes configuration for generative answer.
class GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettingsGenerativeAnswerConfig {
  /// Whether generated answer contains suggested related questions.
  core.bool? disableRelatedQuestions;

  /// Specifies whether to filter out queries that are adversarial.
  ///
  /// Optional.
  core.bool? ignoreAdversarialQuery;

  /// Specifies whether to filter out queries that are not relevant to the
  /// content.
  ///
  /// Optional.
  core.bool? ignoreLowRelevantContent;

  /// Specifies whether to filter out queries that are not answer-seeking.
  ///
  /// The default value is `false`. No answer is returned if the search query is
  /// classified as a non-answer seeking query. If this field is set to `true`,
  /// we skip generating answers for non-answer seeking queries and return
  /// fallback messages instead.
  ///
  /// Optional.
  core.bool? ignoreNonAnswerSeekingQuery;

  /// Source of image returned in the answer.
  ///
  /// Optional.
  /// Possible string values are:
  /// - "IMAGE_SOURCE_UNSPECIFIED" : Unspecified image source (multimodal
  /// feature is disabled by default)
  /// - "ALL_AVAILABLE_SOURCES" : Behavior when service determines the pick from
  /// all available sources.
  /// - "CORPUS_IMAGE_ONLY" : Include image from corpus in the answer.
  /// - "FIGURE_GENERATION_ONLY" : Triggers figure generation in the answer.
  core.String? imageSource;

  /// Language code for Summary.
  ///
  /// Use language tags defined by
  /// [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This is an
  /// experimental feature.
  core.String? languageCode;

  /// Max rephrase steps.
  ///
  /// The max number is 5 steps. If not set or set to \< 1, it will be set to 1
  /// by default.
  core.int? maxRephraseSteps;

  /// Text at the beginning of the prompt that instructs the model that
  /// generates the answer.
  core.String? modelPromptPreamble;

  /// The model version used to generate the answer.
  core.String? modelVersion;

  /// The number of top results to generate the answer from.
  ///
  /// Up to 10.
  core.int? resultCount;

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettingsGenerativeAnswerConfig({
    this.disableRelatedQuestions,
    this.ignoreAdversarialQuery,
    this.ignoreLowRelevantContent,
    this.ignoreNonAnswerSeekingQuery,
    this.imageSource,
    this.languageCode,
    this.maxRephraseSteps,
    this.modelPromptPreamble,
    this.modelVersion,
    this.resultCount,
  });

  GoogleCloudDiscoveryengineV1alphaWidgetConfigUiSettingsGenerativeAnswerConfig.fromJson(
    core.Map json_,
  ) : this(
        disableRelatedQuestions: json_['disableRelatedQuestions'] as core.bool?,
        ignoreAdversarialQuery: json_['ignoreAdversarialQuery'] as core.bool?,
        ignoreLowRelevantContent:
            json_['ignoreLowRelevantContent'] as core.bool?,
        ignoreNonAnswerSeekingQuery:
            json_['ignoreNonAnswerSeekingQuery'] as core.bool?,
        imageSource: json_['imageSource'] as core.String?,
        languageCode: json_['languageCode'] as core.String?,
        maxRephraseSteps: json_['maxRephraseSteps'] as core.int?,
        modelPromptPreamble: json_['modelPromptPreamble'] as core.String?,
        modelVersion: json_['modelVersion'] as core.String?,
        resultCount: json_['resultCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (disableRelatedQuestions != null)
      'disableRelatedQuestions': disableRelatedQuestions!,
    if (ignoreAdversarialQuery != null)
      'ignoreAdversarialQuery': ignoreAdversarialQuery!,
    if (ignoreLowRelevantContent != null)
      'ignoreLowRelevantContent': ignoreLowRelevantContent!,
    if (ignoreNonAnswerSeekingQuery != null)
      'ignoreNonAnswerSeekingQuery': ignoreNonAnswerSeekingQuery!,
    if (imageSource != null) 'imageSource': imageSource!,
    if (languageCode != null) 'languageCode': languageCode!,
    if (maxRephraseSteps != null) 'maxRephraseSteps': maxRephraseSteps!,
    if (modelPromptPreamble != null)
      'modelPromptPreamble': modelPromptPreamble!,
    if (modelVersion != null) 'modelVersion': modelVersion!,
    if (resultCount != null) 'resultCount': resultCount!,
  };
}

/// Config to store data store type configuration for workspace data
typedef GoogleCloudDiscoveryengineV1alphaWorkspaceConfig = $WorkspaceConfig;

/// Metadata about an agentspace source.
class GoogleCloudNotebooklmV1alphaAgentspaceMetadata {
  /// The full document name in Agentspace.
  ///
  /// Output only.
  core.String? documentName;

  /// The title of the document.
  ///
  /// Output only.
  core.String? documentTitle;

  GoogleCloudNotebooklmV1alphaAgentspaceMetadata({
    this.documentName,
    this.documentTitle,
  });

  GoogleCloudNotebooklmV1alphaAgentspaceMetadata.fromJson(core.Map json_)
    : this(
        documentName: json_['documentName'] as core.String?,
        documentTitle: json_['documentTitle'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentName != null) 'documentName': documentName!,
    if (documentTitle != null) 'documentTitle': documentTitle!,
  };
}

/// Request for SourceService.BatchCreateSources method.
class GoogleCloudNotebooklmV1alphaBatchCreateSourcesRequest {
  /// The UserContents to be uploaded.
  ///
  /// Required.
  core.List<GoogleCloudNotebooklmV1alphaUserContent>? userContents;

  GoogleCloudNotebooklmV1alphaBatchCreateSourcesRequest({this.userContents});

  GoogleCloudNotebooklmV1alphaBatchCreateSourcesRequest.fromJson(core.Map json_)
    : this(
        userContents:
            (json_['userContents'] as core.List?)
                ?.map(
                  (value) => GoogleCloudNotebooklmV1alphaUserContent.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (userContents != null) 'userContents': userContents!,
  };
}

/// Response for SourceService.BatchCreateSources method.
class GoogleCloudNotebooklmV1alphaBatchCreateSourcesResponse {
  /// The Sources.
  core.List<GoogleCloudNotebooklmV1alphaSource>? sources;

  GoogleCloudNotebooklmV1alphaBatchCreateSourcesResponse({this.sources});

  GoogleCloudNotebooklmV1alphaBatchCreateSourcesResponse.fromJson(
    core.Map json_,
  ) : this(
        sources:
            (json_['sources'] as core.List?)
                ?.map(
                  (value) => GoogleCloudNotebooklmV1alphaSource.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (sources != null) 'sources': sources!,
  };
}

/// Response for NotebookService.ListRecentlyViewedNotebooks method.
class GoogleCloudNotebooklmV1alphaListRecentlyViewedNotebooksResponse {
  /// The page token, provide this to retrieve the subsequent page.
  core.String? nextPageToken;

  /// The list of recently viewed notebooks.
  core.List<GoogleCloudNotebooklmV1alphaNotebook>? notebooks;

  GoogleCloudNotebooklmV1alphaListRecentlyViewedNotebooksResponse({
    this.nextPageToken,
    this.notebooks,
  });

  GoogleCloudNotebooklmV1alphaListRecentlyViewedNotebooksResponse.fromJson(
    core.Map json_,
  ) : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        notebooks:
            (json_['notebooks'] as core.List?)
                ?.map(
                  (value) => GoogleCloudNotebooklmV1alphaNotebook.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (notebooks != null) 'notebooks': notebooks!,
  };
}

/// Notebook is a resource where users can store their content (as sources) and
/// interacts with the content.
class GoogleCloudNotebooklmV1alphaNotebook {
  /// The emoji of the notebook.
  ///
  /// Output only.
  core.String? emoji;

  /// The metadata of the notebook.
  GoogleCloudNotebooklmV1alphaNotebookMetadata? metadata;

  /// Identifier.
  ///
  /// The identifier of the notebook. Format:
  /// `projects/{project}/locations/{location}/notebooks/{notebook_id}`. This
  /// field must be a UTF-8 encoded string.
  core.String? name;

  /// Notebook id, which is the last segment of the notebook's resource name.
  ///
  /// This is to make it similar with notebooklm API.
  ///
  /// Optional.
  core.String? notebookId;

  /// The title of the notebook.
  ///
  /// Optional.
  core.String? title;

  GoogleCloudNotebooklmV1alphaNotebook({
    this.emoji,
    this.metadata,
    this.name,
    this.notebookId,
    this.title,
  });

  GoogleCloudNotebooklmV1alphaNotebook.fromJson(core.Map json_)
    : this(
        emoji: json_['emoji'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? GoogleCloudNotebooklmV1alphaNotebookMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        notebookId: json_['notebookId'] as core.String?,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (emoji != null) 'emoji': emoji!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (notebookId != null) 'notebookId': notebookId!,
    if (title != null) 'title': title!,
  };
}

/// Metadata for a notebook.
class GoogleCloudNotebooklmV1alphaNotebookMetadata {
  /// The time at which this project was created.
  core.String? createTime;

  /// True if the project is shareable.
  core.bool? isShareable;

  /// True if this project is currently shared with other people, false
  /// otherwise.
  core.bool? isShared;

  /// A timestamp indicating the time that the current in session user has last
  /// viewed the project.
  core.String? lastViewed;

  GoogleCloudNotebooklmV1alphaNotebookMetadata({
    this.createTime,
    this.isShareable,
    this.isShared,
    this.lastViewed,
  });

  GoogleCloudNotebooklmV1alphaNotebookMetadata.fromJson(core.Map json_)
    : this(
        createTime: json_['createTime'] as core.String?,
        isShareable: json_['isShareable'] as core.bool?,
        isShared: json_['isShared'] as core.bool?,
        lastViewed: json_['lastViewed'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (createTime != null) 'createTime': createTime!,
    if (isShareable != null) 'isShareable': isShareable!,
    if (isShared != null) 'isShared': isShared!,
    if (lastViewed != null) 'lastViewed': lastViewed!,
  };
}

/// Source represents a single source of content.
class GoogleCloudNotebooklmV1alphaSource {
  /// Metadata about the source.
  GoogleCloudNotebooklmV1alphaSourceMetadata? metadata;

  /// Identifier.
  ///
  /// The full resource name of the source. Format:
  /// `projects/{project}/locations/{location}/notebooks/{notebook}/sources/{source_id}`.
  /// This field must be a UTF-8 encoded string with a length limit of 1024
  /// characters.
  core.String? name;

  /// Source id, which is the last segment of the source's resource name.
  ///
  /// This is to make it similar with notebooklm API.
  ///
  /// Optional.
  GoogleCloudNotebooklmV1alphaSourceId? sourceId;

  /// Title of the source.
  ///
  /// Optional.
  core.String? title;

  GoogleCloudNotebooklmV1alphaSource({
    this.metadata,
    this.name,
    this.sourceId,
    this.title,
  });

  GoogleCloudNotebooklmV1alphaSource.fromJson(core.Map json_)
    : this(
        metadata:
            json_.containsKey('metadata')
                ? GoogleCloudNotebooklmV1alphaSourceMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        name: json_['name'] as core.String?,
        sourceId:
            json_.containsKey('sourceId')
                ? GoogleCloudNotebooklmV1alphaSourceId.fromJson(
                  json_['sourceId'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        title: json_['title'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (sourceId != null) 'sourceId': sourceId!,
    if (title != null) 'title': title!,
  };
}

/// SourceId is the last segment of the source's resource name.
class GoogleCloudNotebooklmV1alphaSourceId {
  /// The id of the source.
  core.String? id;

  GoogleCloudNotebooklmV1alphaSourceId({this.id});

  GoogleCloudNotebooklmV1alphaSourceId.fromJson(core.Map json_)
    : this(id: json_['id'] as core.String?);

  core.Map<core.String, core.dynamic> toJson() => {if (id != null) 'id': id!};
}

/// Represents the metadata of a source and some additional information.
class GoogleCloudNotebooklmV1alphaSourceMetadata {
  /// Metadata for an agentspace source.
  GoogleCloudNotebooklmV1alphaAgentspaceMetadata? agentspaceMetadata;

  /// The timestamp the source was added.
  core.String? sourceAddedTimestamp;

  /// The number of tokens in the source.
  core.int? tokenCount;

  /// The word count of the source.
  core.int? wordCount;

  GoogleCloudNotebooklmV1alphaSourceMetadata({
    this.agentspaceMetadata,
    this.sourceAddedTimestamp,
    this.tokenCount,
    this.wordCount,
  });

  GoogleCloudNotebooklmV1alphaSourceMetadata.fromJson(core.Map json_)
    : this(
        agentspaceMetadata:
            json_.containsKey('agentspaceMetadata')
                ? GoogleCloudNotebooklmV1alphaAgentspaceMetadata.fromJson(
                  json_['agentspaceMetadata']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        sourceAddedTimestamp: json_['sourceAddedTimestamp'] as core.String?,
        tokenCount: json_['tokenCount'] as core.int?,
        wordCount: json_['wordCount'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agentspaceMetadata != null) 'agentspaceMetadata': agentspaceMetadata!,
    if (sourceAddedTimestamp != null)
      'sourceAddedTimestamp': sourceAddedTimestamp!,
    if (tokenCount != null) 'tokenCount': tokenCount!,
    if (wordCount != null) 'wordCount': wordCount!,
  };
}

/// Request for the SourceService.UploadSourceFile method.
class GoogleCloudNotebooklmV1alphaUploadSourceFileRequest {
  /// Information about the file being uploaded.
  GdataMedia? blob;

  /// Media upload request metadata.
  ApiservingMediaRequestInfo? mediaRequestInfo;

  /// The source id of the associated file.
  ///
  /// If not set, a source id will be generated and a new tentative source will
  /// be created.
  core.String? sourceId;

  GoogleCloudNotebooklmV1alphaUploadSourceFileRequest({
    this.blob,
    this.mediaRequestInfo,
    this.sourceId,
  });

  GoogleCloudNotebooklmV1alphaUploadSourceFileRequest.fromJson(core.Map json_)
    : this(
        blob:
            json_.containsKey('blob')
                ? GdataMedia.fromJson(
                  json_['blob'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        mediaRequestInfo:
            json_.containsKey('mediaRequestInfo')
                ? ApiservingMediaRequestInfo.fromJson(
                  json_['mediaRequestInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        sourceId: json_['sourceId'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (blob != null) 'blob': blob!,
    if (mediaRequestInfo != null) 'mediaRequestInfo': mediaRequestInfo!,
    if (sourceId != null) 'sourceId': sourceId!,
  };
}

/// Response for the SourceService.UploadSourceFile method.
class GoogleCloudNotebooklmV1alphaUploadSourceFileResponse {
  /// Media upload response metadata.
  ApiservingMediaResponseInfo? mediaResponseInfo;

  /// The source id of the uploaded source.
  GoogleCloudNotebooklmV1alphaSourceId? sourceId;

  GoogleCloudNotebooklmV1alphaUploadSourceFileResponse({
    this.mediaResponseInfo,
    this.sourceId,
  });

  GoogleCloudNotebooklmV1alphaUploadSourceFileResponse.fromJson(core.Map json_)
    : this(
        mediaResponseInfo:
            json_.containsKey('mediaResponseInfo')
                ? ApiservingMediaResponseInfo.fromJson(
                  json_['mediaResponseInfo']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        sourceId:
            json_.containsKey('sourceId')
                ? GoogleCloudNotebooklmV1alphaSourceId.fromJson(
                  json_['sourceId'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (mediaResponseInfo != null) 'mediaResponseInfo': mediaResponseInfo!,
    if (sourceId != null) 'sourceId': sourceId!,
  };
}

/// The "Content" messages refer to data the user wants to upload.
class GoogleCloudNotebooklmV1alphaUserContent {
  /// Agentspace content uploaded as source.
  GoogleCloudNotebooklmV1alphaUserContentAgentspaceContent? agentspaceContent;

  GoogleCloudNotebooklmV1alphaUserContent({this.agentspaceContent});

  GoogleCloudNotebooklmV1alphaUserContent.fromJson(core.Map json_)
    : this(
        agentspaceContent:
            json_.containsKey('agentspaceContent')
                ? GoogleCloudNotebooklmV1alphaUserContentAgentspaceContent.fromJson(
                  json_['agentspaceContent']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (agentspaceContent != null) 'agentspaceContent': agentspaceContent!,
  };
}

/// Agentspace content uploaded as source.
class GoogleCloudNotebooklmV1alphaUserContentAgentspaceContent {
  /// The full document name in Agentspace.
  ///
  /// Optional.
  core.String? documentName;

  /// Engine to verify the permission of the document.
  ///
  /// Optional.
  core.String? engineName;

  /// The full idea name for IdeaForge.
  ///
  /// Optional.
  core.String? ideaforgeIdeaName;

  GoogleCloudNotebooklmV1alphaUserContentAgentspaceContent({
    this.documentName,
    this.engineName,
    this.ideaforgeIdeaName,
  });

  GoogleCloudNotebooklmV1alphaUserContentAgentspaceContent.fromJson(
    core.Map json_,
  ) : this(
        documentName: json_['documentName'] as core.String?,
        engineName: json_['engineName'] as core.String?,
        ideaforgeIdeaName: json_['ideaforgeIdeaName'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (documentName != null) 'documentName': documentName!,
    if (engineName != null) 'engineName': engineName!,
    if (ideaforgeIdeaName != null) 'ideaforgeIdeaName': ideaforgeIdeaName!,
  };
}

/// The request message for Operations.CancelOperation.
typedef GoogleLongrunningCancelOperationRequest = $Empty;

/// The response message for Operations.ListOperations.
class GoogleLongrunningListOperationsResponse {
  /// The standard List next-page token.
  core.String? nextPageToken;

  /// A list of operations that matches the specified filter in the request.
  core.List<GoogleLongrunningOperation>? operations;

  GoogleLongrunningListOperationsResponse({
    this.nextPageToken,
    this.operations,
  });

  GoogleLongrunningListOperationsResponse.fromJson(core.Map json_)
    : this(
        nextPageToken: json_['nextPageToken'] as core.String?,
        operations:
            (json_['operations'] as core.List?)
                ?.map(
                  (value) => GoogleLongrunningOperation.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (nextPageToken != null) 'nextPageToken': nextPageToken!,
    if (operations != null) 'operations': operations!,
  };
}

/// This resource represents a long-running operation that is the result of a
/// network API call.
class GoogleLongrunningOperation {
  /// If the value is `false`, it means the operation is still in progress.
  ///
  /// If `true`, the operation is completed, and either `error` or `response` is
  /// available.
  core.bool? done;

  /// The error result of the operation in case of failure or cancellation.
  GoogleRpcStatus? error;

  /// Service-specific metadata associated with the operation.
  ///
  /// It typically contains progress information and common metadata such as
  /// create time. Some services might not provide such metadata. Any method
  /// that returns a long-running operation should document the metadata type,
  /// if any.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? metadata;

  /// The server-assigned name, which is only unique within the same service
  /// that originally returns it.
  ///
  /// If you use the default HTTP mapping, the `name` should be a resource name
  /// ending with `operations/{unique_id}`.
  core.String? name;

  /// The normal, successful response of the operation.
  ///
  /// If the original method returns no data on success, such as `Delete`, the
  /// response is `google.protobuf.Empty`. If the original method is standard
  /// `Get`/`Create`/`Update`, the response should be the resource. For other
  /// methods, the response should have the type `XxxResponse`, where `Xxx` is
  /// the original method name. For example, if the original method name is
  /// `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
  ///
  /// The values for Object must be JSON objects. It can consist of `num`,
  /// `String`, `bool` and `null` as well as `Map` and `List` values.
  core.Map<core.String, core.Object?>? response;

  GoogleLongrunningOperation({
    this.done,
    this.error,
    this.metadata,
    this.name,
    this.response,
  });

  GoogleLongrunningOperation.fromJson(core.Map json_)
    : this(
        done: json_['done'] as core.bool?,
        error:
            json_.containsKey('error')
                ? GoogleRpcStatus.fromJson(
                  json_['error'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metadata:
            json_.containsKey('metadata')
                ? json_['metadata'] as core.Map<core.String, core.dynamic>
                : null,
        name: json_['name'] as core.String?,
        response:
            json_.containsKey('response')
                ? json_['response'] as core.Map<core.String, core.dynamic>
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (done != null) 'done': done!,
    if (error != null) 'error': error!,
    if (metadata != null) 'metadata': metadata!,
    if (name != null) 'name': name!,
    if (response != null) 'response': response!,
  };
}

/// A single data point in a time series.
class GoogleMonitoringV3Point {
  /// The time interval to which the data point applies.
  ///
  /// For `GAUGE` metrics, the start time is optional, but if it is supplied, it
  /// must equal the end time. For `DELTA` metrics, the start and end time
  /// should specify a non-zero interval, with subsequent points specifying
  /// contiguous and non-overlapping intervals. For `CUMULATIVE` metrics, the
  /// start and end time should specify a non-zero interval, with subsequent
  /// points specifying the same start time and increasing end times, until an
  /// event resets the cumulative value to zero and sets a new start time for
  /// the following points.
  GoogleMonitoringV3TimeInterval? interval;

  /// The value of the data point.
  GoogleMonitoringV3TypedValue? value;

  GoogleMonitoringV3Point({this.interval, this.value});

  GoogleMonitoringV3Point.fromJson(core.Map json_)
    : this(
        interval:
            json_.containsKey('interval')
                ? GoogleMonitoringV3TimeInterval.fromJson(
                  json_['interval'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        value:
            json_.containsKey('value')
                ? GoogleMonitoringV3TypedValue.fromJson(
                  json_['value'] as core.Map<core.String, core.dynamic>,
                )
                : null,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (interval != null) 'interval': interval!,
    if (value != null) 'value': value!,
  };
}

/// A time interval extending just after a start time through an end time.
///
/// If the start time is the same as the end time, then the interval represents
/// a single point in time.
typedef GoogleMonitoringV3TimeInterval = $TimeInterval;

/// A collection of data points that describes the time-varying values of a
/// metric.
///
/// A time series is identified by a combination of a fully-specified monitored
/// resource and a fully-specified metric. This type is used for both listing
/// and creating time series.
class GoogleMonitoringV3TimeSeries {
  /// Input only.
  ///
  /// A detailed description of the time series that will be associated with the
  /// google.api.MetricDescriptor for the metric. Once set, this field cannot be
  /// changed through CreateTimeSeries.
  core.String? description;

  /// The associated monitored resource metadata.
  ///
  /// When reading a time series, this field will include metadata labels that
  /// are explicitly named in the reduction. When creating a time series, this
  /// field is ignored.
  ///
  /// Output only.
  GoogleApiMonitoredResourceMetadata? metadata;

  /// The associated metric.
  ///
  /// A fully-specified metric used to identify the time series.
  GoogleApiMetric? metric;

  /// The metric kind of the time series.
  ///
  /// When listing time series, this metric kind might be different from the
  /// metric kind of the associated metric if this time series is an alignment
  /// or reduction of other time series. When creating a time series, this field
  /// is optional. If present, it must be the same as the metric kind of the
  /// associated metric. If the associated metric's descriptor must be
  /// auto-created, then this field specifies the metric kind of the new
  /// descriptor and must be either `GAUGE` (the default) or `CUMULATIVE`.
  /// Possible string values are:
  /// - "METRIC_KIND_UNSPECIFIED" : Do not use this default value.
  /// - "GAUGE" : An instantaneous measurement of a value.
  /// - "DELTA" : The change in a value during a time interval.
  /// - "CUMULATIVE" : A value accumulated over a time interval. Cumulative
  /// measurements in a time series should have the same start time and
  /// increasing end times, until an event resets the cumulative value to zero
  /// and sets a new start time for the following points.
  core.String? metricKind;

  /// The data points of this time series.
  ///
  /// When listing time series, points are returned in reverse time order. When
  /// creating a time series, this field must contain exactly one point and the
  /// point's type must be the same as the value type of the associated metric.
  /// If the associated metric's descriptor must be auto-created, then the value
  /// type of the descriptor is determined by the point's type, which must be
  /// `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
  core.List<GoogleMonitoringV3Point>? points;

  /// The associated monitored resource.
  ///
  /// Custom metrics can use only certain monitored resource types in their time
  /// series data. For more information, see
  /// [Monitored resources for custom metrics](https://cloud.google.com/monitoring/custom-metrics/creating-metrics#custom-metric-resources).
  GoogleApiMonitoredResource? resource;

  /// The units in which the metric value is reported.
  ///
  /// It is only applicable if the `value_type` is `INT64`, `DOUBLE`, or
  /// `DISTRIBUTION`. The `unit` defines the representation of the stored metric
  /// values. This field can only be changed through CreateTimeSeries when it is
  /// empty.
  core.String? unit;

  /// The value type of the time series.
  ///
  /// When listing time series, this value type might be different from the
  /// value type of the associated metric if this time series is an alignment or
  /// reduction of other time series. When creating a time series, this field is
  /// optional. If present, it must be the same as the type of the data in the
  /// `points` field.
  /// Possible string values are:
  /// - "VALUE_TYPE_UNSPECIFIED" : Do not use this default value.
  /// - "BOOL" : The value is a boolean. This value type can be used only if the
  /// metric kind is `GAUGE`.
  /// - "INT64" : The value is a signed 64-bit integer.
  /// - "DOUBLE" : The value is a double precision floating point number.
  /// - "STRING" : The value is a text string. This value type can be used only
  /// if the metric kind is `GAUGE`.
  /// - "DISTRIBUTION" : The value is a `Distribution`.
  /// - "MONEY" : The value is money.
  core.String? valueType;

  GoogleMonitoringV3TimeSeries({
    this.description,
    this.metadata,
    this.metric,
    this.metricKind,
    this.points,
    this.resource,
    this.unit,
    this.valueType,
  });

  GoogleMonitoringV3TimeSeries.fromJson(core.Map json_)
    : this(
        description: json_['description'] as core.String?,
        metadata:
            json_.containsKey('metadata')
                ? GoogleApiMonitoredResourceMetadata.fromJson(
                  json_['metadata'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metric:
            json_.containsKey('metric')
                ? GoogleApiMetric.fromJson(
                  json_['metric'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        metricKind: json_['metricKind'] as core.String?,
        points:
            (json_['points'] as core.List?)
                ?.map(
                  (value) => GoogleMonitoringV3Point.fromJson(
                    value as core.Map<core.String, core.dynamic>,
                  ),
                )
                .toList(),
        resource:
            json_.containsKey('resource')
                ? GoogleApiMonitoredResource.fromJson(
                  json_['resource'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        unit: json_['unit'] as core.String?,
        valueType: json_['valueType'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (description != null) 'description': description!,
    if (metadata != null) 'metadata': metadata!,
    if (metric != null) 'metric': metric!,
    if (metricKind != null) 'metricKind': metricKind!,
    if (points != null) 'points': points!,
    if (resource != null) 'resource': resource!,
    if (unit != null) 'unit': unit!,
    if (valueType != null) 'valueType': valueType!,
  };
}

/// A single strongly-typed value.
class GoogleMonitoringV3TypedValue {
  /// A Boolean value: `true` or `false`.
  core.bool? boolValue;

  /// A distribution value.
  GoogleApiDistribution? distributionValue;

  /// A 64-bit double-precision floating-point number.
  ///
  /// Its magnitude is approximately 10300 and it has 16 significant digits of
  /// precision.
  core.double? doubleValue;

  /// A 64-bit integer.
  ///
  /// Its range is approximately 9.2x1018.
  core.String? int64Value;

  /// A variable-length string value.
  core.String? stringValue;

  GoogleMonitoringV3TypedValue({
    this.boolValue,
    this.distributionValue,
    this.doubleValue,
    this.int64Value,
    this.stringValue,
  });

  GoogleMonitoringV3TypedValue.fromJson(core.Map json_)
    : this(
        boolValue: json_['boolValue'] as core.bool?,
        distributionValue:
            json_.containsKey('distributionValue')
                ? GoogleApiDistribution.fromJson(
                  json_['distributionValue']
                      as core.Map<core.String, core.dynamic>,
                )
                : null,
        doubleValue: (json_['doubleValue'] as core.num?)?.toDouble(),
        int64Value: json_['int64Value'] as core.String?,
        stringValue: json_['stringValue'] as core.String?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (boolValue != null) 'boolValue': boolValue!,
    if (distributionValue != null) 'distributionValue': distributionValue!,
    if (doubleValue != null) 'doubleValue': doubleValue!,
    if (int64Value != null) 'int64Value': int64Value!,
    if (stringValue != null) 'stringValue': stringValue!,
  };
}

/// A generic empty message that you can re-use to avoid defining duplicated
/// empty messages in your APIs.
///
/// A typical example is to use it as the request or the response type of an API
/// method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns
/// (google.protobuf.Empty); }
typedef GoogleProtobufEmpty = $Empty;

/// The `Status` type defines a logical error model that is suitable for
/// different programming environments, including REST APIs and RPC APIs.
///
/// It is used by [gRPC](https://github.com/grpc). Each `Status` message
/// contains three pieces of data: error code, error message, and error details.
/// You can find out more about this error model and how to work with it in the
/// [API Design Guide](https://cloud.google.com/apis/design/errors).
typedef GoogleRpcStatus = $Status00;

/// Represents a whole or partial calendar date, such as a birthday.
///
/// The time of day and time zone are either specified elsewhere or are
/// insignificant. The date is relative to the Gregorian Calendar. This can
/// represent one of the following: * A full date, with non-zero year, month,
/// and day values. * A month and day, with a zero year (for example, an
/// anniversary). * A year on its own, with a zero month and a zero day. * A
/// year and month, with a zero day (for example, a credit card expiration
/// date). Related types: * google.type.TimeOfDay * google.type.DateTime *
/// google.protobuf.Timestamp
typedef GoogleTypeDate = $Date;

/// Represents civil time (or occasionally physical time).
///
/// This type can represent a civil time in one of a few possible ways: * When
/// utc_offset is set and time_zone is unset: a civil time on a calendar day
/// with a particular offset from UTC. * When time_zone is set and utc_offset is
/// unset: a civil time on a calendar day in a particular time zone. * When
/// neither time_zone nor utc_offset is set: a civil time on a calendar day in
/// local time. The date is relative to the Proleptic Gregorian Calendar. If
/// year, month, or day are 0, the DateTime is considered not to have a specific
/// year, month, or day respectively. This type may also be used to represent a
/// physical time if all the date and time fields are set and either case of the
/// `time_offset` oneof is set. Consider using `Timestamp` message for physical
/// time instead. If your use case also would like to store the user's timezone,
/// that can be done in another field. This type is more flexible than some
/// applications may want. Make sure to document and validate your application's
/// limitations.
class GoogleTypeDateTime {
  /// Day of month.
  ///
  /// Must be from 1 to 31 and valid for the year and month, or 0 if specifying
  /// a datetime without a day.
  ///
  /// Optional.
  core.int? day;

  /// Hours of day in 24 hour format.
  ///
  /// Should be from 0 to 23, defaults to 0 (midnight). An API may choose to
  /// allow the value "24:00:00" for scenarios like business closing time.
  ///
  /// Optional.
  core.int? hours;

  /// Minutes of hour of day.
  ///
  /// Must be from 0 to 59, defaults to 0.
  ///
  /// Optional.
  core.int? minutes;

  /// Month of year.
  ///
  /// Must be from 1 to 12, or 0 if specifying a datetime without a month.
  ///
  /// Optional.
  core.int? month;

  /// Fractions of seconds in nanoseconds.
  ///
  /// Must be from 0 to 999,999,999, defaults to 0.
  ///
  /// Optional.
  core.int? nanos;

  /// Seconds of minutes of the time.
  ///
  /// Must normally be from 0 to 59, defaults to 0. An API may allow the value
  /// 60 if it allows leap-seconds.
  ///
  /// Optional.
  core.int? seconds;

  /// Time zone.
  GoogleTypeTimeZone? timeZone;

  /// UTC offset.
  ///
  /// Must be whole seconds, between -18 hours and +18 hours. For example, a UTC
  /// offset of -4:00 would be represented as { seconds: -14400 }.
  core.String? utcOffset;

  /// Year of date.
  ///
  /// Must be from 1 to 9999, or 0 if specifying a datetime without a year.
  ///
  /// Optional.
  core.int? year;

  GoogleTypeDateTime({
    this.day,
    this.hours,
    this.minutes,
    this.month,
    this.nanos,
    this.seconds,
    this.timeZone,
    this.utcOffset,
    this.year,
  });

  GoogleTypeDateTime.fromJson(core.Map json_)
    : this(
        day: json_['day'] as core.int?,
        hours: json_['hours'] as core.int?,
        minutes: json_['minutes'] as core.int?,
        month: json_['month'] as core.int?,
        nanos: json_['nanos'] as core.int?,
        seconds: json_['seconds'] as core.int?,
        timeZone:
            json_.containsKey('timeZone')
                ? GoogleTypeTimeZone.fromJson(
                  json_['timeZone'] as core.Map<core.String, core.dynamic>,
                )
                : null,
        utcOffset: json_['utcOffset'] as core.String?,
        year: json_['year'] as core.int?,
      );

  core.Map<core.String, core.dynamic> toJson() => {
    if (day != null) 'day': day!,
    if (hours != null) 'hours': hours!,
    if (minutes != null) 'minutes': minutes!,
    if (month != null) 'month': month!,
    if (nanos != null) 'nanos': nanos!,
    if (seconds != null) 'seconds': seconds!,
    if (timeZone != null) 'timeZone': timeZone!,
    if (utcOffset != null) 'utcOffset': utcOffset!,
    if (year != null) 'year': year!,
  };
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax.
///
/// CEL is a C-like expression language. The syntax and semantics of CEL are
/// documented at https://github.com/google/cel-spec. Example (Comparison):
/// title: "Summary size limit" description: "Determines if a summary is less
/// than 100 chars" expression: "document.summary.size() \< 100" Example
/// (Equality): title: "Requestor is owner" description: "Determines if
/// requestor is the document owner" expression: "document.owner ==
/// request.auth.claims.email" Example (Logic): title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// Example (Data Manipulation): title: "Notification string" description:
/// "Create a notification string with a timestamp." expression: "'New message
/// received at ' + string(document.create_time)" The exact variables and
/// functions that may be referenced within an expression are determined by the
/// service that evaluates it. See the service documentation for additional
/// information.
typedef GoogleTypeExpr = $Expr;

/// Represents a time zone from the
/// [IANA Time Zone Database](https://www.iana.org/time-zones).
typedef GoogleTypeTimeZone = $TimeZone;
